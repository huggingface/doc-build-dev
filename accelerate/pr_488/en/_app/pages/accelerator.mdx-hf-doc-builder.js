import{S as jd,i as Nd,s as Sd,e as o,k as s,w as m,t as r,M as Vd,c,d as t,m as i,a as n,x as u,h as a,b as h,G as e,g as x,y as g,q as f,o as _,B as v,v as qd}from"../chunks/vendor-hf-doc-builder.js";import{T as Ud}from"../chunks/Tip-hf-doc-builder.js";import{D as $}from"../chunks/Docstring-hf-doc-builder.js";import{C as Gd}from"../chunks/CodeBlock-hf-doc-builder.js";import{I as Md}from"../chunks/IconCopyLink-hf-doc-builder.js";function Rd(St){let b,z,w,k,I;return{c(){b=o("p"),z=r("Using this with "),w=o("code"),k=r("dispatch_batches=True"),I=r("  (which is the default for iterable datasets) is currently not supported.")},l(E){b=c(E,"P",{});var T=n(b);z=a(T,"Using this with "),w=c(T,"CODE",{});var C=n(w);k=a(C,"dispatch_batches=True"),C.forEach(t),I=a(T,"  (which is the default for iterable datasets) is currently not supported."),T.forEach(t)},m(E,T){x(E,b,T),e(b,z),e(b,w),e(w,k),e(b,I)},d(E){E&&t(b)}}}function Wd(St){let b,z,w,k,I,E,T,C,K,oe,U;return{c(){b=o("p"),z=r("Every "),w=o("code"),k=r("object"),I=r(" must have a "),E=o("code"),T=r("load_state_dict"),C=r(" and "),K=o("code"),oe=r("state_dict"),U=r(" function to be stored.")},l(B){b=c(B,"P",{});var D=n(b);z=a(D,"Every "),w=c(D,"CODE",{});var Vt=n(w);k=a(Vt,"object"),Vt.forEach(t),I=a(D," must have a "),E=c(D,"CODE",{});var qt=n(E);T=a(qt,"load_state_dict"),qt.forEach(t),C=a(D," and "),K=c(D,"CODE",{});var qe=n(K);oe=a(qe,"state_dict"),qe.forEach(t),U=a(D," function to be stored."),D.forEach(t)},m(B,D){x(B,b,D),e(b,z),e(b,w),e(w,k),e(b,I),e(b,E),e(E,T),e(b,C),e(b,K),e(K,oe),e(b,U)},d(B){B&&t(b)}}}function Fd(St){let b,z,w,k,I,E,T,C,K,oe,U,B,D,Vt,qt,qe,P,X,Po,Gt,Lo,Io,ur,Oo,zo,Co,Ge,Uo,Mt,jo,No,So,S,Vo,gr,qo,Go,fr,Mo,Ro,_r,Wo,Fo,Ho,J,Yo,vr,Ko,Bo,br,Xo,Jo,Qo,Me,Zo,Rt,ec,tc,La,ce,rc,$r,ac,oc,Ia,A,ne,yr,cc,nc,Wt,lc,sc,ic,Re,dc,wr,pc,hc,mc,We,uc,Er,gc,fc,_c,Fe,vc,Ft,bc,$c,yc,He,wc,Ht,Ec,Ac,xc,Q,Dc,Yt,kc,Tc,Ar,Pc,Lc,Ic,O,Oc,le,zc,xr,Cc,Uc,jc,Dr,Nc,Sc,se,Vc,kr,qc,Gc,Mc,Tr,Rc,Wc,Oa,q,Fc,Kt,Hc,Yc,Pr,Kc,Bc,za,Ye,Ca,ie,Ua,d,Ke,Xc,Lr,Jc,Qc,Ir,Zc,en,Be,de,Or,tn,rn,zr,an,on,cn,pe,Cr,nn,ln,Bt,sn,dn,pn,he,Xe,hn,Ur,mn,un,me,Je,gn,jr,fn,_n,ue,Qe,vn,Z,bn,Nr,$n,yn,Sr,wn,En,An,ge,Ze,xn,et,Dn,Vr,kn,Tn,Pn,fe,tt,Ln,rt,In,qr,On,zn,Cn,_e,at,Un,ot,jn,Gr,Nn,Sn,Vn,ve,ct,qn,Mr,Gn,Mn,be,nt,Rn,Rr,Wn,Fn,G,lt,Hn,st,Yn,Wr,Kn,Bn,Xn,Fr,Jn,Qn,$e,it,Zn,dt,el,Hr,tl,rl,al,ye,pt,ol,ht,cl,Yr,nl,ll,sl,we,mt,il,Kr,dl,pl,M,ut,hl,Br,ml,ul,Xr,gl,fl,Ee,gt,_l,ee,vl,Jr,bl,$l,Qr,yl,wl,El,R,ft,Al,Zr,xl,Dl,ea,kl,Tl,W,_t,Pl,vt,Ll,ta,Il,Ol,zl,bt,Cl,ra,Ul,jl,Nl,Ae,$t,Sl,aa,Vl,ql,xe,yt,Gl,oa,Ml,Rl,De,wt,Wl,ca,Fl,Hl,ke,Et,Yl,na,Kl,Bl,Te,At,Xl,la,Jl,Ql,j,xt,Zl,Dt,es,sa,ts,rs,as,ia,os,cs,te,Xt,da,ns,ls,ss,Jt,pa,is,ds,ps,Qt,ha,hs,ms,us,Pe,kt,gs,Tt,fs,ma,_s,vs,bs,F,Pt,$s,re,ys,ua,ws,Es,ga,As,xs,Ds,fa,ks,Ts,N,Lt,Ps,V,Ls,_a,Is,Os,va,zs,Cs,ba,Us,js,Ns,$a,Ss,Vs,Le,qs,Ie,It,Gs,Ot,Ms,ya,Rs,Ws,Fs,Oe,zt,Hs,wa,Ys,Ks,ze,Ct,Bs,Ea,Xs,Js,Ce,Ut,Qs,ae,Zs,Aa,ei,ti,Zt,ri,ai,oi,Ue,jt,ci,xa,ni,ja;return E=new Md({}),Ye=new Gd({props:{code:`accelerator = Accelerator(gradient_accumulation_steps=2)
model, optimizer, training_dataloader = accelerator.prepare(model, optimizer, training_dataloader)

for input, label in training_dataloader:
    with accelerator.accumulate(model):
        predictions = model(input)
        loss = loss_function(predictions, label)
        accelerator.backward(loss)
        optimizer.step()
        scheduler.step()
        optimizer.zero_grad()`,highlighted:`accelerator = Accelerator(gradient_accumulation_steps=<span class="hljs-number">2</span>)
model, optimizer, training_dataloader = accelerator.prepare(model, optimizer, training_dataloader)

<span class="hljs-keyword">for</span> <span class="hljs-built_in">input</span>, label <span class="hljs-keyword">in</span> training_dataloader:
    <span class="hljs-keyword">with</span> accelerator.accumulate(model):
        predictions = model(<span class="hljs-built_in">input</span>)
        loss = loss_function(predictions, label)
        accelerator.backward(loss)
        optimizer.step()
        scheduler.step()
        optimizer.zero_grad()`}}),ie=new Ud({props:{warning:!0,$$slots:{default:[Rd]},$$scope:{ctx:St}}}),Ke=new $({props:{name:"class accelerate.Accelerator",anchor:"accelerate.Accelerator",parameters:[{name:"device_placement",val:": bool = True"},{name:"split_batches",val:": bool = False"},{name:"fp16",val:": bool = None"},{name:"mixed_precision",val:": typing.Union[accelerate.utils.dataclasses.PrecisionType, str] = None"},{name:"gradient_accumulation_steps",val:": int = 1"},{name:"cpu",val:": bool = False"},{name:"deepspeed_plugin",val:": DeepSpeedPlugin = None"},{name:"fsdp_plugin",val:": FullyShardedDataParallelPlugin = None"},{name:"rng_types",val:": typing.Union[typing.List[typing.Union[str, accelerate.utils.dataclasses.RNGType]], NoneType] = None"},{name:"log_with",val:": typing.Union[typing.List[typing.Union[str, accelerate.utils.dataclasses.LoggerType, accelerate.tracking.GeneralTracker]], NoneType] = None"},{name:"logging_dir",val:": typing.Union[str, os.PathLike, NoneType] = None"},{name:"dispatch_batches",val:": typing.Optional[bool] = None"},{name:"step_scheduler_with_optimizer",val:": bool = True"},{name:"kwargs_handlers",val:": typing.Optional[typing.List[accelerate.utils.dataclasses.KwargsHandler]] = None"}],parametersDescription:[{anchor:"accelerate.Accelerator.device_placement",description:`<strong>device_placement</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>True</code>) &#x2014;
Whether or not the accelerator should put objects on device (tensors yielded by the dataloader, model,
etc&#x2026;).`,name:"device_placement"},{anchor:"accelerate.Accelerator.split_batches",description:`<strong>split_batches</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether or not the accelerator should split the batches yielded by the dataloaders across the devices. If
<code>True</code> the actual batch size used will be the same on any kind of distributed processes, but it must be a
round multiple of the <code>num_processes</code> you are using. If <code>False</code>, actual batch size used will be the one set
in your script multiplied by the number of processes.`,name:"split_batches"},{anchor:"accelerate.Accelerator.mixed_precision",description:`<strong>mixed_precision</strong> (<code>str</code>, <em>optional</em>) &#x2014;
Whether or not to use mixed precision training (fp16 or bfloat16). Choose from &#x2018;no&#x2019;,&#x2018;fp16&#x2019;,&#x2018;bf16&#x2019;. Will
default to the value in the environment variable <code>MIXED_PRECISION</code>, which will use the default value in the
accelerate config of the current system or the flag passed with the <code>accelerate.launch</code> command. &#x2018;fp16&#x2019;
requires pytorch 1.6 or higher. &#x2018;bf16&#x2019; requires pytorch 1.10 or higher.`,name:"mixed_precision"},{anchor:"accelerate.Accelerator.gradient_accumulation_steps",description:`<strong>gradient_accumulation_steps</strong> (<code>int</code>, <em>optional</em>, default to 1) &#x2014;
The number of steps that should pass before gradients are accumulated. A number &gt; 1 should be combined with
<code>Accelerator.accumulate</code>.`,name:"gradient_accumulation_steps"},{anchor:"accelerate.Accelerator.cpu",description:`<strong>cpu</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to force the script to execute on CPU. Will ignore GPU available if set to <code>True</code> and force
the execution on one process only.`,name:"cpu"},{anchor:"accelerate.Accelerator.deepspeed_plugin",description:`<strong>deepspeed_plugin</strong> (<code>DeepSpeedPlugin</code>, <em>optional</em>) &#x2014;
Tweak your DeepSpeed related args using this argument. This argument is optional and can be configured
directly using <em>accelerate config</em>`,name:"deepspeed_plugin"},{anchor:"accelerate.Accelerator.fsdp_plugin",description:`<strong>fsdp_plugin</strong> (<code>FullyShardedDataParallelPlugin</code>, <em>optional</em>) &#x2014;
Tweak your FSDP related args using this argument. This argument is optional and can be configured directly
using <em>accelerate config</em>`,name:"fsdp_plugin"},{anchor:"accelerate.Accelerator.rng_types",description:`<strong>rng_types</strong> (list of <code>str</code> or <code>RNGType</code>) &#x2014;
The list of random number generators to synchronize at the beginning of each iteration in your prepared
dataloaders. Should be one or several of:</p>
<ul>
<li><code>&quot;torch&quot;</code>: the base torch random number generator</li>
<li><code>&quot;cuda&quot;</code>: the CUDA random number generator (GPU only)</li>
<li><code>&quot;xla&quot;</code>: the XLA random number generator (TPU only)</li>
<li><code>&quot;generator&quot;</code>: the <code>torch.Generator</code> of the sampler (or batch sampler if there is no sampler in your
dataloader) or of the iterable dataset (if it exists) if the underlying dataset is of that type.</li>
</ul>
<p>Will default to <code>[&quot;torch&quot;]</code> for PyTorch versions &lt;=1.5.1 and <code>[&quot;generator&quot;]</code> for PyTorch versions &gt;= 1.6.`,name:"rng_types"},{anchor:"accelerate.Accelerator.log_with",description:`<strong>log_with</strong> (list of <code>str</code>, <a href="/docs/accelerate/pr_488/en/utilities#accelerate.utils.LoggerType">LoggerType</a> or <a href="/docs/accelerate/pr_488/en/internal#accelerate.tracking.GeneralTracker">GeneralTracker</a>, <em>optional</em>) &#x2014;
A list of loggers to be setup for experiment tracking. Should be one or several of:</p>
<ul>
<li><code>&quot;all&quot;</code></li>
<li><code>&quot;tensorboard&quot;</code></li>
<li><code>&quot;wandb&quot;</code></li>
<li><code>&quot;comet_ml&quot;</code>
If <code>&quot;all</code>&#x201D; is selected, will pick up all available trackers in the environment and intialize them. Can also
accept implementations of <code>GeneralTracker</code> for custom trackers, and can be combined with <code>&quot;all&quot;</code>.</li>
</ul>`,name:"log_with"},{anchor:"accelerate.Accelerator.logging_dir",description:`<strong>logging_dir</strong> (<code>str</code>, <code>os.PathLike</code>, <em>optional</em>) &#x2014;
A path to a directory for storing logs of locally-compatible loggers.`,name:"logging_dir"},{anchor:"accelerate.Accelerator.dispatch_batches",description:`<strong>dispatch_batches</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
If set to <code>True</code>, the dataloader prepared by the Accelerator is only iterated through on the main process
and then the batches are split and broadcast to each process. Will default to <code>True</code> for <code>DataLoader</code> whose
underlying dataset is an <code>IterableDataset</code>, <code>False</code> otherwise.`,name:"dispatch_batches"},{anchor:"accelerate.Accelerator.step_scheduler_with_optimizer",description:"<strong>step_scheduler_with_optimizer</strong> (<code>bool</code>, *optional<code>, defaults to </code>True<code>) -- Set </code>True<code>if the learning rate scheduler is stepped at the same time as the optimizer,</code>False` if only\ndone under certain circumstances (at the end of each epoch, for instance).",name:"step_scheduler_with_optimizer"},{anchor:"accelerate.Accelerator.kwargs_handlers",description:`<strong>kwargs_handlers</strong> (<code>List[KwargHandler]</code>, <em>optional</em>) &#x2014;
A list of <code>KwargHandler</code> to customize how the objects related to distributed training or mixed precision
are created. See <a href="kwargs">kwargs</a> for more information.`,name:"kwargs_handlers"}],source:"https://github.com/huggingface/accelerate/blob/vr_488/src/accelerate/accelerator.py#L79"}}),Xe=new $({props:{name:"accumulate",anchor:"accelerate.Accelerator.accumulate",parameters:[{name:"model",val:""}],parametersDescription:[{anchor:"accelerate.Accelerator.accumulate.model",description:`<strong>model</strong> (<code>torch.nn.Module</code>) &#x2014;
PyTorch Module that was prepared with <code>Accelerator.prepare</code>`,name:"model"}],source:"https://github.com/huggingface/accelerate/blob/vr_488/src/accelerate/accelerator.py#L473"}}),Je=new $({props:{name:"autocast",anchor:"accelerate.Accelerator.autocast",parameters:[],source:"https://github.com/huggingface/accelerate/blob/vr_488/src/accelerate/accelerator.py#L1230"}}),Qe=new $({props:{name:"backward",anchor:"accelerate.Accelerator.backward",parameters:[{name:"loss",val:""},{name:"**kwargs",val:""}],source:"https://github.com/huggingface/accelerate/blob/vr_488/src/accelerate/accelerator.py#L857"}}),Ze=new $({props:{name:"clear",anchor:"accelerate.Accelerator.clear",parameters:[],source:"https://github.com/huggingface/accelerate/blob/vr_488/src/accelerate/accelerator.py#L1147"}}),tt=new $({props:{name:"clip_grad_norm_",anchor:"accelerate.Accelerator.clip_grad_norm_",parameters:[{name:"parameters",val:""},{name:"max_norm",val:""},{name:"norm_type",val:" = 2"}],source:"https://github.com/huggingface/accelerate/blob/vr_488/src/accelerate/accelerator.py#L889"}}),at=new $({props:{name:"clip_grad_value_",anchor:"accelerate.Accelerator.clip_grad_value_",parameters:[{name:"parameters",val:""},{name:"clip_value",val:""}],source:"https://github.com/huggingface/accelerate/blob/vr_488/src/accelerate/accelerator.py#L906"}}),ct=new $({props:{name:"end_training",anchor:"accelerate.Accelerator.end_training",parameters:[],source:"https://github.com/huggingface/accelerate/blob/vr_488/src/accelerate/accelerator.py#L1069"}}),nt=new $({props:{name:"free_memory",anchor:"accelerate.Accelerator.free_memory",parameters:[],source:"https://github.com/huggingface/accelerate/blob/vr_488/src/accelerate/accelerator.py#L1135"}}),lt=new $({props:{name:"gather",anchor:"accelerate.Accelerator.gather",parameters:[{name:"tensor",val:""}],parametersDescription:[{anchor:"accelerate.Accelerator.gather.tensor",description:`<strong>tensor</strong> (<code>torch.Tensor</code>, or a nested tuple/list/dictionary of <code>torch.Tensor</code>) &#x2014;
The tensors to gather across all processes.`,name:"tensor"}],source:"https://github.com/huggingface/accelerate/blob/vr_488/src/accelerate/accelerator.py#L915",returnDescription:`
<p>The gathered tensor(s). Note that the
first dimension of the result is <em>num_processes</em> multiplied by the first dimension of the input tensors.</p>
`,returnType:`
<p><code>torch.Tensor</code>, or a nested tuple/list/dictionary of <code>torch.Tensor</code></p>
`}}),it=new $({props:{name:"gather_for_metrics",anchor:"accelerate.Accelerator.gather_for_metrics",parameters:[{name:"tensor",val:""},{name:"dataloader",val:""}],parametersDescription:[{anchor:"accelerate.Accelerator.gather_for_metrics.tensor",description:`<strong>tensor</strong> (<code>torch.Tensor</code>, or a nested tuple/list/dictionary of <code>torch.Tensor</code>) &#x2014;
The tensors for calculating metrics across all processes.`,name:"tensor"},{anchor:"accelerate.Accelerator.gather_for_metrics.dataloader",description:`<strong>dataloader</strong> (<code>torch.utils.data.DataLoader</code>) &#x2014;
A dataloader prepared with <code>Accelerator.prepare</code>`,name:"dataloader"}],source:"https://github.com/huggingface/accelerate/blob/vr_488/src/accelerate/accelerator.py#L933"}}),pt=new $({props:{name:"init_trackers",anchor:"accelerate.Accelerator.init_trackers",parameters:[{name:"project_name",val:": str"},{name:"config",val:": typing.Optional[dict] = None"},{name:"init_kwargs",val:": typing.Optional[dict] = {}"}],parametersDescription:[{anchor:"accelerate.Accelerator.init_trackers.project_name",description:`<strong>project_name</strong> (<code>str</code>) &#x2014;
The name of the project. All trackers will save their data based on this`,name:"project_name"},{anchor:"accelerate.Accelerator.init_trackers.config",description:`<strong>config</strong> (<code>dict</code>, <em>optional</em>) &#x2014;
Optional starting configuration to be logged.`,name:"config"},{anchor:"accelerate.Accelerator.init_trackers.init_kwargs",description:`<strong>init_kwargs</strong> (<code>dict</code>, <em>optional</em>) &#x2014;
A nested dictionary of kwargs to be passed to a specific tracker&#x2019;s <code>__init__</code> function. Should be
formatted like this:`,name:"init_kwargs"}],source:"https://github.com/huggingface/accelerate/blob/vr_488/src/accelerate/accelerator.py#L1015"}}),mt=new $({props:{name:"load_state",anchor:"accelerate.Accelerator.load_state",parameters:[{name:"input_dir",val:": str"}],parametersDescription:[{anchor:"accelerate.Accelerator.load_state.input_dir",description:`<strong>input_dir</strong> (<code>str</code> or <code>os.PathLike</code>) &#x2014;
The name of the folder all relevant weights and states were saved in.`,name:"input_dir"}],source:"https://github.com/huggingface/accelerate/blob/vr_488/src/accelerate/accelerator.py#L1108"}}),ut=new $({props:{name:"local_main_process_first",anchor:"accelerate.Accelerator.local_main_process_first",parameters:[],source:"https://github.com/huggingface/accelerate/blob/vr_488/src/accelerate/accelerator.py#L432"}}),gt=new $({props:{name:"log",anchor:"accelerate.Accelerator.log",parameters:[{name:"values",val:": dict"},{name:"step",val:": typing.Optional[int] = None"},{name:"log_kwargs",val:": typing.Optional[dict] = {}"}],parametersDescription:[{anchor:"accelerate.Accelerator.log.values",description:`<strong>values</strong> (<code>dict</code>) &#x2014;
Values should be a dictionary-like object containing only types <code>int</code>, <code>float</code>, or <code>str</code>.`,name:"values"},{anchor:"accelerate.Accelerator.log.step",description:`<strong>step</strong> (<code>int</code>, <em>optional</em>) &#x2014;
The run step. If included, the log will be affiliated with this step.`,name:"step"},{anchor:"accelerate.Accelerator.log.log_kwargs",description:`<strong>log_kwargs</strong> (<code>dict</code>, <em>optional</em>) &#x2014;
A nested dictionary of kwargs to be passed to a specific tracker&#x2019;s <code>log</code> function. Should be formatted
like this:`,name:"log_kwargs"}],source:"https://github.com/huggingface/accelerate/blob/vr_488/src/accelerate/accelerator.py#L1049"}}),ft=new $({props:{name:"main_process_first",anchor:"accelerate.Accelerator.main_process_first",parameters:[],source:"https://github.com/huggingface/accelerate/blob/vr_488/src/accelerate/accelerator.py#L423"}}),_t=new $({props:{name:"no_sync",anchor:"accelerate.Accelerator.no_sync",parameters:[{name:"model",val:""}],parametersDescription:[{anchor:"accelerate.Accelerator.no_sync.model",description:`<strong>model</strong> (<code>torch.nn.Module</code>) &#x2014;
PyTorch Module that was prepared with <code>Accelerator.prepare</code>`,name:"model"}],source:"https://github.com/huggingface/accelerate/blob/vr_488/src/accelerate/accelerator.py#L441"}}),$t=new $({props:{name:"on_local_main_process",anchor:"accelerate.Accelerator.on_local_main_process",parameters:[{name:"func",val:""}],source:"https://github.com/huggingface/accelerate/blob/vr_488/src/accelerate/accelerator.py#L372"}}),yt=new $({props:{name:"on_local_process",anchor:"accelerate.Accelerator.on_local_process",parameters:[{name:"local_process_idx",val:""}],source:"https://github.com/huggingface/accelerate/blob/vr_488/src/accelerate/accelerator.py#L399"}}),wt=new $({props:{name:"on_main_process",anchor:"accelerate.Accelerator.on_main_process",parameters:[{name:"func",val:""}],source:"https://github.com/huggingface/accelerate/blob/vr_488/src/accelerate/accelerator.py#L360"}}),Et=new $({props:{name:"on_process",anchor:"accelerate.Accelerator.on_process",parameters:[{name:"process_idx",val:""}],source:"https://github.com/huggingface/accelerate/blob/vr_488/src/accelerate/accelerator.py#L384"}}),At=new $({props:{name:"pad_across_processes",anchor:"accelerate.Accelerator.pad_across_processes",parameters:[{name:"tensor",val:""},{name:"dim",val:" = 0"},{name:"pad_index",val:" = 0"},{name:"pad_first",val:" = False"}],parametersDescription:[{anchor:"accelerate.Accelerator.pad_across_processes.tensor",description:`<strong>tensor</strong> (nested list/tuple/dictionary of <code>torch.Tensor</code>) &#x2014;
The data to gather.`,name:"tensor"},{anchor:"accelerate.Accelerator.pad_across_processes.dim",description:`<strong>dim</strong> (<code>int</code>, <em>optional</em>, defaults to 0) &#x2014;
The dimension on which to pad.`,name:"dim"},{anchor:"accelerate.Accelerator.pad_across_processes.pad_index",description:`<strong>pad_index</strong> (<code>int</code>, <em>optional</em>, defaults to 0) &#x2014;
The value with which to pad.`,name:"pad_index"},{anchor:"accelerate.Accelerator.pad_across_processes.pad_first",description:`<strong>pad_first</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether to pad at the beginning or the end.`,name:"pad_first"}],source:"https://github.com/huggingface/accelerate/blob/vr_488/src/accelerate/accelerator.py#L980"}}),xt=new $({props:{name:"prepare",anchor:"accelerate.Accelerator.prepare",parameters:[{name:"*args",val:""}],source:"https://github.com/huggingface/accelerate/blob/vr_488/src/accelerate/accelerator.py#L556"}}),kt=new $({props:{name:"print",anchor:"accelerate.Accelerator.print",parameters:[{name:"*args",val:""},{name:"**kwargs",val:""}],source:"https://github.com/huggingface/accelerate/blob/vr_488/src/accelerate/accelerator.py#L491"}}),Pt=new $({props:{name:"reduce",anchor:"accelerate.Accelerator.reduce",parameters:[{name:"tensor",val:""},{name:"reduction",val:" = 'sum'"}],parametersDescription:[{anchor:"accelerate.Accelerator.reduce.tensor",description:`<strong>tensor</strong> (<code>torch.Tensor</code>, or a nested tuple/list/dictionary of <code>torch.Tensor</code>) &#x2014;
The tensors to reduce across all processes.`,name:"tensor"},{anchor:"accelerate.Accelerator.reduce.reduction",description:`<strong>reduction</strong> (<code>str</code>, <em>optional</em>, defaults to &#x201C;sum&#x201D;) &#x2014;
A reduction type, can be one of &#x2018;sum&#x2019;, &#x2018;mean&#x2019;, or &#x2018;none&#x2019;. If &#x2018;none&#x2019;, will not perform any operation.`,name:"reduction"}],source:"https://github.com/huggingface/accelerate/blob/vr_488/src/accelerate/accelerator.py#L962",returnDescription:`
<p>The reduced tensor(s).</p>
`,returnType:`
<p><code>torch.Tensor</code>, or a nested tuple/list/dictionary of <code>torch.Tensor</code></p>
`}}),Lt=new $({props:{name:"register_for_checkpointing",anchor:"accelerate.Accelerator.register_for_checkpointing",parameters:[{name:"*objects",val:""}],source:"https://github.com/huggingface/accelerate/blob/vr_488/src/accelerate/accelerator.py#L1206"}}),Le=new Ud({props:{$$slots:{default:[Wd]},$$scope:{ctx:St}}}),It=new $({props:{name:"save",anchor:"accelerate.Accelerator.save",parameters:[{name:"obj",val:""},{name:"f",val:""}],parametersDescription:[{anchor:"accelerate.Accelerator.save.f",description:`<strong>f</strong> (<code>str</code> or <code>os.PathLike</code>) &#x2014;
Where to save the content of <code>obj</code>.`,name:"f"}],source:"https://github.com/huggingface/accelerate/blob/vr_488/src/accelerate/accelerator.py#L1077"}}),zt=new $({props:{name:"save_state",anchor:"accelerate.Accelerator.save_state",parameters:[{name:"output_dir",val:": str"}],parametersDescription:[{anchor:"accelerate.Accelerator.save_state.output_dir",description:`<strong>output_dir</strong> (<code>str</code> or <code>os.PathLike</code>) &#x2014;
The name of the folder to save all relevant weights and states.`,name:"output_dir"}],source:"https://github.com/huggingface/accelerate/blob/vr_488/src/accelerate/accelerator.py#L1088"}}),Ct=new $({props:{name:"unscale_gradients",anchor:"accelerate.Accelerator.unscale_gradients",parameters:[{name:"optimizer",val:" = None"}],parametersDescription:[{anchor:"accelerate.Accelerator.unscale_gradients.optimizer",description:`<strong>optimizer</strong> (<code>torch.optim.Optimizer</code> or <code>List[torch.optim.Optimizer]</code>, <em>optional</em>) &#x2014;
The optimizer(s) for which to unscale gradients. If not set, will unscale gradients on all optimizers
that were passed to <a href="/docs/accelerate/pr_488/en/accelerator#accelerate.Accelerator.prepare">prepare()</a>.`,name:"optimizer"}],source:"https://github.com/huggingface/accelerate/blob/vr_488/src/accelerate/accelerator.py#L869"}}),Ut=new $({props:{name:"unwrap_model",anchor:"accelerate.Accelerator.unwrap_model",parameters:[{name:"model",val:""}],parametersDescription:[{anchor:"accelerate.Accelerator.unwrap_model.model",description:`<strong>model</strong> (<code>torch.nn.Module</code>) &#x2014;
The model to unwrap.`,name:"model"}],source:"https://github.com/huggingface/accelerate/blob/vr_488/src/accelerate/accelerator.py#L997"}}),jt=new $({props:{name:"wait_for_everyone",anchor:"accelerate.Accelerator.wait_for_everyone",parameters:[],source:"https://github.com/huggingface/accelerate/blob/vr_488/src/accelerate/accelerator.py#L1008"}}),{c(){b=o("meta"),z=s(),w=o("h1"),k=o("a"),I=o("span"),m(E.$$.fragment),T=s(),C=o("span"),K=r("Accelerator"),oe=s(),U=o("p"),B=r("The "),D=o("a"),Vt=r("Accelerator"),qt=r(` is the main class provided by \u{1F917} Accelerate. It serves at the main entrypoint for
the API. To quickly adapt your script to work on any kind of setup with \u{1F917} Accelerate just:`),qe=s(),P=o("ol"),X=o("li"),Po=r("Initialize an "),Gt=o("a"),Lo=r("Accelerator"),Io=r(" object (that we will call "),ur=o("code"),Oo=r("accelerator"),zo=r(` in the rest of this
page) as early as possible in your script.`),Co=s(),Ge=o("li"),Uo=r("Pass along your model(s), optimizer(s), dataloader(s) to the "),Mt=o("a"),jo=r("prepare()"),No=r(" method."),So=s(),S=o("li"),Vo=r("(Optional but best practice) Remove all the "),gr=o("code"),qo=r(".cuda()"),Go=r(" or "),fr=o("code"),Mo=r(".to(device)"),Ro=r(` in your code and let the
`),_r=o("code"),Wo=r("accelerator"),Fo=r(" handle device placement for you."),Ho=s(),J=o("li"),Yo=r("Replace the "),vr=o("code"),Ko=r("loss.backward()"),Bo=r(" in your code by "),br=o("code"),Xo=r("accelerator.backward(loss)"),Jo=r("."),Qo=s(),Me=o("li"),Zo=r(`(Optional, when using distributed evaluation) Gather your predictions and labels before storing them or using
them for metric computation using `),Rt=o("a"),ec=r("gather()"),tc=r("."),La=s(),ce=o("p"),rc=r(`This is all that is needed in most cases. For more advanced cases or a nicer experience here are the functions you
should search for and replace by the corresponding methods of your `),$r=o("code"),ac=r("accelerator"),oc=r(":"),Ia=s(),A=o("ul"),ne=o("li"),yr=o("code"),cc=r("print"),nc=r(" statements should be replaced by "),Wt=o("a"),lc=r("print()"),sc=r(` to be only printed once per
process.`),ic=s(),Re=o("li"),dc=r("Use "),wr=o("code"),pc=r("is_local_main_process"),hc=r(" for statements that should be executed once per server."),mc=s(),We=o("li"),uc=r("Use "),Er=o("code"),gc=r("is_main_process"),fc=r(" for statements that should be executed once only."),_c=s(),Fe=o("li"),vc=r("Use "),Ft=o("a"),bc=r("wait_for_everyone()"),$c=r(` to make sure all processes join that point before continuing
(useful before a model save for instance).`),yc=s(),He=o("li"),wc=r("Use "),Ht=o("a"),Ec=r("unwrap_model()"),Ac=r(" to unwrap your model before saving it."),xc=s(),Q=o("li"),Dc=r("Use "),Yt=o("a"),kc=r("save()"),Tc=r(" instead of "),Ar=o("code"),Pc=r("torch.save"),Lc=r("."),Ic=s(),O=o("li"),Oc=r("Use "),le=o("a"),zc=r("clip"),xr=o("em"),Cc=r("grad_norm"),Uc=r("()"),jc=r(" instead of "),Dr=o("code"),Nc=r("torch.nn.utils.clip_grad_norm_"),Sc=r(` and
`),se=o("a"),Vc=r("clip"),kr=o("em"),qc=r("grad_value"),Gc=r("()"),Mc=r(" instead of "),Tr=o("code"),Rc=r("torch.nn.utils.clip_grad_value_"),Wc=r("."),Oa=s(),q=o("p"),Fc=r("To perform gradient accumulation use "),Kt=o("a"),Hc=r("accumulate()"),Yc=r(" and specify a "),Pr=o("code"),Kc=r("gradient_accumulation_steps"),Bc=r(`.
This will also automatically ensure the gradients are synced or unsynced when on multi-device training, check if the step should
actually be performed, and auto-scale the loss:`),za=s(),m(Ye.$$.fragment),Ca=s(),m(ie.$$.fragment),Ua=s(),d=o("div"),m(Ke.$$.fragment),Xc=s(),Lr=o("p"),Jc=r("Creates an instance of an accelerator for distributed training (on multi-GPU, TPU) or mixed precision training."),Qc=s(),Ir=o("p"),Zc=r("Attributes"),en=s(),Be=o("ul"),de=o("li"),Or=o("strong"),tn=r("device"),rn=r(" ("),zr=o("code"),an=r("torch.device"),on=r(") \u2014 The device to use."),cn=s(),pe=o("li"),Cr=o("strong"),nn=r("state"),ln=r(" ("),Bt=o("a"),sn=r("AcceleratorState"),dn=r(") \u2014 The distributed setup state."),pn=s(),he=o("div"),m(Xe.$$.fragment),hn=s(),Ur=o("p"),mn=r("A context manager that will lightly wrap around and perform gradient accumulation automatically"),un=s(),me=o("div"),m(Je.$$.fragment),gn=s(),jr=o("p"),fn=r(`Will apply automatic mixed-precision inside the block inside this context manager, if it is enabled. Nothing
different will happen otherwise.`),_n=s(),ue=o("div"),m(Qe.$$.fragment),vn=s(),Z=o("p"),bn=r("Use "),Nr=o("code"),$n=r("accelerator.backward(loss)"),yn=r(" in lieu of "),Sr=o("code"),wn=r("loss.backward()"),En=r("."),An=s(),ge=o("div"),m(Ze.$$.fragment),xn=s(),et=o("p"),Dn=r("Alias for "),Vr=o("code"),kn=r("Accelerate.free_memory"),Tn=r(`, releases all references to the internal objects stored and call the
garbage collector. You should call this method between two trainings with different models/optimizers.`),Pn=s(),fe=o("div"),m(tt.$$.fragment),Ln=s(),rt=o("p"),In=r("Should be used in place of "),qr=o("code"),On=r("torch.nn.utils.clip_grad_norm_"),zn=r("."),Cn=s(),_e=o("div"),m(at.$$.fragment),Un=s(),ot=o("p"),jn=r("Should be used in place of "),Gr=o("code"),Nn=r("torch.nn.utils.clip_grad_value_"),Sn=r("."),Vn=s(),ve=o("div"),m(ct.$$.fragment),qn=s(),Mr=o("p"),Gn=r("Runs any special end training behaviors, such as stopping trackers"),Mn=s(),be=o("div"),m(nt.$$.fragment),Rn=s(),Rr=o("p"),Wn=r(`Will release all references to the internal objects stored and call the garbage collector. You should call this
method between two trainings with different models/optimizers.`),Fn=s(),G=o("div"),m(lt.$$.fragment),Hn=s(),st=o("p"),Yn=r("Gather the values in "),Wr=o("em"),Kn=r("tensor"),Bn=r(` across all processes and concatenate them on the first dimension. Useful to
regroup the predictions from all processes when doing evaluation.`),Xn=s(),Fr=o("p"),Jn=r(`Note:
This gather happens in all processes.`),Qn=s(),$e=o("div"),m(it.$$.fragment),Zn=s(),dt=o("p"),el=r("Gathers "),Hr=o("code"),tl=r("tensor"),rl=r(` and potentially drops duplicates in the last batch if on a distributed system. Should be used
for gathering the inputs and targets for metric calculation.`),al=s(),ye=o("div"),m(pt.$$.fragment),ol=s(),ht=o("p"),cl=r("Initializes a run for all trackers stored in "),Yr=o("code"),nl=r("self.log_with"),ll=r(", potentially with starting configurations"),sl=s(),we=o("div"),m(mt.$$.fragment),il=s(),Kr=o("p"),dl=r("Loads the current states of the model, optimizer, scaler, RNG generators, and registered objects."),pl=s(),M=o("div"),m(ut.$$.fragment),hl=s(),Br=o("p"),ml=r("Lets the local main process go inside a with block."),ul=s(),Xr=o("p"),gl=r("The other processes will enter the with block after the main process exits."),fl=s(),Ee=o("div"),m(gt.$$.fragment),_l=s(),ee=o("p"),vl=r("Logs "),Jr=o("code"),bl=r("values"),$l=r(" to all stored trackers in "),Qr=o("code"),yl=r("self.trackers"),wl=r("."),El=s(),R=o("div"),m(ft.$$.fragment),Al=s(),Zr=o("p"),xl=r("Lets the main process go first inside a with block."),Dl=s(),ea=o("p"),kl=r("The other processes will enter the with block after the main process exits."),Tl=s(),W=o("div"),m(_t.$$.fragment),Pl=s(),vt=o("p"),Ll=r(`A context manager to disable gradient synchronizations across DDP processes by calling
`),ta=o("code"),Il=r("torch.nn.parallel.DistributedDataParallel.no_sync"),Ol=r("."),zl=s(),bt=o("p"),Cl=r("If "),ra=o("code"),Ul=r("model"),jl=r(" is not in DDP, this context manager does nothing"),Nl=s(),Ae=o("div"),m($t.$$.fragment),Sl=s(),aa=o("p"),Vl=r("A decorator that will run the decorated function on the local main process only."),ql=s(),xe=o("div"),m(yt.$$.fragment),Gl=s(),oa=o("p"),Ml=r("Run func on certain local process only"),Rl=s(),De=o("div"),m(wt.$$.fragment),Wl=s(),ca=o("p"),Fl=r("A decorator that will run the decorated function on the main process only."),Hl=s(),ke=o("div"),m(Et.$$.fragment),Yl=s(),na=o("p"),Kl=r("A decorator that will run the decorated function on a given process index only."),Bl=s(),Te=o("div"),m(At.$$.fragment),Xl=s(),la=o("p"),Jl=r(`Recursively pad the tensors in a nested list/tuple/dictionary of tensors from all devices to the same size so
they can safely be gathered.`),Ql=s(),j=o("div"),m(xt.$$.fragment),Zl=s(),Dt=o("p"),es=r("Prepare all objects passed in "),sa=o("code"),ts=r("args"),rs=r(` for distributed training and mixed precision, then return them in the same
order.`),as=s(),ia=o("p"),os=r("Accepts the following type of objects:"),cs=s(),te=o("ul"),Xt=o("li"),da=o("code"),ns=r("torch.utils.data.DataLoader"),ls=r(": PyTorch Dataloader"),ss=s(),Jt=o("li"),pa=o("code"),is=r("torch.nn.Module"),ds=r(": PyTorch Module"),ps=s(),Qt=o("li"),ha=o("code"),hs=r("torch.optim.Optimizer"),ms=r(": PyTorch Optimizer"),us=s(),Pe=o("div"),m(kt.$$.fragment),gs=s(),Tt=o("p"),fs=r("Use in replacement of "),ma=o("code"),_s=r("print()"),vs=r(" to only print once per server."),bs=s(),F=o("div"),m(Pt.$$.fragment),$s=s(),re=o("p"),ys=r("Reduce the values in "),ua=o("em"),ws=r("tensor"),Es=r(" across all processes based on "),ga=o("em"),As=r("reduction"),xs=r("."),Ds=s(),fa=o("p"),ks=r(`Note:
All processes get the reduced value.`),Ts=s(),N=o("div"),m(Lt.$$.fragment),Ps=s(),V=o("p"),Ls=r("Makes note of "),_a=o("code"),Is=r("objects"),Os=r(" and will save or load them in during "),va=o("code"),zs=r("save_state"),Cs=r(" or "),ba=o("code"),Us=r("load_state"),js=r("."),Ns=s(),$a=o("p"),Ss=r(`These should be utilized when the state is being loaded or saved in the same script. It is not designed to be
used in different scripts`),Vs=s(),m(Le.$$.fragment),qs=s(),Ie=o("div"),m(It.$$.fragment),Gs=s(),Ot=o("p"),Ms=r("Save the object passed to disk once per machine. Use in place of "),ya=o("code"),Rs=r("torch.save"),Ws=r("."),Fs=s(),Oe=o("div"),m(zt.$$.fragment),Hs=s(),wa=o("p"),Ys=r("Saves the current states of the model, optimizer, scaler, RNG generators, and registered objects."),Ks=s(),ze=o("div"),m(Ct.$$.fragment),Bs=s(),Ea=o("p"),Xs=r("Unscale the gradients in mixed precision training with AMP. This is a noop in all other settings."),Js=s(),Ce=o("div"),m(Ut.$$.fragment),Qs=s(),ae=o("p"),Zs=r("Unwraps the "),Aa=o("code"),ei=r("model"),ti=r(" from the additional layer possible added by "),Zt=o("a"),ri=r("prepare()"),ai=r(`. Useful before saving
the model.`),oi=s(),Ue=o("div"),m(jt.$$.fragment),ci=s(),xa=o("p"),ni=r(`Will stop the execution of the current process until every other process has reached that point (so this does
nothing when the script is only run in one process). Useful to do before saving a model.`),this.h()},l(l){const y=Vd('[data-svelte="svelte-1phssyn"]',document.head);b=c(y,"META",{name:!0,content:!0}),y.forEach(t),z=i(l),w=c(l,"H1",{class:!0});var Nt=n(w);k=c(Nt,"A",{id:!0,class:!0,href:!0});var Da=n(k);I=c(Da,"SPAN",{});var di=n(I);u(E.$$.fragment,di),di.forEach(t),Da.forEach(t),T=i(Nt),C=c(Nt,"SPAN",{});var pi=n(C);K=a(pi,"Accelerator"),pi.forEach(t),Nt.forEach(t),oe=i(l),U=c(l,"P",{});var Na=n(U);B=a(Na,"The "),D=c(Na,"A",{href:!0});var hi=n(D);Vt=a(hi,"Accelerator"),hi.forEach(t),qt=a(Na,` is the main class provided by \u{1F917} Accelerate. It serves at the main entrypoint for
the API. To quickly adapt your script to work on any kind of setup with \u{1F917} Accelerate just:`),Na.forEach(t),qe=i(l),P=c(l,"OL",{});var H=n(P);X=c(H,"LI",{});var er=n(X);Po=a(er,"Initialize an "),Gt=c(er,"A",{href:!0});var mi=n(Gt);Lo=a(mi,"Accelerator"),mi.forEach(t),Io=a(er," object (that we will call "),ur=c(er,"CODE",{});var ui=n(ur);Oo=a(ui,"accelerator"),ui.forEach(t),zo=a(er,` in the rest of this
page) as early as possible in your script.`),er.forEach(t),Co=i(H),Ge=c(H,"LI",{});var Sa=n(Ge);Uo=a(Sa,"Pass along your model(s), optimizer(s), dataloader(s) to the "),Mt=c(Sa,"A",{href:!0});var gi=n(Mt);jo=a(gi,"prepare()"),gi.forEach(t),No=a(Sa," method."),Sa.forEach(t),So=i(H),S=c(H,"LI",{});var je=n(S);Vo=a(je,"(Optional but best practice) Remove all the "),gr=c(je,"CODE",{});var fi=n(gr);qo=a(fi,".cuda()"),fi.forEach(t),Go=a(je," or "),fr=c(je,"CODE",{});var _i=n(fr);Mo=a(_i,".to(device)"),_i.forEach(t),Ro=a(je,` in your code and let the
`),_r=c(je,"CODE",{});var vi=n(_r);Wo=a(vi,"accelerator"),vi.forEach(t),Fo=a(je," handle device placement for you."),je.forEach(t),Ho=i(H),J=c(H,"LI",{});var tr=n(J);Yo=a(tr,"Replace the "),vr=c(tr,"CODE",{});var bi=n(vr);Ko=a(bi,"loss.backward()"),bi.forEach(t),Bo=a(tr," in your code by "),br=c(tr,"CODE",{});var $i=n(br);Xo=a($i,"accelerator.backward(loss)"),$i.forEach(t),Jo=a(tr,"."),tr.forEach(t),Qo=i(H),Me=c(H,"LI",{});var Va=n(Me);Zo=a(Va,`(Optional, when using distributed evaluation) Gather your predictions and labels before storing them or using
them for metric computation using `),Rt=c(Va,"A",{href:!0});var yi=n(Rt);ec=a(yi,"gather()"),yi.forEach(t),tc=a(Va,"."),Va.forEach(t),H.forEach(t),La=i(l),ce=c(l,"P",{});var qa=n(ce);rc=a(qa,`This is all that is needed in most cases. For more advanced cases or a nicer experience here are the functions you
should search for and replace by the corresponding methods of your `),$r=c(qa,"CODE",{});var wi=n($r);ac=a(wi,"accelerator"),wi.forEach(t),oc=a(qa,":"),qa.forEach(t),Ia=i(l),A=c(l,"UL",{});var L=n(A);ne=c(L,"LI",{});var ka=n(ne);yr=c(ka,"CODE",{});var Ei=n(yr);cc=a(Ei,"print"),Ei.forEach(t),nc=a(ka," statements should be replaced by "),Wt=c(ka,"A",{href:!0});var Ai=n(Wt);lc=a(Ai,"print()"),Ai.forEach(t),sc=a(ka,` to be only printed once per
process.`),ka.forEach(t),ic=i(L),Re=c(L,"LI",{});var Ga=n(Re);dc=a(Ga,"Use "),wr=c(Ga,"CODE",{});var xi=n(wr);pc=a(xi,"is_local_main_process"),xi.forEach(t),hc=a(Ga," for statements that should be executed once per server."),Ga.forEach(t),mc=i(L),We=c(L,"LI",{});var Ma=n(We);uc=a(Ma,"Use "),Er=c(Ma,"CODE",{});var Di=n(Er);gc=a(Di,"is_main_process"),Di.forEach(t),fc=a(Ma," for statements that should be executed once only."),Ma.forEach(t),_c=i(L),Fe=c(L,"LI",{});var Ra=n(Fe);vc=a(Ra,"Use "),Ft=c(Ra,"A",{href:!0});var ki=n(Ft);bc=a(ki,"wait_for_everyone()"),ki.forEach(t),$c=a(Ra,` to make sure all processes join that point before continuing
(useful before a model save for instance).`),Ra.forEach(t),yc=i(L),He=c(L,"LI",{});var Wa=n(He);wc=a(Wa,"Use "),Ht=c(Wa,"A",{href:!0});var Ti=n(Ht);Ec=a(Ti,"unwrap_model()"),Ti.forEach(t),Ac=a(Wa," to unwrap your model before saving it."),Wa.forEach(t),xc=i(L),Q=c(L,"LI",{});var rr=n(Q);Dc=a(rr,"Use "),Yt=c(rr,"A",{href:!0});var Pi=n(Yt);kc=a(Pi,"save()"),Pi.forEach(t),Tc=a(rr," instead of "),Ar=c(rr,"CODE",{});var Li=n(Ar);Pc=a(Li,"torch.save"),Li.forEach(t),Lc=a(rr,"."),rr.forEach(t),Ic=i(L),O=c(L,"LI",{});var Y=n(O);Oc=a(Y,"Use "),le=c(Y,"A",{href:!0});var Fa=n(le);zc=a(Fa,"clip"),xr=c(Fa,"EM",{});var Ii=n(xr);Cc=a(Ii,"grad_norm"),Ii.forEach(t),Uc=a(Fa,"()"),Fa.forEach(t),jc=a(Y," instead of "),Dr=c(Y,"CODE",{});var Oi=n(Dr);Nc=a(Oi,"torch.nn.utils.clip_grad_norm_"),Oi.forEach(t),Sc=a(Y,` and
`),se=c(Y,"A",{href:!0});var Ha=n(se);Vc=a(Ha,"clip"),kr=c(Ha,"EM",{});var zi=n(kr);qc=a(zi,"grad_value"),zi.forEach(t),Gc=a(Ha,"()"),Ha.forEach(t),Mc=a(Y," instead of "),Tr=c(Y,"CODE",{});var Ci=n(Tr);Rc=a(Ci,"torch.nn.utils.clip_grad_value_"),Ci.forEach(t),Wc=a(Y,"."),Y.forEach(t),L.forEach(t),Oa=i(l),q=c(l,"P",{});var ar=n(q);Fc=a(ar,"To perform gradient accumulation use "),Kt=c(ar,"A",{href:!0});var Ui=n(Kt);Hc=a(Ui,"accumulate()"),Ui.forEach(t),Yc=a(ar," and specify a "),Pr=c(ar,"CODE",{});var ji=n(Pr);Kc=a(ji,"gradient_accumulation_steps"),ji.forEach(t),Bc=a(ar,`.
This will also automatically ensure the gradients are synced or unsynced when on multi-device training, check if the step should
actually be performed, and auto-scale the loss:`),ar.forEach(t),za=i(l),u(Ye.$$.fragment,l),Ca=i(l),u(ie.$$.fragment,l),Ua=i(l),d=c(l,"DIV",{class:!0});var p=n(d);u(Ke.$$.fragment,p),Xc=i(p),Lr=c(p,"P",{});var Ni=n(Lr);Jc=a(Ni,"Creates an instance of an accelerator for distributed training (on multi-GPU, TPU) or mixed precision training."),Ni.forEach(t),Qc=i(p),Ir=c(p,"P",{});var Si=n(Ir);Zc=a(Si,"Attributes"),Si.forEach(t),en=i(p),Be=c(p,"UL",{});var Ya=n(Be);de=c(Ya,"LI",{});var Ta=n(de);Or=c(Ta,"STRONG",{});var Vi=n(Or);tn=a(Vi,"device"),Vi.forEach(t),rn=a(Ta," ("),zr=c(Ta,"CODE",{});var qi=n(zr);an=a(qi,"torch.device"),qi.forEach(t),on=a(Ta,") \u2014 The device to use."),Ta.forEach(t),cn=i(Ya),pe=c(Ya,"LI",{});var Pa=n(pe);Cr=c(Pa,"STRONG",{});var Gi=n(Cr);nn=a(Gi,"state"),Gi.forEach(t),ln=a(Pa," ("),Bt=c(Pa,"A",{href:!0});var Mi=n(Bt);sn=a(Mi,"AcceleratorState"),Mi.forEach(t),dn=a(Pa,") \u2014 The distributed setup state."),Pa.forEach(t),Ya.forEach(t),pn=i(p),he=c(p,"DIV",{class:!0});var Ka=n(he);u(Xe.$$.fragment,Ka),hn=i(Ka),Ur=c(Ka,"P",{});var Ri=n(Ur);mn=a(Ri,"A context manager that will lightly wrap around and perform gradient accumulation automatically"),Ri.forEach(t),Ka.forEach(t),un=i(p),me=c(p,"DIV",{class:!0});var Ba=n(me);u(Je.$$.fragment,Ba),gn=i(Ba),jr=c(Ba,"P",{});var Wi=n(jr);fn=a(Wi,`Will apply automatic mixed-precision inside the block inside this context manager, if it is enabled. Nothing
different will happen otherwise.`),Wi.forEach(t),Ba.forEach(t),_n=i(p),ue=c(p,"DIV",{class:!0});var Xa=n(ue);u(Qe.$$.fragment,Xa),vn=i(Xa),Z=c(Xa,"P",{});var or=n(Z);bn=a(or,"Use "),Nr=c(or,"CODE",{});var Fi=n(Nr);$n=a(Fi,"accelerator.backward(loss)"),Fi.forEach(t),yn=a(or," in lieu of "),Sr=c(or,"CODE",{});var Hi=n(Sr);wn=a(Hi,"loss.backward()"),Hi.forEach(t),En=a(or,"."),or.forEach(t),Xa.forEach(t),An=i(p),ge=c(p,"DIV",{class:!0});var Ja=n(ge);u(Ze.$$.fragment,Ja),xn=i(Ja),et=c(Ja,"P",{});var Qa=n(et);Dn=a(Qa,"Alias for "),Vr=c(Qa,"CODE",{});var Yi=n(Vr);kn=a(Yi,"Accelerate.free_memory"),Yi.forEach(t),Tn=a(Qa,`, releases all references to the internal objects stored and call the
garbage collector. You should call this method between two trainings with different models/optimizers.`),Qa.forEach(t),Ja.forEach(t),Pn=i(p),fe=c(p,"DIV",{class:!0});var Za=n(fe);u(tt.$$.fragment,Za),Ln=i(Za),rt=c(Za,"P",{});var eo=n(rt);In=a(eo,"Should be used in place of "),qr=c(eo,"CODE",{});var Ki=n(qr);On=a(Ki,"torch.nn.utils.clip_grad_norm_"),Ki.forEach(t),zn=a(eo,"."),eo.forEach(t),Za.forEach(t),Cn=i(p),_e=c(p,"DIV",{class:!0});var to=n(_e);u(at.$$.fragment,to),Un=i(to),ot=c(to,"P",{});var ro=n(ot);jn=a(ro,"Should be used in place of "),Gr=c(ro,"CODE",{});var Bi=n(Gr);Nn=a(Bi,"torch.nn.utils.clip_grad_value_"),Bi.forEach(t),Sn=a(ro,"."),ro.forEach(t),to.forEach(t),Vn=i(p),ve=c(p,"DIV",{class:!0});var ao=n(ve);u(ct.$$.fragment,ao),qn=i(ao),Mr=c(ao,"P",{});var Xi=n(Mr);Gn=a(Xi,"Runs any special end training behaviors, such as stopping trackers"),Xi.forEach(t),ao.forEach(t),Mn=i(p),be=c(p,"DIV",{class:!0});var oo=n(be);u(nt.$$.fragment,oo),Rn=i(oo),Rr=c(oo,"P",{});var Ji=n(Rr);Wn=a(Ji,`Will release all references to the internal objects stored and call the garbage collector. You should call this
method between two trainings with different models/optimizers.`),Ji.forEach(t),oo.forEach(t),Fn=i(p),G=c(p,"DIV",{class:!0});var cr=n(G);u(lt.$$.fragment,cr),Hn=i(cr),st=c(cr,"P",{});var co=n(st);Yn=a(co,"Gather the values in "),Wr=c(co,"EM",{});var Qi=n(Wr);Kn=a(Qi,"tensor"),Qi.forEach(t),Bn=a(co,` across all processes and concatenate them on the first dimension. Useful to
regroup the predictions from all processes when doing evaluation.`),co.forEach(t),Xn=i(cr),Fr=c(cr,"P",{});var Zi=n(Fr);Jn=a(Zi,`Note:
This gather happens in all processes.`),Zi.forEach(t),cr.forEach(t),Qn=i(p),$e=c(p,"DIV",{class:!0});var no=n($e);u(it.$$.fragment,no),Zn=i(no),dt=c(no,"P",{});var lo=n(dt);el=a(lo,"Gathers "),Hr=c(lo,"CODE",{});var ed=n(Hr);tl=a(ed,"tensor"),ed.forEach(t),rl=a(lo,` and potentially drops duplicates in the last batch if on a distributed system. Should be used
for gathering the inputs and targets for metric calculation.`),lo.forEach(t),no.forEach(t),al=i(p),ye=c(p,"DIV",{class:!0});var so=n(ye);u(pt.$$.fragment,so),ol=i(so),ht=c(so,"P",{});var io=n(ht);cl=a(io,"Initializes a run for all trackers stored in "),Yr=c(io,"CODE",{});var td=n(Yr);nl=a(td,"self.log_with"),td.forEach(t),ll=a(io,", potentially with starting configurations"),io.forEach(t),so.forEach(t),sl=i(p),we=c(p,"DIV",{class:!0});var po=n(we);u(mt.$$.fragment,po),il=i(po),Kr=c(po,"P",{});var rd=n(Kr);dl=a(rd,"Loads the current states of the model, optimizer, scaler, RNG generators, and registered objects."),rd.forEach(t),po.forEach(t),pl=i(p),M=c(p,"DIV",{class:!0});var nr=n(M);u(ut.$$.fragment,nr),hl=i(nr),Br=c(nr,"P",{});var ad=n(Br);ml=a(ad,"Lets the local main process go inside a with block."),ad.forEach(t),ul=i(nr),Xr=c(nr,"P",{});var od=n(Xr);gl=a(od,"The other processes will enter the with block after the main process exits."),od.forEach(t),nr.forEach(t),fl=i(p),Ee=c(p,"DIV",{class:!0});var ho=n(Ee);u(gt.$$.fragment,ho),_l=i(ho),ee=c(ho,"P",{});var lr=n(ee);vl=a(lr,"Logs "),Jr=c(lr,"CODE",{});var cd=n(Jr);bl=a(cd,"values"),cd.forEach(t),$l=a(lr," to all stored trackers in "),Qr=c(lr,"CODE",{});var nd=n(Qr);yl=a(nd,"self.trackers"),nd.forEach(t),wl=a(lr,"."),lr.forEach(t),ho.forEach(t),El=i(p),R=c(p,"DIV",{class:!0});var sr=n(R);u(ft.$$.fragment,sr),Al=i(sr),Zr=c(sr,"P",{});var ld=n(Zr);xl=a(ld,"Lets the main process go first inside a with block."),ld.forEach(t),Dl=i(sr),ea=c(sr,"P",{});var sd=n(ea);kl=a(sd,"The other processes will enter the with block after the main process exits."),sd.forEach(t),sr.forEach(t),Tl=i(p),W=c(p,"DIV",{class:!0});var ir=n(W);u(_t.$$.fragment,ir),Pl=i(ir),vt=c(ir,"P",{});var mo=n(vt);Ll=a(mo,`A context manager to disable gradient synchronizations across DDP processes by calling
`),ta=c(mo,"CODE",{});var id=n(ta);Il=a(id,"torch.nn.parallel.DistributedDataParallel.no_sync"),id.forEach(t),Ol=a(mo,"."),mo.forEach(t),zl=i(ir),bt=c(ir,"P",{});var uo=n(bt);Cl=a(uo,"If "),ra=c(uo,"CODE",{});var dd=n(ra);Ul=a(dd,"model"),dd.forEach(t),jl=a(uo," is not in DDP, this context manager does nothing"),uo.forEach(t),ir.forEach(t),Nl=i(p),Ae=c(p,"DIV",{class:!0});var go=n(Ae);u($t.$$.fragment,go),Sl=i(go),aa=c(go,"P",{});var pd=n(aa);Vl=a(pd,"A decorator that will run the decorated function on the local main process only."),pd.forEach(t),go.forEach(t),ql=i(p),xe=c(p,"DIV",{class:!0});var fo=n(xe);u(yt.$$.fragment,fo),Gl=i(fo),oa=c(fo,"P",{});var hd=n(oa);Ml=a(hd,"Run func on certain local process only"),hd.forEach(t),fo.forEach(t),Rl=i(p),De=c(p,"DIV",{class:!0});var _o=n(De);u(wt.$$.fragment,_o),Wl=i(_o),ca=c(_o,"P",{});var md=n(ca);Fl=a(md,"A decorator that will run the decorated function on the main process only."),md.forEach(t),_o.forEach(t),Hl=i(p),ke=c(p,"DIV",{class:!0});var vo=n(ke);u(Et.$$.fragment,vo),Yl=i(vo),na=c(vo,"P",{});var ud=n(na);Kl=a(ud,"A decorator that will run the decorated function on a given process index only."),ud.forEach(t),vo.forEach(t),Bl=i(p),Te=c(p,"DIV",{class:!0});var bo=n(Te);u(At.$$.fragment,bo),Xl=i(bo),la=c(bo,"P",{});var gd=n(la);Jl=a(gd,`Recursively pad the tensors in a nested list/tuple/dictionary of tensors from all devices to the same size so
they can safely be gathered.`),gd.forEach(t),bo.forEach(t),Ql=i(p),j=c(p,"DIV",{class:!0});var Ne=n(j);u(xt.$$.fragment,Ne),Zl=i(Ne),Dt=c(Ne,"P",{});var $o=n(Dt);es=a($o,"Prepare all objects passed in "),sa=c($o,"CODE",{});var fd=n(sa);ts=a(fd,"args"),fd.forEach(t),rs=a($o,` for distributed training and mixed precision, then return them in the same
order.`),$o.forEach(t),as=i(Ne),ia=c(Ne,"P",{});var _d=n(ia);os=a(_d,"Accepts the following type of objects:"),_d.forEach(t),cs=i(Ne),te=c(Ne,"UL",{});var dr=n(te);Xt=c(dr,"LI",{});var li=n(Xt);da=c(li,"CODE",{});var vd=n(da);ns=a(vd,"torch.utils.data.DataLoader"),vd.forEach(t),ls=a(li,": PyTorch Dataloader"),li.forEach(t),ss=i(dr),Jt=c(dr,"LI",{});var si=n(Jt);pa=c(si,"CODE",{});var bd=n(pa);is=a(bd,"torch.nn.Module"),bd.forEach(t),ds=a(si,": PyTorch Module"),si.forEach(t),ps=i(dr),Qt=c(dr,"LI",{});var ii=n(Qt);ha=c(ii,"CODE",{});var $d=n(ha);hs=a($d,"torch.optim.Optimizer"),$d.forEach(t),ms=a(ii,": PyTorch Optimizer"),ii.forEach(t),dr.forEach(t),Ne.forEach(t),us=i(p),Pe=c(p,"DIV",{class:!0});var yo=n(Pe);u(kt.$$.fragment,yo),gs=i(yo),Tt=c(yo,"P",{});var wo=n(Tt);fs=a(wo,"Use in replacement of "),ma=c(wo,"CODE",{});var yd=n(ma);_s=a(yd,"print()"),yd.forEach(t),vs=a(wo," to only print once per server."),wo.forEach(t),yo.forEach(t),bs=i(p),F=c(p,"DIV",{class:!0});var pr=n(F);u(Pt.$$.fragment,pr),$s=i(pr),re=c(pr,"P",{});var hr=n(re);ys=a(hr,"Reduce the values in "),ua=c(hr,"EM",{});var wd=n(ua);ws=a(wd,"tensor"),wd.forEach(t),Es=a(hr," across all processes based on "),ga=c(hr,"EM",{});var Ed=n(ga);As=a(Ed,"reduction"),Ed.forEach(t),xs=a(hr,"."),hr.forEach(t),Ds=i(pr),fa=c(pr,"P",{});var Ad=n(fa);ks=a(Ad,`Note:
All processes get the reduced value.`),Ad.forEach(t),pr.forEach(t),Ts=i(p),N=c(p,"DIV",{class:!0});var Se=n(N);u(Lt.$$.fragment,Se),Ps=i(Se),V=c(Se,"P",{});var Ve=n(V);Ls=a(Ve,"Makes note of "),_a=c(Ve,"CODE",{});var xd=n(_a);Is=a(xd,"objects"),xd.forEach(t),Os=a(Ve," and will save or load them in during "),va=c(Ve,"CODE",{});var Dd=n(va);zs=a(Dd,"save_state"),Dd.forEach(t),Cs=a(Ve," or "),ba=c(Ve,"CODE",{});var kd=n(ba);Us=a(kd,"load_state"),kd.forEach(t),js=a(Ve,"."),Ve.forEach(t),Ns=i(Se),$a=c(Se,"P",{});var Td=n($a);Ss=a(Td,`These should be utilized when the state is being loaded or saved in the same script. It is not designed to be
used in different scripts`),Td.forEach(t),Vs=i(Se),u(Le.$$.fragment,Se),Se.forEach(t),qs=i(p),Ie=c(p,"DIV",{class:!0});var Eo=n(Ie);u(It.$$.fragment,Eo),Gs=i(Eo),Ot=c(Eo,"P",{});var Ao=n(Ot);Ms=a(Ao,"Save the object passed to disk once per machine. Use in place of "),ya=c(Ao,"CODE",{});var Pd=n(ya);Rs=a(Pd,"torch.save"),Pd.forEach(t),Ws=a(Ao,"."),Ao.forEach(t),Eo.forEach(t),Fs=i(p),Oe=c(p,"DIV",{class:!0});var xo=n(Oe);u(zt.$$.fragment,xo),Hs=i(xo),wa=c(xo,"P",{});var Ld=n(wa);Ys=a(Ld,"Saves the current states of the model, optimizer, scaler, RNG generators, and registered objects."),Ld.forEach(t),xo.forEach(t),Ks=i(p),ze=c(p,"DIV",{class:!0});var Do=n(ze);u(Ct.$$.fragment,Do),Bs=i(Do),Ea=c(Do,"P",{});var Id=n(Ea);Xs=a(Id,"Unscale the gradients in mixed precision training with AMP. This is a noop in all other settings."),Id.forEach(t),Do.forEach(t),Js=i(p),Ce=c(p,"DIV",{class:!0});var ko=n(Ce);u(Ut.$$.fragment,ko),Qs=i(ko),ae=c(ko,"P",{});var mr=n(ae);Zs=a(mr,"Unwraps the "),Aa=c(mr,"CODE",{});var Od=n(Aa);ei=a(Od,"model"),Od.forEach(t),ti=a(mr," from the additional layer possible added by "),Zt=c(mr,"A",{href:!0});var zd=n(Zt);ri=a(zd,"prepare()"),zd.forEach(t),ai=a(mr,`. Useful before saving
the model.`),mr.forEach(t),ko.forEach(t),oi=i(p),Ue=c(p,"DIV",{class:!0});var To=n(Ue);u(jt.$$.fragment,To),ci=i(To),xa=c(To,"P",{});var Cd=n(xa);ni=a(Cd,`Will stop the execution of the current process until every other process has reached that point (so this does
nothing when the script is only run in one process). Useful to do before saving a model.`),Cd.forEach(t),To.forEach(t),p.forEach(t),this.h()},h(){h(b,"name","hf:doc:metadata"),h(b,"content",JSON.stringify(Hd)),h(k,"id","accelerate.Accelerator"),h(k,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),h(k,"href","#accelerate.Accelerator"),h(w,"class","relative group"),h(D,"href","/docs/accelerate/pr_488/en/accelerator#accelerate.Accelerator"),h(Gt,"href","/docs/accelerate/pr_488/en/accelerator#accelerate.Accelerator"),h(Mt,"href","/docs/accelerate/pr_488/en/accelerator#accelerate.Accelerator.prepare"),h(Rt,"href","/docs/accelerate/pr_488/en/accelerator#accelerate.Accelerator.gather"),h(Wt,"href","/docs/accelerate/pr_488/en/accelerator#accelerate.Accelerator.print"),h(Ft,"href","/docs/accelerate/pr_488/en/accelerator#accelerate.Accelerator.wait_for_everyone"),h(Ht,"href","/docs/accelerate/pr_488/en/accelerator#accelerate.Accelerator.unwrap_model"),h(Yt,"href","/docs/accelerate/pr_488/en/accelerator#accelerate.Accelerator.save"),h(le,"href","/docs/accelerate/pr_488/en/accelerator#accelerate.Accelerator.clip_grad_norm_"),h(se,"href","/docs/accelerate/pr_488/en/accelerator#accelerate.Accelerator.clip_grad_value_"),h(Kt,"href","/docs/accelerate/pr_488/en/accelerator#accelerate.Accelerator.accumulate"),h(Bt,"href","/docs/accelerate/pr_488/en/internal#accelerate.state.AcceleratorState"),h(he,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),h(me,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),h(ue,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),h(ge,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),h(fe,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),h(_e,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),h(ve,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),h(be,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),h(G,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),h($e,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),h(ye,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),h(we,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),h(M,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),h(Ee,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),h(R,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),h(W,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),h(Ae,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),h(xe,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),h(De,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),h(ke,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),h(Te,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),h(j,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),h(Pe,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),h(F,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),h(N,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),h(Ie,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),h(Oe,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),h(ze,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),h(Zt,"href","/docs/accelerate/pr_488/en/accelerator#accelerate.Accelerator.prepare"),h(Ce,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),h(Ue,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),h(d,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8")},m(l,y){e(document.head,b),x(l,z,y),x(l,w,y),e(w,k),e(k,I),g(E,I,null),e(w,T),e(w,C),e(C,K),x(l,oe,y),x(l,U,y),e(U,B),e(U,D),e(D,Vt),e(U,qt),x(l,qe,y),x(l,P,y),e(P,X),e(X,Po),e(X,Gt),e(Gt,Lo),e(X,Io),e(X,ur),e(ur,Oo),e(X,zo),e(P,Co),e(P,Ge),e(Ge,Uo),e(Ge,Mt),e(Mt,jo),e(Ge,No),e(P,So),e(P,S),e(S,Vo),e(S,gr),e(gr,qo),e(S,Go),e(S,fr),e(fr,Mo),e(S,Ro),e(S,_r),e(_r,Wo),e(S,Fo),e(P,Ho),e(P,J),e(J,Yo),e(J,vr),e(vr,Ko),e(J,Bo),e(J,br),e(br,Xo),e(J,Jo),e(P,Qo),e(P,Me),e(Me,Zo),e(Me,Rt),e(Rt,ec),e(Me,tc),x(l,La,y),x(l,ce,y),e(ce,rc),e(ce,$r),e($r,ac),e(ce,oc),x(l,Ia,y),x(l,A,y),e(A,ne),e(ne,yr),e(yr,cc),e(ne,nc),e(ne,Wt),e(Wt,lc),e(ne,sc),e(A,ic),e(A,Re),e(Re,dc),e(Re,wr),e(wr,pc),e(Re,hc),e(A,mc),e(A,We),e(We,uc),e(We,Er),e(Er,gc),e(We,fc),e(A,_c),e(A,Fe),e(Fe,vc),e(Fe,Ft),e(Ft,bc),e(Fe,$c),e(A,yc),e(A,He),e(He,wc),e(He,Ht),e(Ht,Ec),e(He,Ac),e(A,xc),e(A,Q),e(Q,Dc),e(Q,Yt),e(Yt,kc),e(Q,Tc),e(Q,Ar),e(Ar,Pc),e(Q,Lc),e(A,Ic),e(A,O),e(O,Oc),e(O,le),e(le,zc),e(le,xr),e(xr,Cc),e(le,Uc),e(O,jc),e(O,Dr),e(Dr,Nc),e(O,Sc),e(O,se),e(se,Vc),e(se,kr),e(kr,qc),e(se,Gc),e(O,Mc),e(O,Tr),e(Tr,Rc),e(O,Wc),x(l,Oa,y),x(l,q,y),e(q,Fc),e(q,Kt),e(Kt,Hc),e(q,Yc),e(q,Pr),e(Pr,Kc),e(q,Bc),x(l,za,y),g(Ye,l,y),x(l,Ca,y),g(ie,l,y),x(l,Ua,y),x(l,d,y),g(Ke,d,null),e(d,Xc),e(d,Lr),e(Lr,Jc),e(d,Qc),e(d,Ir),e(Ir,Zc),e(d,en),e(d,Be),e(Be,de),e(de,Or),e(Or,tn),e(de,rn),e(de,zr),e(zr,an),e(de,on),e(Be,cn),e(Be,pe),e(pe,Cr),e(Cr,nn),e(pe,ln),e(pe,Bt),e(Bt,sn),e(pe,dn),e(d,pn),e(d,he),g(Xe,he,null),e(he,hn),e(he,Ur),e(Ur,mn),e(d,un),e(d,me),g(Je,me,null),e(me,gn),e(me,jr),e(jr,fn),e(d,_n),e(d,ue),g(Qe,ue,null),e(ue,vn),e(ue,Z),e(Z,bn),e(Z,Nr),e(Nr,$n),e(Z,yn),e(Z,Sr),e(Sr,wn),e(Z,En),e(d,An),e(d,ge),g(Ze,ge,null),e(ge,xn),e(ge,et),e(et,Dn),e(et,Vr),e(Vr,kn),e(et,Tn),e(d,Pn),e(d,fe),g(tt,fe,null),e(fe,Ln),e(fe,rt),e(rt,In),e(rt,qr),e(qr,On),e(rt,zn),e(d,Cn),e(d,_e),g(at,_e,null),e(_e,Un),e(_e,ot),e(ot,jn),e(ot,Gr),e(Gr,Nn),e(ot,Sn),e(d,Vn),e(d,ve),g(ct,ve,null),e(ve,qn),e(ve,Mr),e(Mr,Gn),e(d,Mn),e(d,be),g(nt,be,null),e(be,Rn),e(be,Rr),e(Rr,Wn),e(d,Fn),e(d,G),g(lt,G,null),e(G,Hn),e(G,st),e(st,Yn),e(st,Wr),e(Wr,Kn),e(st,Bn),e(G,Xn),e(G,Fr),e(Fr,Jn),e(d,Qn),e(d,$e),g(it,$e,null),e($e,Zn),e($e,dt),e(dt,el),e(dt,Hr),e(Hr,tl),e(dt,rl),e(d,al),e(d,ye),g(pt,ye,null),e(ye,ol),e(ye,ht),e(ht,cl),e(ht,Yr),e(Yr,nl),e(ht,ll),e(d,sl),e(d,we),g(mt,we,null),e(we,il),e(we,Kr),e(Kr,dl),e(d,pl),e(d,M),g(ut,M,null),e(M,hl),e(M,Br),e(Br,ml),e(M,ul),e(M,Xr),e(Xr,gl),e(d,fl),e(d,Ee),g(gt,Ee,null),e(Ee,_l),e(Ee,ee),e(ee,vl),e(ee,Jr),e(Jr,bl),e(ee,$l),e(ee,Qr),e(Qr,yl),e(ee,wl),e(d,El),e(d,R),g(ft,R,null),e(R,Al),e(R,Zr),e(Zr,xl),e(R,Dl),e(R,ea),e(ea,kl),e(d,Tl),e(d,W),g(_t,W,null),e(W,Pl),e(W,vt),e(vt,Ll),e(vt,ta),e(ta,Il),e(vt,Ol),e(W,zl),e(W,bt),e(bt,Cl),e(bt,ra),e(ra,Ul),e(bt,jl),e(d,Nl),e(d,Ae),g($t,Ae,null),e(Ae,Sl),e(Ae,aa),e(aa,Vl),e(d,ql),e(d,xe),g(yt,xe,null),e(xe,Gl),e(xe,oa),e(oa,Ml),e(d,Rl),e(d,De),g(wt,De,null),e(De,Wl),e(De,ca),e(ca,Fl),e(d,Hl),e(d,ke),g(Et,ke,null),e(ke,Yl),e(ke,na),e(na,Kl),e(d,Bl),e(d,Te),g(At,Te,null),e(Te,Xl),e(Te,la),e(la,Jl),e(d,Ql),e(d,j),g(xt,j,null),e(j,Zl),e(j,Dt),e(Dt,es),e(Dt,sa),e(sa,ts),e(Dt,rs),e(j,as),e(j,ia),e(ia,os),e(j,cs),e(j,te),e(te,Xt),e(Xt,da),e(da,ns),e(Xt,ls),e(te,ss),e(te,Jt),e(Jt,pa),e(pa,is),e(Jt,ds),e(te,ps),e(te,Qt),e(Qt,ha),e(ha,hs),e(Qt,ms),e(d,us),e(d,Pe),g(kt,Pe,null),e(Pe,gs),e(Pe,Tt),e(Tt,fs),e(Tt,ma),e(ma,_s),e(Tt,vs),e(d,bs),e(d,F),g(Pt,F,null),e(F,$s),e(F,re),e(re,ys),e(re,ua),e(ua,ws),e(re,Es),e(re,ga),e(ga,As),e(re,xs),e(F,Ds),e(F,fa),e(fa,ks),e(d,Ts),e(d,N),g(Lt,N,null),e(N,Ps),e(N,V),e(V,Ls),e(V,_a),e(_a,Is),e(V,Os),e(V,va),e(va,zs),e(V,Cs),e(V,ba),e(ba,Us),e(V,js),e(N,Ns),e(N,$a),e($a,Ss),e(N,Vs),g(Le,N,null),e(d,qs),e(d,Ie),g(It,Ie,null),e(Ie,Gs),e(Ie,Ot),e(Ot,Ms),e(Ot,ya),e(ya,Rs),e(Ot,Ws),e(d,Fs),e(d,Oe),g(zt,Oe,null),e(Oe,Hs),e(Oe,wa),e(wa,Ys),e(d,Ks),e(d,ze),g(Ct,ze,null),e(ze,Bs),e(ze,Ea),e(Ea,Xs),e(d,Js),e(d,Ce),g(Ut,Ce,null),e(Ce,Qs),e(Ce,ae),e(ae,Zs),e(ae,Aa),e(Aa,ei),e(ae,ti),e(ae,Zt),e(Zt,ri),e(ae,ai),e(d,oi),e(d,Ue),g(jt,Ue,null),e(Ue,ci),e(Ue,xa),e(xa,ni),ja=!0},p(l,[y]){const Nt={};y&2&&(Nt.$$scope={dirty:y,ctx:l}),ie.$set(Nt);const Da={};y&2&&(Da.$$scope={dirty:y,ctx:l}),Le.$set(Da)},i(l){ja||(f(E.$$.fragment,l),f(Ye.$$.fragment,l),f(ie.$$.fragment,l),f(Ke.$$.fragment,l),f(Xe.$$.fragment,l),f(Je.$$.fragment,l),f(Qe.$$.fragment,l),f(Ze.$$.fragment,l),f(tt.$$.fragment,l),f(at.$$.fragment,l),f(ct.$$.fragment,l),f(nt.$$.fragment,l),f(lt.$$.fragment,l),f(it.$$.fragment,l),f(pt.$$.fragment,l),f(mt.$$.fragment,l),f(ut.$$.fragment,l),f(gt.$$.fragment,l),f(ft.$$.fragment,l),f(_t.$$.fragment,l),f($t.$$.fragment,l),f(yt.$$.fragment,l),f(wt.$$.fragment,l),f(Et.$$.fragment,l),f(At.$$.fragment,l),f(xt.$$.fragment,l),f(kt.$$.fragment,l),f(Pt.$$.fragment,l),f(Lt.$$.fragment,l),f(Le.$$.fragment,l),f(It.$$.fragment,l),f(zt.$$.fragment,l),f(Ct.$$.fragment,l),f(Ut.$$.fragment,l),f(jt.$$.fragment,l),ja=!0)},o(l){_(E.$$.fragment,l),_(Ye.$$.fragment,l),_(ie.$$.fragment,l),_(Ke.$$.fragment,l),_(Xe.$$.fragment,l),_(Je.$$.fragment,l),_(Qe.$$.fragment,l),_(Ze.$$.fragment,l),_(tt.$$.fragment,l),_(at.$$.fragment,l),_(ct.$$.fragment,l),_(nt.$$.fragment,l),_(lt.$$.fragment,l),_(it.$$.fragment,l),_(pt.$$.fragment,l),_(mt.$$.fragment,l),_(ut.$$.fragment,l),_(gt.$$.fragment,l),_(ft.$$.fragment,l),_(_t.$$.fragment,l),_($t.$$.fragment,l),_(yt.$$.fragment,l),_(wt.$$.fragment,l),_(Et.$$.fragment,l),_(At.$$.fragment,l),_(xt.$$.fragment,l),_(kt.$$.fragment,l),_(Pt.$$.fragment,l),_(Lt.$$.fragment,l),_(Le.$$.fragment,l),_(It.$$.fragment,l),_(zt.$$.fragment,l),_(Ct.$$.fragment,l),_(Ut.$$.fragment,l),_(jt.$$.fragment,l),ja=!1},d(l){t(b),l&&t(z),l&&t(w),v(E),l&&t(oe),l&&t(U),l&&t(qe),l&&t(P),l&&t(La),l&&t(ce),l&&t(Ia),l&&t(A),l&&t(Oa),l&&t(q),l&&t(za),v(Ye,l),l&&t(Ca),v(ie,l),l&&t(Ua),l&&t(d),v(Ke),v(Xe),v(Je),v(Qe),v(Ze),v(tt),v(at),v(ct),v(nt),v(lt),v(it),v(pt),v(mt),v(ut),v(gt),v(ft),v(_t),v($t),v(yt),v(wt),v(Et),v(At),v(xt),v(kt),v(Pt),v(Lt),v(Le),v(It),v(zt),v(Ct),v(Ut),v(jt)}}}const Hd={local:"accelerate.Accelerator",title:"Accelerator"};function Yd(St){return qd(()=>{new URLSearchParams(window.location.search).get("fw")}),[]}class Zd extends jd{constructor(b){super();Nd(this,b,Yd,Fd,Sd,{})}}export{Zd as default,Hd as metadata};
