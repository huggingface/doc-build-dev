import{S as be,i as xe,s as Ee,e as a,k as h,w as ie,t as c,M as Ae,c as n,d as t,m as d,a as l,x as se,h as u,b as S,G as o,g as i,y as le,q as ce,o as ue,B as fe,v as Pe}from"../../chunks/vendor-hf-doc-builder.js";import{T as ke}from"../../chunks/Tip-hf-doc-builder.js";import{I as Se}from"../../chunks/IconCopyLink-hf-doc-builder.js";import{C as Ue}from"../../chunks/CodeBlock-hf-doc-builder.js";function Ce(T){let s;return{c(){s=c(`Some of these are utilized with the [Accelerator.main_process_first()](/docs/accelerate/pr_495/en/package_reference/accelerator#accelerate.Accelerator.main_process_first) context manager, which utilizes [Accelerator.wait_for_everyone()](/docs/accelerate/pr_495/en/package_reference/accelerator#accelerate.Accelerator.wait_for_everyone) to 
run a particular set of code on the main process beforehand before triggering and launching the other processes`)},l(p){s=u(p,`Some of these are utilized with the [Accelerator.main_process_first()](/docs/accelerate/pr_495/en/package_reference/accelerator#accelerate.Accelerator.main_process_first) context manager, which utilizes [Accelerator.wait_for_everyone()](/docs/accelerate/pr_495/en/package_reference/accelerator#accelerate.Accelerator.wait_for_everyone) to 
run a particular set of code on the main process beforehand before triggering and launching the other processes`)},m(p,f){i(p,s,f)},d(p){p&&t(s)}}}function De(T){let s,p,f,_,U,v,Y,C,H,z,x,J,G,E,R,I,g,q,A,K,M,P,Q,N,w,O,m,D,V,X,y,Z,L,ee,te,oe,$,re,j,ae,ne,B;return v=new Se({}),g=new Ue({props:{code:"accelerator.wait_for_everyone()",highlighted:'accelerator.wait<span class="hljs-constructor">_for_everyone()</span>'}}),w=new ke({props:{$$slots:{default:[Ce]},$$scope:{ctx:T}}}),{c(){s=a("meta"),p=h(),f=a("h1"),_=a("a"),U=a("span"),ie(v.$$.fragment),Y=h(),C=a("span"),H=c("Deferring Executions"),z=h(),x=a("p"),J=c(`When you run your usual script, instructions are executed in order. Using \u{1F917} Accelerate to deploy your script on several
GPUs at the same time introduces a complication: while each process executes all instructions in order, some may be
faster than others.`),G=h(),E=a("p"),R=c(`You might need to wait for all processes to have reached a certain point before executing a given instruction. For
instance, you shouldn\u2019t save a model before being sure every process is done with training, and you wouldn\u2019t want to
continue training before all the model weights have been loaded in. To do this, just write the following line in your code:`),I=h(),ie(g.$$.fragment),q=h(),A=a("p"),K=c(`This instruction will block all the processes that arrive first until all the other processes have reached that
point (if you run your script on just one GPU or CPU, this won\u2019t do anything).`),M=h(),P=a("p"),Q=c("A few example cases for when to use this utility are listed below:"),N=h(),ie(w.$$.fragment),O=h(),m=a("ul"),D=a("li"),V=c("Downloading a dataset on the main process first and then loading the cached dataset in afterwards"),X=h(),y=a("li"),Z=c("Saving the "),L=a("code"),ee=c("state_dict"),te=c(" of the model, since you would normally save one file on just the main process"),oe=h(),$=a("li"),re=c("Loading in the "),j=a("code"),ae=c("state_dict"),ne=c(" to a model, optimizer, or scheduler before moving on to training"),this.h()},l(e){const r=Ae('[data-svelte="svelte-1phssyn"]',document.head);s=n(r,"META",{name:!0,content:!0}),r.forEach(t),p=d(e),f=n(e,"H1",{class:!0});var b=l(f);_=n(b,"A",{id:!0,class:!0,href:!0});var he=l(_);U=n(he,"SPAN",{});var de=l(U);se(v.$$.fragment,de),de.forEach(t),he.forEach(t),Y=d(b),C=n(b,"SPAN",{});var pe=l(C);H=u(pe,"Deferring Executions"),pe.forEach(t),b.forEach(t),z=d(e),x=n(e,"P",{});var me=l(x);J=u(me,`When you run your usual script, instructions are executed in order. Using \u{1F917} Accelerate to deploy your script on several
GPUs at the same time introduces a complication: while each process executes all instructions in order, some may be
faster than others.`),me.forEach(t),G=d(e),E=n(e,"P",{});var _e=l(E);R=u(_e,`You might need to wait for all processes to have reached a certain point before executing a given instruction. For
instance, you shouldn\u2019t save a model before being sure every process is done with training, and you wouldn\u2019t want to
continue training before all the model weights have been loaded in. To do this, just write the following line in your code:`),_e.forEach(t),I=d(e),se(g.$$.fragment,e),q=d(e),A=n(e,"P",{});var we=l(A);K=u(we,`This instruction will block all the processes that arrive first until all the other processes have reached that
point (if you run your script on just one GPU or CPU, this won\u2019t do anything).`),we.forEach(t),M=d(e),P=n(e,"P",{});var ve=l(P);Q=u(ve,"A few example cases for when to use this utility are listed below:"),ve.forEach(t),N=d(e),se(w.$$.fragment,e),O=d(e),m=n(e,"UL",{});var k=l(m);D=n(k,"LI",{});var ge=l(D);V=u(ge,"Downloading a dataset on the main process first and then loading the cached dataset in afterwards"),ge.forEach(t),X=d(k),y=n(k,"LI",{});var F=l(y);Z=u(F,"Saving the "),L=n(F,"CODE",{});var ye=l(L);ee=u(ye,"state_dict"),ye.forEach(t),te=u(F," of the model, since you would normally save one file on just the main process"),F.forEach(t),oe=d(k),$=n(k,"LI",{});var W=l($);re=u(W,"Loading in the "),j=n(W,"CODE",{});var $e=l(j);ae=u($e,"state_dict"),$e.forEach(t),ne=u(W," to a model, optimizer, or scheduler before moving on to training"),W.forEach(t),k.forEach(t),this.h()},h(){S(s,"name","hf:doc:metadata"),S(s,"content",JSON.stringify(Le)),S(_,"id","deferring-executions"),S(_,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),S(_,"href","#deferring-executions"),S(f,"class","relative group")},m(e,r){o(document.head,s),i(e,p,r),i(e,f,r),o(f,_),o(_,U),le(v,U,null),o(f,Y),o(f,C),o(C,H),i(e,z,r),i(e,x,r),o(x,J),i(e,G,r),i(e,E,r),o(E,R),i(e,I,r),le(g,e,r),i(e,q,r),i(e,A,r),o(A,K),i(e,M,r),i(e,P,r),o(P,Q),i(e,N,r),le(w,e,r),i(e,O,r),i(e,m,r),o(m,D),o(D,V),o(m,X),o(m,y),o(y,Z),o(y,L),o(L,ee),o(y,te),o(m,oe),o(m,$),o($,re),o($,j),o(j,ae),o($,ne),B=!0},p(e,[r]){const b={};r&2&&(b.$$scope={dirty:r,ctx:e}),w.$set(b)},i(e){B||(ce(v.$$.fragment,e),ce(g.$$.fragment,e),ce(w.$$.fragment,e),B=!0)},o(e){ue(v.$$.fragment,e),ue(g.$$.fragment,e),ue(w.$$.fragment,e),B=!1},d(e){t(s),e&&t(p),e&&t(f),fe(v),e&&t(z),e&&t(x),e&&t(G),e&&t(E),e&&t(I),fe(g,e),e&&t(q),e&&t(A),e&&t(M),e&&t(P),e&&t(N),fe(w,e),e&&t(O),e&&t(m)}}}const Le={local:"deferring-executions",title:"Deferring Executions"};function je(T){return Pe(()=>{new URLSearchParams(window.location.search).get("fw")}),[]}class qe extends be{constructor(s){super();xe(this,s,je,De,Ee,{})}}export{qe as default,Le as metadata};
