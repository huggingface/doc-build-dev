import{S as Cs,i as Os,s as Ns,e as n,k as c,w as _,t as s,M as Ws,c as r,d as t,m as p,a as o,x as $,h as i,b as u,G as e,g as ee,y as v,q as k,o as E,B as w,v as Rs}from"../../chunks/vendor-hf-doc-builder.js";import{T as Fs}from"../../chunks/Tip-hf-doc-builder.js";import{D as y}from"../../chunks/Docstring-hf-doc-builder.js";import{I as Ms}from"../../chunks/IconCopyLink-hf-doc-builder.js";import{T as Hs,M as Ho}from"../../chunks/TokenizersLanguageContent-hf-doc-builder.js";function Bs(P){let a,m,d,f,b;return{c(){a=n("p"),m=s(`This is deprecated and will be removed in a future version.
Please use `),d=n("code"),f=s("~tokenizers.Encoding.word_ids"),b=s(" instead.")},l(T){a=r(T,"P",{});var q=o(a);m=i(q,`This is deprecated and will be removed in a future version.
Please use `),d=r(q,"CODE",{});var D=o(d);f=i(D,"~tokenizers.Encoding.word_ids"),D.forEach(t),b=i(q," instead."),q.forEach(t)},m(T,q){ee(T,a,q),e(a,m),e(a,d),e(d,f),e(a,b)},d(T){T&&t(a)}}}function Js(P){let a,m,d,f,b,T,q,D,l,G,L,I,x,z,M,Fe,Y,He,mn,_n,O,le,$n,_t,vn,kn,$t,En,wn,N,ge,bn,vt,xn,Tn,kt,yn,qn,te,ue,zn,Et,Dn,Pn,W,fe,In,wt,An,Gn,bt,Ln,Sn,S,me,Vn,ne,Mn,xt,Cn,On,Be,Nn,Wn,_e,Rn,Je,Fn,Hn,Bn,Tt,Jn,Un,R,$e,jn,yt,Kn,Qn,qt,Xn,Yn,F,ve,Zn,zt,er,tr,Dt,nr,rr,H,ke,or,Pt,sr,ir,It,ar,dr,B,Ee,cr,At,pr,hr,Gt,lr,gr,V,we,ur,Lt,fr,mr,be,_r,Ue,$r,vr,kr,je,Er,St,wr,br,A,xe,xr,Vt,Tr,yr,re,qr,Te,zr,Ke,Dr,Pr,Ir,Qe,Ar,Mt,Gr,Lr,oe,ye,Sr,Ct,Vr,Mr,se,qe,Cr,Ot,Or,Nr,ie,ze,Wr,Xe,Rr,Ye,Fr,Hr,ae,De,Br,Pe,Jr,Ze,Ur,jr,Kr,J,Ie,Qr,Nt,Xr,Yr,Ae,Zr,et,eo,to,no,U,Ge,ro,Wt,oo,so,Le,io,Rt,ao,co,po,j,Se,ho,Ft,lo,go,Z,uo,Ht,fo,mo,Bt,_o,$o,vo,K,Ve,ko,Jt,Eo,wo,Me,bo,Ut,xo,To,yo,Q,Ce,qo,Oe,zo,tt,Do,Po,Io,Ne,Ao,nt,Go,Lo,So,de,We,Vo,jt,Mo,Co,ce,Re,Oo,Kt,No,Yt;return f=new Ms({}),G=new y({props:{name:"class tokenizers.Encoding",anchor:"tokenizers.Encoding",parameters:""}}),le=new y({props:{name:"attention_mask",anchor:"tokenizers.Encoding.attention_mask",parameters:[],returnDescription:`
<p>The attention mask</p>
`,returnType:`
<p><code>List[int]</code></p>
`,isGetSetDescriptor:!0}}),ge=new y({props:{name:"ids",anchor:"tokenizers.Encoding.ids",parameters:[],returnDescription:`
<p>The list of IDs</p>
`,returnType:`
<p><code>List[int]</code></p>
`,isGetSetDescriptor:!0}}),ue=new y({props:{name:"n_sequences",anchor:"tokenizers.Encoding.n_sequences",parameters:[],returnDescription:`
<p>The number of sequences in this <a
  href="/docs/tokenizers/pr_1032/en/api/encoding#tokenizers.Encoding"
>Encoding</a></p>
`,returnType:`
<p><code>int</code></p>
`,isGetSetDescriptor:!0}}),fe=new y({props:{name:"offsets",anchor:"tokenizers.Encoding.offsets",parameters:[],returnDescription:`
<p>The list of offsets</p>
`,returnType:`
<p>A <code>List</code> of <code>Tuple[int, int]</code></p>
`,isGetSetDescriptor:!0}}),me=new y({props:{name:"overflowing",anchor:"tokenizers.Encoding.overflowing",parameters:[],isGetSetDescriptor:!0}}),$e=new y({props:{name:"sequence_ids",anchor:"tokenizers.Encoding.sequence_ids",parameters:[],returnDescription:`
<p>A list of optional sequence index.</p>
`,returnType:`
<p>A <code>List</code> of <code>Optional[int]</code></p>
`,isGetSetDescriptor:!0}}),ve=new y({props:{name:"special_tokens_mask",anchor:"tokenizers.Encoding.special_tokens_mask",parameters:[],returnDescription:`
<p>The special tokens mask</p>
`,returnType:`
<p><code>List[int]</code></p>
`,isGetSetDescriptor:!0}}),ke=new y({props:{name:"tokens",anchor:"tokenizers.Encoding.tokens",parameters:[],returnDescription:`
<p>The list of tokens</p>
`,returnType:`
<p><code>List[str]</code></p>
`,isGetSetDescriptor:!0}}),Ee=new y({props:{name:"type_ids",anchor:"tokenizers.Encoding.type_ids",parameters:[],returnDescription:`
<p>The list of type ids</p>
`,returnType:`
<p><code>List[int]</code></p>
`,isGetSetDescriptor:!0}}),we=new y({props:{name:"word_ids",anchor:"tokenizers.Encoding.word_ids",parameters:[],returnDescription:`
<p>A list of optional word index.</p>
`,returnType:`
<p>A <code>List</code> of <code>Optional[int]</code></p>
`,isGetSetDescriptor:!0}}),xe=new y({props:{name:"words",anchor:"tokenizers.Encoding.words",parameters:[],returnDescription:`
<p>A list of optional word index.</p>
`,returnType:`
<p>A <code>List</code> of <code>Optional[int]</code></p>
`,isGetSetDescriptor:!0}}),re=new Fs({props:{warning:!0,$$slots:{default:[Bs]},$$scope:{ctx:P}}}),ye=new y({props:{name:"char_to_token",anchor:"tokenizers.Encoding.char_to_token",parameters:[{name:"char_pos",val:""},{name:"sequence_index",val:" = 0"}],parametersDescription:[{anchor:"tokenizers.Encoding.char_to_token.char_pos",description:`<strong>char_pos</strong> (<code>int</code>) &#x2014;
The position of a char in the input string`,name:"char_pos"},{anchor:"tokenizers.Encoding.char_to_token.sequence_index",description:`<strong>sequence_index</strong> (<code>int</code>, defaults to <code>0</code>) &#x2014;
The index of the sequence that contains the target char`,name:"sequence_index"}],returnDescription:`
<p>The index of the token that contains this char in the encoded sequence</p>
`,returnType:`
<p><code>int</code></p>
`}}),qe=new y({props:{name:"char_to_word",anchor:"tokenizers.Encoding.char_to_word",parameters:[{name:"char_pos",val:""},{name:"sequence_index",val:" = 0"}],parametersDescription:[{anchor:"tokenizers.Encoding.char_to_word.char_pos",description:`<strong>char_pos</strong> (<code>int</code>) &#x2014;
The position of a char in the input string`,name:"char_pos"},{anchor:"tokenizers.Encoding.char_to_word.sequence_index",description:`<strong>sequence_index</strong> (<code>int</code>, defaults to <code>0</code>) &#x2014;
The index of the sequence that contains the target char`,name:"sequence_index"}],returnDescription:`
<p>The index of the word that contains this char in the input sequence</p>
`,returnType:`
<p><code>int</code></p>
`}}),ze=new y({props:{name:"merge",anchor:"tokenizers.Encoding.merge",parameters:[{name:"encodings",val:""},{name:"growing_offsets",val:" = True"}],parametersDescription:[{anchor:"tokenizers.Encoding.merge.encodings",description:`<strong>encodings</strong> (A <code>List</code> of <a href="/docs/tokenizers/pr_1032/en/api/encoding#tokenizers.Encoding">Encoding</a>) &#x2014;
The list of encodings that should be merged in one`,name:"encodings"},{anchor:"tokenizers.Encoding.merge.growing_offsets",description:`<strong>growing_offsets</strong> (<code>bool</code>, defaults to <code>True</code>) &#x2014;
Whether the offsets should accumulate while merging`,name:"growing_offsets"}],returnDescription:`
<p>The resulting Encoding</p>
`,returnType:`
<p><a href="/docs/tokenizers/pr_1032/en/api/encoding#tokenizers.Encoding">Encoding</a></p>
`}}),De=new y({props:{name:"pad",anchor:"tokenizers.Encoding.pad",parameters:[{name:"length",val:""},{name:"direction",val:" = 'right'"},{name:"pad_id",val:" = 0"},{name:"pad_type_id",val:" = 0"},{name:"pad_token",val:" = '[PAD]'"}],parametersDescription:[{anchor:"tokenizers.Encoding.pad.length",description:`<strong>length</strong> (<code>int</code>) &#x2014;
The desired length</p>
<p>direction &#x2014; (<code>str</code>, defaults to <code>right</code>):
The expected padding direction. Can be either <code>right</code> or <code>left</code>`,name:"length"},{anchor:"tokenizers.Encoding.pad.pad_id",description:`<strong>pad_id</strong> (<code>int</code>, defaults to <code>0</code>) &#x2014;
The ID corresponding to the padding token`,name:"pad_id"},{anchor:"tokenizers.Encoding.pad.pad_type_id",description:`<strong>pad_type_id</strong> (<code>int</code>, defaults to <code>0</code>) &#x2014;
The type ID corresponding to the padding token`,name:"pad_type_id"},{anchor:"tokenizers.Encoding.pad.pad_token",description:`<strong>pad_token</strong> (<code>str</code>, defaults to <em>[PAD]</em>) &#x2014;
The pad token to use`,name:"pad_token"}]}}),Ie=new y({props:{name:"set_sequence_id",anchor:"tokenizers.Encoding.set_sequence_id",parameters:[{name:"sequence_id",val:""}]}}),Ge=new y({props:{name:"token_to_chars",anchor:"tokenizers.Encoding.token_to_chars",parameters:[{name:"token_index",val:""}],parametersDescription:[{anchor:"tokenizers.Encoding.token_to_chars.token_index",description:`<strong>token_index</strong> (<code>int</code>) &#x2014;
The index of a token in the encoded sequence.`,name:"token_index"}],returnDescription:`
<p>The token offsets <code>(first, last + 1)</code></p>
`,returnType:`
<p><code>Tuple[int, int]</code></p>
`}}),Se=new y({props:{name:"token_to_sequence",anchor:"tokenizers.Encoding.token_to_sequence",parameters:[{name:"token_index",val:""}],parametersDescription:[{anchor:"tokenizers.Encoding.token_to_sequence.token_index",description:`<strong>token_index</strong> (<code>int</code>) &#x2014;
The index of a token in the encoded sequence.`,name:"token_index"}],returnDescription:`
<p>The sequence id of the given token</p>
`,returnType:`
<p><code>int</code></p>
`}}),Ve=new y({props:{name:"token_to_word",anchor:"tokenizers.Encoding.token_to_word",parameters:[{name:"token_index",val:""}],parametersDescription:[{anchor:"tokenizers.Encoding.token_to_word.token_index",description:`<strong>token_index</strong> (<code>int</code>) &#x2014;
The index of a token in the encoded sequence.`,name:"token_index"}],returnDescription:`
<p>The index of the word in the relevant input sequence.</p>
`,returnType:`
<p><code>int</code></p>
`}}),Ce=new y({props:{name:"truncate",anchor:"tokenizers.Encoding.truncate",parameters:[{name:"max_length",val:""},{name:"stride",val:" = 0"},{name:"direction",val:" = 'right'"}],parametersDescription:[{anchor:"tokenizers.Encoding.truncate.max_length",description:`<strong>max_length</strong> (<code>int</code>) &#x2014;
The desired length`,name:"max_length"},{anchor:"tokenizers.Encoding.truncate.stride",description:`<strong>stride</strong> (<code>int</code>, defaults to <code>0</code>) &#x2014;
The length of previous content to be included in each overflowing piece`,name:"stride"},{anchor:"tokenizers.Encoding.truncate.direction",description:`<strong>direction</strong> (<code>str</code>, defaults to <code>right</code>) &#x2014;
Truncate direction`,name:"direction"}]}}),We=new y({props:{name:"word_to_chars",anchor:"tokenizers.Encoding.word_to_chars",parameters:[{name:"word_index",val:""},{name:"sequence_index",val:" = 0"}],parametersDescription:[{anchor:"tokenizers.Encoding.word_to_chars.word_index",description:`<strong>word_index</strong> (<code>int</code>) &#x2014;
The index of a word in one of the input sequences.`,name:"word_index"},{anchor:"tokenizers.Encoding.word_to_chars.sequence_index",description:`<strong>sequence_index</strong> (<code>int</code>, defaults to <code>0</code>) &#x2014;
The index of the sequence that contains the target word`,name:"sequence_index"}],returnDescription:`
<p>The range of characters (span) <code>(first, last + 1)</code></p>
`,returnType:`
<p><code>Tuple[int, int]</code></p>
`}}),Re=new y({props:{name:"word_to_tokens",anchor:"tokenizers.Encoding.word_to_tokens",parameters:[{name:"word_index",val:""},{name:"sequence_index",val:" = 0"}],parametersDescription:[{anchor:"tokenizers.Encoding.word_to_tokens.word_index",description:`<strong>word_index</strong> (<code>int</code>) &#x2014;
The index of a word in one of the input sequences.`,name:"word_index"},{anchor:"tokenizers.Encoding.word_to_tokens.sequence_index",description:`<strong>sequence_index</strong> (<code>int</code>, defaults to <code>0</code>) &#x2014;
The index of the sequence that contains the target word`,name:"sequence_index"}],returnDescription:`
<p>The range of tokens: <code>(first, last + 1)</code></p>
`,returnType:`
<p><code>Tuple[int, int]</code></p>
`}}),{c(){a=n("h2"),m=n("a"),d=n("span"),_(f.$$.fragment),b=c(),T=n("span"),q=s("Encoding"),D=c(),l=n("div"),_(G.$$.fragment),L=c(),I=n("p"),x=s("The "),z=n("a"),M=s("Encoding"),Fe=s(" represents the output of a "),Y=n("a"),He=s("Tokenizer"),mn=s("."),_n=c(),O=n("div"),_(le.$$.fragment),$n=c(),_t=n("p"),vn=s("The attention mask"),kn=c(),$t=n("p"),En=s(`This indicates to the LM which tokens should be attended to, and which should not.
This is especially important when batching sequences, where we need to applying
padding.`),wn=c(),N=n("div"),_(ge.$$.fragment),bn=c(),vt=n("p"),xn=s("The generated IDs"),Tn=c(),kt=n("p"),yn=s(`The IDs are the main input to a Language Model. They are the token indices,
the numerical representations that a LM understands.`),qn=c(),te=n("div"),_(ue.$$.fragment),zn=c(),Et=n("p"),Dn=s("The number of sequences represented"),Pn=c(),W=n("div"),_(fe.$$.fragment),In=c(),wt=n("p"),An=s("The offsets associated to each token"),Gn=c(),bt=n("p"),Ln=s(`These offsets let\u2019s you slice the input string, and thus retrieve the original
part that led to producing the corresponding token.`),Sn=c(),S=n("div"),_(me.$$.fragment),Vn=c(),ne=n("p"),Mn=s("A "),xt=n("code"),Cn=s("List"),On=s(" of overflowing "),Be=n("a"),Nn=s("Encoding"),Wn=c(),_e=n("p"),Rn=s("When using truncation, the "),Je=n("a"),Fn=s("Tokenizer"),Hn=s(` takes care of splitting
the output into as many pieces as required to match the specified maximum length.
This field lets you retrieve all the subsequent pieces.`),Bn=c(),Tt=n("p"),Jn=s(`When you use pairs of sequences, the overflowing pieces will contain enough
variations to cover all the possible combinations, while respecting the provided
maximum length.`),Un=c(),R=n("div"),_($e.$$.fragment),jn=c(),yt=n("p"),Kn=s("The generated sequence indices."),Qn=c(),qt=n("p"),Xn=s(`They represent the index of the input sequence associated to each token.
The sequence id can be None if the token is not related to any input sequence,
like for example with special tokens.`),Yn=c(),F=n("div"),_(ve.$$.fragment),Zn=c(),zt=n("p"),er=s("The special token mask"),tr=c(),Dt=n("p"),nr=s("This indicates which tokens are special tokens, and which are not."),rr=c(),H=n("div"),_(ke.$$.fragment),or=c(),Pt=n("p"),sr=s("The generated tokens"),ir=c(),It=n("p"),ar=s("They are the string representation of the IDs."),dr=c(),B=n("div"),_(Ee.$$.fragment),cr=c(),At=n("p"),pr=s("The generated type IDs"),hr=c(),Gt=n("p"),lr=s(`Generally used for tasks like sequence classification or question answering,
these tokens let the LM know which input sequence corresponds to each tokens.`),gr=c(),V=n("div"),_(we.$$.fragment),ur=c(),Lt=n("p"),fr=s("The generated word indices."),mr=c(),be=n("p"),_r=s(`They represent the index of the word associated to each token.
When the input is pre-tokenized, they correspond to the ID of the given input label,
otherwise they correspond to the words indices as defined by the
`),Ue=n("a"),$r=s("PreTokenizer"),vr=s(" that was used."),kr=c(),je=n("p"),Er=s(`For special tokens and such (any token that was generated from something that was
not part of the input), the output is `),St=n("code"),wr=s("None"),br=c(),A=n("div"),_(xe.$$.fragment),xr=c(),Vt=n("p"),Tr=s("The generated word indices."),yr=c(),_(re.$$.fragment),qr=c(),Te=n("p"),zr=s(`They represent the index of the word associated to each token.
When the input is pre-tokenized, they correspond to the ID of the given input label,
otherwise they correspond to the words indices as defined by the
`),Ke=n("a"),Dr=s("PreTokenizer"),Pr=s(" that was used."),Ir=c(),Qe=n("p"),Ar=s(`For special tokens and such (any token that was generated from something that was
not part of the input), the output is `),Mt=n("code"),Gr=s("None"),Lr=c(),oe=n("div"),_(ye.$$.fragment),Sr=c(),Ct=n("p"),Vr=s("Get the token that contains the char at the given position in the input sequence."),Mr=c(),se=n("div"),_(qe.$$.fragment),Cr=c(),Ot=n("p"),Or=s("Get the word that contains the char at the given position in the input sequence."),Nr=c(),ie=n("div"),_(ze.$$.fragment),Wr=c(),Xe=n("p"),Rr=s("Merge the list of encodings into one final "),Ye=n("a"),Fr=s("Encoding"),Hr=c(),ae=n("div"),_(De.$$.fragment),Br=c(),Pe=n("p"),Jr=s("Pad the "),Ze=n("a"),Ur=s("Encoding"),jr=s(" at the given length"),Kr=c(),J=n("div"),_(Ie.$$.fragment),Qr=c(),Nt=n("p"),Xr=s("Set the given sequence index"),Yr=c(),Ae=n("p"),Zr=s(`Set the given sequence index for the whole range of tokens contained in this
`),et=n("a"),eo=s("Encoding"),to=s("."),no=c(),U=n("div"),_(Ge.$$.fragment),ro=c(),Wt=n("p"),oo=s("Get the offsets of the token at the given index."),so=c(),Le=n("p"),io=s(`The returned offsets are related to the input sequence that contains the
token.  In order to determine in which input sequence it belongs, you
must call `),Rt=n("code"),ao=s("token_to_sequence()"),co=s("."),po=c(),j=n("div"),_(Se.$$.fragment),ho=c(),Ft=n("p"),lo=s("Get the index of the sequence represented by the given token."),go=c(),Z=n("p"),uo=s("In the general use case, this method returns "),Ht=n("code"),fo=s("0"),mo=s(` for a single sequence or
the first sequence of a pair, and `),Bt=n("code"),_o=s("1"),$o=s(" for the second sequence of a pair"),vo=c(),K=n("div"),_(Ve.$$.fragment),ko=c(),Jt=n("p"),Eo=s("Get the index of the word that contains the token in one of the input sequences."),wo=c(),Me=n("p"),bo=s(`The returned word index is related to the input sequence that contains
the token.  In order to determine in which input sequence it belongs, you
must call `),Ut=n("code"),xo=s("token_to_sequence()"),To=s("."),yo=c(),Q=n("div"),_(Ce.$$.fragment),qo=c(),Oe=n("p"),zo=s("Truncate the "),tt=n("a"),Do=s("Encoding"),Po=s(" at the given length"),Io=c(),Ne=n("p"),Ao=s("If this "),nt=n("a"),Go=s("Encoding"),Lo=s(` represents multiple sequences, when truncating
this information is lost. It will be considered as representing a single sequence.`),So=c(),de=n("div"),_(We.$$.fragment),Vo=c(),jt=n("p"),Mo=s("Get the offsets of the word at the given index in one of the input sequences."),Co=c(),ce=n("div"),_(Re.$$.fragment),Oo=c(),Kt=n("p"),No=s(`Get the encoded tokens corresponding to the word at the given index
in one of the input sequences.`),this.h()},l(h){a=r(h,"H2",{class:!0});var C=o(a);m=r(C,"A",{id:!0,class:!0,href:!0});var Qt=o(m);d=r(Qt,"SPAN",{});var Bo=o(d);$(f.$$.fragment,Bo),Bo.forEach(t),Qt.forEach(t),b=p(C),T=r(C,"SPAN",{});var Jo=o(T);q=i(Jo,"Encoding"),Jo.forEach(t),C.forEach(t),D=p(h),l=r(h,"DIV",{class:!0});var g=o(l);$(G.$$.fragment,g),L=p(g),I=r(g,"P",{});var rt=o(I);x=i(rt,"The "),z=r(rt,"A",{href:!0});var Uo=o(z);M=i(Uo,"Encoding"),Uo.forEach(t),Fe=i(rt," represents the output of a "),Y=r(rt,"A",{href:!0});var jo=o(Y);He=i(jo,"Tokenizer"),jo.forEach(t),mn=i(rt,"."),rt.forEach(t),_n=p(g),O=r(g,"DIV",{class:!0});var ot=o(O);$(le.$$.fragment,ot),$n=p(ot),_t=r(ot,"P",{});var Ko=o(_t);vn=i(Ko,"The attention mask"),Ko.forEach(t),kn=p(ot),$t=r(ot,"P",{});var Qo=o($t);En=i(Qo,`This indicates to the LM which tokens should be attended to, and which should not.
This is especially important when batching sequences, where we need to applying
padding.`),Qo.forEach(t),ot.forEach(t),wn=p(g),N=r(g,"DIV",{class:!0});var st=o(N);$(ge.$$.fragment,st),bn=p(st),vt=r(st,"P",{});var Xo=o(vt);xn=i(Xo,"The generated IDs"),Xo.forEach(t),Tn=p(st),kt=r(st,"P",{});var Yo=o(kt);yn=i(Yo,`The IDs are the main input to a Language Model. They are the token indices,
the numerical representations that a LM understands.`),Yo.forEach(t),st.forEach(t),qn=p(g),te=r(g,"DIV",{class:!0});var Zt=o(te);$(ue.$$.fragment,Zt),zn=p(Zt),Et=r(Zt,"P",{});var Zo=o(Et);Dn=i(Zo,"The number of sequences represented"),Zo.forEach(t),Zt.forEach(t),Pn=p(g),W=r(g,"DIV",{class:!0});var it=o(W);$(fe.$$.fragment,it),In=p(it),wt=r(it,"P",{});var es=o(wt);An=i(es,"The offsets associated to each token"),es.forEach(t),Gn=p(it),bt=r(it,"P",{});var ts=o(bt);Ln=i(ts,`These offsets let\u2019s you slice the input string, and thus retrieve the original
part that led to producing the corresponding token.`),ts.forEach(t),it.forEach(t),Sn=p(g),S=r(g,"DIV",{class:!0});var pe=o(S);$(me.$$.fragment,pe),Vn=p(pe),ne=r(pe,"P",{});var Xt=o(ne);Mn=i(Xt,"A "),xt=r(Xt,"CODE",{});var ns=o(xt);Cn=i(ns,"List"),ns.forEach(t),On=i(Xt," of overflowing "),Be=r(Xt,"A",{href:!0});var rs=o(Be);Nn=i(rs,"Encoding"),rs.forEach(t),Xt.forEach(t),Wn=p(pe),_e=r(pe,"P",{});var en=o(_e);Rn=i(en,"When using truncation, the "),Je=r(en,"A",{href:!0});var os=o(Je);Fn=i(os,"Tokenizer"),os.forEach(t),Hn=i(en,` takes care of splitting
the output into as many pieces as required to match the specified maximum length.
This field lets you retrieve all the subsequent pieces.`),en.forEach(t),Bn=p(pe),Tt=r(pe,"P",{});var ss=o(Tt);Jn=i(ss,`When you use pairs of sequences, the overflowing pieces will contain enough
variations to cover all the possible combinations, while respecting the provided
maximum length.`),ss.forEach(t),pe.forEach(t),Un=p(g),R=r(g,"DIV",{class:!0});var at=o(R);$($e.$$.fragment,at),jn=p(at),yt=r(at,"P",{});var is=o(yt);Kn=i(is,"The generated sequence indices."),is.forEach(t),Qn=p(at),qt=r(at,"P",{});var as=o(qt);Xn=i(as,`They represent the index of the input sequence associated to each token.
The sequence id can be None if the token is not related to any input sequence,
like for example with special tokens.`),as.forEach(t),at.forEach(t),Yn=p(g),F=r(g,"DIV",{class:!0});var dt=o(F);$(ve.$$.fragment,dt),Zn=p(dt),zt=r(dt,"P",{});var ds=o(zt);er=i(ds,"The special token mask"),ds.forEach(t),tr=p(dt),Dt=r(dt,"P",{});var cs=o(Dt);nr=i(cs,"This indicates which tokens are special tokens, and which are not."),cs.forEach(t),dt.forEach(t),rr=p(g),H=r(g,"DIV",{class:!0});var ct=o(H);$(ke.$$.fragment,ct),or=p(ct),Pt=r(ct,"P",{});var ps=o(Pt);sr=i(ps,"The generated tokens"),ps.forEach(t),ir=p(ct),It=r(ct,"P",{});var hs=o(It);ar=i(hs,"They are the string representation of the IDs."),hs.forEach(t),ct.forEach(t),dr=p(g),B=r(g,"DIV",{class:!0});var pt=o(B);$(Ee.$$.fragment,pt),cr=p(pt),At=r(pt,"P",{});var ls=o(At);pr=i(ls,"The generated type IDs"),ls.forEach(t),hr=p(pt),Gt=r(pt,"P",{});var gs=o(Gt);lr=i(gs,`Generally used for tasks like sequence classification or question answering,
these tokens let the LM know which input sequence corresponds to each tokens.`),gs.forEach(t),pt.forEach(t),gr=p(g),V=r(g,"DIV",{class:!0});var he=o(V);$(we.$$.fragment,he),ur=p(he),Lt=r(he,"P",{});var us=o(Lt);fr=i(us,"The generated word indices."),us.forEach(t),mr=p(he),be=r(he,"P",{});var tn=o(be);_r=i(tn,`They represent the index of the word associated to each token.
When the input is pre-tokenized, they correspond to the ID of the given input label,
otherwise they correspond to the words indices as defined by the
`),Ue=r(tn,"A",{href:!0});var fs=o(Ue);$r=i(fs,"PreTokenizer"),fs.forEach(t),vr=i(tn," that was used."),tn.forEach(t),kr=p(he),je=r(he,"P",{});var Wo=o(je);Er=i(Wo,`For special tokens and such (any token that was generated from something that was
not part of the input), the output is `),St=r(Wo,"CODE",{});var ms=o(St);wr=i(ms,"None"),ms.forEach(t),Wo.forEach(t),he.forEach(t),br=p(g),A=r(g,"DIV",{class:!0});var X=o(A);$(xe.$$.fragment,X),xr=p(X),Vt=r(X,"P",{});var _s=o(Vt);Tr=i(_s,"The generated word indices."),_s.forEach(t),yr=p(X),$(re.$$.fragment,X),qr=p(X),Te=r(X,"P",{});var nn=o(Te);zr=i(nn,`They represent the index of the word associated to each token.
When the input is pre-tokenized, they correspond to the ID of the given input label,
otherwise they correspond to the words indices as defined by the
`),Ke=r(nn,"A",{href:!0});var $s=o(Ke);Dr=i($s,"PreTokenizer"),$s.forEach(t),Pr=i(nn," that was used."),nn.forEach(t),Ir=p(X),Qe=r(X,"P",{});var Ro=o(Qe);Ar=i(Ro,`For special tokens and such (any token that was generated from something that was
not part of the input), the output is `),Mt=r(Ro,"CODE",{});var vs=o(Mt);Gr=i(vs,"None"),vs.forEach(t),Ro.forEach(t),X.forEach(t),Lr=p(g),oe=r(g,"DIV",{class:!0});var rn=o(oe);$(ye.$$.fragment,rn),Sr=p(rn),Ct=r(rn,"P",{});var ks=o(Ct);Vr=i(ks,"Get the token that contains the char at the given position in the input sequence."),ks.forEach(t),rn.forEach(t),Mr=p(g),se=r(g,"DIV",{class:!0});var on=o(se);$(qe.$$.fragment,on),Cr=p(on),Ot=r(on,"P",{});var Es=o(Ot);Or=i(Es,"Get the word that contains the char at the given position in the input sequence."),Es.forEach(t),on.forEach(t),Nr=p(g),ie=r(g,"DIV",{class:!0});var sn=o(ie);$(ze.$$.fragment,sn),Wr=p(sn),Xe=r(sn,"P",{});var Fo=o(Xe);Rr=i(Fo,"Merge the list of encodings into one final "),Ye=r(Fo,"A",{href:!0});var ws=o(Ye);Fr=i(ws,"Encoding"),ws.forEach(t),Fo.forEach(t),sn.forEach(t),Hr=p(g),ae=r(g,"DIV",{class:!0});var an=o(ae);$(De.$$.fragment,an),Br=p(an),Pe=r(an,"P",{});var dn=o(Pe);Jr=i(dn,"Pad the "),Ze=r(dn,"A",{href:!0});var bs=o(Ze);Ur=i(bs,"Encoding"),bs.forEach(t),jr=i(dn," at the given length"),dn.forEach(t),an.forEach(t),Kr=p(g),J=r(g,"DIV",{class:!0});var ht=o(J);$(Ie.$$.fragment,ht),Qr=p(ht),Nt=r(ht,"P",{});var xs=o(Nt);Xr=i(xs,"Set the given sequence index"),xs.forEach(t),Yr=p(ht),Ae=r(ht,"P",{});var cn=o(Ae);Zr=i(cn,`Set the given sequence index for the whole range of tokens contained in this
`),et=r(cn,"A",{href:!0});var Ts=o(et);eo=i(Ts,"Encoding"),Ts.forEach(t),to=i(cn,"."),cn.forEach(t),ht.forEach(t),no=p(g),U=r(g,"DIV",{class:!0});var lt=o(U);$(Ge.$$.fragment,lt),ro=p(lt),Wt=r(lt,"P",{});var ys=o(Wt);oo=i(ys,"Get the offsets of the token at the given index."),ys.forEach(t),so=p(lt),Le=r(lt,"P",{});var pn=o(Le);io=i(pn,`The returned offsets are related to the input sequence that contains the
token.  In order to determine in which input sequence it belongs, you
must call `),Rt=r(pn,"CODE",{});var qs=o(Rt);ao=i(qs,"token_to_sequence()"),qs.forEach(t),co=i(pn,"."),pn.forEach(t),lt.forEach(t),po=p(g),j=r(g,"DIV",{class:!0});var gt=o(j);$(Se.$$.fragment,gt),ho=p(gt),Ft=r(gt,"P",{});var zs=o(Ft);lo=i(zs,"Get the index of the sequence represented by the given token."),zs.forEach(t),go=p(gt),Z=r(gt,"P",{});var ut=o(Z);uo=i(ut,"In the general use case, this method returns "),Ht=r(ut,"CODE",{});var Ds=o(Ht);fo=i(Ds,"0"),Ds.forEach(t),mo=i(ut,` for a single sequence or
the first sequence of a pair, and `),Bt=r(ut,"CODE",{});var Ps=o(Bt);_o=i(Ps,"1"),Ps.forEach(t),$o=i(ut," for the second sequence of a pair"),ut.forEach(t),gt.forEach(t),vo=p(g),K=r(g,"DIV",{class:!0});var ft=o(K);$(Ve.$$.fragment,ft),ko=p(ft),Jt=r(ft,"P",{});var Is=o(Jt);Eo=i(Is,"Get the index of the word that contains the token in one of the input sequences."),Is.forEach(t),wo=p(ft),Me=r(ft,"P",{});var hn=o(Me);bo=i(hn,`The returned word index is related to the input sequence that contains
the token.  In order to determine in which input sequence it belongs, you
must call `),Ut=r(hn,"CODE",{});var As=o(Ut);xo=i(As,"token_to_sequence()"),As.forEach(t),To=i(hn,"."),hn.forEach(t),ft.forEach(t),yo=p(g),Q=r(g,"DIV",{class:!0});var mt=o(Q);$(Ce.$$.fragment,mt),qo=p(mt),Oe=r(mt,"P",{});var ln=o(Oe);zo=i(ln,"Truncate the "),tt=r(ln,"A",{href:!0});var Gs=o(tt);Do=i(Gs,"Encoding"),Gs.forEach(t),Po=i(ln," at the given length"),ln.forEach(t),Io=p(mt),Ne=r(mt,"P",{});var gn=o(Ne);Ao=i(gn,"If this "),nt=r(gn,"A",{href:!0});var Ls=o(nt);Go=i(Ls,"Encoding"),Ls.forEach(t),Lo=i(gn,` represents multiple sequences, when truncating
this information is lost. It will be considered as representing a single sequence.`),gn.forEach(t),mt.forEach(t),So=p(g),de=r(g,"DIV",{class:!0});var un=o(de);$(We.$$.fragment,un),Vo=p(un),jt=r(un,"P",{});var Ss=o(jt);Mo=i(Ss,"Get the offsets of the word at the given index in one of the input sequences."),Ss.forEach(t),un.forEach(t),Co=p(g),ce=r(g,"DIV",{class:!0});var fn=o(ce);$(Re.$$.fragment,fn),Oo=p(fn),Kt=r(fn,"P",{});var Vs=o(Kt);No=i(Vs,`Get the encoded tokens corresponding to the word at the given index
in one of the input sequences.`),Vs.forEach(t),fn.forEach(t),g.forEach(t),this.h()},h(){u(m,"id","tokenizers.Encoding"),u(m,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),u(m,"href","#tokenizers.Encoding"),u(a,"class","relative group"),u(z,"href","/docs/tokenizers/pr_1032/en/api/encoding#tokenizers.Encoding"),u(Y,"href","/docs/tokenizers/pr_1032/en/api/tokenizer#tokenizers.Tokenizer"),u(O,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),u(N,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),u(te,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),u(W,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),u(Be,"href","/docs/tokenizers/pr_1032/en/api/encoding#tokenizers.Encoding"),u(Je,"href","/docs/tokenizers/pr_1032/en/api/tokenizer#tokenizers.Tokenizer"),u(S,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),u(R,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),u(F,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),u(H,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),u(B,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),u(Ue,"href","/docs/tokenizers/pr_1032/en/api/pre-tokenizers#tokenizers.pre_tokenizers.PreTokenizer"),u(V,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),u(Ke,"href","/docs/tokenizers/pr_1032/en/api/pre-tokenizers#tokenizers.pre_tokenizers.PreTokenizer"),u(A,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),u(oe,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),u(se,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),u(Ye,"href","/docs/tokenizers/pr_1032/en/api/encoding#tokenizers.Encoding"),u(ie,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),u(Ze,"href","/docs/tokenizers/pr_1032/en/api/encoding#tokenizers.Encoding"),u(ae,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),u(et,"href","/docs/tokenizers/pr_1032/en/api/encoding#tokenizers.Encoding"),u(J,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),u(U,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),u(j,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),u(K,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),u(tt,"href","/docs/tokenizers/pr_1032/en/api/encoding#tokenizers.Encoding"),u(nt,"href","/docs/tokenizers/pr_1032/en/api/encoding#tokenizers.Encoding"),u(Q,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),u(de,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),u(ce,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),u(l,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8")},m(h,C){ee(h,a,C),e(a,m),e(m,d),v(f,d,null),e(a,b),e(a,T),e(T,q),ee(h,D,C),ee(h,l,C),v(G,l,null),e(l,L),e(l,I),e(I,x),e(I,z),e(z,M),e(I,Fe),e(I,Y),e(Y,He),e(I,mn),e(l,_n),e(l,O),v(le,O,null),e(O,$n),e(O,_t),e(_t,vn),e(O,kn),e(O,$t),e($t,En),e(l,wn),e(l,N),v(ge,N,null),e(N,bn),e(N,vt),e(vt,xn),e(N,Tn),e(N,kt),e(kt,yn),e(l,qn),e(l,te),v(ue,te,null),e(te,zn),e(te,Et),e(Et,Dn),e(l,Pn),e(l,W),v(fe,W,null),e(W,In),e(W,wt),e(wt,An),e(W,Gn),e(W,bt),e(bt,Ln),e(l,Sn),e(l,S),v(me,S,null),e(S,Vn),e(S,ne),e(ne,Mn),e(ne,xt),e(xt,Cn),e(ne,On),e(ne,Be),e(Be,Nn),e(S,Wn),e(S,_e),e(_e,Rn),e(_e,Je),e(Je,Fn),e(_e,Hn),e(S,Bn),e(S,Tt),e(Tt,Jn),e(l,Un),e(l,R),v($e,R,null),e(R,jn),e(R,yt),e(yt,Kn),e(R,Qn),e(R,qt),e(qt,Xn),e(l,Yn),e(l,F),v(ve,F,null),e(F,Zn),e(F,zt),e(zt,er),e(F,tr),e(F,Dt),e(Dt,nr),e(l,rr),e(l,H),v(ke,H,null),e(H,or),e(H,Pt),e(Pt,sr),e(H,ir),e(H,It),e(It,ar),e(l,dr),e(l,B),v(Ee,B,null),e(B,cr),e(B,At),e(At,pr),e(B,hr),e(B,Gt),e(Gt,lr),e(l,gr),e(l,V),v(we,V,null),e(V,ur),e(V,Lt),e(Lt,fr),e(V,mr),e(V,be),e(be,_r),e(be,Ue),e(Ue,$r),e(be,vr),e(V,kr),e(V,je),e(je,Er),e(je,St),e(St,wr),e(l,br),e(l,A),v(xe,A,null),e(A,xr),e(A,Vt),e(Vt,Tr),e(A,yr),v(re,A,null),e(A,qr),e(A,Te),e(Te,zr),e(Te,Ke),e(Ke,Dr),e(Te,Pr),e(A,Ir),e(A,Qe),e(Qe,Ar),e(Qe,Mt),e(Mt,Gr),e(l,Lr),e(l,oe),v(ye,oe,null),e(oe,Sr),e(oe,Ct),e(Ct,Vr),e(l,Mr),e(l,se),v(qe,se,null),e(se,Cr),e(se,Ot),e(Ot,Or),e(l,Nr),e(l,ie),v(ze,ie,null),e(ie,Wr),e(ie,Xe),e(Xe,Rr),e(Xe,Ye),e(Ye,Fr),e(l,Hr),e(l,ae),v(De,ae,null),e(ae,Br),e(ae,Pe),e(Pe,Jr),e(Pe,Ze),e(Ze,Ur),e(Pe,jr),e(l,Kr),e(l,J),v(Ie,J,null),e(J,Qr),e(J,Nt),e(Nt,Xr),e(J,Yr),e(J,Ae),e(Ae,Zr),e(Ae,et),e(et,eo),e(Ae,to),e(l,no),e(l,U),v(Ge,U,null),e(U,ro),e(U,Wt),e(Wt,oo),e(U,so),e(U,Le),e(Le,io),e(Le,Rt),e(Rt,ao),e(Le,co),e(l,po),e(l,j),v(Se,j,null),e(j,ho),e(j,Ft),e(Ft,lo),e(j,go),e(j,Z),e(Z,uo),e(Z,Ht),e(Ht,fo),e(Z,mo),e(Z,Bt),e(Bt,_o),e(Z,$o),e(l,vo),e(l,K),v(Ve,K,null),e(K,ko),e(K,Jt),e(Jt,Eo),e(K,wo),e(K,Me),e(Me,bo),e(Me,Ut),e(Ut,xo),e(Me,To),e(l,yo),e(l,Q),v(Ce,Q,null),e(Q,qo),e(Q,Oe),e(Oe,zo),e(Oe,tt),e(tt,Do),e(Oe,Po),e(Q,Io),e(Q,Ne),e(Ne,Ao),e(Ne,nt),e(nt,Go),e(Ne,Lo),e(l,So),e(l,de),v(We,de,null),e(de,Vo),e(de,jt),e(jt,Mo),e(l,Co),e(l,ce),v(Re,ce,null),e(ce,Oo),e(ce,Kt),e(Kt,No),Yt=!0},p(h,C){const Qt={};C&2&&(Qt.$$scope={dirty:C,ctx:h}),re.$set(Qt)},i(h){Yt||(k(f.$$.fragment,h),k(G.$$.fragment,h),k(le.$$.fragment,h),k(ge.$$.fragment,h),k(ue.$$.fragment,h),k(fe.$$.fragment,h),k(me.$$.fragment,h),k($e.$$.fragment,h),k(ve.$$.fragment,h),k(ke.$$.fragment,h),k(Ee.$$.fragment,h),k(we.$$.fragment,h),k(xe.$$.fragment,h),k(re.$$.fragment,h),k(ye.$$.fragment,h),k(qe.$$.fragment,h),k(ze.$$.fragment,h),k(De.$$.fragment,h),k(Ie.$$.fragment,h),k(Ge.$$.fragment,h),k(Se.$$.fragment,h),k(Ve.$$.fragment,h),k(Ce.$$.fragment,h),k(We.$$.fragment,h),k(Re.$$.fragment,h),Yt=!0)},o(h){E(f.$$.fragment,h),E(G.$$.fragment,h),E(le.$$.fragment,h),E(ge.$$.fragment,h),E(ue.$$.fragment,h),E(fe.$$.fragment,h),E(me.$$.fragment,h),E($e.$$.fragment,h),E(ve.$$.fragment,h),E(ke.$$.fragment,h),E(Ee.$$.fragment,h),E(we.$$.fragment,h),E(xe.$$.fragment,h),E(re.$$.fragment,h),E(ye.$$.fragment,h),E(qe.$$.fragment,h),E(ze.$$.fragment,h),E(De.$$.fragment,h),E(Ie.$$.fragment,h),E(Ge.$$.fragment,h),E(Se.$$.fragment,h),E(Ve.$$.fragment,h),E(Ce.$$.fragment,h),E(We.$$.fragment,h),E(Re.$$.fragment,h),Yt=!1},d(h){h&&t(a),w(f),h&&t(D),h&&t(l),w(G),w(le),w(ge),w(ue),w(fe),w(me),w($e),w(ve),w(ke),w(Ee),w(we),w(xe),w(re),w(ye),w(qe),w(ze),w(De),w(Ie),w(Ge),w(Se),w(Ve),w(Ce),w(We),w(Re)}}}function Us(P){let a,m;return a=new Ho({props:{$$slots:{default:[Js]},$$scope:{ctx:P}}}),{c(){_(a.$$.fragment)},l(d){$(a.$$.fragment,d)},m(d,f){v(a,d,f),m=!0},p(d,f){const b={};f&2&&(b.$$scope={dirty:f,ctx:d}),a.$set(b)},i(d){m||(k(a.$$.fragment,d),m=!0)},o(d){E(a.$$.fragment,d),m=!1},d(d){w(a,d)}}}function js(P){let a,m,d,f,b;return{c(){a=n("p"),m=s("The Rust API Reference is available directly on the "),d=n("a"),f=s("Docs.rs"),b=s(" website."),this.h()},l(T){a=r(T,"P",{});var q=o(a);m=i(q,"The Rust API Reference is available directly on the "),d=r(q,"A",{href:!0,rel:!0});var D=o(d);f=i(D,"Docs.rs"),D.forEach(t),b=i(q," website."),q.forEach(t),this.h()},h(){u(d,"href","https://docs.rs/tokenizers/latest/tokenizers/"),u(d,"rel","nofollow")},m(T,q){ee(T,a,q),e(a,m),e(a,d),e(d,f),e(a,b)},d(T){T&&t(a)}}}function Ks(P){let a,m;return a=new Ho({props:{$$slots:{default:[js]},$$scope:{ctx:P}}}),{c(){_(a.$$.fragment)},l(d){$(a.$$.fragment,d)},m(d,f){v(a,d,f),m=!0},p(d,f){const b={};f&2&&(b.$$scope={dirty:f,ctx:d}),a.$set(b)},i(d){m||(k(a.$$.fragment,d),m=!0)},o(d){E(a.$$.fragment,d),m=!1},d(d){w(a,d)}}}function Qs(P){let a,m;return{c(){a=n("p"),m=s("The node API has not been documented yet.")},l(d){a=r(d,"P",{});var f=o(a);m=i(f,"The node API has not been documented yet."),f.forEach(t)},m(d,f){ee(d,a,f),e(a,m)},d(d){d&&t(a)}}}function Xs(P){let a,m;return a=new Ho({props:{$$slots:{default:[Qs]},$$scope:{ctx:P}}}),{c(){_(a.$$.fragment)},l(d){$(a.$$.fragment,d)},m(d,f){v(a,d,f),m=!0},p(d,f){const b={};f&2&&(b.$$scope={dirty:f,ctx:d}),a.$set(b)},i(d){m||(k(a.$$.fragment,d),m=!0)},o(d){E(a.$$.fragment,d),m=!1},d(d){w(a,d)}}}function Ys(P){let a,m,d,f,b,T,q,D,l,G,L,I;return T=new Ms({}),L=new Hs({props:{python:!0,rust:!0,node:!0,$$slots:{node:[Xs],rust:[Ks],python:[Us]},$$scope:{ctx:P}}}),{c(){a=n("meta"),m=c(),d=n("h1"),f=n("a"),b=n("span"),_(T.$$.fragment),q=c(),D=n("span"),l=s("Encoding"),G=c(),_(L.$$.fragment),this.h()},l(x){const z=Ws('[data-svelte="svelte-1phssyn"]',document.head);a=r(z,"META",{name:!0,content:!0}),z.forEach(t),m=p(x),d=r(x,"H1",{class:!0});var M=o(d);f=r(M,"A",{id:!0,class:!0,href:!0});var Fe=o(f);b=r(Fe,"SPAN",{});var Y=o(b);$(T.$$.fragment,Y),Y.forEach(t),Fe.forEach(t),q=p(M),D=r(M,"SPAN",{});var He=o(D);l=i(He,"Encoding"),He.forEach(t),M.forEach(t),G=p(x),$(L.$$.fragment,x),this.h()},h(){u(a,"name","hf:doc:metadata"),u(a,"content",JSON.stringify(Zs)),u(f,"id","encoding"),u(f,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),u(f,"href","#encoding"),u(d,"class","relative group")},m(x,z){e(document.head,a),ee(x,m,z),ee(x,d,z),e(d,f),e(f,b),v(T,b,null),e(d,q),e(d,D),e(D,l),ee(x,G,z),v(L,x,z),I=!0},p(x,[z]){const M={};z&2&&(M.$$scope={dirty:z,ctx:x}),L.$set(M)},i(x){I||(k(T.$$.fragment,x),k(L.$$.fragment,x),I=!0)},o(x){E(T.$$.fragment,x),E(L.$$.fragment,x),I=!1},d(x){t(a),x&&t(m),x&&t(d),w(T),x&&t(G),w(L,x)}}}const Zs={local:"encoding",sections:[{local:"tokenizers.Encoding",title:"Encoding"}],title:"Encoding"};function ei(P){return Rs(()=>{new URLSearchParams(window.location.search).get("fw")}),[]}class ii extends Cs{constructor(a){super();Os(this,a,ei,Ys,Ns,{})}}export{ii as default,Zs as metadata};
