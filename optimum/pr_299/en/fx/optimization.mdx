---
local: optimization
sections:
- local: the-transformation-guide
  sections:
  - local: write-a-nonreversible-transformation
    title: Write a non-reversible transformation
  - local: write-a-reversible-transformation
    title: Write a reversible transformation
  - local: composing-transformations-together
    title: Composing transformations together
  title: The transformation guide
- local: the-optimization-api
  sections:
  - local: optimum.fx.optimization.Transformation
    title: Main classes and functions
  - local: optimum.fx.optimization.MergeLinears
    title: Transformations
  title: The Optimization API
title: Optimization
---
<script lang="ts">
import {onMount} from "svelte";
import Tip from "$lib/Tip.svelte";
import Youtube from "$lib/Youtube.svelte";
import Docstring from "$lib/Docstring.svelte";
import CodeBlock from "$lib/CodeBlock.svelte";
import CodeBlockFw from "$lib/CodeBlockFw.svelte";
import DocNotebookDropdown from "$lib/DocNotebookDropdown.svelte";
import IconCopyLink from "$lib/IconCopyLink.svelte";
import FrameworkContent from "$lib/FrameworkContent.svelte";
import Markdown from "$lib/Markdown.svelte";
import Question from "$lib/Question.svelte";
import FrameworkSwitchCourse from "$lib/FrameworkSwitchCourse.svelte";
import InferenceApi from "$lib/InferenceApi.svelte";
import TokenizersLanguageContent from "$lib/TokenizersLanguageContent.svelte";
import ExampleCodeBlock from "$lib/ExampleCodeBlock.svelte";
let fw: "pt" | "tf" = "pt";
onMount(() => {
    const urlParams = new URLSearchParams(window.location.search);
    fw = urlParams.get("fw") || "pt";
});
</script>
<svelte:head>
  <meta name="hf:doc:metadata" content={JSON.stringify(metadata)} >
</svelte:head>
<!--Copyright 2022 The HuggingFace Team. All rights reserved.

Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
the License. You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
specific language governing permissions and limitations under the License.
-->

<h1 id="optimization">Optimization</h1>

The `optimum.fx.optimization` module provides a set of torch.fx graph transformations, along with classes and functions to write your own transformations and compose them.

<h2 id="the-transformation-guide">The transformation guide</h2>

In ðŸ¤— Optimum, there are two kinds of transformations: reversible and non-reversible transformations.


<h3 id="write-a-nonreversible-transformation">Write a non-reversible transformation</h3>

The most basic case of transformations is non-reversible transformations. Those transformations cannot be reversed, meaning that after applying them to a graph module, there is no way to get the original model back. To implement such transformations in ðŸ¤— Optimum, it is very easy: you just need to subclass [Transformation](/docs/optimum/pr_299/en/fx/optimization#optimum.fx.optimization.Transformation) and implement the [transform()](/docs/optimum/pr_299/en/fx/optimization#optimum.fx.optimization.Transformation.transform) method.

For instance, the following transformation changes all the multiplications to additions:

```python
>>> from optimum.fx.optimization import Transformation

>>> class ChangeMulToAdd(Transformation):
>>>     def transform(self, graph_module):
>>>         for node in graph_module.graph.nodes:
>>>             if node.op == "call_function" and node.target == operator.mul:
>>>                 node.target = operator.add
>>>         return graph_module
```

After implementing it, your transformation can be used as a regular function:

```python
>>> from transformers import BertModel
>>> from transformers.utils.fx import symbolic_trace

>>> model = BertModel.from_pretrained("bert-base-uncased")
>>> traced = symbolic_trace(
>>>     model,
>>>     input_names=["input_ids", "attention_mask", "token_type_ids"],
>>> )

>>> transformation = ChangeMulToAdd()
>>> transformed_model = transformation(traced)
```

<h3 id="write-a-reversible-transformation">Write a reversible transformation</h3>

A reversible transformation implements both the transformation and its reverse, allowing to retrieve the original model from the transformed one. To implement such transformation, you need to subclass [ReversibleTransformation](/docs/optimum/pr_299/en/fx/optimization#optimum.fx.optimization.ReversibleTransformation) and implement the [transform()](/docs/optimum/pr_299/en/fx/optimization#optimum.fx.optimization.Transformation.transform) and [reverse()](/docs/optimum/pr_299/en/fx/optimization#optimum.fx.optimization.ReversibleTransformation.reverse) methods.

For instance, the following transformation is reversible:

```python
>>> from optimum.fx.optimization import ReversibleTransformation

>>> class MulToMulTimesTwo(ReversibleTransformation):
>>>     def transform(self, graph_module):
>>>         for node in graph_module.graph.nodes:
>>>             if node.op == "call_function" and node.target == operator.mul:
>>>                 x, y = node.args
>>>                 node.args = (2 * x, y)
>>>         return graph_module

>>>     def reverse(self, graph_module):
>>>         for node in graph_module.graph.nodes:
>>>             if node.op == "call_function" and node.target == operator.mul:
>>>                 x, y = node.args
>>>                 node.args = (x / 2, y)
>>>         return graph_module
```

<h3 id="composing-transformations-together">Composing transformations together</h3>

As applying mutilple transformations in chain is needed more often that not, [compose()](/docs/optimum/pr_299/en/fx/optimization#optimum.fx.optimization.compose) is provided. It is an utility function that allows you to create a transformation by chaining multiple other transformations.

```python
>>> from optimum.fx.optimization import compose
>>> composition = compose(MulToMulTimesTwo(), ChangeMulToAdd())
```

<h2 id="the-optimization-api">The Optimization API</h2>

<h3 id="optimum.fx.optimization.Transformation">Main classes and functions</h3>

<div class="docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8">

<docstring><name>class optimum.fx.optimization.Transformation</name><anchor>optimum.fx.optimization.Transformation</anchor><source>https://github.com/huggingface/optimum/blob/vr_299/src/optimum/fx/optimization/transformations.py#L87</source><parameters>[]</parameters><paramsdesc>- **preserves_computation** (`bool`, defaults to `False`) --
  Whether the transformation preserves the graph computation or not. If `True`, the original and the
  transformed graph should produce the same outputs.</paramsdesc><paramgroups>0</paramgroups></docstring>

A torch.fx graph transformation.

It  must implemement the [transform()](/docs/optimum/pr_299/en/fx/optimization#optimum.fx.optimization.Transformation.transform) method, and be used as a
callable.






<div class="docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8">
<docstring><name>__call__</name><anchor>optimum.fx.optimization.Transformation.__call__</anchor><source>https://github.com/huggingface/optimum/blob/vr_299/src/optimum/fx/optimization/transformations.py#L110</source><parameters>[{"name": "graph_module", "val": ": GraphModule"}, {"name": "lint_and_recompile", "val": ": bool = True"}]</parameters><paramsdesc>- **graph_module** (`torch.fx.GraphModule`) --
  The module to transform.
- **lint_and_recompile** (`bool`, defaults to `True`) --
  Whether the transformed module should be linted and recompiled.
  This can be set to `False` when chaining transformations together to perform this operation only once.</paramsdesc><paramgroups>0</paramgroups><rettype>`torch.fx.GraphModule`</rettype><retdesc>The transformed module.</retdesc></docstring>








</div>
<div class="docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8">
<docstring><name>get_transformed_nodes</name><anchor>optimum.fx.optimization.Transformation.get_transformed_nodes</anchor><source>https://github.com/huggingface/optimum/blob/vr_299/src/optimum/fx/optimization/transformations.py#L163</source><parameters>[{"name": "graph_module", "val": ": GraphModule"}]</parameters><paramsdesc>- **graph_module** (`torch.fx.GraphModule`) --
  The graph_module to get the nodes from.</paramsdesc><paramgroups>0</paramgroups><rettype>`List[torch.fx.Node]`</rettype><retdesc>Gives the list of nodes that were transformed by the transformation.</retdesc></docstring>








</div>
<div class="docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8">
<docstring><name>mark_as_transformed</name><anchor>optimum.fx.optimization.Transformation.mark_as_transformed</anchor><source>https://github.com/huggingface/optimum/blob/vr_299/src/optimum/fx/optimization/transformations.py#L139</source><parameters>[{"name": "node", "val": ": Node"}]</parameters><paramsdesc>- **node** (`torch.fx.Node`) --
  The node to mark as transformed.</paramsdesc><paramgroups>0</paramgroups></docstring>

Marks a node as transformed by this transformation.




</div>
<div class="docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8">
<docstring><name>transform</name><anchor>optimum.fx.optimization.Transformation.transform</anchor><source>https://github.com/huggingface/optimum/blob/vr_299/src/optimum/fx/optimization/transformations.py#L97</source><parameters>[{"name": "graph_module", "val": ": GraphModule"}]</parameters><paramsdesc>- **graph_module** (`torch.fx.GraphModule`) --
  The module to transform.</paramsdesc><paramgroups>0</paramgroups><rettype>`torch.fx.GraphModule`</rettype><retdesc>The transformed module.</retdesc></docstring>








</div>
<div class="docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8">
<docstring><name>transformed</name><anchor>optimum.fx.optimization.Transformation.transformed</anchor><source>https://github.com/huggingface/optimum/blob/vr_299/src/optimum/fx/optimization/transformations.py#L151</source><parameters>[{"name": "node", "val": ": Node"}]</parameters><paramsdesc>- **node** (`torch.fx.Node`) --
  The node to check.</paramsdesc><paramgroups>0</paramgroups><rettype>`bool`</rettype><retdesc>Specifies whether the node was transformed by this transformation or not.</retdesc></docstring>








</div></div>

<div class="docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8">

<docstring><name>class optimum.fx.optimization.ReversibleTransformation</name><anchor>optimum.fx.optimization.ReversibleTransformation</anchor><source>https://github.com/huggingface/optimum/blob/vr_299/src/optimum/fx/optimization/transformations.py#L178</source><parameters>[]</parameters><paramsdesc>- **preserves_computation** (`bool`, defaults to `False`) --
  Whether the transformation preserves the graph computation or not. If `True`, the original and the
  transformed graph should produce the same outputs.</paramsdesc><paramgroups>0</paramgroups></docstring>

A torch.fx graph transformation that is reversible.

It must implemement the [transform()](/docs/optimum/pr_299/en/fx/optimization#optimum.fx.optimization.Transformation.transform) and
[reverse()](/docs/optimum/pr_299/en/fx/optimization#optimum.fx.optimization.ReversibleTransformation.reverse) methods, and be used as a callable.






<div class="docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8">
<docstring><name>__call__</name><anchor>optimum.fx.optimization.ReversibleTransformation.__call__</anchor><source>https://github.com/huggingface/optimum/blob/vr_299/src/optimum/fx/optimization/transformations.py#L199</source><parameters>[{"name": "graph_module", "val": ": GraphModule"}, {"name": "lint_and_recompile", "val": ": bool = True"}, {"name": "reverse", "val": ": bool = False"}]</parameters><paramsdesc>- **graph_module** (`torch.fx.GraphModule`) --
  The module to transform.
- **lint_and_recompile** (`bool`, defaults to `True`) --
  Whether the transformed module should be linted and recompiled.
  This can be set to `False` when chaining transformations together to perform this operation only once.
- **reverse** (`bool`, defaults to `False`) --
  If `True`, the reverse transformation is performed.</paramsdesc><paramgroups>0</paramgroups><rettype>`torch.fx.GraphModule`</rettype><retdesc>The transformed module.</retdesc></docstring>








</div>
<div class="docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8">
<docstring><name>mark_as_restored</name><anchor>optimum.fx.optimization.ReversibleTransformation.mark_as_restored</anchor><source>https://github.com/huggingface/optimum/blob/vr_299/src/optimum/fx/optimization/transformations.py#L224</source><parameters>[{"name": "node", "val": ": Node"}]</parameters><paramsdesc>- **node** (`torch.fx.Node`) --
  The node to mark as restored.</paramsdesc><paramgroups>0</paramgroups></docstring>

Marks a node as restored back to its original state.




</div>
<div class="docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8">
<docstring><name>reverse</name><anchor>optimum.fx.optimization.ReversibleTransformation.reverse</anchor><source>https://github.com/huggingface/optimum/blob/vr_299/src/optimum/fx/optimization/transformations.py#L186</source><parameters>[{"name": "graph_module", "val": ": GraphModule"}]</parameters><paramsdesc>- **graph_module** (`torch.fx.GraphModule`) --
  The module to transform.</paramsdesc><paramgroups>0</paramgroups><rettype>`torch.fx.GraphModule`</rettype><retdesc>The reverse transformed module.</retdesc></docstring>








</div></div>

<div class="docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8">

<docstring><name>optimum.fx.optimization.compose</name><anchor>optimum.fx.optimization.compose</anchor><source>https://github.com/huggingface/optimum/blob/vr_299/src/optimum/fx/optimization/transformations.py#L435</source><parameters>[{"name": "*args", "val": ": Transformation"}, {"name": "inplace", "val": ": bool = True"}]</parameters><paramsdesc>- **args** ([Transformation](/docs/optimum/pr_299/en/fx/optimization#optimum.fx.optimization.Transformation)) --
  The transformations to compose together.
- **inplace** (`bool`, defaults to `True`) --
  Whether the resulting transformation should be inplace, or create a new graph module.</paramsdesc><paramgroups>0</paramgroups><retdesc>The composition transformation object.</retdesc></docstring>

Composes a list of transformations together.





<ExampleCodeBlock anchor="optimum.fx.optimization.compose.example">

Example:

```python
>>> from transformers import BertModel
>>> from transformers.utils.fx import symbolic_trace
>>> from optimum.fx.optimization import ChangeTrueDivToMulByInverse, MergeLinears, compose

>>> model = BertModel.from_pretrained("bert-base-uncased")
>>> traced = symbolic_trace(
>>>     model,
>>>     input_names=["input_ids", "attention_mask", "token_type_ids"],
>>> )
>>> composition = compose(ChangeTrueDivToMulByInverse(), MergeLinears())
>>> transformed_model = composition(traced)
```

</ExampleCodeBlock>


</div>

<h3 id="optimum.fx.optimization.MergeLinears">Transformations</h3>

<div class="docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8">

<docstring><name>class optimum.fx.optimization.MergeLinears</name><anchor>optimum.fx.optimization.MergeLinears</anchor><source>https://github.com/huggingface/optimum/blob/vr_299/src/optimum/fx/optimization/transformations.py#L239</source><parameters>[]</parameters><paramsdesc>- **preserves_computation** (`bool`, defaults to `False`) --
  Whether the transformation preserves the graph computation or not. If `True`, the original and the
  transformed graph should produce the same outputs.</paramsdesc><paramgroups>0</paramgroups></docstring>

Transformation that merges linear layers that take the same input into one big linear layer.




<ExampleCodeBlock anchor="optimum.fx.optimization.MergeLinears.example">

Example:

```python
>>> from transformers import BertModel
>>> from transformers.utils.fx import symbolic_trace
>>> from optimum.fx.optimization import MergeLinears

>>> model = BertModel.from_pretrained("bert-base-uncased")
>>> traced = symbolic_trace(
>>>     model,
>>>     input_names=["input_ids", "attention_mask", "token_type_ids"],
>>> )
>>> transformation = MergeLinears()
>>> transformed_model = transformation(traced)
>>> restored_model = transformation(transformed_model, reverse=True)
```

</ExampleCodeBlock>


</div>

<div class="docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8">

<docstring><name>class optimum.fx.optimization.ChangeTrueDivToMulByInverse</name><anchor>optimum.fx.optimization.ChangeTrueDivToMulByInverse</anchor><source>https://github.com/huggingface/optimum/blob/vr_299/src/optimum/fx/optimization/transformations.py#L366</source><parameters>[]</parameters><paramsdesc>- **preserves_computation** (`bool`, defaults to `False`) --
  Whether the transformation preserves the graph computation or not. If `True`, the original and the
  transformed graph should produce the same outputs.</paramsdesc><paramgroups>0</paramgroups></docstring>

Transformation that changes truediv nodes to multiplication by the inverse nodes when the denominator is static.
For example, that is sometimes the case for the scaling factor in attention layers.




<ExampleCodeBlock anchor="optimum.fx.optimization.ChangeTrueDivToMulByInverse.example">

Example:

```python
>>> from transformers import BertModel
>>> from transformers.utils.fx import symbolic_trace
>>> from optimum.fx.optimization import ChangeTrueDivToMulByInverse

>>> model = BertModel.from_pretrained("bert-base-uncased")
>>> traced = symbolic_trace(
>>>     model,
>>>     input_names=["input_ids", "attention_mask", "token_type_ids"],
>>> )
>>> transformation = ChangeTrueDivToMulByInverse()
>>> transformed_model = transformation(traced)
>>> restored_model = transformation(transformed_model, reverse=True)
```

</ExampleCodeBlock>


</div>
