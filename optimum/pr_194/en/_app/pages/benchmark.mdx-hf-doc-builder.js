import{S as rn,i as sn,s as on,e as n,k as o,w as u,t as m,M as ln,c as r,d as a,m as i,a as s,x as g,h as p,b as l,G as t,g as d,y as h,L as mn,q as f,o as _,B as v,v as pn}from"../chunks/vendor-hf-doc-builder.js";import{D as y}from"../chunks/Docstring-hf-doc-builder.js";import{I as yt}from"../chunks/IconCopyLink-hf-doc-builder.js";function cn(Pa){let C,Qe,E,S,xe,Q,kt,De,xt,Je,T,V,we,J,Dt,Pe,wt,je,j,K,Ke,b,X,Pt,D,Y,zt,ze,Ct,Et,Ce,Tt,Rt,w,Z,Lt,Ee,At,Nt,Te,qt,It,M,ee,St,Re,Vt,Mt,O,te,Ot,ae,Ft,_e,Bt,Gt,Ht,F,ne,Ut,re,Wt,ve,Qt,Jt,Xe,R,B,Le,se,jt,Ae,Kt,Ye,L,oe,Xt,Ne,Yt,Ze,A,ie,Zt,qe,ea,et,N,le,ta,Ie,aa,tt,q,me,na,Se,ra,at,I,G,Ve,pe,sa,Me,oa,nt,$,ce,ia,P,de,la,Oe,ma,pa,Fe,ca,da,z,ue,ua,Be,ga,ha,Ge,fa,_a,H,ge,va,He,ba,$a,U,he,ya,Ue,ka,xa,W,fe,Da,We,wa,rt;return Q=new yt({}),J=new yt({}),K=new y({props:{name:"optimum.pipelines.pipeline",anchor:"optimum.pipelines.pipeline",parameters:[{name:"task",val:": str = None"},{name:"model",val:": typing.Optional[typing.Any] = None"},{name:"tokenizer",val:": typing.Union[str, transformers.tokenization_utils.PreTrainedTokenizer, NoneType] = None"},{name:"feature_extractor",val:": typing.Union[str, ForwardRef('SequenceFeatureExtractor'), NoneType] = None"},{name:"use_fast",val:": bool = True"},{name:"use_auth_token",val:": typing.Union[str, bool, NoneType] = None"},{name:"accelerator",val:": typing.Optional[str] = 'ort'"},{name:"**kwargs",val:""}],source:"https://github.com/huggingface/optimum/blob/vr_194/src/optimum/pipelines.py#L66"}}),X=new y({props:{name:"class optimum.runs_base.Run",anchor:"optimum.runs_base.Run",parameters:[{name:"run_config",val:": dict"}],source:"https://github.com/huggingface/optimum/blob/vr_194/src/optimum/runs_base.py#L46"}}),Y=new y({props:{name:"__init__",anchor:"optimum.runs_base.Run.__init__",parameters:[{name:"run_config",val:": dict"}],parametersDescription:[{anchor:"optimum.runs_base.Run.__init__.run_config",description:'<strong>run_config</strong> (dict) &#x2014; Parameters to use for the run. See <a href="/docs/optimum/pr_194/en/benchmark#optimum.utils.runs.RunConfig">RunConfig</a> for the expected keys.',name:"run_config"}],source:"https://github.com/huggingface/optimum/blob/vr_194/src/optimum/runs_base.py#L47"}}),Z=new y({props:{name:"launch",anchor:"optimum.runs_base.Run.launch",parameters:[],source:"https://github.com/huggingface/optimum/blob/vr_194/src/optimum/runs_base.py#L104",returnDescription:`
<p>Finalized run data with metrics stored in the \u201Cevaluation\u201D key.</p>
`,returnType:`
<p><code>dict</code></p>
`}}),ee=new y({props:{name:"load_datasets",anchor:"optimum.runs_base.Run.load_datasets",parameters:[],source:"https://github.com/huggingface/optimum/blob/vr_194/src/optimum/runs_base.py#L138"}}),te=new y({props:{name:"get_calibration_dataset",anchor:"optimum.runs_base.Run.get_calibration_dataset",parameters:[],source:"https://github.com/huggingface/optimum/blob/vr_194/src/optimum/runs_base.py#L146",returnDescription:`
<p>Calibration dataset.</p>
`,returnType:`
<p><code>datasets.Dataset</code></p>
`}}),ne=new y({props:{name:"get_eval_dataset",anchor:"optimum.runs_base.Run.get_eval_dataset",parameters:[],source:"https://github.com/huggingface/optimum/blob/vr_194/src/optimum/runs_base.py#L156",returnDescription:`
<p>Evaluation dataset.</p>
`,returnType:`
<p><code>datasets.Dataset</code></p>
`}}),se=new yt({}),oe=new y({props:{name:"class optimum.utils.runs.RunConfig",anchor:"optimum.utils.runs.RunConfig",parameters:[{name:"model_name_or_path",val:": str"},{name:"task",val:": str"},{name:"task_args",val:": TaskArgs = None"},{name:"quantization_approach",val:": QuantizationApproach"},{name:"dataset",val:": DatasetArgs"},{name:"operators_to_quantize",val:": typing.List[str] = ['Add', 'MatMul']"},{name:"node_exclusion",val:": typing.List[str] = []"},{name:"per_channel",val:": bool = False"},{name:"calibration",val:": Calibration = None"},{name:"framework",val:": Frameworks"},{name:"framework_args",val:": FrameworkArgs"},{name:"aware_training",val:": bool = False"},{name:"metrics",val:": typing.List[str]"},{name:"batch_sizes",val:": typing.List[int] = [4, 8]"},{name:"input_lengths",val:": typing.List[int] = [128]"}],parametersDescription:[{anchor:"optimum.utils.runs.RunConfig.model_name_or_path",description:"<strong>model_name_or_path</strong> (<code>str</code>) &#x2014; Name of the model hosted on the Hub to use for the run.",name:"model_name_or_path"},{anchor:"optimum.utils.runs.RunConfig.task",description:"<strong>task</strong> (<code>str</code>) &#x2014; Task performed by the model.",name:"task"},{anchor:"optimum.utils.runs.RunConfig.task_args",description:"<strong>task_args</strong> (<code>TaskArgs</code>, <em>optional</em>) &#x2014; Task-specific arguments (default: <code>None</code>).",name:"task_args"},{anchor:"optimum.utils.runs.RunConfig.quantization_approach",description:"<strong>quantization_approach</strong> (<code>QuantizationApproach</code>) &#x2014; Whether to use dynamic or static quantization.",name:"quantization_approach"},{anchor:"optimum.utils.runs.RunConfig.dataset",description:"<strong>dataset</strong> (<code>DatasetArgs</code>) &#x2014; Dataset to use. Several keys must be set on top of the dataset name.",name:"dataset"},{anchor:"optimum.utils.runs.RunConfig.operators_to_quantize",description:"<strong>operators_to_quantize</strong> (<code>List[str]</code>, <em>optional</em>) &#x2014; Operators to quantize, doing no modifications to others (default: <code>[&quot;Add&quot;, &quot;MatMul&quot;]</code>).",name:"operators_to_quantize"},{anchor:"optimum.utils.runs.RunConfig.node_exclusion",description:"<strong>node_exclusion</strong> (<code>List[str]</code>, <em>optional</em>) &#x2014; Specific nodes to exclude from being quantized (default: <code>[]</code>).",name:"node_exclusion"},{anchor:"optimum.utils.runs.RunConfig.per_channel",description:"<strong>per_channel</strong> (<code>bool</code>, <em>optional</em>) &#x2014; Whether to quantize per channel (default: <code>False</code>).",name:"per_channel"},{anchor:"optimum.utils.runs.RunConfig.calibration",description:"<strong>calibration</strong> (<code>Calibration</code>, <em>optional</em>) &#x2014; Calibration parameters, in case static quantization is used.",name:"calibration"},{anchor:"optimum.utils.runs.RunConfig.framework",description:"<strong>framework</strong> (<code>Frameworks</code>) &#x2014; Name of the framework used (e.g. &#x201C;onnxruntime&#x201D;).",name:"framework"},{anchor:"optimum.utils.runs.RunConfig.framework_args",description:"<strong>framework_args</strong> (<code>FrameworkArgs</code>) &#x2014; Framework-specific arguments.",name:"framework_args"},{anchor:"optimum.utils.runs.RunConfig.aware_training",description:"<strong>aware_training</strong> (<code>bool</code>, <em>optional</em>) &#x2014; Whether the quantization is to be done with Quantization-Aware Training (not supported).",name:"aware_training"},{anchor:"optimum.utils.runs.RunConfig.metrics",description:"<strong>metrics</strong> (<code>List[str]</code>) &#x2014; List of metrics to evaluate on.",name:"metrics"},{anchor:"optimum.utils.runs.RunConfig.batch_sizes",description:"<strong>batch_sizes</strong> (<code>List[int]</code>, <em>optional</em>) &#x2014; Batch sizes to include in the run to measure time metrics.",name:"batch_sizes"},{anchor:"optimum.utils.runs.RunConfig.input_lengths",description:"<strong>input_lengths</strong> (<code>List[int]</code>, <em>optional</em>) &#x2014; Input lengths to include in the run to measure time metrics.",name:"input_lengths"}],source:"https://github.com/huggingface/optimum/blob/vr_194/src/optimum/utils/runs.py#L205"}}),ie=new y({props:{name:"class optimum.utils.runs.Calibration",anchor:"optimum.utils.runs.Calibration",parameters:[{name:"method",val:": CalibrationMethods"},{name:"num_calibration_samples",val:": int"},{name:"calibration_histogram_percentile",val:": float = None"},{name:"calibration_moving_average",val:": bool = None"},{name:"calibration_moving_average_constant",val:": float = None"}],parametersDescription:[{anchor:"optimum.utils.runs.Calibration.method",description:"<strong>method</strong> (<code>CalibrationMethods</code>) &#x2014; Calibration method used, either &#x201C;minmax&#x201D;, &#x201C;entropy&#x201D; or &#x201C;percentile&#x201D;.",name:"method"},{anchor:"optimum.utils.runs.Calibration.num_calibration_samples",description:"<strong>num_calibration_samples</strong> (<code>int</code>) &#x2014; Number of examples to use for the calibration step resulting from static quantization.",name:"num_calibration_samples"},{anchor:"optimum.utils.runs.Calibration.calibration_histogram_percentile",description:"<strong>calibration_histogram_percentile</strong> (<code>float</code>, <em>optional</em>) &#x2014; The percentile used for the percentile calibration method.",name:"calibration_histogram_percentile"},{anchor:"optimum.utils.runs.Calibration.calibration_moving_average",description:"<strong>calibration_moving_average</strong> (<code>bool</code>, <em>optional</em>) &#x2014; Whether to compute the moving average of the minimum and maximum values for the minmax calibration method.",name:"calibration_moving_average"},{anchor:"optimum.utils.runs.Calibration.calibration_moving_average_constant",description:"<strong>calibration_moving_average_constant</strong> (<code>float</code>, <em>optional</em>) &#x2014; Constant smoothing factor to use when computing the moving average of the minimum and maximum values. Effective only when the selected calibration method is minmax and <code>calibration_moving_average</code> is set to True.",name:"calibration_moving_average_constant"}],source:"https://github.com/huggingface/optimum/blob/vr_194/src/optimum/utils/runs.py#L59"}}),le=new y({props:{name:"class optimum.utils.runs.DatasetArgs",anchor:"optimum.utils.runs.DatasetArgs",parameters:[{name:"path",val:": str"},{name:"name",val:": str = None"},{name:"calibration_split",val:": str = None"},{name:"eval_split",val:": str"},{name:"data_keys",val:": typing.Dict[str, typing.Optional[str]]"},{name:"ref_keys",val:": typing.List[str]"}],parametersDescription:[{anchor:"optimum.utils.runs.DatasetArgs.path",description:"<strong>path</strong> (<code>str</code>) &#x2014; Path to the dataset, as in <code>datasets.load_dataset(path)</code>.",name:"path"},{anchor:"optimum.utils.runs.DatasetArgs.name",description:"<strong>name</strong> (<code>str</code>, <em>optional</em>) &#x2014; Name of the dataset, as in <code>datasets.load_dataset(path, name)</code>.",name:"name"},{anchor:"optimum.utils.runs.DatasetArgs.calibration_split",description:"<strong>calibration_split</strong> (<code>str</code>, <em>optional</em>) &#x2014; Dataset split used for calibration (e.g. &#x201C;train&#x201D;).",name:"calibration_split"},{anchor:"optimum.utils.runs.DatasetArgs.eval_split",description:"<strong>eval_split</strong> (<code>str</code>) &#x2014; Dataset split used for evaluation (e.g. &#x201C;test&#x201D;).",name:"eval_split"},{anchor:"optimum.utils.runs.DatasetArgs.data_keys",description:"<strong>data_keys</strong> (<code>Mapping[str, Union[str, NoneType]]</code>) &#x2014; Dataset columns used as input data. At most two, indicated with &#x201C;primary&#x201D; and &#x201C;secondary&#x201D;.",name:"data_keys"},{anchor:"optimum.utils.runs.DatasetArgs.ref_keys",description:"<strong>ref_keys</strong> (<code>List[str]</code>) &#x2014; Dataset column used for references during evaluation.",name:"ref_keys"}],source:"https://github.com/huggingface/optimum/blob/vr_194/src/optimum/utils/runs.py#L118"}}),me=new y({props:{name:"class optimum.utils.runs.TaskArgs",anchor:"optimum.utils.runs.TaskArgs",parameters:[{name:"is_regression",val:": bool = None"}],parametersDescription:[{anchor:"optimum.utils.runs.TaskArgs.is_regression",description:"<strong>is_regression</strong> (<code>bool</code>, <em>optional</em>) &#x2014; Text classification specific. Set whether the task is regression (output = one float).",name:"is_regression"}],source:"https://github.com/huggingface/optimum/blob/vr_194/src/optimum/utils/runs.py#L133"}}),pe=new yt({}),ce=new y({props:{name:"class optimum.utils.preprocessing.base.DatasetProcessing",anchor:"optimum.utils.preprocessing.base.DatasetProcessing",parameters:[{name:"dataset_path",val:": str"},{name:"dataset_name",val:": str"},{name:"tokenizer",val:": PreTrainedTokenizerBase"},{name:"eval_split",val:": str"},{name:"static_quantization",val:": bool"},{name:"data_keys",val:": typing.Dict[str, str]"},{name:"ref_keys",val:": typing.List[str]"},{name:"config",val:": PretrainedConfig"},{name:"task_args",val:": typing.Optional[typing.Dict] = None"},{name:"num_calibration_samples",val:": typing.Optional[int] = None"},{name:"calibration_split",val:": typing.Optional[str] = None"}],source:"https://github.com/huggingface/optimum/blob/vr_194/src/optimum/utils/preprocessing/base.py#L7"}}),de=new y({props:{name:"__init__",anchor:"optimum.utils.preprocessing.base.DatasetProcessing.__init__",parameters:[{name:"dataset_path",val:": str"},{name:"dataset_name",val:": str"},{name:"tokenizer",val:": PreTrainedTokenizerBase"},{name:"eval_split",val:": str"},{name:"static_quantization",val:": bool"},{name:"data_keys",val:": typing.Dict[str, str]"},{name:"ref_keys",val:": typing.List[str]"},{name:"config",val:": PretrainedConfig"},{name:"task_args",val:": typing.Optional[typing.Dict] = None"},{name:"num_calibration_samples",val:": typing.Optional[int] = None"},{name:"calibration_split",val:": typing.Optional[str] = None"}],parametersDescription:[{anchor:"optimum.utils.preprocessing.base.DatasetProcessing.__init__.dataset_path",description:'<strong>dataset_path</strong> (<code>str</code>) &#x2014; Dataset path (<a href="https://huggingface.co/docs/datasets/v2.2.1/en/package_reference/loading_methods#datasets.load_dataset.path" rel="nofollow">https://huggingface.co/docs/datasets/v2.2.1/en/package_reference/loading_methods#datasets.load_dataset.path</a>)',name:"dataset_path"},{anchor:"optimum.utils.preprocessing.base.DatasetProcessing.__init__.dataset_name",description:'<strong>dataset_name</strong> (<code>str</code>) &#x2014; Dataset name (<a href="https://huggingface.co/docs/datasets/v2.2.1/en/package_reference/loading_methods#datasets.load_dataset.name" rel="nofollow">https://huggingface.co/docs/datasets/v2.2.1/en/package_reference/loading_methods#datasets.load_dataset.name</a>)',name:"dataset_name"},{anchor:"optimum.utils.preprocessing.base.DatasetProcessing.__init__.tokenizer",description:"<strong>tokenizer</strong> (<code>PreTrainedTokenizerBase</code>) &#x2014; Tokenizer used for evaluation.",name:"tokenizer"},{anchor:"optimum.utils.preprocessing.base.DatasetProcessing.__init__.eval_split",description:"<strong>eval_split</strong> (<code>str</code>) &#x2014; Dataset split used for evaluation (e.g. &#x201C;test&#x201D;).",name:"eval_split"},{anchor:"optimum.utils.preprocessing.base.DatasetProcessing.__init__.static_quantization",description:"<strong>static_quantization</strong> (<code>bool</code>) &#x2014; Static quantization is used.",name:"static_quantization"},{anchor:"optimum.utils.preprocessing.base.DatasetProcessing.__init__.data_keys",description:"<strong>data_keys</strong> (<code>Dict[str, str]</code>) &#x2014; Map &#x201C;primary&#x201D; and &#x201C;secondary&#x201D; to data column names.",name:"data_keys"},{anchor:"optimum.utils.preprocessing.base.DatasetProcessing.__init__.ref_keys",description:"<strong>ref_keys</strong> (<code>List[str]</code>) &#x2014; References column names.",name:"ref_keys"},{anchor:"optimum.utils.preprocessing.base.DatasetProcessing.__init__.config",description:"<strong>config</strong> (<code>PretrainedConfig</code>) &#x2014; Model configuration, useful for some tasks.",name:"config"},{anchor:"optimum.utils.preprocessing.base.DatasetProcessing.__init__.task_args(Dict,",description:"<strong>task_args(<code>Dict</code>,</strong> <em>optional</em>) &#x2014; Task-specific arguments.",name:"task_args(Dict,"},{anchor:"optimum.utils.preprocessing.base.DatasetProcessing.__init__.num_calibration_samples",description:"<strong>num_calibration_samples</strong> (<code>int</code>, <em>optional</em>) &#x2014; Number of calibration samples for static quantization. Defaults to None.",name:"num_calibration_samples"},{anchor:"optimum.utils.preprocessing.base.DatasetProcessing.__init__.calibration_split",description:"<strong>calibration_split</strong> (<code>str</code>, <em>optional</em>) &#x2014; Calibration split (e.g. &#x201C;train&#x201D;) for static quantization. Defaults to None.",name:"calibration_split"}],source:"https://github.com/huggingface/optimum/blob/vr_194/src/optimum/utils/preprocessing/base.py#L8"}}),ue=new y({props:{name:"load_datasets",anchor:"optimum.utils.preprocessing.base.DatasetProcessing.load_datasets",parameters:[],source:"https://github.com/huggingface/optimum/blob/vr_194/src/optimum/utils/preprocessing/base.py#L54",returnDescription:`
<p>Dictionary holding the datasets.</p>
`,returnType:`
<p><code>Dict</code></p>
`}}),ge=new y({props:{name:"run_inference",anchor:"optimum.utils.preprocessing.base.DatasetProcessing.run_inference",parameters:[{name:"eval_dataset",val:": Dataset"},{name:"pipeline",val:": Pipeline"}],parametersDescription:[{anchor:"optimum.utils.preprocessing.base.DatasetProcessing.run_inference.eval_dataset",description:"<strong>eval_dataset</strong> (<code>Dataset</code>) &#x2014; Raw dataset to run inference on.",name:"eval_dataset"},{anchor:"optimum.utils.preprocessing.base.DatasetProcessing.run_inference.pipeline",description:"<strong>pipeline</strong> (<code>Pipeline</code>) &#x2014; Pipeline used for inference. Should be initialized beforehand.",name:"pipeline"}],source:"https://github.com/huggingface/optimum/blob/vr_194/src/optimum/utils/preprocessing/base.py#L64",returnDescription:`
<ul>
<li><strong>labels</strong> are the references for evaluation.</li>
<li><strong>predictions</strong> are the predictions on the dataset using the pipeline.</li>
</ul>
`,returnType:`
<p><code>tuple(List)</code> comprising labels and predictions</p>
`}}),he=new y({props:{name:"get_metrics",anchor:"optimum.utils.preprocessing.base.DatasetProcessing.get_metrics",parameters:[{name:"predictions",val:""},{name:"references",val:""},{name:"metric",val:""}],parametersDescription:[{anchor:"optimum.utils.preprocessing.base.DatasetProcessing.get_metrics.predictions",description:"<strong>predictions</strong> (<code>List</code>) &#x2014; Predictions.",name:"predictions"},{anchor:"optimum.utils.preprocessing.base.DatasetProcessing.get_metrics.references",description:"<strong>references</strong> (<code>List</code>) &#x2014; References.",name:"references"},{anchor:"optimum.utils.preprocessing.base.DatasetProcessing.get_metrics.metric",description:"<strong>metric</strong> (<code>Metric</code>) &#x2014; Pre-loaded metric to run evaluation on.",name:"metric"}],source:"https://github.com/huggingface/optimum/blob/vr_194/src/optimum/utils/preprocessing/base.py#L78",returnDescription:`
<p>Computed metrics.</p>
`,returnType:`
<p><code>Dict</code></p>
`}}),fe=new y({props:{name:"get_pipeline_kwargs",anchor:"optimum.utils.preprocessing.base.DatasetProcessing.get_pipeline_kwargs",parameters:[],source:"https://github.com/huggingface/optimum/blob/vr_194/src/optimum/utils/preprocessing/base.py#L91",returnDescription:`
<p>Task-specific kwargs to initialize the pipeline.</p>
`,returnType:`
<p><code>Dict</code></p>
`}}),{c(){C=n("meta"),Qe=o(),E=n("h1"),S=n("a"),xe=n("span"),u(Q.$$.fragment),kt=o(),De=n("span"),xt=m("Benchmarking"),Je=o(),T=n("h2"),V=n("a"),we=n("span"),u(J.$$.fragment),Dt=o(),Pe=n("span"),wt=m("Run"),je=o(),j=n("div"),u(K.$$.fragment),Ke=o(),b=n("div"),u(X.$$.fragment),Pt=o(),D=n("div"),u(Y.$$.fragment),zt=o(),ze=n("p"),Ct=m("Initialize the Run class holding methods to perform inference and evaluation given a config."),Et=o(),Ce=n("p"),Tt=m("A run compares a transformers model and an optimized model on latency/throughput, model size, and provided metrics."),Rt=o(),w=n("div"),u(Z.$$.fragment),Lt=o(),Ee=n("p"),At=m("Launch inference to compare metrics between the original and optimized model."),Nt=o(),Te=n("p"),qt=m("These metrics are latency, throughput, model size, and user provided metrics."),It=o(),M=n("div"),u(ee.$$.fragment),St=o(),Re=n("p"),Vt=m("Load evaluation dataset, and if needed, calibration dataset for static quantization."),Mt=o(),O=n("div"),u(te.$$.fragment),Ot=o(),ae=n("p"),Ft=m("Get calibration dataset. The dataset needs to be loaded first with "),_e=n("a"),Bt=m("load_datasets()"),Gt=m("."),Ht=o(),F=n("div"),u(ne.$$.fragment),Ut=o(),re=n("p"),Wt=m("Get evaluation dataset.  The dataset needs to be loaded first with "),ve=n("a"),Qt=m("load_datasets()"),Jt=m("."),Xe=o(),R=n("h2"),B=n("a"),Le=n("span"),u(se.$$.fragment),jt=o(),Ae=n("span"),Kt=m("RunConfig"),Ye=o(),L=n("div"),u(oe.$$.fragment),Xt=o(),Ne=n("p"),Yt=m("Parameters defining a run. A run is an evaluation of a triplet (model, dataset, metric) coupled with optimization parameters, allowing to compare a transformers baseline and a model optimized with Optimum."),Ze=o(),A=n("div"),u(ie.$$.fragment),Zt=o(),qe=n("p"),ea=m("Parameters for post-training calibration with static quantization."),et=o(),N=n("div"),u(le.$$.fragment),ta=o(),Ie=n("p"),aa=m("Parameters related to the dataset."),tt=o(),q=n("div"),u(me.$$.fragment),na=o(),Se=n("p"),ra=m("Task-specific parameters."),at=o(),I=n("h2"),G=n("a"),Ve=n("span"),u(pe.$$.fragment),sa=o(),Me=n("span"),oa=m("Processing utility methods"),nt=o(),$=n("div"),u(ce.$$.fragment),ia=o(),P=n("div"),u(de.$$.fragment),la=o(),Oe=n("p"),ma=m("Initialize the class in charge of loading datasets, running inference and evaluation."),pa=o(),Fe=n("p"),ca=m("This class should be task-dependent, backend independent."),da=o(),z=n("div"),u(ue.$$.fragment),ua=o(),Be=n("p"),ga=m("Load calibration dataset if needed, and evaluation dataset."),ha=o(),Ge=n("p"),fa=m("The evaluation dataset is meant to be used by a pipeline and is therefore not preprocessed. The calibration dataset is preprocessed."),_a=o(),H=n("div"),u(ge.$$.fragment),va=o(),He=n("p"),ba=m("Run inference on the provided dataset using a pipeline, and return all labels, predictions."),$a=o(),U=n("div"),u(he.$$.fragment),ya=o(),Ue=n("p"),ka=m("Compute a metric given pre-formatted predictions and references."),xa=o(),W=n("div"),u(fe.$$.fragment),Da=o(),We=n("p"),wa=m("Get task-specific kwargs to initialize the pipeline."),this.h()},l(e){const c=ln('[data-svelte="svelte-1phssyn"]',document.head);C=r(c,"META",{name:!0,content:!0}),c.forEach(a),Qe=i(e),E=r(e,"H1",{class:!0});var st=s(E);S=r(st,"A",{id:!0,class:!0,href:!0});var za=s(S);xe=r(za,"SPAN",{});var Ca=s(xe);g(Q.$$.fragment,Ca),Ca.forEach(a),za.forEach(a),kt=i(st),De=r(st,"SPAN",{});var Ea=s(De);xt=p(Ea,"Benchmarking"),Ea.forEach(a),st.forEach(a),Je=i(e),T=r(e,"H2",{class:!0});var ot=s(T);V=r(ot,"A",{id:!0,class:!0,href:!0});var Ta=s(V);we=r(Ta,"SPAN",{});var Ra=s(we);g(J.$$.fragment,Ra),Ra.forEach(a),Ta.forEach(a),Dt=i(ot),Pe=r(ot,"SPAN",{});var La=s(Pe);wt=p(La,"Run"),La.forEach(a),ot.forEach(a),je=i(e),j=r(e,"DIV",{class:!0});var Aa=s(j);g(K.$$.fragment,Aa),Aa.forEach(a),Ke=i(e),b=r(e,"DIV",{class:!0});var k=s(b);g(X.$$.fragment,k),Pt=i(k),D=r(k,"DIV",{class:!0});var be=s(D);g(Y.$$.fragment,be),zt=i(be),ze=r(be,"P",{});var Na=s(ze);Ct=p(Na,"Initialize the Run class holding methods to perform inference and evaluation given a config."),Na.forEach(a),Et=i(be),Ce=r(be,"P",{});var qa=s(Ce);Tt=p(qa,"A run compares a transformers model and an optimized model on latency/throughput, model size, and provided metrics."),qa.forEach(a),be.forEach(a),Rt=i(k),w=r(k,"DIV",{class:!0});var $e=s(w);g(Z.$$.fragment,$e),Lt=i($e),Ee=r($e,"P",{});var Ia=s(Ee);At=p(Ia,"Launch inference to compare metrics between the original and optimized model."),Ia.forEach(a),Nt=i($e),Te=r($e,"P",{});var Sa=s(Te);qt=p(Sa,"These metrics are latency, throughput, model size, and user provided metrics."),Sa.forEach(a),$e.forEach(a),It=i(k),M=r(k,"DIV",{class:!0});var it=s(M);g(ee.$$.fragment,it),St=i(it),Re=r(it,"P",{});var Va=s(Re);Vt=p(Va,"Load evaluation dataset, and if needed, calibration dataset for static quantization."),Va.forEach(a),it.forEach(a),Mt=i(k),O=r(k,"DIV",{class:!0});var lt=s(O);g(te.$$.fragment,lt),Ot=i(lt),ae=r(lt,"P",{});var mt=s(ae);Ft=p(mt,"Get calibration dataset. The dataset needs to be loaded first with "),_e=r(mt,"A",{href:!0});var Ma=s(_e);Bt=p(Ma,"load_datasets()"),Ma.forEach(a),Gt=p(mt,"."),mt.forEach(a),lt.forEach(a),Ht=i(k),F=r(k,"DIV",{class:!0});var pt=s(F);g(ne.$$.fragment,pt),Ut=i(pt),re=r(pt,"P",{});var ct=s(re);Wt=p(ct,"Get evaluation dataset.  The dataset needs to be loaded first with "),ve=r(ct,"A",{href:!0});var Oa=s(ve);Qt=p(Oa,"load_datasets()"),Oa.forEach(a),Jt=p(ct,"."),ct.forEach(a),pt.forEach(a),k.forEach(a),Xe=i(e),R=r(e,"H2",{class:!0});var dt=s(R);B=r(dt,"A",{id:!0,class:!0,href:!0});var Fa=s(B);Le=r(Fa,"SPAN",{});var Ba=s(Le);g(se.$$.fragment,Ba),Ba.forEach(a),Fa.forEach(a),jt=i(dt),Ae=r(dt,"SPAN",{});var Ga=s(Ae);Kt=p(Ga,"RunConfig"),Ga.forEach(a),dt.forEach(a),Ye=i(e),L=r(e,"DIV",{class:!0});var ut=s(L);g(oe.$$.fragment,ut),Xt=i(ut),Ne=r(ut,"P",{});var Ha=s(Ne);Yt=p(Ha,"Parameters defining a run. A run is an evaluation of a triplet (model, dataset, metric) coupled with optimization parameters, allowing to compare a transformers baseline and a model optimized with Optimum."),Ha.forEach(a),ut.forEach(a),Ze=i(e),A=r(e,"DIV",{class:!0});var gt=s(A);g(ie.$$.fragment,gt),Zt=i(gt),qe=r(gt,"P",{});var Ua=s(qe);ea=p(Ua,"Parameters for post-training calibration with static quantization."),Ua.forEach(a),gt.forEach(a),et=i(e),N=r(e,"DIV",{class:!0});var ht=s(N);g(le.$$.fragment,ht),ta=i(ht),Ie=r(ht,"P",{});var Wa=s(Ie);aa=p(Wa,"Parameters related to the dataset."),Wa.forEach(a),ht.forEach(a),tt=i(e),q=r(e,"DIV",{class:!0});var ft=s(q);g(me.$$.fragment,ft),na=i(ft),Se=r(ft,"P",{});var Qa=s(Se);ra=p(Qa,"Task-specific parameters."),Qa.forEach(a),ft.forEach(a),at=i(e),I=r(e,"H2",{class:!0});var _t=s(I);G=r(_t,"A",{id:!0,class:!0,href:!0});var Ja=s(G);Ve=r(Ja,"SPAN",{});var ja=s(Ve);g(pe.$$.fragment,ja),ja.forEach(a),Ja.forEach(a),sa=i(_t),Me=r(_t,"SPAN",{});var Ka=s(Me);oa=p(Ka,"Processing utility methods"),Ka.forEach(a),_t.forEach(a),nt=i(e),$=r(e,"DIV",{class:!0});var x=s($);g(ce.$$.fragment,x),ia=i(x),P=r(x,"DIV",{class:!0});var ye=s(P);g(de.$$.fragment,ye),la=i(ye),Oe=r(ye,"P",{});var Xa=s(Oe);ma=p(Xa,"Initialize the class in charge of loading datasets, running inference and evaluation."),Xa.forEach(a),pa=i(ye),Fe=r(ye,"P",{});var Ya=s(Fe);ca=p(Ya,"This class should be task-dependent, backend independent."),Ya.forEach(a),ye.forEach(a),da=i(x),z=r(x,"DIV",{class:!0});var ke=s(z);g(ue.$$.fragment,ke),ua=i(ke),Be=r(ke,"P",{});var Za=s(Be);ga=p(Za,"Load calibration dataset if needed, and evaluation dataset."),Za.forEach(a),ha=i(ke),Ge=r(ke,"P",{});var en=s(Ge);fa=p(en,"The evaluation dataset is meant to be used by a pipeline and is therefore not preprocessed. The calibration dataset is preprocessed."),en.forEach(a),ke.forEach(a),_a=i(x),H=r(x,"DIV",{class:!0});var vt=s(H);g(ge.$$.fragment,vt),va=i(vt),He=r(vt,"P",{});var tn=s(He);ba=p(tn,"Run inference on the provided dataset using a pipeline, and return all labels, predictions."),tn.forEach(a),vt.forEach(a),$a=i(x),U=r(x,"DIV",{class:!0});var bt=s(U);g(he.$$.fragment,bt),ya=i(bt),Ue=r(bt,"P",{});var an=s(Ue);ka=p(an,"Compute a metric given pre-formatted predictions and references."),an.forEach(a),bt.forEach(a),xa=i(x),W=r(x,"DIV",{class:!0});var $t=s(W);g(fe.$$.fragment,$t),Da=i($t),We=r($t,"P",{});var nn=s(We);wa=p(nn,"Get task-specific kwargs to initialize the pipeline."),nn.forEach(a),$t.forEach(a),x.forEach(a),this.h()},h(){l(C,"name","hf:doc:metadata"),l(C,"content",JSON.stringify(dn)),l(S,"id","benchmarking"),l(S,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),l(S,"href","#benchmarking"),l(E,"class","relative group"),l(V,"id","optimum.pipelines.pipeline"),l(V,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),l(V,"href","#optimum.pipelines.pipeline"),l(T,"class","relative group"),l(j,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),l(D,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),l(w,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),l(M,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),l(_e,"href","/docs/optimum/pr_194/en/benchmark#optimum.runs_base.Run.load_datasets"),l(O,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),l(ve,"href","/docs/optimum/pr_194/en/benchmark#optimum.runs_base.Run.load_datasets"),l(F,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),l(b,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),l(B,"id","optimum.utils.runs.RunConfig"),l(B,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),l(B,"href","#optimum.utils.runs.RunConfig"),l(R,"class","relative group"),l(L,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),l(A,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),l(N,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),l(q,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),l(G,"id","optimum.utils.preprocessing.base.DatasetProcessing"),l(G,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),l(G,"href","#optimum.utils.preprocessing.base.DatasetProcessing"),l(I,"class","relative group"),l(P,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),l(z,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),l(H,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),l(U,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),l(W,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),l($,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8")},m(e,c){t(document.head,C),d(e,Qe,c),d(e,E,c),t(E,S),t(S,xe),h(Q,xe,null),t(E,kt),t(E,De),t(De,xt),d(e,Je,c),d(e,T,c),t(T,V),t(V,we),h(J,we,null),t(T,Dt),t(T,Pe),t(Pe,wt),d(e,je,c),d(e,j,c),h(K,j,null),d(e,Ke,c),d(e,b,c),h(X,b,null),t(b,Pt),t(b,D),h(Y,D,null),t(D,zt),t(D,ze),t(ze,Ct),t(D,Et),t(D,Ce),t(Ce,Tt),t(b,Rt),t(b,w),h(Z,w,null),t(w,Lt),t(w,Ee),t(Ee,At),t(w,Nt),t(w,Te),t(Te,qt),t(b,It),t(b,M),h(ee,M,null),t(M,St),t(M,Re),t(Re,Vt),t(b,Mt),t(b,O),h(te,O,null),t(O,Ot),t(O,ae),t(ae,Ft),t(ae,_e),t(_e,Bt),t(ae,Gt),t(b,Ht),t(b,F),h(ne,F,null),t(F,Ut),t(F,re),t(re,Wt),t(re,ve),t(ve,Qt),t(re,Jt),d(e,Xe,c),d(e,R,c),t(R,B),t(B,Le),h(se,Le,null),t(R,jt),t(R,Ae),t(Ae,Kt),d(e,Ye,c),d(e,L,c),h(oe,L,null),t(L,Xt),t(L,Ne),t(Ne,Yt),d(e,Ze,c),d(e,A,c),h(ie,A,null),t(A,Zt),t(A,qe),t(qe,ea),d(e,et,c),d(e,N,c),h(le,N,null),t(N,ta),t(N,Ie),t(Ie,aa),d(e,tt,c),d(e,q,c),h(me,q,null),t(q,na),t(q,Se),t(Se,ra),d(e,at,c),d(e,I,c),t(I,G),t(G,Ve),h(pe,Ve,null),t(I,sa),t(I,Me),t(Me,oa),d(e,nt,c),d(e,$,c),h(ce,$,null),t($,ia),t($,P),h(de,P,null),t(P,la),t(P,Oe),t(Oe,ma),t(P,pa),t(P,Fe),t(Fe,ca),t($,da),t($,z),h(ue,z,null),t(z,ua),t(z,Be),t(Be,ga),t(z,ha),t(z,Ge),t(Ge,fa),t($,_a),t($,H),h(ge,H,null),t(H,va),t(H,He),t(He,ba),t($,$a),t($,U),h(he,U,null),t(U,ya),t(U,Ue),t(Ue,ka),t($,xa),t($,W),h(fe,W,null),t(W,Da),t(W,We),t(We,wa),rt=!0},p:mn,i(e){rt||(f(Q.$$.fragment,e),f(J.$$.fragment,e),f(K.$$.fragment,e),f(X.$$.fragment,e),f(Y.$$.fragment,e),f(Z.$$.fragment,e),f(ee.$$.fragment,e),f(te.$$.fragment,e),f(ne.$$.fragment,e),f(se.$$.fragment,e),f(oe.$$.fragment,e),f(ie.$$.fragment,e),f(le.$$.fragment,e),f(me.$$.fragment,e),f(pe.$$.fragment,e),f(ce.$$.fragment,e),f(de.$$.fragment,e),f(ue.$$.fragment,e),f(ge.$$.fragment,e),f(he.$$.fragment,e),f(fe.$$.fragment,e),rt=!0)},o(e){_(Q.$$.fragment,e),_(J.$$.fragment,e),_(K.$$.fragment,e),_(X.$$.fragment,e),_(Y.$$.fragment,e),_(Z.$$.fragment,e),_(ee.$$.fragment,e),_(te.$$.fragment,e),_(ne.$$.fragment,e),_(se.$$.fragment,e),_(oe.$$.fragment,e),_(ie.$$.fragment,e),_(le.$$.fragment,e),_(me.$$.fragment,e),_(pe.$$.fragment,e),_(ce.$$.fragment,e),_(de.$$.fragment,e),_(ue.$$.fragment,e),_(ge.$$.fragment,e),_(he.$$.fragment,e),_(fe.$$.fragment,e),rt=!1},d(e){a(C),e&&a(Qe),e&&a(E),v(Q),e&&a(Je),e&&a(T),v(J),e&&a(je),e&&a(j),v(K),e&&a(Ke),e&&a(b),v(X),v(Y),v(Z),v(ee),v(te),v(ne),e&&a(Xe),e&&a(R),v(se),e&&a(Ye),e&&a(L),v(oe),e&&a(Ze),e&&a(A),v(ie),e&&a(et),e&&a(N),v(le),e&&a(tt),e&&a(q),v(me),e&&a(at),e&&a(I),v(pe),e&&a(nt),e&&a($),v(ce),v(de),v(ue),v(ge),v(he),v(fe)}}}const dn={local:"benchmarking",sections:[{local:"optimum.pipelines.pipeline",title:"Run"},{local:"optimum.utils.runs.RunConfig",title:"RunConfig"},{local:"optimum.utils.preprocessing.base.DatasetProcessing",title:"Processing utility methods"}],title:"Benchmarking"};function un(Pa){return pn(()=>{new URLSearchParams(window.location.search).get("fw")}),[]}class _n extends rn{constructor(C){super();sn(this,C,un,cn,on,{})}}export{_n as default,dn as metadata};
