import{S as ho,i as uo,s as go,e as a,k as l,w as _,t as c,M as _o,c as o,d as e,m as p,a as r,x as v,h as d,b as f,G as s,g as m,y as $,q as b,o as y,B as x,v as vo,L as ms}from"../../chunks/vendor-hf-doc-builder.js";import{D as C}from"../../chunks/Docstring-hf-doc-builder.js";import{C as it}from"../../chunks/CodeBlock-hf-doc-builder.js";import{I as nt}from"../../chunks/IconCopyLink-hf-doc-builder.js";import{E as is}from"../../chunks/ExampleCodeBlock-hf-doc-builder.js";function $o(B){let u,T,j,h,w;return h=new it({props:{code:`from transformers import BertModel
from transformers.utils.fx import symbolic_trace
from optimum.fx.optimization import ChangeTrueDivToMulByInverse, MergeLinears, compose

model = BertModel.from_pretrained("bert-base-uncased")
traced = symbolic_trace(
    model,
    input_names=["input_ids", "attention_mask", "token_type_ids"],
)
composition = compose(ChangeTrueDivToMulByInverse(), MergeLinears())
transformed_model = composition(traced)`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> BertModel
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers.utils.fx <span class="hljs-keyword">import</span> symbolic_trace
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> optimum.fx.optimization <span class="hljs-keyword">import</span> ChangeTrueDivToMulByInverse, MergeLinears, compose

<span class="hljs-meta">&gt;&gt;&gt; </span>model = BertModel.from_pretrained(<span class="hljs-string">&quot;bert-base-uncased&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>traced = symbolic_trace(
<span class="hljs-meta">&gt;&gt;&gt; </span>    model,
<span class="hljs-meta">&gt;&gt;&gt; </span>    input_names=[<span class="hljs-string">&quot;input_ids&quot;</span>, <span class="hljs-string">&quot;attention_mask&quot;</span>, <span class="hljs-string">&quot;token_type_ids&quot;</span>],
<span class="hljs-meta">&gt;&gt;&gt; </span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>composition = compose(ChangeTrueDivToMulByInverse(), MergeLinears())
<span class="hljs-meta">&gt;&gt;&gt; </span>transformed_model = composition(traced)`}}),{c(){u=a("p"),T=c("Example:"),j=l(),_(h.$$.fragment)},l(n){u=o(n,"P",{});var g=r(u);T=d(g,"Example:"),g.forEach(e),j=p(n),v(h.$$.fragment,n)},m(n,g){m(n,u,g),s(u,T),m(n,j,g),$(h,n,g),w=!0},p:ms,i(n){w||(b(h.$$.fragment,n),w=!0)},o(n){y(h.$$.fragment,n),w=!1},d(n){n&&e(u),n&&e(j),x(h,n)}}}function bo(B){let u,T,j,h,w;return h=new it({props:{code:`from transformers import BertModel
from transformers.utils.fx import symbolic_trace
from optimum.fx.optimization import MergeLinears

model = BertModel.from_pretrained("bert-base-uncased")
traced = symbolic_trace(
    model,
    input_names=["input_ids", "attention_mask", "token_type_ids"],
)
transformation = MergeLinears()
transformed_model = transformation(traced)
restored_model = transformation(transformed_model, reverse=True)`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> BertModel
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers.utils.fx <span class="hljs-keyword">import</span> symbolic_trace
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> optimum.fx.optimization <span class="hljs-keyword">import</span> MergeLinears

<span class="hljs-meta">&gt;&gt;&gt; </span>model = BertModel.from_pretrained(<span class="hljs-string">&quot;bert-base-uncased&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>traced = symbolic_trace(
<span class="hljs-meta">&gt;&gt;&gt; </span>    model,
<span class="hljs-meta">&gt;&gt;&gt; </span>    input_names=[<span class="hljs-string">&quot;input_ids&quot;</span>, <span class="hljs-string">&quot;attention_mask&quot;</span>, <span class="hljs-string">&quot;token_type_ids&quot;</span>],
<span class="hljs-meta">&gt;&gt;&gt; </span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>transformation = MergeLinears()
<span class="hljs-meta">&gt;&gt;&gt; </span>transformed_model = transformation(traced)
<span class="hljs-meta">&gt;&gt;&gt; </span>restored_model = transformation(transformed_model, reverse=<span class="hljs-literal">True</span>)`}}),{c(){u=a("p"),T=c("Example:"),j=l(),_(h.$$.fragment)},l(n){u=o(n,"P",{});var g=r(u);T=d(g,"Example:"),g.forEach(e),j=p(n),v(h.$$.fragment,n)},m(n,g){m(n,u,g),s(u,T),m(n,j,g),$(h,n,g),w=!0},p:ms,i(n){w||(b(h.$$.fragment,n),w=!0)},o(n){y(h.$$.fragment,n),w=!1},d(n){n&&e(u),n&&e(j),x(h,n)}}}function yo(B){let u,T,j,h,w;return h=new it({props:{code:`from transformers import BertModel
from transformers.utils.fx import symbolic_trace
from optimum.fx.optimization import FuseBiasInLinear

model = BertModel.from_pretrained("bert-base-uncased")
traced = symbolic_trace(
    model,
    input_names=["input_ids", "attention_mask", "token_type_ids"],
)
transformation = FuseBiasInLinear()
transformed_model = transformation(traced)
restored_model = transformation(transformed_model, reverse=True)`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> BertModel
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers.utils.fx <span class="hljs-keyword">import</span> symbolic_trace
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> optimum.fx.optimization <span class="hljs-keyword">import</span> FuseBiasInLinear

<span class="hljs-meta">&gt;&gt;&gt; </span>model = BertModel.from_pretrained(<span class="hljs-string">&quot;bert-base-uncased&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>traced = symbolic_trace(
<span class="hljs-meta">&gt;&gt;&gt; </span>    model,
<span class="hljs-meta">&gt;&gt;&gt; </span>    input_names=[<span class="hljs-string">&quot;input_ids&quot;</span>, <span class="hljs-string">&quot;attention_mask&quot;</span>, <span class="hljs-string">&quot;token_type_ids&quot;</span>],
<span class="hljs-meta">&gt;&gt;&gt; </span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>transformation = FuseBiasInLinear()
<span class="hljs-meta">&gt;&gt;&gt; </span>transformed_model = transformation(traced)
<span class="hljs-meta">&gt;&gt;&gt; </span>restored_model = transformation(transformed_model, reverse=<span class="hljs-literal">True</span>)`}}),{c(){u=a("p"),T=c("Example:"),j=l(),_(h.$$.fragment)},l(n){u=o(n,"P",{});var g=r(u);T=d(g,"Example:"),g.forEach(e),j=p(n),v(h.$$.fragment,n)},m(n,g){m(n,u,g),s(u,T),m(n,j,g),$(h,n,g),w=!0},p:ms,i(n){w||(b(h.$$.fragment,n),w=!0)},o(n){y(h.$$.fragment,n),w=!1},d(n){n&&e(u),n&&e(j),x(h,n)}}}function xo(B){let u,T,j,h,w;return h=new it({props:{code:`from transformers import BertModel
from transformers.utils.fx import symbolic_trace
from optimum.fx.optimization import ChangeTrueDivToMulByInverse

model = BertModel.from_pretrained("bert-base-uncased")
traced = symbolic_trace(
    model,
    input_names=["input_ids", "attention_mask", "token_type_ids"],
)
transformation = ChangeTrueDivToMulByInverse()
transformed_model = transformation(traced)
restored_model = transformation(transformed_model, reverse=True)`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> BertModel
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers.utils.fx <span class="hljs-keyword">import</span> symbolic_trace
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> optimum.fx.optimization <span class="hljs-keyword">import</span> ChangeTrueDivToMulByInverse

<span class="hljs-meta">&gt;&gt;&gt; </span>model = BertModel.from_pretrained(<span class="hljs-string">&quot;bert-base-uncased&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>traced = symbolic_trace(
<span class="hljs-meta">&gt;&gt;&gt; </span>    model,
<span class="hljs-meta">&gt;&gt;&gt; </span>    input_names=[<span class="hljs-string">&quot;input_ids&quot;</span>, <span class="hljs-string">&quot;attention_mask&quot;</span>, <span class="hljs-string">&quot;token_type_ids&quot;</span>],
<span class="hljs-meta">&gt;&gt;&gt; </span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>transformation = ChangeTrueDivToMulByInverse()
<span class="hljs-meta">&gt;&gt;&gt; </span>transformed_model = transformation(traced)
<span class="hljs-meta">&gt;&gt;&gt; </span>restored_model = transformation(transformed_model, reverse=<span class="hljs-literal">True</span>)`}}),{c(){u=a("p"),T=c("Example:"),j=l(),_(h.$$.fragment)},l(n){u=o(n,"P",{});var g=r(u);T=d(g,"Example:"),g.forEach(e),j=p(n),v(h.$$.fragment,n)},m(n,g){m(n,u,g),s(u,T),m(n,j,g),$(h,n,g),w=!0},p:ms,i(n){w||(b(h.$$.fragment,n),w=!0)},o(n){y(h.$$.fragment,n),w=!1},d(n){n&&e(u),n&&e(j),x(h,n)}}}function jo(B){let u,T,j,h,w,n,g,te,ls,Te,H,ps,ee,fs,cs,ke,F,J,se,mt,ds,ae,hs,ze,qt,us,Ee,S,U,oe,lt,gs,re,_s,Me,P,vs,It,$s,bs,Bt,ys,xs,Ae,Pt,js,qe,pt,Ie,Dt,ws,Be,ft,Pe,R,K,ne,ct,Ts,ie,ks,De,E,zs,Lt,Es,Ms,Ct,As,qs,Ft,Is,Bs,Le,St,Ps,Ce,dt,Fe,N,Q,me,ht,Ds,le,Ls,Se,X,Cs,Rt,Fs,Ss,Re,ut,Ne,W,Y,pe,gt,Rs,fe,Ns,We,G,Z,ce,_t,Ws,de,Gs,Ge,k,vt,Os,he,Vs,Hs,$t,Js,Nt,Us,Ks,Qs,Wt,bt,Xs,Gt,yt,Oe,z,xt,Ys,ue,Zs,ta,O,ea,Ot,sa,aa,Vt,oa,ra,na,Ht,jt,ia,Jt,wt,Ve,M,Tt,ma,ge,la,pa,tt,He,V,et,_e,kt,fa,ve,ca,Je,A,zt,da,$e,ha,ua,st,Ue,q,Et,ga,be,_a,va,at,Ke,I,Mt,$a,ye,ba,ya,ot,Qe;return n=new nt({}),mt=new nt({}),lt=new nt({}),pt=new it({props:{code:`from optimum.fx.optimization import Transformation

class ChangeMulToAdd(Transformation):
    def transform(self, graph_module):
        for node in graph_module.graph.nodes:
            if node.op == "call_function" and node.target == operator.mul:
                node.target = operator.add
        return graph_module`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> optimum.fx.optimization <span class="hljs-keyword">import</span> Transformation

<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">class</span> <span class="hljs-title class_">ChangeMulToAdd</span>(<span class="hljs-title class_ inherited__">Transformation</span>):
<span class="hljs-meta">&gt;&gt;&gt; </span>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">transform</span>(<span class="hljs-params">self, graph_module</span>):
<span class="hljs-meta">&gt;&gt;&gt; </span>        <span class="hljs-keyword">for</span> node <span class="hljs-keyword">in</span> graph_module.graph.nodes:
<span class="hljs-meta">&gt;&gt;&gt; </span>            <span class="hljs-keyword">if</span> node.op == <span class="hljs-string">&quot;call_function&quot;</span> <span class="hljs-keyword">and</span> node.target == operator.mul:
<span class="hljs-meta">&gt;&gt;&gt; </span>                node.target = operator.add
<span class="hljs-meta">&gt;&gt;&gt; </span>        <span class="hljs-keyword">return</span> graph_module`}}),ft=new it({props:{code:`from transformers import BertModel
from transformers.utils.fx import symbolic_trace

model = BertModel.from_pretrained("bert-base-uncased")
traced = symbolic_trace(
    model,
    input_names=["input_ids", "attention_mask", "token_type_ids"],
)

transformation = ChangeMulToAdd()
transformed_model = transformation(traced)`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> BertModel
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers.utils.fx <span class="hljs-keyword">import</span> symbolic_trace

<span class="hljs-meta">&gt;&gt;&gt; </span>model = BertModel.from_pretrained(<span class="hljs-string">&quot;bert-base-uncased&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>traced = symbolic_trace(
<span class="hljs-meta">&gt;&gt;&gt; </span>    model,
<span class="hljs-meta">&gt;&gt;&gt; </span>    input_names=[<span class="hljs-string">&quot;input_ids&quot;</span>, <span class="hljs-string">&quot;attention_mask&quot;</span>, <span class="hljs-string">&quot;token_type_ids&quot;</span>],
<span class="hljs-meta">&gt;&gt;&gt; </span>)

<span class="hljs-meta">&gt;&gt;&gt; </span>transformation = ChangeMulToAdd()
<span class="hljs-meta">&gt;&gt;&gt; </span>transformed_model = transformation(traced)`}}),ct=new nt({}),dt=new it({props:{code:`from optimum.fx.optimization import ReversibleTransformation

class MulToMulTimesTwo(ReversibleTransformation):
    def transform(self, graph_module):
        for node in graph_module.graph.nodes:
            if node.op == "call_function" and node.target == operator.mul:
                x, y = node.args
                node.args = (2 * x, y)
        return graph_module

    def reverse(self, graph_module):
        for node in graph_module.graph.nodes:
            if node.op == "call_function" and node.target == operator.mul:
                x, y = node.args
                node.args = (x / 2, y)
        return graph_module`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> optimum.fx.optimization <span class="hljs-keyword">import</span> ReversibleTransformation

<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">class</span> <span class="hljs-title class_">MulToMulTimesTwo</span>(<span class="hljs-title class_ inherited__">ReversibleTransformation</span>):
<span class="hljs-meta">&gt;&gt;&gt; </span>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">transform</span>(<span class="hljs-params">self, graph_module</span>):
<span class="hljs-meta">&gt;&gt;&gt; </span>        <span class="hljs-keyword">for</span> node <span class="hljs-keyword">in</span> graph_module.graph.nodes:
<span class="hljs-meta">&gt;&gt;&gt; </span>            <span class="hljs-keyword">if</span> node.op == <span class="hljs-string">&quot;call_function&quot;</span> <span class="hljs-keyword">and</span> node.target == operator.mul:
<span class="hljs-meta">&gt;&gt;&gt; </span>                x, y = node.args
<span class="hljs-meta">&gt;&gt;&gt; </span>                node.args = (<span class="hljs-number">2</span> * x, y)
<span class="hljs-meta">&gt;&gt;&gt; </span>        <span class="hljs-keyword">return</span> graph_module

<span class="hljs-meta">&gt;&gt;&gt; </span>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">reverse</span>(<span class="hljs-params">self, graph_module</span>):
<span class="hljs-meta">&gt;&gt;&gt; </span>        <span class="hljs-keyword">for</span> node <span class="hljs-keyword">in</span> graph_module.graph.nodes:
<span class="hljs-meta">&gt;&gt;&gt; </span>            <span class="hljs-keyword">if</span> node.op == <span class="hljs-string">&quot;call_function&quot;</span> <span class="hljs-keyword">and</span> node.target == operator.mul:
<span class="hljs-meta">&gt;&gt;&gt; </span>                x, y = node.args
<span class="hljs-meta">&gt;&gt;&gt; </span>                node.args = (x / <span class="hljs-number">2</span>, y)
<span class="hljs-meta">&gt;&gt;&gt; </span>        <span class="hljs-keyword">return</span> graph_module`}}),ht=new nt({}),ut=new it({props:{code:`from optimum.fx.optimization import compose
composition = compose(MulToMulTimesTwo(), ChangeMulToAdd())`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> optimum.fx.optimization <span class="hljs-keyword">import</span> compose
<span class="hljs-meta">&gt;&gt;&gt; </span>composition = compose(MulToMulTimesTwo(), ChangeMulToAdd())`}}),gt=new nt({}),_t=new nt({}),vt=new C({props:{name:"class optimum.fx.optimization.Transformation",anchor:"optimum.fx.optimization.Transformation",parameters:[],parametersDescription:[{anchor:"optimum.fx.optimization.Transformation.preserves_computation",description:`<strong>preserves_computation</strong> (<code>bool</code>, defaults to <code>False</code>) &#x2014;
Whether the transformation preserves the graph computation or not. If <code>True</code>, the original and the
transformed graph should produce the same outputs.`,name:"preserves_computation"}],source:"https://github.com/huggingface/optimum/blob/vr_253/src/optimum/fx/optimization/transformations.py#L88"}}),bt=new C({props:{name:"__call__",anchor:"optimum.fx.optimization.Transformation.__call__",parameters:[{name:"graph_module",val:": GraphModule"},{name:"lint_and_recompile",val:": bool = True"}],parametersDescription:[{anchor:"optimum.fx.optimization.Transformation.__call__.graph_module",description:`<strong>graph_module</strong> (<code>torch.fx.GraphModule</code>) &#x2014;
The module to transform.`,name:"graph_module"},{anchor:"optimum.fx.optimization.Transformation.__call__.lint_and_recompile",description:`<strong>lint_and_recompile</strong> (<code>bool</code>, defaults to <code>True</code>) &#x2014;
Whether the transformed module should be linted and recompiled.
This can be set to <code>False</code> when chaining transformations together to perform this operation only once.`,name:"lint_and_recompile"}],source:"https://github.com/huggingface/optimum/blob/vr_253/src/optimum/fx/optimization/transformations.py#L111",returnDescription:`
<p>The transformed module.</p>
`,returnType:`
<p><code>torch.fx.GraphModule</code></p>
`}}),yt=new C({props:{name:"transform",anchor:"optimum.fx.optimization.Transformation.transform",parameters:[{name:"graph_module",val:": GraphModule"}],parametersDescription:[{anchor:"optimum.fx.optimization.Transformation.transform.graph_module",description:`<strong>graph_module</strong> (<code>torch.fx.GraphModule</code>) &#x2014;
The module to transform.`,name:"graph_module"}],source:"https://github.com/huggingface/optimum/blob/vr_253/src/optimum/fx/optimization/transformations.py#L98",returnDescription:`
<p>The transformed module.</p>
`,returnType:`
<p><code>torch.fx.GraphModule</code></p>
`}}),xt=new C({props:{name:"class optimum.fx.optimization.ReversibleTransformation",anchor:"optimum.fx.optimization.ReversibleTransformation",parameters:[],parametersDescription:[{anchor:"optimum.fx.optimization.ReversibleTransformation.preserves_computation",description:`<strong>preserves_computation</strong> (<code>bool</code>, defaults to <code>False</code>) &#x2014;
Whether the transformation preserves the graph computation or not. If <code>True</code>, the original and the
transformed graph should produce the same outputs.`,name:"preserves_computation"}],source:"https://github.com/huggingface/optimum/blob/vr_253/src/optimum/fx/optimization/transformations.py#L132"}}),jt=new C({props:{name:"__call__",anchor:"optimum.fx.optimization.ReversibleTransformation.__call__",parameters:[{name:"graph_module",val:": GraphModule"},{name:"lint_and_recompile",val:": bool = True"},{name:"reverse",val:": bool = False"}],parametersDescription:[{anchor:"optimum.fx.optimization.ReversibleTransformation.__call__.graph_module",description:`<strong>graph_module</strong> (<code>torch.fx.GraphModule</code>) &#x2014;
The module to transform.`,name:"graph_module"},{anchor:"optimum.fx.optimization.ReversibleTransformation.__call__.lint_and_recompile",description:`<strong>lint_and_recompile</strong> (<code>bool</code>, defaults to <code>True</code>) &#x2014;
Whether the transformed module should be linted and recompiled.
This can be set to <code>False</code> when chaining transformations together to perform this operation only once.`,name:"lint_and_recompile"},{anchor:"optimum.fx.optimization.ReversibleTransformation.__call__.reverse",description:`<strong>reverse</strong> (<code>bool</code>, defaults to <code>False</code>) &#x2014;
If <code>True</code>, the reverse transformation is performed.`,name:"reverse"}],source:"https://github.com/huggingface/optimum/blob/vr_253/src/optimum/fx/optimization/transformations.py#L153",returnDescription:`
<p>The transformed module.</p>
`,returnType:`
<p><code>torch.fx.GraphModule</code></p>
`}}),wt=new C({props:{name:"reverse",anchor:"optimum.fx.optimization.ReversibleTransformation.reverse",parameters:[{name:"graph_module",val:": GraphModule"}],parametersDescription:[{anchor:"optimum.fx.optimization.ReversibleTransformation.reverse.graph_module",description:`<strong>graph_module</strong> (<code>torch.fx.GraphModule</code>) &#x2014;
The module to transform.`,name:"graph_module"}],source:"https://github.com/huggingface/optimum/blob/vr_253/src/optimum/fx/optimization/transformations.py#L140",returnDescription:`
<p>The reverse transformed module.</p>
`,returnType:`
<p><code>torch.fx.GraphModule</code></p>
`}}),Tt=new C({props:{name:"optimum.fx.optimization.compose",anchor:"optimum.fx.optimization.compose",parameters:[{name:"*args",val:": Transformation"},{name:"inplace",val:": bool = True"}],parametersDescription:[{anchor:"optimum.fx.optimization.compose.args",description:`<strong>args</strong> (<a href="/docs/optimum/pr_253/en/fx/optimization#optimum.fx.optimization.Transformation">Transformation</a>) &#x2014;
The transformations to compose together.`,name:"args"},{anchor:"optimum.fx.optimization.compose.inplace",description:`<strong>inplace</strong> (<code>bool</code>, defaults to <code>True</code>) &#x2014;
Whether the resulting transformation should be inplace, or create a new graph module.`,name:"inplace"}],source:"https://github.com/huggingface/optimum/blob/vr_253/src/optimum/fx/optimization/transformations.py#L424",returnDescription:`
<p>The composition transformation object.</p>
`}}),tt=new is({props:{anchor:"optimum.fx.optimization.compose.example",$$slots:{default:[$o]},$$scope:{ctx:B}}}),kt=new nt({}),zt=new C({props:{name:"class optimum.fx.optimization.MergeLinears",anchor:"optimum.fx.optimization.MergeLinears",parameters:[],parametersDescription:[{anchor:"optimum.fx.optimization.MergeLinears.preserves_computation",description:`<strong>preserves_computation</strong> (<code>bool</code>, defaults to <code>False</code>) &#x2014;
Whether the transformation preserves the graph computation or not. If <code>True</code>, the original and the
transformed graph should produce the same outputs.`,name:"preserves_computation"}],source:"https://github.com/huggingface/optimum/blob/vr_253/src/optimum/fx/optimization/transformations.py#L180"}}),st=new is({props:{anchor:"optimum.fx.optimization.MergeLinears.example",$$slots:{default:[bo]},$$scope:{ctx:B}}}),Et=new C({props:{name:"class optimum.fx.optimization.FuseBiasInLinear",anchor:"optimum.fx.optimization.FuseBiasInLinear",parameters:[],parametersDescription:[{anchor:"optimum.fx.optimization.FuseBiasInLinear.preserves_computation",description:`<strong>preserves_computation</strong> (<code>bool</code>, defaults to <code>False</code>) &#x2014;
Whether the transformation preserves the graph computation or not. If <code>True</code>, the original and the
transformed graph should produce the same outputs.`,name:"preserves_computation"}],source:"https://github.com/huggingface/optimum/blob/vr_253/src/optimum/fx/optimization/transformations.py#L305"}}),at=new is({props:{anchor:"optimum.fx.optimization.FuseBiasInLinear.example",$$slots:{default:[yo]},$$scope:{ctx:B}}}),Mt=new C({props:{name:"class optimum.fx.optimization.ChangeTrueDivToMulByInverse",anchor:"optimum.fx.optimization.ChangeTrueDivToMulByInverse",parameters:[],parametersDescription:[{anchor:"optimum.fx.optimization.ChangeTrueDivToMulByInverse.preserves_computation",description:`<strong>preserves_computation</strong> (<code>bool</code>, defaults to <code>False</code>) &#x2014;
Whether the transformation preserves the graph computation or not. If <code>True</code>, the original and the
transformed graph should produce the same outputs.`,name:"preserves_computation"}],source:"https://github.com/huggingface/optimum/blob/vr_253/src/optimum/fx/optimization/transformations.py#L355"}}),ot=new is({props:{anchor:"optimum.fx.optimization.ChangeTrueDivToMulByInverse.example",$$slots:{default:[xo]},$$scope:{ctx:B}}}),{c(){u=a("meta"),T=l(),j=a("h1"),h=a("a"),w=a("span"),_(n.$$.fragment),g=l(),te=a("span"),ls=c("Optimization"),Te=l(),H=a("p"),ps=c("The "),ee=a("code"),fs=c("optimum.fx.optimization"),cs=c(" module provides a set of torch.fx graph transformations, along with classes and functions to write your own transformations and compose them."),ke=l(),F=a("h2"),J=a("a"),se=a("span"),_(mt.$$.fragment),ds=l(),ae=a("span"),hs=c("The transformation guide"),ze=l(),qt=a("p"),us=c("In \u{1F917} Optimum, there are two kinds of transformations: reversible and non-reversible transformations."),Ee=l(),S=a("h3"),U=a("a"),oe=a("span"),_(lt.$$.fragment),gs=l(),re=a("span"),_s=c("Write a non-reversible transformation"),Me=l(),P=a("p"),vs=c("The most basic case of transformations is non-reversible transformations. Those transformations cannot be reversed, meaning that after applying them to a graph module, there is no way to get the original model back. To implement such transformations in \u{1F917} Optimum, it is very easy: you just need to subclass "),It=a("a"),$s=c("Transformation"),bs=c(" and implement the "),Bt=a("a"),ys=c("transform()"),xs=c(" method."),Ae=l(),Pt=a("p"),js=c("For instance, the following transformation changes all the multiplications to additions:"),qe=l(),_(pt.$$.fragment),Ie=l(),Dt=a("p"),ws=c("After implementing it, your transformation can be used as a regular function:"),Be=l(),_(ft.$$.fragment),Pe=l(),R=a("h3"),K=a("a"),ne=a("span"),_(ct.$$.fragment),Ts=l(),ie=a("span"),ks=c("Write a reversible transformation"),De=l(),E=a("p"),zs=c("A reversible transformation implements both the transformation and its reverse, allowing to retrieve the original model from the transformed one. To implement such transformation, you need to subclass "),Lt=a("a"),Es=c("ReversibleTransformation"),Ms=c(" and implement the "),Ct=a("a"),As=c("transform()"),qs=c(" and "),Ft=a("a"),Is=c("reverse()"),Bs=c(" methods."),Le=l(),St=a("p"),Ps=c("For instance, the following transformation is reversible:"),Ce=l(),_(dt.$$.fragment),Fe=l(),N=a("h3"),Q=a("a"),me=a("span"),_(ht.$$.fragment),Ds=l(),le=a("span"),Ls=c("Composing transformations together"),Se=l(),X=a("p"),Cs=c("As applying mutilple transformations in chain is needed more often that not, "),Rt=a("a"),Fs=c("compose()"),Ss=c(" is provided. It is an utility function that allows you to create a transformation by chaining multiple other transformations."),Re=l(),_(ut.$$.fragment),Ne=l(),W=a("h2"),Y=a("a"),pe=a("span"),_(gt.$$.fragment),Rs=l(),fe=a("span"),Ns=c("The Optimization API"),We=l(),G=a("h3"),Z=a("a"),ce=a("span"),_(_t.$$.fragment),Ws=l(),de=a("span"),Gs=c("Main classes and functions"),Ge=l(),k=a("div"),_(vt.$$.fragment),Os=l(),he=a("p"),Vs=c("A torch.fx graph transformation."),Hs=l(),$t=a("p"),Js=c("It  must implemement the "),Nt=a("a"),Us=c("transform()"),Ks=c(` method, and be used as a
callable.`),Qs=l(),Wt=a("div"),_(bt.$$.fragment),Xs=l(),Gt=a("div"),_(yt.$$.fragment),Oe=l(),z=a("div"),_(xt.$$.fragment),Ys=l(),ue=a("p"),Zs=c("A torch.fx graph transformation that is reversible."),ta=l(),O=a("p"),ea=c("It must implemement the "),Ot=a("a"),sa=c("transform()"),aa=c(` and
`),Vt=a("a"),oa=c("reverse()"),ra=c(" methods, and be used as a callable."),na=l(),Ht=a("div"),_(jt.$$.fragment),ia=l(),Jt=a("div"),_(wt.$$.fragment),Ve=l(),M=a("div"),_(Tt.$$.fragment),ma=l(),ge=a("p"),la=c("Composes a list of transformations together."),pa=l(),_(tt.$$.fragment),He=l(),V=a("h3"),et=a("a"),_e=a("span"),_(kt.$$.fragment),fa=l(),ve=a("span"),ca=c("Transformations"),Je=l(),A=a("div"),_(zt.$$.fragment),da=l(),$e=a("p"),ha=c("Transformation that merges linear layers that take the same input into one big linear layer."),ua=l(),_(st.$$.fragment),Ue=l(),q=a("div"),_(Et.$$.fragment),ga=l(),be=a("p"),_a=c("Transformation that fuses the bias to the weight in torch.nn.Linear."),va=l(),_(at.$$.fragment),Ke=l(),I=a("div"),_(Mt.$$.fragment),$a=l(),ye=a("p"),ba=c(`Transformation that changes truediv nodes to multiplication by the inverse nodes when the denominator is static.
For example, that is sometimes the case for the scaling factor in attention layers.`),ya=l(),_(ot.$$.fragment),this.h()},l(t){const i=_o('[data-svelte="svelte-1phssyn"]',document.head);u=o(i,"META",{name:!0,content:!0}),i.forEach(e),T=p(t),j=o(t,"H1",{class:!0});var At=r(j);h=o(At,"A",{id:!0,class:!0,href:!0});var xe=r(h);w=o(xe,"SPAN",{});var je=r(w);v(n.$$.fragment,je),je.forEach(e),xe.forEach(e),g=p(At),te=o(At,"SPAN",{});var we=r(te);ls=d(we,"Optimization"),we.forEach(e),At.forEach(e),Te=p(t),H=o(t,"P",{});var Xe=r(H);ps=d(Xe,"The "),ee=o(Xe,"CODE",{});var xa=r(ee);fs=d(xa,"optimum.fx.optimization"),xa.forEach(e),cs=d(Xe," module provides a set of torch.fx graph transformations, along with classes and functions to write your own transformations and compose them."),Xe.forEach(e),ke=p(t),F=o(t,"H2",{class:!0});var Ye=r(F);J=o(Ye,"A",{id:!0,class:!0,href:!0});var ja=r(J);se=o(ja,"SPAN",{});var wa=r(se);v(mt.$$.fragment,wa),wa.forEach(e),ja.forEach(e),ds=p(Ye),ae=o(Ye,"SPAN",{});var Ta=r(ae);hs=d(Ta,"The transformation guide"),Ta.forEach(e),Ye.forEach(e),ze=p(t),qt=o(t,"P",{});var ka=r(qt);us=d(ka,"In \u{1F917} Optimum, there are two kinds of transformations: reversible and non-reversible transformations."),ka.forEach(e),Ee=p(t),S=o(t,"H3",{class:!0});var Ze=r(S);U=o(Ze,"A",{id:!0,class:!0,href:!0});var za=r(U);oe=o(za,"SPAN",{});var Ea=r(oe);v(lt.$$.fragment,Ea),Ea.forEach(e),za.forEach(e),gs=p(Ze),re=o(Ze,"SPAN",{});var Ma=r(re);_s=d(Ma,"Write a non-reversible transformation"),Ma.forEach(e),Ze.forEach(e),Me=p(t),P=o(t,"P",{});var Ut=r(P);vs=d(Ut,"The most basic case of transformations is non-reversible transformations. Those transformations cannot be reversed, meaning that after applying them to a graph module, there is no way to get the original model back. To implement such transformations in \u{1F917} Optimum, it is very easy: you just need to subclass "),It=o(Ut,"A",{href:!0});var Aa=r(It);$s=d(Aa,"Transformation"),Aa.forEach(e),bs=d(Ut," and implement the "),Bt=o(Ut,"A",{href:!0});var qa=r(Bt);ys=d(qa,"transform()"),qa.forEach(e),xs=d(Ut," method."),Ut.forEach(e),Ae=p(t),Pt=o(t,"P",{});var Ia=r(Pt);js=d(Ia,"For instance, the following transformation changes all the multiplications to additions:"),Ia.forEach(e),qe=p(t),v(pt.$$.fragment,t),Ie=p(t),Dt=o(t,"P",{});var Ba=r(Dt);ws=d(Ba,"After implementing it, your transformation can be used as a regular function:"),Ba.forEach(e),Be=p(t),v(ft.$$.fragment,t),Pe=p(t),R=o(t,"H3",{class:!0});var ts=r(R);K=o(ts,"A",{id:!0,class:!0,href:!0});var Pa=r(K);ne=o(Pa,"SPAN",{});var Da=r(ne);v(ct.$$.fragment,Da),Da.forEach(e),Pa.forEach(e),Ts=p(ts),ie=o(ts,"SPAN",{});var La=r(ie);ks=d(La,"Write a reversible transformation"),La.forEach(e),ts.forEach(e),De=p(t),E=o(t,"P",{});var rt=r(E);zs=d(rt,"A reversible transformation implements both the transformation and its reverse, allowing to retrieve the original model from the transformed one. To implement such transformation, you need to subclass "),Lt=o(rt,"A",{href:!0});var Ca=r(Lt);Es=d(Ca,"ReversibleTransformation"),Ca.forEach(e),Ms=d(rt," and implement the "),Ct=o(rt,"A",{href:!0});var Fa=r(Ct);As=d(Fa,"transform()"),Fa.forEach(e),qs=d(rt," and "),Ft=o(rt,"A",{href:!0});var Sa=r(Ft);Is=d(Sa,"reverse()"),Sa.forEach(e),Bs=d(rt," methods."),rt.forEach(e),Le=p(t),St=o(t,"P",{});var Ra=r(St);Ps=d(Ra,"For instance, the following transformation is reversible:"),Ra.forEach(e),Ce=p(t),v(dt.$$.fragment,t),Fe=p(t),N=o(t,"H3",{class:!0});var es=r(N);Q=o(es,"A",{id:!0,class:!0,href:!0});var Na=r(Q);me=o(Na,"SPAN",{});var Wa=r(me);v(ht.$$.fragment,Wa),Wa.forEach(e),Na.forEach(e),Ds=p(es),le=o(es,"SPAN",{});var Ga=r(le);Ls=d(Ga,"Composing transformations together"),Ga.forEach(e),es.forEach(e),Se=p(t),X=o(t,"P",{});var ss=r(X);Cs=d(ss,"As applying mutilple transformations in chain is needed more often that not, "),Rt=o(ss,"A",{href:!0});var Oa=r(Rt);Fs=d(Oa,"compose()"),Oa.forEach(e),Ss=d(ss," is provided. It is an utility function that allows you to create a transformation by chaining multiple other transformations."),ss.forEach(e),Re=p(t),v(ut.$$.fragment,t),Ne=p(t),W=o(t,"H2",{class:!0});var as=r(W);Y=o(as,"A",{id:!0,class:!0,href:!0});var Va=r(Y);pe=o(Va,"SPAN",{});var Ha=r(pe);v(gt.$$.fragment,Ha),Ha.forEach(e),Va.forEach(e),Rs=p(as),fe=o(as,"SPAN",{});var Ja=r(fe);Ns=d(Ja,"The Optimization API"),Ja.forEach(e),as.forEach(e),We=p(t),G=o(t,"H3",{class:!0});var os=r(G);Z=o(os,"A",{id:!0,class:!0,href:!0});var Ua=r(Z);ce=o(Ua,"SPAN",{});var Ka=r(ce);v(_t.$$.fragment,Ka),Ka.forEach(e),Ua.forEach(e),Ws=p(os),de=o(os,"SPAN",{});var Qa=r(de);Gs=d(Qa,"Main classes and functions"),Qa.forEach(e),os.forEach(e),Ge=p(t),k=o(t,"DIV",{class:!0});var D=r(k);v(vt.$$.fragment,D),Os=p(D),he=o(D,"P",{});var Xa=r(he);Vs=d(Xa,"A torch.fx graph transformation."),Xa.forEach(e),Hs=p(D),$t=o(D,"P",{});var rs=r($t);Js=d(rs,"It  must implemement the "),Nt=o(rs,"A",{href:!0});var Ya=r(Nt);Us=d(Ya,"transform()"),Ya.forEach(e),Ks=d(rs,` method, and be used as a
callable.`),rs.forEach(e),Qs=p(D),Wt=o(D,"DIV",{class:!0});var Za=r(Wt);v(bt.$$.fragment,Za),Za.forEach(e),Xs=p(D),Gt=o(D,"DIV",{class:!0});var to=r(Gt);v(yt.$$.fragment,to),to.forEach(e),D.forEach(e),Oe=p(t),z=o(t,"DIV",{class:!0});var L=r(z);v(xt.$$.fragment,L),Ys=p(L),ue=o(L,"P",{});var eo=r(ue);Zs=d(eo,"A torch.fx graph transformation that is reversible."),eo.forEach(e),ta=p(L),O=o(L,"P",{});var Kt=r(O);ea=d(Kt,"It must implemement the "),Ot=o(Kt,"A",{href:!0});var so=r(Ot);sa=d(so,"transform()"),so.forEach(e),aa=d(Kt,` and
`),Vt=o(Kt,"A",{href:!0});var ao=r(Vt);oa=d(ao,"reverse()"),ao.forEach(e),ra=d(Kt," methods, and be used as a callable."),Kt.forEach(e),na=p(L),Ht=o(L,"DIV",{class:!0});var oo=r(Ht);v(jt.$$.fragment,oo),oo.forEach(e),ia=p(L),Jt=o(L,"DIV",{class:!0});var ro=r(Jt);v(wt.$$.fragment,ro),ro.forEach(e),L.forEach(e),Ve=p(t),M=o(t,"DIV",{class:!0});var Qt=r(M);v(Tt.$$.fragment,Qt),ma=p(Qt),ge=o(Qt,"P",{});var no=r(ge);la=d(no,"Composes a list of transformations together."),no.forEach(e),pa=p(Qt),v(tt.$$.fragment,Qt),Qt.forEach(e),He=p(t),V=o(t,"H3",{class:!0});var ns=r(V);et=o(ns,"A",{id:!0,class:!0,href:!0});var io=r(et);_e=o(io,"SPAN",{});var mo=r(_e);v(kt.$$.fragment,mo),mo.forEach(e),io.forEach(e),fa=p(ns),ve=o(ns,"SPAN",{});var lo=r(ve);ca=d(lo,"Transformations"),lo.forEach(e),ns.forEach(e),Je=p(t),A=o(t,"DIV",{class:!0});var Xt=r(A);v(zt.$$.fragment,Xt),da=p(Xt),$e=o(Xt,"P",{});var po=r($e);ha=d(po,"Transformation that merges linear layers that take the same input into one big linear layer."),po.forEach(e),ua=p(Xt),v(st.$$.fragment,Xt),Xt.forEach(e),Ue=p(t),q=o(t,"DIV",{class:!0});var Yt=r(q);v(Et.$$.fragment,Yt),ga=p(Yt),be=o(Yt,"P",{});var fo=r(be);_a=d(fo,"Transformation that fuses the bias to the weight in torch.nn.Linear."),fo.forEach(e),va=p(Yt),v(at.$$.fragment,Yt),Yt.forEach(e),Ke=p(t),I=o(t,"DIV",{class:!0});var Zt=r(I);v(Mt.$$.fragment,Zt),$a=p(Zt),ye=o(Zt,"P",{});var co=r(ye);ba=d(co,`Transformation that changes truediv nodes to multiplication by the inverse nodes when the denominator is static.
For example, that is sometimes the case for the scaling factor in attention layers.`),co.forEach(e),ya=p(Zt),v(ot.$$.fragment,Zt),Zt.forEach(e),this.h()},h(){f(u,"name","hf:doc:metadata"),f(u,"content",JSON.stringify(wo)),f(h,"id","optimization"),f(h,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),f(h,"href","#optimization"),f(j,"class","relative group"),f(J,"id","the-transformation-guide"),f(J,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),f(J,"href","#the-transformation-guide"),f(F,"class","relative group"),f(U,"id","write-a-nonreversible-transformation"),f(U,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),f(U,"href","#write-a-nonreversible-transformation"),f(S,"class","relative group"),f(It,"href","/docs/optimum/pr_253/en/fx/optimization#optimum.fx.optimization.Transformation"),f(Bt,"href","/docs/optimum/pr_253/en/fx/optimization#optimum.fx.optimization.Transformation.transform"),f(K,"id","write-a-reversible-transformation"),f(K,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),f(K,"href","#write-a-reversible-transformation"),f(R,"class","relative group"),f(Lt,"href","/docs/optimum/pr_253/en/fx/optimization#optimum.fx.optimization.ReversibleTransformation"),f(Ct,"href","/docs/optimum/pr_253/en/fx/optimization#optimum.fx.optimization.Transformation.transform"),f(Ft,"href","/docs/optimum/pr_253/en/fx/optimization#optimum.fx.optimization.ReversibleTransformation.reverse"),f(Q,"id","composing-transformations-together"),f(Q,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),f(Q,"href","#composing-transformations-together"),f(N,"class","relative group"),f(Rt,"href","/docs/optimum/pr_253/en/fx/optimization#optimum.fx.optimization.compose"),f(Y,"id","the-optimization-api"),f(Y,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),f(Y,"href","#the-optimization-api"),f(W,"class","relative group"),f(Z,"id","optimum.fx.optimization.Transformation"),f(Z,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),f(Z,"href","#optimum.fx.optimization.Transformation"),f(G,"class","relative group"),f(Nt,"href","/docs/optimum/pr_253/en/fx/optimization#optimum.fx.optimization.Transformation.transform"),f(Wt,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),f(Gt,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),f(k,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),f(Ot,"href","/docs/optimum/pr_253/en/fx/optimization#optimum.fx.optimization.Transformation.transform"),f(Vt,"href","/docs/optimum/pr_253/en/fx/optimization#optimum.fx.optimization.ReversibleTransformation.reverse"),f(Ht,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),f(Jt,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),f(z,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),f(M,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),f(et,"id","optimum.fx.optimization.MergeLinears"),f(et,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),f(et,"href","#optimum.fx.optimization.MergeLinears"),f(V,"class","relative group"),f(A,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),f(q,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),f(I,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8")},m(t,i){s(document.head,u),m(t,T,i),m(t,j,i),s(j,h),s(h,w),$(n,w,null),s(j,g),s(j,te),s(te,ls),m(t,Te,i),m(t,H,i),s(H,ps),s(H,ee),s(ee,fs),s(H,cs),m(t,ke,i),m(t,F,i),s(F,J),s(J,se),$(mt,se,null),s(F,ds),s(F,ae),s(ae,hs),m(t,ze,i),m(t,qt,i),s(qt,us),m(t,Ee,i),m(t,S,i),s(S,U),s(U,oe),$(lt,oe,null),s(S,gs),s(S,re),s(re,_s),m(t,Me,i),m(t,P,i),s(P,vs),s(P,It),s(It,$s),s(P,bs),s(P,Bt),s(Bt,ys),s(P,xs),m(t,Ae,i),m(t,Pt,i),s(Pt,js),m(t,qe,i),$(pt,t,i),m(t,Ie,i),m(t,Dt,i),s(Dt,ws),m(t,Be,i),$(ft,t,i),m(t,Pe,i),m(t,R,i),s(R,K),s(K,ne),$(ct,ne,null),s(R,Ts),s(R,ie),s(ie,ks),m(t,De,i),m(t,E,i),s(E,zs),s(E,Lt),s(Lt,Es),s(E,Ms),s(E,Ct),s(Ct,As),s(E,qs),s(E,Ft),s(Ft,Is),s(E,Bs),m(t,Le,i),m(t,St,i),s(St,Ps),m(t,Ce,i),$(dt,t,i),m(t,Fe,i),m(t,N,i),s(N,Q),s(Q,me),$(ht,me,null),s(N,Ds),s(N,le),s(le,Ls),m(t,Se,i),m(t,X,i),s(X,Cs),s(X,Rt),s(Rt,Fs),s(X,Ss),m(t,Re,i),$(ut,t,i),m(t,Ne,i),m(t,W,i),s(W,Y),s(Y,pe),$(gt,pe,null),s(W,Rs),s(W,fe),s(fe,Ns),m(t,We,i),m(t,G,i),s(G,Z),s(Z,ce),$(_t,ce,null),s(G,Ws),s(G,de),s(de,Gs),m(t,Ge,i),m(t,k,i),$(vt,k,null),s(k,Os),s(k,he),s(he,Vs),s(k,Hs),s(k,$t),s($t,Js),s($t,Nt),s(Nt,Us),s($t,Ks),s(k,Qs),s(k,Wt),$(bt,Wt,null),s(k,Xs),s(k,Gt),$(yt,Gt,null),m(t,Oe,i),m(t,z,i),$(xt,z,null),s(z,Ys),s(z,ue),s(ue,Zs),s(z,ta),s(z,O),s(O,ea),s(O,Ot),s(Ot,sa),s(O,aa),s(O,Vt),s(Vt,oa),s(O,ra),s(z,na),s(z,Ht),$(jt,Ht,null),s(z,ia),s(z,Jt),$(wt,Jt,null),m(t,Ve,i),m(t,M,i),$(Tt,M,null),s(M,ma),s(M,ge),s(ge,la),s(M,pa),$(tt,M,null),m(t,He,i),m(t,V,i),s(V,et),s(et,_e),$(kt,_e,null),s(V,fa),s(V,ve),s(ve,ca),m(t,Je,i),m(t,A,i),$(zt,A,null),s(A,da),s(A,$e),s($e,ha),s(A,ua),$(st,A,null),m(t,Ue,i),m(t,q,i),$(Et,q,null),s(q,ga),s(q,be),s(be,_a),s(q,va),$(at,q,null),m(t,Ke,i),m(t,I,i),$(Mt,I,null),s(I,$a),s(I,ye),s(ye,ba),s(I,ya),$(ot,I,null),Qe=!0},p(t,[i]){const At={};i&2&&(At.$$scope={dirty:i,ctx:t}),tt.$set(At);const xe={};i&2&&(xe.$$scope={dirty:i,ctx:t}),st.$set(xe);const je={};i&2&&(je.$$scope={dirty:i,ctx:t}),at.$set(je);const we={};i&2&&(we.$$scope={dirty:i,ctx:t}),ot.$set(we)},i(t){Qe||(b(n.$$.fragment,t),b(mt.$$.fragment,t),b(lt.$$.fragment,t),b(pt.$$.fragment,t),b(ft.$$.fragment,t),b(ct.$$.fragment,t),b(dt.$$.fragment,t),b(ht.$$.fragment,t),b(ut.$$.fragment,t),b(gt.$$.fragment,t),b(_t.$$.fragment,t),b(vt.$$.fragment,t),b(bt.$$.fragment,t),b(yt.$$.fragment,t),b(xt.$$.fragment,t),b(jt.$$.fragment,t),b(wt.$$.fragment,t),b(Tt.$$.fragment,t),b(tt.$$.fragment,t),b(kt.$$.fragment,t),b(zt.$$.fragment,t),b(st.$$.fragment,t),b(Et.$$.fragment,t),b(at.$$.fragment,t),b(Mt.$$.fragment,t),b(ot.$$.fragment,t),Qe=!0)},o(t){y(n.$$.fragment,t),y(mt.$$.fragment,t),y(lt.$$.fragment,t),y(pt.$$.fragment,t),y(ft.$$.fragment,t),y(ct.$$.fragment,t),y(dt.$$.fragment,t),y(ht.$$.fragment,t),y(ut.$$.fragment,t),y(gt.$$.fragment,t),y(_t.$$.fragment,t),y(vt.$$.fragment,t),y(bt.$$.fragment,t),y(yt.$$.fragment,t),y(xt.$$.fragment,t),y(jt.$$.fragment,t),y(wt.$$.fragment,t),y(Tt.$$.fragment,t),y(tt.$$.fragment,t),y(kt.$$.fragment,t),y(zt.$$.fragment,t),y(st.$$.fragment,t),y(Et.$$.fragment,t),y(at.$$.fragment,t),y(Mt.$$.fragment,t),y(ot.$$.fragment,t),Qe=!1},d(t){e(u),t&&e(T),t&&e(j),x(n),t&&e(Te),t&&e(H),t&&e(ke),t&&e(F),x(mt),t&&e(ze),t&&e(qt),t&&e(Ee),t&&e(S),x(lt),t&&e(Me),t&&e(P),t&&e(Ae),t&&e(Pt),t&&e(qe),x(pt,t),t&&e(Ie),t&&e(Dt),t&&e(Be),x(ft,t),t&&e(Pe),t&&e(R),x(ct),t&&e(De),t&&e(E),t&&e(Le),t&&e(St),t&&e(Ce),x(dt,t),t&&e(Fe),t&&e(N),x(ht),t&&e(Se),t&&e(X),t&&e(Re),x(ut,t),t&&e(Ne),t&&e(W),x(gt),t&&e(We),t&&e(G),x(_t),t&&e(Ge),t&&e(k),x(vt),x(bt),x(yt),t&&e(Oe),t&&e(z),x(xt),x(jt),x(wt),t&&e(Ve),t&&e(M),x(Tt),x(tt),t&&e(He),t&&e(V),x(kt),t&&e(Je),t&&e(A),x(zt),x(st),t&&e(Ue),t&&e(q),x(Et),x(at),t&&e(Ke),t&&e(I),x(Mt),x(ot)}}}const wo={local:"optimization",sections:[{local:"the-transformation-guide",sections:[{local:"write-a-nonreversible-transformation",title:"Write a non-reversible transformation"},{local:"write-a-reversible-transformation",title:"Write a reversible transformation"},{local:"composing-transformations-together",title:"Composing transformations together"}],title:"The transformation guide"},{local:"the-optimization-api",sections:[{local:"optimum.fx.optimization.Transformation",title:"Main classes and functions"},{local:"optimum.fx.optimization.MergeLinears",title:"Transformations"}],title:"The Optimization API"}],title:"Optimization"};function To(B){return vo(()=>{new URLSearchParams(window.location.search).get("fw")}),[]}class qo extends ho{constructor(u){super();uo(this,u,To,jo,go,{})}}export{qo as default,wo as metadata};
