import{S as Er,i as Mr,s as Ar,e as a,k as m,w as u,t as d,M as Dr,c as r,d as e,m as p,a as s,x as g,h as c,b as i,G as o,g as f,y as _,q as v,o as $,B as b,v as Ir,L as Ia}from"../../chunks/vendor-hf-doc-builder.js";import{D as M}from"../../chunks/Docstring-hf-doc-builder.js";import{C as Pt}from"../../chunks/CodeBlock-hf-doc-builder.js";import{I as nt}from"../../chunks/IconCopyLink-hf-doc-builder.js";import{E as Da}from"../../chunks/ExampleCodeBlock-hf-doc-builder.js";function Pr(V){let y,z,x,h,j;return h=new Pt({props:{code:`from transformers import BertModel
from transformers.utils.fx import symbolic_trace
from optimum.fx.optimization import ChangeTrueDivToMulByInverse, MergeLinears, compose

model = BertModel.from_pretrained("bert-base-uncased")
traced = symbolic_trace(
    model,
    input_names=["input_ids", "attention_mask", "token_type_ids"],
)
composition = compose(ChangeTrueDivToMulByInverse(), MergeLinears())
transformed_model = composition(traced)`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> BertModel
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers.utils.fx <span class="hljs-keyword">import</span> symbolic_trace
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> optimum.fx.optimization <span class="hljs-keyword">import</span> ChangeTrueDivToMulByInverse, MergeLinears, compose

<span class="hljs-meta">&gt;&gt;&gt; </span>model = BertModel.from_pretrained(<span class="hljs-string">&quot;bert-base-uncased&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>traced = symbolic_trace(
<span class="hljs-meta">&gt;&gt;&gt; </span>    model,
<span class="hljs-meta">&gt;&gt;&gt; </span>    input_names=[<span class="hljs-string">&quot;input_ids&quot;</span>, <span class="hljs-string">&quot;attention_mask&quot;</span>, <span class="hljs-string">&quot;token_type_ids&quot;</span>],
<span class="hljs-meta">&gt;&gt;&gt; </span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>composition = compose(ChangeTrueDivToMulByInverse(), MergeLinears())
<span class="hljs-meta">&gt;&gt;&gt; </span>transformed_model = composition(traced)`}}),{c(){y=a("p"),z=d("Example:"),x=m(),u(h.$$.fragment)},l(l){y=r(l,"P",{});var w=s(y);z=c(w,"Example:"),w.forEach(e),x=p(l),g(h.$$.fragment,l)},m(l,w){f(l,y,w),o(y,z),f(l,x,w),_(h,l,w),j=!0},p:Ia,i(l){j||(v(h.$$.fragment,l),j=!0)},o(l){$(h.$$.fragment,l),j=!1},d(l){l&&e(y),l&&e(x),b(h,l)}}}function qr(V){let y,z,x,h,j;return h=new Pt({props:{code:`from transformers import BertModel
from transformers.utils.fx import symbolic_trace
from optimum.fx.optimization import MergeLinears

model = BertModel.from_pretrained("bert-base-uncased")
traced = symbolic_trace(
    model,
    input_names=["input_ids", "attention_mask", "token_type_ids"],
)
transformation = MergeLinears()
transformed_model = transformation(traced)
restored_model = transformation(transformed_model, reverse=True)`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> BertModel
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers.utils.fx <span class="hljs-keyword">import</span> symbolic_trace
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> optimum.fx.optimization <span class="hljs-keyword">import</span> MergeLinears

<span class="hljs-meta">&gt;&gt;&gt; </span>model = BertModel.from_pretrained(<span class="hljs-string">&quot;bert-base-uncased&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>traced = symbolic_trace(
<span class="hljs-meta">&gt;&gt;&gt; </span>    model,
<span class="hljs-meta">&gt;&gt;&gt; </span>    input_names=[<span class="hljs-string">&quot;input_ids&quot;</span>, <span class="hljs-string">&quot;attention_mask&quot;</span>, <span class="hljs-string">&quot;token_type_ids&quot;</span>],
<span class="hljs-meta">&gt;&gt;&gt; </span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>transformation = MergeLinears()
<span class="hljs-meta">&gt;&gt;&gt; </span>transformed_model = transformation(traced)
<span class="hljs-meta">&gt;&gt;&gt; </span>restored_model = transformation(transformed_model, reverse=<span class="hljs-literal">True</span>)`}}),{c(){y=a("p"),z=d("Example:"),x=m(),u(h.$$.fragment)},l(l){y=r(l,"P",{});var w=s(y);z=c(w,"Example:"),w.forEach(e),x=p(l),g(h.$$.fragment,l)},m(l,w){f(l,y,w),o(y,z),f(l,x,w),_(h,l,w),j=!0},p:Ia,i(l){j||(v(h.$$.fragment,l),j=!0)},o(l){$(h.$$.fragment,l),j=!1},d(l){l&&e(y),l&&e(x),b(h,l)}}}function Lr(V){let y,z,x,h,j;return h=new Pt({props:{code:`from transformers import BertModel
from transformers.utils.fx import symbolic_trace
from optimum.fx.optimization import ChangeTrueDivToMulByInverse

model = BertModel.from_pretrained("bert-base-uncased")
traced = symbolic_trace(
    model,
    input_names=["input_ids", "attention_mask", "token_type_ids"],
)
transformation = ChangeTrueDivToMulByInverse()
transformed_model = transformation(traced)
restored_model = transformation(transformed_model, reverse=True)`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> BertModel
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers.utils.fx <span class="hljs-keyword">import</span> symbolic_trace
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> optimum.fx.optimization <span class="hljs-keyword">import</span> ChangeTrueDivToMulByInverse

<span class="hljs-meta">&gt;&gt;&gt; </span>model = BertModel.from_pretrained(<span class="hljs-string">&quot;bert-base-uncased&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>traced = symbolic_trace(
<span class="hljs-meta">&gt;&gt;&gt; </span>    model,
<span class="hljs-meta">&gt;&gt;&gt; </span>    input_names=[<span class="hljs-string">&quot;input_ids&quot;</span>, <span class="hljs-string">&quot;attention_mask&quot;</span>, <span class="hljs-string">&quot;token_type_ids&quot;</span>],
<span class="hljs-meta">&gt;&gt;&gt; </span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>transformation = ChangeTrueDivToMulByInverse()
<span class="hljs-meta">&gt;&gt;&gt; </span>transformed_model = transformation(traced)
<span class="hljs-meta">&gt;&gt;&gt; </span>restored_model = transformation(transformed_model, reverse=<span class="hljs-literal">True</span>)`}}),{c(){y=a("p"),z=d("Example:"),x=m(),u(h.$$.fragment)},l(l){y=r(l,"P",{});var w=s(y);z=c(w,"Example:"),w.forEach(e),x=p(l),g(h.$$.fragment,l)},m(l,w){f(l,y,w),o(y,z),f(l,x,w),_(h,l,w),j=!0},p:Ia,i(l){j||(v(h.$$.fragment,l),j=!0)},o(l){$(h.$$.fragment,l),j=!1},d(l){l&&e(y),l&&e(x),b(h,l)}}}function Br(V){let y,z,x,h,j,l,w,re,co,Me,W,ho,se,uo,go,Ae,B,H,ne,it,_o,ie,vo,De,qt,$o,Ie,C,J,me,mt,bo,pe,yo,Pe,L,xo,Lt,wo,To,Bt,jo,ko,qe,Ct,zo,Le,pt,Be,Nt,Eo,Ce,lt,Ne,N,U,le,ft,Mo,fe,Ao,Re,A,Do,Rt,Io,Po,St,qo,Lo,Gt,Bo,Co,Se,Ft,No,Ge,dt,Fe,R,K,de,ct,Ro,ce,So,Oe,Q,Go,Ot,Fo,Oo,Ve,ht,We,S,X,he,ut,Vo,ue,Wo,He,G,Y,ge,gt,Ho,_e,Jo,Je,T,_t,Uo,ve,Ko,Qo,vt,Xo,Vt,Yo,Zo,ta,Wt,$t,ea,Ht,bt,oa,Z,yt,aa,$e,ra,sa,Jt,xt,na,Ut,wt,Ue,k,Tt,ia,be,ma,pa,F,la,Kt,fa,da,Qt,ca,ha,ua,Xt,jt,ga,tt,kt,_a,ye,va,$a,Yt,zt,Ke,I,Et,ba,xe,ya,xa,et,Qe,O,ot,we,Mt,wa,Te,Ta,Xe,P,At,ja,je,ka,za,at,Ye,q,Dt,Ea,ke,Ma,Aa,rt,Ze;return l=new nt({}),it=new nt({}),mt=new nt({}),pt=new Pt({props:{code:`from optimum.fx.optimization import Transformation

class ChangeMulToAdd(Transformation):
    def transform(self, graph_module):
        for node in graph_module.graph.nodes:
            if node.op == "call_function" and node.target == operator.mul:
                node.target = operator.add
        return graph_module`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> optimum.fx.optimization <span class="hljs-keyword">import</span> Transformation

<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">class</span> <span class="hljs-title class_">ChangeMulToAdd</span>(<span class="hljs-title class_ inherited__">Transformation</span>):
<span class="hljs-meta">&gt;&gt;&gt; </span>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">transform</span>(<span class="hljs-params">self, graph_module</span>):
<span class="hljs-meta">&gt;&gt;&gt; </span>        <span class="hljs-keyword">for</span> node <span class="hljs-keyword">in</span> graph_module.graph.nodes:
<span class="hljs-meta">&gt;&gt;&gt; </span>            <span class="hljs-keyword">if</span> node.op == <span class="hljs-string">&quot;call_function&quot;</span> <span class="hljs-keyword">and</span> node.target == operator.mul:
<span class="hljs-meta">&gt;&gt;&gt; </span>                node.target = operator.add
<span class="hljs-meta">&gt;&gt;&gt; </span>        <span class="hljs-keyword">return</span> graph_module`}}),lt=new Pt({props:{code:`from transformers import BertModel
from transformers.utils.fx import symbolic_trace

model = BertModel.from_pretrained("bert-base-uncased")
traced = symbolic_trace(
    model,
    input_names=["input_ids", "attention_mask", "token_type_ids"],
)

transformation = ChangeMulToAdd()
transformed_model = transformation(traced)`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> BertModel
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers.utils.fx <span class="hljs-keyword">import</span> symbolic_trace

<span class="hljs-meta">&gt;&gt;&gt; </span>model = BertModel.from_pretrained(<span class="hljs-string">&quot;bert-base-uncased&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>traced = symbolic_trace(
<span class="hljs-meta">&gt;&gt;&gt; </span>    model,
<span class="hljs-meta">&gt;&gt;&gt; </span>    input_names=[<span class="hljs-string">&quot;input_ids&quot;</span>, <span class="hljs-string">&quot;attention_mask&quot;</span>, <span class="hljs-string">&quot;token_type_ids&quot;</span>],
<span class="hljs-meta">&gt;&gt;&gt; </span>)

<span class="hljs-meta">&gt;&gt;&gt; </span>transformation = ChangeMulToAdd()
<span class="hljs-meta">&gt;&gt;&gt; </span>transformed_model = transformation(traced)`}}),ft=new nt({}),dt=new Pt({props:{code:`from optimum.fx.optimization import ReversibleTransformation

class MulToMulTimesTwo(ReversibleTransformation):
    def transform(self, graph_module):
        for node in graph_module.graph.nodes:
            if node.op == "call_function" and node.target == operator.mul:
                x, y = node.args
                node.args = (2 * x, y)
        return graph_module

    def reverse(self, graph_module):
        for node in graph_module.graph.nodes:
            if node.op == "call_function" and node.target == operator.mul:
                x, y = node.args
                node.args = (x / 2, y)
        return graph_module`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> optimum.fx.optimization <span class="hljs-keyword">import</span> ReversibleTransformation

<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">class</span> <span class="hljs-title class_">MulToMulTimesTwo</span>(<span class="hljs-title class_ inherited__">ReversibleTransformation</span>):
<span class="hljs-meta">&gt;&gt;&gt; </span>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">transform</span>(<span class="hljs-params">self, graph_module</span>):
<span class="hljs-meta">&gt;&gt;&gt; </span>        <span class="hljs-keyword">for</span> node <span class="hljs-keyword">in</span> graph_module.graph.nodes:
<span class="hljs-meta">&gt;&gt;&gt; </span>            <span class="hljs-keyword">if</span> node.op == <span class="hljs-string">&quot;call_function&quot;</span> <span class="hljs-keyword">and</span> node.target == operator.mul:
<span class="hljs-meta">&gt;&gt;&gt; </span>                x, y = node.args
<span class="hljs-meta">&gt;&gt;&gt; </span>                node.args = (<span class="hljs-number">2</span> * x, y)
<span class="hljs-meta">&gt;&gt;&gt; </span>        <span class="hljs-keyword">return</span> graph_module

<span class="hljs-meta">&gt;&gt;&gt; </span>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">reverse</span>(<span class="hljs-params">self, graph_module</span>):
<span class="hljs-meta">&gt;&gt;&gt; </span>        <span class="hljs-keyword">for</span> node <span class="hljs-keyword">in</span> graph_module.graph.nodes:
<span class="hljs-meta">&gt;&gt;&gt; </span>            <span class="hljs-keyword">if</span> node.op == <span class="hljs-string">&quot;call_function&quot;</span> <span class="hljs-keyword">and</span> node.target == operator.mul:
<span class="hljs-meta">&gt;&gt;&gt; </span>                x, y = node.args
<span class="hljs-meta">&gt;&gt;&gt; </span>                node.args = (x / <span class="hljs-number">2</span>, y)
<span class="hljs-meta">&gt;&gt;&gt; </span>        <span class="hljs-keyword">return</span> graph_module`}}),ct=new nt({}),ht=new Pt({props:{code:`from optimum.fx.optimization import compose
composition = compose(MulToMulTimesTwo(), ChangeMulToAdd())`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> optimum.fx.optimization <span class="hljs-keyword">import</span> compose
<span class="hljs-meta">&gt;&gt;&gt; </span>composition = compose(MulToMulTimesTwo(), ChangeMulToAdd())`}}),ut=new nt({}),gt=new nt({}),_t=new M({props:{name:"class optimum.fx.optimization.Transformation",anchor:"optimum.fx.optimization.Transformation",parameters:[],parametersDescription:[{anchor:"optimum.fx.optimization.Transformation.preserves_computation",description:`<strong>preserves_computation</strong> (<code>bool</code>, defaults to <code>False</code>) &#x2014;
Whether the transformation preserves the graph computation or not. If <code>True</code>, the original and the
transformed graph should produce the same outputs.`,name:"preserves_computation"}],source:"https://github.com/huggingface/optimum/blob/vr_303/src/optimum/fx/optimization/transformations.py#L87"}}),$t=new M({props:{name:"__call__",anchor:"optimum.fx.optimization.Transformation.__call__",parameters:[{name:"graph_module",val:": GraphModule"},{name:"lint_and_recompile",val:": bool = True"}],parametersDescription:[{anchor:"optimum.fx.optimization.Transformation.__call__.graph_module",description:`<strong>graph_module</strong> (<code>torch.fx.GraphModule</code>) &#x2014;
The module to transform.`,name:"graph_module"},{anchor:"optimum.fx.optimization.Transformation.__call__.lint_and_recompile",description:`<strong>lint_and_recompile</strong> (<code>bool</code>, defaults to <code>True</code>) &#x2014;
Whether the transformed module should be linted and recompiled.
This can be set to <code>False</code> when chaining transformations together to perform this operation only once.`,name:"lint_and_recompile"}],source:"https://github.com/huggingface/optimum/blob/vr_303/src/optimum/fx/optimization/transformations.py#L110",returnDescription:`
<p>The transformed module.</p>
`,returnType:`
<p><code>torch.fx.GraphModule</code></p>
`}}),bt=new M({props:{name:"get_transformed_nodes",anchor:"optimum.fx.optimization.Transformation.get_transformed_nodes",parameters:[{name:"graph_module",val:": GraphModule"}],parametersDescription:[{anchor:"optimum.fx.optimization.Transformation.get_transformed_nodes.graph_module",description:`<strong>graph_module</strong> (<code>torch.fx.GraphModule</code>) &#x2014;
The graph_module to get the nodes from.`,name:"graph_module"}],source:"https://github.com/huggingface/optimum/blob/vr_303/src/optimum/fx/optimization/transformations.py#L163",returnDescription:`
<p>Gives the list of nodes that were transformed by the transformation.</p>
`,returnType:`
<p><code>List[torch.fx.Node]</code></p>
`}}),yt=new M({props:{name:"mark_as_transformed",anchor:"optimum.fx.optimization.Transformation.mark_as_transformed",parameters:[{name:"node",val:": Node"}],parametersDescription:[{anchor:"optimum.fx.optimization.Transformation.mark_as_transformed.node",description:`<strong>node</strong> (<code>torch.fx.Node</code>) &#x2014;
The node to mark as transformed.`,name:"node"}],source:"https://github.com/huggingface/optimum/blob/vr_303/src/optimum/fx/optimization/transformations.py#L139"}}),xt=new M({props:{name:"transform",anchor:"optimum.fx.optimization.Transformation.transform",parameters:[{name:"graph_module",val:": GraphModule"}],parametersDescription:[{anchor:"optimum.fx.optimization.Transformation.transform.graph_module",description:`<strong>graph_module</strong> (<code>torch.fx.GraphModule</code>) &#x2014;
The module to transform.`,name:"graph_module"}],source:"https://github.com/huggingface/optimum/blob/vr_303/src/optimum/fx/optimization/transformations.py#L97",returnDescription:`
<p>The transformed module.</p>
`,returnType:`
<p><code>torch.fx.GraphModule</code></p>
`}}),wt=new M({props:{name:"transformed",anchor:"optimum.fx.optimization.Transformation.transformed",parameters:[{name:"node",val:": Node"}],parametersDescription:[{anchor:"optimum.fx.optimization.Transformation.transformed.node",description:`<strong>node</strong> (<code>torch.fx.Node</code>) &#x2014;
The node to check.`,name:"node"}],source:"https://github.com/huggingface/optimum/blob/vr_303/src/optimum/fx/optimization/transformations.py#L151",returnDescription:`
<p>Specifies whether the node was transformed by this transformation or not.</p>
`,returnType:`
<p><code>bool</code></p>
`}}),Tt=new M({props:{name:"class optimum.fx.optimization.ReversibleTransformation",anchor:"optimum.fx.optimization.ReversibleTransformation",parameters:[],parametersDescription:[{anchor:"optimum.fx.optimization.ReversibleTransformation.preserves_computation",description:`<strong>preserves_computation</strong> (<code>bool</code>, defaults to <code>False</code>) &#x2014;
Whether the transformation preserves the graph computation or not. If <code>True</code>, the original and the
transformed graph should produce the same outputs.`,name:"preserves_computation"}],source:"https://github.com/huggingface/optimum/blob/vr_303/src/optimum/fx/optimization/transformations.py#L178"}}),jt=new M({props:{name:"__call__",anchor:"optimum.fx.optimization.ReversibleTransformation.__call__",parameters:[{name:"graph_module",val:": GraphModule"},{name:"lint_and_recompile",val:": bool = True"},{name:"reverse",val:": bool = False"}],parametersDescription:[{anchor:"optimum.fx.optimization.ReversibleTransformation.__call__.graph_module",description:`<strong>graph_module</strong> (<code>torch.fx.GraphModule</code>) &#x2014;
The module to transform.`,name:"graph_module"},{anchor:"optimum.fx.optimization.ReversibleTransformation.__call__.lint_and_recompile",description:`<strong>lint_and_recompile</strong> (<code>bool</code>, defaults to <code>True</code>) &#x2014;
Whether the transformed module should be linted and recompiled.
This can be set to <code>False</code> when chaining transformations together to perform this operation only once.`,name:"lint_and_recompile"},{anchor:"optimum.fx.optimization.ReversibleTransformation.__call__.reverse",description:`<strong>reverse</strong> (<code>bool</code>, defaults to <code>False</code>) &#x2014;
If <code>True</code>, the reverse transformation is performed.`,name:"reverse"}],source:"https://github.com/huggingface/optimum/blob/vr_303/src/optimum/fx/optimization/transformations.py#L199",returnDescription:`
<p>The transformed module.</p>
`,returnType:`
<p><code>torch.fx.GraphModule</code></p>
`}}),kt=new M({props:{name:"mark_as_restored",anchor:"optimum.fx.optimization.ReversibleTransformation.mark_as_restored",parameters:[{name:"node",val:": Node"}],parametersDescription:[{anchor:"optimum.fx.optimization.ReversibleTransformation.mark_as_restored.node",description:`<strong>node</strong> (<code>torch.fx.Node</code>) &#x2014;
The node to mark as restored.`,name:"node"}],source:"https://github.com/huggingface/optimum/blob/vr_303/src/optimum/fx/optimization/transformations.py#L224"}}),zt=new M({props:{name:"reverse",anchor:"optimum.fx.optimization.ReversibleTransformation.reverse",parameters:[{name:"graph_module",val:": GraphModule"}],parametersDescription:[{anchor:"optimum.fx.optimization.ReversibleTransformation.reverse.graph_module",description:`<strong>graph_module</strong> (<code>torch.fx.GraphModule</code>) &#x2014;
The module to transform.`,name:"graph_module"}],source:"https://github.com/huggingface/optimum/blob/vr_303/src/optimum/fx/optimization/transformations.py#L186",returnDescription:`
<p>The reverse transformed module.</p>
`,returnType:`
<p><code>torch.fx.GraphModule</code></p>
`}}),Et=new M({props:{name:"optimum.fx.optimization.compose",anchor:"optimum.fx.optimization.compose",parameters:[{name:"*args",val:": Transformation"},{name:"inplace",val:": bool = True"}],parametersDescription:[{anchor:"optimum.fx.optimization.compose.args",description:`<strong>args</strong> (<a href="/docs/optimum/pr_303/en/fx/optimization#optimum.fx.optimization.Transformation">Transformation</a>) &#x2014;
The transformations to compose together.`,name:"args"},{anchor:"optimum.fx.optimization.compose.inplace",description:`<strong>inplace</strong> (<code>bool</code>, defaults to <code>True</code>) &#x2014;
Whether the resulting transformation should be inplace, or create a new graph module.`,name:"inplace"}],source:"https://github.com/huggingface/optimum/blob/vr_303/src/optimum/fx/optimization/transformations.py#L435",returnDescription:`
<p>The composition transformation object.</p>
`}}),et=new Da({props:{anchor:"optimum.fx.optimization.compose.example",$$slots:{default:[Pr]},$$scope:{ctx:V}}}),Mt=new nt({}),At=new M({props:{name:"class optimum.fx.optimization.MergeLinears",anchor:"optimum.fx.optimization.MergeLinears",parameters:[],parametersDescription:[{anchor:"optimum.fx.optimization.MergeLinears.preserves_computation",description:`<strong>preserves_computation</strong> (<code>bool</code>, defaults to <code>False</code>) &#x2014;
Whether the transformation preserves the graph computation or not. If <code>True</code>, the original and the
transformed graph should produce the same outputs.`,name:"preserves_computation"}],source:"https://github.com/huggingface/optimum/blob/vr_303/src/optimum/fx/optimization/transformations.py#L239"}}),at=new Da({props:{anchor:"optimum.fx.optimization.MergeLinears.example",$$slots:{default:[qr]},$$scope:{ctx:V}}}),Dt=new M({props:{name:"class optimum.fx.optimization.ChangeTrueDivToMulByInverse",anchor:"optimum.fx.optimization.ChangeTrueDivToMulByInverse",parameters:[],parametersDescription:[{anchor:"optimum.fx.optimization.ChangeTrueDivToMulByInverse.preserves_computation",description:`<strong>preserves_computation</strong> (<code>bool</code>, defaults to <code>False</code>) &#x2014;
Whether the transformation preserves the graph computation or not. If <code>True</code>, the original and the
transformed graph should produce the same outputs.`,name:"preserves_computation"}],source:"https://github.com/huggingface/optimum/blob/vr_303/src/optimum/fx/optimization/transformations.py#L366"}}),rt=new Da({props:{anchor:"optimum.fx.optimization.ChangeTrueDivToMulByInverse.example",$$slots:{default:[Lr]},$$scope:{ctx:V}}}),{c(){y=a("meta"),z=m(),x=a("h1"),h=a("a"),j=a("span"),u(l.$$.fragment),w=m(),re=a("span"),co=d("Optimization"),Me=m(),W=a("p"),ho=d("The "),se=a("code"),uo=d("optimum.fx.optimization"),go=d(" module provides a set of torch.fx graph transformations, along with classes and functions to write your own transformations and compose them."),Ae=m(),B=a("h2"),H=a("a"),ne=a("span"),u(it.$$.fragment),_o=m(),ie=a("span"),vo=d("The transformation guide"),De=m(),qt=a("p"),$o=d("In \u{1F917} Optimum, there are two kinds of transformations: reversible and non-reversible transformations."),Ie=m(),C=a("h3"),J=a("a"),me=a("span"),u(mt.$$.fragment),bo=m(),pe=a("span"),yo=d("Write a non-reversible transformation"),Pe=m(),L=a("p"),xo=d("The most basic case of transformations is non-reversible transformations. Those transformations cannot be reversed, meaning that after applying them to a graph module, there is no way to get the original model back. To implement such transformations in \u{1F917} Optimum, it is very easy: you just need to subclass "),Lt=a("a"),wo=d("Transformation"),To=d(" and implement the "),Bt=a("a"),jo=d("transform()"),ko=d(" method."),qe=m(),Ct=a("p"),zo=d("For instance, the following transformation changes all the multiplications to additions:"),Le=m(),u(pt.$$.fragment),Be=m(),Nt=a("p"),Eo=d("After implementing it, your transformation can be used as a regular function:"),Ce=m(),u(lt.$$.fragment),Ne=m(),N=a("h3"),U=a("a"),le=a("span"),u(ft.$$.fragment),Mo=m(),fe=a("span"),Ao=d("Write a reversible transformation"),Re=m(),A=a("p"),Do=d("A reversible transformation implements both the transformation and its reverse, allowing to retrieve the original model from the transformed one. To implement such transformation, you need to subclass "),Rt=a("a"),Io=d("ReversibleTransformation"),Po=d(" and implement the "),St=a("a"),qo=d("transform()"),Lo=d(" and "),Gt=a("a"),Bo=d("reverse()"),Co=d(" methods."),Se=m(),Ft=a("p"),No=d("For instance, the following transformation is reversible:"),Ge=m(),u(dt.$$.fragment),Fe=m(),R=a("h3"),K=a("a"),de=a("span"),u(ct.$$.fragment),Ro=m(),ce=a("span"),So=d("Composing transformations together"),Oe=m(),Q=a("p"),Go=d("As applying mutilple transformations in chain is needed more often that not, "),Ot=a("a"),Fo=d("compose()"),Oo=d(" is provided. It is an utility function that allows you to create a transformation by chaining multiple other transformations."),Ve=m(),u(ht.$$.fragment),We=m(),S=a("h2"),X=a("a"),he=a("span"),u(ut.$$.fragment),Vo=m(),ue=a("span"),Wo=d("The Optimization API"),He=m(),G=a("h3"),Y=a("a"),ge=a("span"),u(gt.$$.fragment),Ho=m(),_e=a("span"),Jo=d("Main classes and functions"),Je=m(),T=a("div"),u(_t.$$.fragment),Uo=m(),ve=a("p"),Ko=d("A torch.fx graph transformation."),Qo=m(),vt=a("p"),Xo=d("It  must implemement the "),Vt=a("a"),Yo=d("transform()"),Zo=d(` method, and be used as a
callable.`),ta=m(),Wt=a("div"),u($t.$$.fragment),ea=m(),Ht=a("div"),u(bt.$$.fragment),oa=m(),Z=a("div"),u(yt.$$.fragment),aa=m(),$e=a("p"),ra=d("Marks a node as transformed by this transformation."),sa=m(),Jt=a("div"),u(xt.$$.fragment),na=m(),Ut=a("div"),u(wt.$$.fragment),Ue=m(),k=a("div"),u(Tt.$$.fragment),ia=m(),be=a("p"),ma=d("A torch.fx graph transformation that is reversible."),pa=m(),F=a("p"),la=d("It must implemement the "),Kt=a("a"),fa=d("transform()"),da=d(` and
`),Qt=a("a"),ca=d("reverse()"),ha=d(" methods, and be used as a callable."),ua=m(),Xt=a("div"),u(jt.$$.fragment),ga=m(),tt=a("div"),u(kt.$$.fragment),_a=m(),ye=a("p"),va=d("Marks a node as restored back to its original state."),$a=m(),Yt=a("div"),u(zt.$$.fragment),Ke=m(),I=a("div"),u(Et.$$.fragment),ba=m(),xe=a("p"),ya=d("Composes a list of transformations together."),xa=m(),u(et.$$.fragment),Qe=m(),O=a("h3"),ot=a("a"),we=a("span"),u(Mt.$$.fragment),wa=m(),Te=a("span"),Ta=d("Transformations"),Xe=m(),P=a("div"),u(At.$$.fragment),ja=m(),je=a("p"),ka=d("Transformation that merges linear layers that take the same input into one big linear layer."),za=m(),u(at.$$.fragment),Ye=m(),q=a("div"),u(Dt.$$.fragment),Ea=m(),ke=a("p"),Ma=d(`Transformation that changes truediv nodes to multiplication by the inverse nodes when the denominator is static.
For example, that is sometimes the case for the scaling factor in attention layers.`),Aa=m(),u(rt.$$.fragment),this.h()},l(t){const n=Dr('[data-svelte="svelte-1phssyn"]',document.head);y=r(n,"META",{name:!0,content:!0}),n.forEach(e),z=p(t),x=r(t,"H1",{class:!0});var It=s(x);h=r(It,"A",{id:!0,class:!0,href:!0});var ze=s(h);j=r(ze,"SPAN",{});var Ee=s(j);g(l.$$.fragment,Ee),Ee.forEach(e),ze.forEach(e),w=p(It),re=r(It,"SPAN",{});var Pa=s(re);co=c(Pa,"Optimization"),Pa.forEach(e),It.forEach(e),Me=p(t),W=r(t,"P",{});var to=s(W);ho=c(to,"The "),se=r(to,"CODE",{});var qa=s(se);uo=c(qa,"optimum.fx.optimization"),qa.forEach(e),go=c(to," module provides a set of torch.fx graph transformations, along with classes and functions to write your own transformations and compose them."),to.forEach(e),Ae=p(t),B=r(t,"H2",{class:!0});var eo=s(B);H=r(eo,"A",{id:!0,class:!0,href:!0});var La=s(H);ne=r(La,"SPAN",{});var Ba=s(ne);g(it.$$.fragment,Ba),Ba.forEach(e),La.forEach(e),_o=p(eo),ie=r(eo,"SPAN",{});var Ca=s(ie);vo=c(Ca,"The transformation guide"),Ca.forEach(e),eo.forEach(e),De=p(t),qt=r(t,"P",{});var Na=s(qt);$o=c(Na,"In \u{1F917} Optimum, there are two kinds of transformations: reversible and non-reversible transformations."),Na.forEach(e),Ie=p(t),C=r(t,"H3",{class:!0});var oo=s(C);J=r(oo,"A",{id:!0,class:!0,href:!0});var Ra=s(J);me=r(Ra,"SPAN",{});var Sa=s(me);g(mt.$$.fragment,Sa),Sa.forEach(e),Ra.forEach(e),bo=p(oo),pe=r(oo,"SPAN",{});var Ga=s(pe);yo=c(Ga,"Write a non-reversible transformation"),Ga.forEach(e),oo.forEach(e),Pe=p(t),L=r(t,"P",{});var Zt=s(L);xo=c(Zt,"The most basic case of transformations is non-reversible transformations. Those transformations cannot be reversed, meaning that after applying them to a graph module, there is no way to get the original model back. To implement such transformations in \u{1F917} Optimum, it is very easy: you just need to subclass "),Lt=r(Zt,"A",{href:!0});var Fa=s(Lt);wo=c(Fa,"Transformation"),Fa.forEach(e),To=c(Zt," and implement the "),Bt=r(Zt,"A",{href:!0});var Oa=s(Bt);jo=c(Oa,"transform()"),Oa.forEach(e),ko=c(Zt," method."),Zt.forEach(e),qe=p(t),Ct=r(t,"P",{});var Va=s(Ct);zo=c(Va,"For instance, the following transformation changes all the multiplications to additions:"),Va.forEach(e),Le=p(t),g(pt.$$.fragment,t),Be=p(t),Nt=r(t,"P",{});var Wa=s(Nt);Eo=c(Wa,"After implementing it, your transformation can be used as a regular function:"),Wa.forEach(e),Ce=p(t),g(lt.$$.fragment,t),Ne=p(t),N=r(t,"H3",{class:!0});var ao=s(N);U=r(ao,"A",{id:!0,class:!0,href:!0});var Ha=s(U);le=r(Ha,"SPAN",{});var Ja=s(le);g(ft.$$.fragment,Ja),Ja.forEach(e),Ha.forEach(e),Mo=p(ao),fe=r(ao,"SPAN",{});var Ua=s(fe);Ao=c(Ua,"Write a reversible transformation"),Ua.forEach(e),ao.forEach(e),Re=p(t),A=r(t,"P",{});var st=s(A);Do=c(st,"A reversible transformation implements both the transformation and its reverse, allowing to retrieve the original model from the transformed one. To implement such transformation, you need to subclass "),Rt=r(st,"A",{href:!0});var Ka=s(Rt);Io=c(Ka,"ReversibleTransformation"),Ka.forEach(e),Po=c(st," and implement the "),St=r(st,"A",{href:!0});var Qa=s(St);qo=c(Qa,"transform()"),Qa.forEach(e),Lo=c(st," and "),Gt=r(st,"A",{href:!0});var Xa=s(Gt);Bo=c(Xa,"reverse()"),Xa.forEach(e),Co=c(st," methods."),st.forEach(e),Se=p(t),Ft=r(t,"P",{});var Ya=s(Ft);No=c(Ya,"For instance, the following transformation is reversible:"),Ya.forEach(e),Ge=p(t),g(dt.$$.fragment,t),Fe=p(t),R=r(t,"H3",{class:!0});var ro=s(R);K=r(ro,"A",{id:!0,class:!0,href:!0});var Za=s(K);de=r(Za,"SPAN",{});var tr=s(de);g(ct.$$.fragment,tr),tr.forEach(e),Za.forEach(e),Ro=p(ro),ce=r(ro,"SPAN",{});var er=s(ce);So=c(er,"Composing transformations together"),er.forEach(e),ro.forEach(e),Oe=p(t),Q=r(t,"P",{});var so=s(Q);Go=c(so,"As applying mutilple transformations in chain is needed more often that not, "),Ot=r(so,"A",{href:!0});var or=s(Ot);Fo=c(or,"compose()"),or.forEach(e),Oo=c(so," is provided. It is an utility function that allows you to create a transformation by chaining multiple other transformations."),so.forEach(e),Ve=p(t),g(ht.$$.fragment,t),We=p(t),S=r(t,"H2",{class:!0});var no=s(S);X=r(no,"A",{id:!0,class:!0,href:!0});var ar=s(X);he=r(ar,"SPAN",{});var rr=s(he);g(ut.$$.fragment,rr),rr.forEach(e),ar.forEach(e),Vo=p(no),ue=r(no,"SPAN",{});var sr=s(ue);Wo=c(sr,"The Optimization API"),sr.forEach(e),no.forEach(e),He=p(t),G=r(t,"H3",{class:!0});var io=s(G);Y=r(io,"A",{id:!0,class:!0,href:!0});var nr=s(Y);ge=r(nr,"SPAN",{});var ir=s(ge);g(gt.$$.fragment,ir),ir.forEach(e),nr.forEach(e),Ho=p(io),_e=r(io,"SPAN",{});var mr=s(_e);Jo=c(mr,"Main classes and functions"),mr.forEach(e),io.forEach(e),Je=p(t),T=r(t,"DIV",{class:!0});var E=s(T);g(_t.$$.fragment,E),Uo=p(E),ve=r(E,"P",{});var pr=s(ve);Ko=c(pr,"A torch.fx graph transformation."),pr.forEach(e),Qo=p(E),vt=r(E,"P",{});var mo=s(vt);Xo=c(mo,"It  must implemement the "),Vt=r(mo,"A",{href:!0});var lr=s(Vt);Yo=c(lr,"transform()"),lr.forEach(e),Zo=c(mo,` method, and be used as a
callable.`),mo.forEach(e),ta=p(E),Wt=r(E,"DIV",{class:!0});var fr=s(Wt);g($t.$$.fragment,fr),fr.forEach(e),ea=p(E),Ht=r(E,"DIV",{class:!0});var dr=s(Ht);g(bt.$$.fragment,dr),dr.forEach(e),oa=p(E),Z=r(E,"DIV",{class:!0});var po=s(Z);g(yt.$$.fragment,po),aa=p(po),$e=r(po,"P",{});var cr=s($e);ra=c(cr,"Marks a node as transformed by this transformation."),cr.forEach(e),po.forEach(e),sa=p(E),Jt=r(E,"DIV",{class:!0});var hr=s(Jt);g(xt.$$.fragment,hr),hr.forEach(e),na=p(E),Ut=r(E,"DIV",{class:!0});var ur=s(Ut);g(wt.$$.fragment,ur),ur.forEach(e),E.forEach(e),Ue=p(t),k=r(t,"DIV",{class:!0});var D=s(k);g(Tt.$$.fragment,D),ia=p(D),be=r(D,"P",{});var gr=s(be);ma=c(gr,"A torch.fx graph transformation that is reversible."),gr.forEach(e),pa=p(D),F=r(D,"P",{});var te=s(F);la=c(te,"It must implemement the "),Kt=r(te,"A",{href:!0});var _r=s(Kt);fa=c(_r,"transform()"),_r.forEach(e),da=c(te,` and
`),Qt=r(te,"A",{href:!0});var vr=s(Qt);ca=c(vr,"reverse()"),vr.forEach(e),ha=c(te," methods, and be used as a callable."),te.forEach(e),ua=p(D),Xt=r(D,"DIV",{class:!0});var $r=s(Xt);g(jt.$$.fragment,$r),$r.forEach(e),ga=p(D),tt=r(D,"DIV",{class:!0});var lo=s(tt);g(kt.$$.fragment,lo),_a=p(lo),ye=r(lo,"P",{});var br=s(ye);va=c(br,"Marks a node as restored back to its original state."),br.forEach(e),lo.forEach(e),$a=p(D),Yt=r(D,"DIV",{class:!0});var yr=s(Yt);g(zt.$$.fragment,yr),yr.forEach(e),D.forEach(e),Ke=p(t),I=r(t,"DIV",{class:!0});var ee=s(I);g(Et.$$.fragment,ee),ba=p(ee),xe=r(ee,"P",{});var xr=s(xe);ya=c(xr,"Composes a list of transformations together."),xr.forEach(e),xa=p(ee),g(et.$$.fragment,ee),ee.forEach(e),Qe=p(t),O=r(t,"H3",{class:!0});var fo=s(O);ot=r(fo,"A",{id:!0,class:!0,href:!0});var wr=s(ot);we=r(wr,"SPAN",{});var Tr=s(we);g(Mt.$$.fragment,Tr),Tr.forEach(e),wr.forEach(e),wa=p(fo),Te=r(fo,"SPAN",{});var jr=s(Te);Ta=c(jr,"Transformations"),jr.forEach(e),fo.forEach(e),Xe=p(t),P=r(t,"DIV",{class:!0});var oe=s(P);g(At.$$.fragment,oe),ja=p(oe),je=r(oe,"P",{});var kr=s(je);ka=c(kr,"Transformation that merges linear layers that take the same input into one big linear layer."),kr.forEach(e),za=p(oe),g(at.$$.fragment,oe),oe.forEach(e),Ye=p(t),q=r(t,"DIV",{class:!0});var ae=s(q);g(Dt.$$.fragment,ae),Ea=p(ae),ke=r(ae,"P",{});var zr=s(ke);Ma=c(zr,`Transformation that changes truediv nodes to multiplication by the inverse nodes when the denominator is static.
For example, that is sometimes the case for the scaling factor in attention layers.`),zr.forEach(e),Aa=p(ae),g(rt.$$.fragment,ae),ae.forEach(e),this.h()},h(){i(y,"name","hf:doc:metadata"),i(y,"content",JSON.stringify(Cr)),i(h,"id","optimization"),i(h,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),i(h,"href","#optimization"),i(x,"class","relative group"),i(H,"id","the-transformation-guide"),i(H,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),i(H,"href","#the-transformation-guide"),i(B,"class","relative group"),i(J,"id","write-a-nonreversible-transformation"),i(J,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),i(J,"href","#write-a-nonreversible-transformation"),i(C,"class","relative group"),i(Lt,"href","/docs/optimum/pr_303/en/fx/optimization#optimum.fx.optimization.Transformation"),i(Bt,"href","/docs/optimum/pr_303/en/fx/optimization#optimum.fx.optimization.Transformation.transform"),i(U,"id","write-a-reversible-transformation"),i(U,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),i(U,"href","#write-a-reversible-transformation"),i(N,"class","relative group"),i(Rt,"href","/docs/optimum/pr_303/en/fx/optimization#optimum.fx.optimization.ReversibleTransformation"),i(St,"href","/docs/optimum/pr_303/en/fx/optimization#optimum.fx.optimization.Transformation.transform"),i(Gt,"href","/docs/optimum/pr_303/en/fx/optimization#optimum.fx.optimization.ReversibleTransformation.reverse"),i(K,"id","composing-transformations-together"),i(K,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),i(K,"href","#composing-transformations-together"),i(R,"class","relative group"),i(Ot,"href","/docs/optimum/pr_303/en/fx/optimization#optimum.fx.optimization.compose"),i(X,"id","the-optimization-api"),i(X,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),i(X,"href","#the-optimization-api"),i(S,"class","relative group"),i(Y,"id","optimum.fx.optimization.Transformation"),i(Y,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),i(Y,"href","#optimum.fx.optimization.Transformation"),i(G,"class","relative group"),i(Vt,"href","/docs/optimum/pr_303/en/fx/optimization#optimum.fx.optimization.Transformation.transform"),i(Wt,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),i(Ht,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),i(Z,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),i(Jt,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),i(Ut,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),i(T,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),i(Kt,"href","/docs/optimum/pr_303/en/fx/optimization#optimum.fx.optimization.Transformation.transform"),i(Qt,"href","/docs/optimum/pr_303/en/fx/optimization#optimum.fx.optimization.ReversibleTransformation.reverse"),i(Xt,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),i(tt,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),i(Yt,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),i(k,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),i(I,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),i(ot,"id","optimum.fx.optimization.MergeLinears"),i(ot,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),i(ot,"href","#optimum.fx.optimization.MergeLinears"),i(O,"class","relative group"),i(P,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),i(q,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8")},m(t,n){o(document.head,y),f(t,z,n),f(t,x,n),o(x,h),o(h,j),_(l,j,null),o(x,w),o(x,re),o(re,co),f(t,Me,n),f(t,W,n),o(W,ho),o(W,se),o(se,uo),o(W,go),f(t,Ae,n),f(t,B,n),o(B,H),o(H,ne),_(it,ne,null),o(B,_o),o(B,ie),o(ie,vo),f(t,De,n),f(t,qt,n),o(qt,$o),f(t,Ie,n),f(t,C,n),o(C,J),o(J,me),_(mt,me,null),o(C,bo),o(C,pe),o(pe,yo),f(t,Pe,n),f(t,L,n),o(L,xo),o(L,Lt),o(Lt,wo),o(L,To),o(L,Bt),o(Bt,jo),o(L,ko),f(t,qe,n),f(t,Ct,n),o(Ct,zo),f(t,Le,n),_(pt,t,n),f(t,Be,n),f(t,Nt,n),o(Nt,Eo),f(t,Ce,n),_(lt,t,n),f(t,Ne,n),f(t,N,n),o(N,U),o(U,le),_(ft,le,null),o(N,Mo),o(N,fe),o(fe,Ao),f(t,Re,n),f(t,A,n),o(A,Do),o(A,Rt),o(Rt,Io),o(A,Po),o(A,St),o(St,qo),o(A,Lo),o(A,Gt),o(Gt,Bo),o(A,Co),f(t,Se,n),f(t,Ft,n),o(Ft,No),f(t,Ge,n),_(dt,t,n),f(t,Fe,n),f(t,R,n),o(R,K),o(K,de),_(ct,de,null),o(R,Ro),o(R,ce),o(ce,So),f(t,Oe,n),f(t,Q,n),o(Q,Go),o(Q,Ot),o(Ot,Fo),o(Q,Oo),f(t,Ve,n),_(ht,t,n),f(t,We,n),f(t,S,n),o(S,X),o(X,he),_(ut,he,null),o(S,Vo),o(S,ue),o(ue,Wo),f(t,He,n),f(t,G,n),o(G,Y),o(Y,ge),_(gt,ge,null),o(G,Ho),o(G,_e),o(_e,Jo),f(t,Je,n),f(t,T,n),_(_t,T,null),o(T,Uo),o(T,ve),o(ve,Ko),o(T,Qo),o(T,vt),o(vt,Xo),o(vt,Vt),o(Vt,Yo),o(vt,Zo),o(T,ta),o(T,Wt),_($t,Wt,null),o(T,ea),o(T,Ht),_(bt,Ht,null),o(T,oa),o(T,Z),_(yt,Z,null),o(Z,aa),o(Z,$e),o($e,ra),o(T,sa),o(T,Jt),_(xt,Jt,null),o(T,na),o(T,Ut),_(wt,Ut,null),f(t,Ue,n),f(t,k,n),_(Tt,k,null),o(k,ia),o(k,be),o(be,ma),o(k,pa),o(k,F),o(F,la),o(F,Kt),o(Kt,fa),o(F,da),o(F,Qt),o(Qt,ca),o(F,ha),o(k,ua),o(k,Xt),_(jt,Xt,null),o(k,ga),o(k,tt),_(kt,tt,null),o(tt,_a),o(tt,ye),o(ye,va),o(k,$a),o(k,Yt),_(zt,Yt,null),f(t,Ke,n),f(t,I,n),_(Et,I,null),o(I,ba),o(I,xe),o(xe,ya),o(I,xa),_(et,I,null),f(t,Qe,n),f(t,O,n),o(O,ot),o(ot,we),_(Mt,we,null),o(O,wa),o(O,Te),o(Te,Ta),f(t,Xe,n),f(t,P,n),_(At,P,null),o(P,ja),o(P,je),o(je,ka),o(P,za),_(at,P,null),f(t,Ye,n),f(t,q,n),_(Dt,q,null),o(q,Ea),o(q,ke),o(ke,Ma),o(q,Aa),_(rt,q,null),Ze=!0},p(t,[n]){const It={};n&2&&(It.$$scope={dirty:n,ctx:t}),et.$set(It);const ze={};n&2&&(ze.$$scope={dirty:n,ctx:t}),at.$set(ze);const Ee={};n&2&&(Ee.$$scope={dirty:n,ctx:t}),rt.$set(Ee)},i(t){Ze||(v(l.$$.fragment,t),v(it.$$.fragment,t),v(mt.$$.fragment,t),v(pt.$$.fragment,t),v(lt.$$.fragment,t),v(ft.$$.fragment,t),v(dt.$$.fragment,t),v(ct.$$.fragment,t),v(ht.$$.fragment,t),v(ut.$$.fragment,t),v(gt.$$.fragment,t),v(_t.$$.fragment,t),v($t.$$.fragment,t),v(bt.$$.fragment,t),v(yt.$$.fragment,t),v(xt.$$.fragment,t),v(wt.$$.fragment,t),v(Tt.$$.fragment,t),v(jt.$$.fragment,t),v(kt.$$.fragment,t),v(zt.$$.fragment,t),v(Et.$$.fragment,t),v(et.$$.fragment,t),v(Mt.$$.fragment,t),v(At.$$.fragment,t),v(at.$$.fragment,t),v(Dt.$$.fragment,t),v(rt.$$.fragment,t),Ze=!0)},o(t){$(l.$$.fragment,t),$(it.$$.fragment,t),$(mt.$$.fragment,t),$(pt.$$.fragment,t),$(lt.$$.fragment,t),$(ft.$$.fragment,t),$(dt.$$.fragment,t),$(ct.$$.fragment,t),$(ht.$$.fragment,t),$(ut.$$.fragment,t),$(gt.$$.fragment,t),$(_t.$$.fragment,t),$($t.$$.fragment,t),$(bt.$$.fragment,t),$(yt.$$.fragment,t),$(xt.$$.fragment,t),$(wt.$$.fragment,t),$(Tt.$$.fragment,t),$(jt.$$.fragment,t),$(kt.$$.fragment,t),$(zt.$$.fragment,t),$(Et.$$.fragment,t),$(et.$$.fragment,t),$(Mt.$$.fragment,t),$(At.$$.fragment,t),$(at.$$.fragment,t),$(Dt.$$.fragment,t),$(rt.$$.fragment,t),Ze=!1},d(t){e(y),t&&e(z),t&&e(x),b(l),t&&e(Me),t&&e(W),t&&e(Ae),t&&e(B),b(it),t&&e(De),t&&e(qt),t&&e(Ie),t&&e(C),b(mt),t&&e(Pe),t&&e(L),t&&e(qe),t&&e(Ct),t&&e(Le),b(pt,t),t&&e(Be),t&&e(Nt),t&&e(Ce),b(lt,t),t&&e(Ne),t&&e(N),b(ft),t&&e(Re),t&&e(A),t&&e(Se),t&&e(Ft),t&&e(Ge),b(dt,t),t&&e(Fe),t&&e(R),b(ct),t&&e(Oe),t&&e(Q),t&&e(Ve),b(ht,t),t&&e(We),t&&e(S),b(ut),t&&e(He),t&&e(G),b(gt),t&&e(Je),t&&e(T),b(_t),b($t),b(bt),b(yt),b(xt),b(wt),t&&e(Ue),t&&e(k),b(Tt),b(jt),b(kt),b(zt),t&&e(Ke),t&&e(I),b(Et),b(et),t&&e(Qe),t&&e(O),b(Mt),t&&e(Xe),t&&e(P),b(At),b(at),t&&e(Ye),t&&e(q),b(Dt),b(rt)}}}const Cr={local:"optimization",sections:[{local:"the-transformation-guide",sections:[{local:"write-a-nonreversible-transformation",title:"Write a non-reversible transformation"},{local:"write-a-reversible-transformation",title:"Write a reversible transformation"},{local:"composing-transformations-together",title:"Composing transformations together"}],title:"The transformation guide"},{local:"the-optimization-api",sections:[{local:"optimum.fx.optimization.Transformation",title:"Main classes and functions"},{local:"optimum.fx.optimization.MergeLinears",title:"Transformations"}],title:"The Optimization API"}],title:"Optimization"};function Nr(V){return Ir(()=>{new URLSearchParams(window.location.search).get("fw")}),[]}class Vr extends Er{constructor(y){super();Mr(this,y,Nr,Br,Ar,{})}}export{Vr as default,Cr as metadata};
