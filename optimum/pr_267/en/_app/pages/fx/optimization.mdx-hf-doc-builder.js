import{S as Es,i as Ms,s as As,e as a,k as i,w as g,t as d,M as Ds,c as s,d as o,m,a as r,x as _,h as c,b as p,G as e,g as f,y as v,q as $,o as b,B as y,v as Ps,L as Ia}from"../../chunks/vendor-hf-doc-builder.js";import{D}from"../../chunks/Docstring-hf-doc-builder.js";import{C as It}from"../../chunks/CodeBlock-hf-doc-builder.js";import{I as it}from"../../chunks/IconCopyLink-hf-doc-builder.js";import{E as Pa}from"../../chunks/ExampleCodeBlock-hf-doc-builder.js";function Is(W){let u,z,x,h,T;return h=new It({props:{code:`from transformers import BertModel
from transformers.utils.fx import symbolic_trace
from optimum.fx.optimization import ChangeTrueDivToMulByInverse, MergeLinears, compose

model = BertModel.from_pretrained("bert-base-uncased")
traced = symbolic_trace(
    model,
    input_names=["input_ids", "attention_mask", "token_type_ids"],
)
composition = compose(ChangeTrueDivToMulByInverse(), MergeLinears())
transformed_model = composition(traced)`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> BertModel
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers.utils.fx <span class="hljs-keyword">import</span> symbolic_trace
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> optimum.fx.optimization <span class="hljs-keyword">import</span> ChangeTrueDivToMulByInverse, MergeLinears, compose

<span class="hljs-meta">&gt;&gt;&gt; </span>model = BertModel.from_pretrained(<span class="hljs-string">&quot;bert-base-uncased&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>traced = symbolic_trace(
<span class="hljs-meta">&gt;&gt;&gt; </span>    model,
<span class="hljs-meta">&gt;&gt;&gt; </span>    input_names=[<span class="hljs-string">&quot;input_ids&quot;</span>, <span class="hljs-string">&quot;attention_mask&quot;</span>, <span class="hljs-string">&quot;token_type_ids&quot;</span>],
<span class="hljs-meta">&gt;&gt;&gt; </span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>composition = compose(ChangeTrueDivToMulByInverse(), MergeLinears())
<span class="hljs-meta">&gt;&gt;&gt; </span>transformed_model = composition(traced)`}}),{c(){u=a("p"),z=d("Example:"),x=i(),g(h.$$.fragment)},l(l){u=s(l,"P",{});var w=r(u);z=c(w,"Example:"),w.forEach(o),x=m(l),_(h.$$.fragment,l)},m(l,w){f(l,u,w),e(u,z),f(l,x,w),v(h,l,w),T=!0},p:Ia,i(l){T||($(h.$$.fragment,l),T=!0)},o(l){b(h.$$.fragment,l),T=!1},d(l){l&&o(u),l&&o(x),y(h,l)}}}function qs(W){let u,z,x,h,T;return h=new It({props:{code:`from transformers import BertModel
from transformers.utils.fx import symbolic_trace
from optimum.fx.optimization import MergeLinears

model = BertModel.from_pretrained("bert-base-uncased")
traced = symbolic_trace(
    model,
    input_names=["input_ids", "attention_mask", "token_type_ids"],
)
transformation = MergeLinears()
transformed_model = transformation(traced)
restored_model = transformation(transformed_model, reverse=True)`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> BertModel
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers.utils.fx <span class="hljs-keyword">import</span> symbolic_trace
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> optimum.fx.optimization <span class="hljs-keyword">import</span> MergeLinears

<span class="hljs-meta">&gt;&gt;&gt; </span>model = BertModel.from_pretrained(<span class="hljs-string">&quot;bert-base-uncased&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>traced = symbolic_trace(
<span class="hljs-meta">&gt;&gt;&gt; </span>    model,
<span class="hljs-meta">&gt;&gt;&gt; </span>    input_names=[<span class="hljs-string">&quot;input_ids&quot;</span>, <span class="hljs-string">&quot;attention_mask&quot;</span>, <span class="hljs-string">&quot;token_type_ids&quot;</span>],
<span class="hljs-meta">&gt;&gt;&gt; </span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>transformation = MergeLinears()
<span class="hljs-meta">&gt;&gt;&gt; </span>transformed_model = transformation(traced)
<span class="hljs-meta">&gt;&gt;&gt; </span>restored_model = transformation(transformed_model, reverse=<span class="hljs-literal">True</span>)`}}),{c(){u=a("p"),z=d("Example:"),x=i(),g(h.$$.fragment)},l(l){u=s(l,"P",{});var w=r(u);z=c(w,"Example:"),w.forEach(o),x=m(l),_(h.$$.fragment,l)},m(l,w){f(l,u,w),e(u,z),f(l,x,w),v(h,l,w),T=!0},p:Ia,i(l){T||($(h.$$.fragment,l),T=!0)},o(l){b(h.$$.fragment,l),T=!1},d(l){l&&o(u),l&&o(x),y(h,l)}}}function Bs(W){let u,z,x,h,T;return h=new It({props:{code:`from transformers import BertModel
from transformers.utils.fx import symbolic_trace
from optimum.fx.optimization import ChangeTrueDivToMulByInverse

model = BertModel.from_pretrained("bert-base-uncased")
traced = symbolic_trace(
    model,
    input_names=["input_ids", "attention_mask", "token_type_ids"],
)
transformation = ChangeTrueDivToMulByInverse()
transformed_model = transformation(traced)
restored_model = transformation(transformed_model, reverse=True)`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> BertModel
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers.utils.fx <span class="hljs-keyword">import</span> symbolic_trace
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> optimum.fx.optimization <span class="hljs-keyword">import</span> ChangeTrueDivToMulByInverse

<span class="hljs-meta">&gt;&gt;&gt; </span>model = BertModel.from_pretrained(<span class="hljs-string">&quot;bert-base-uncased&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>traced = symbolic_trace(
<span class="hljs-meta">&gt;&gt;&gt; </span>    model,
<span class="hljs-meta">&gt;&gt;&gt; </span>    input_names=[<span class="hljs-string">&quot;input_ids&quot;</span>, <span class="hljs-string">&quot;attention_mask&quot;</span>, <span class="hljs-string">&quot;token_type_ids&quot;</span>],
<span class="hljs-meta">&gt;&gt;&gt; </span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>transformation = ChangeTrueDivToMulByInverse()
<span class="hljs-meta">&gt;&gt;&gt; </span>transformed_model = transformation(traced)
<span class="hljs-meta">&gt;&gt;&gt; </span>restored_model = transformation(transformed_model, reverse=<span class="hljs-literal">True</span>)`}}),{c(){u=a("p"),z=d("Example:"),x=i(),g(h.$$.fragment)},l(l){u=s(l,"P",{});var w=r(u);z=c(w,"Example:"),w.forEach(o),x=m(l),_(h.$$.fragment,l)},m(l,w){f(l,u,w),e(u,z),f(l,x,w),v(h,l,w),T=!0},p:Ia,i(l){T||($(h.$$.fragment,l),T=!0)},o(l){b(h.$$.fragment,l),T=!1},d(l){l&&o(u),l&&o(x),y(h,l)}}}function Ls(W){let u,z,x,h,T,l,w,oe,co,Ee,V,ho,ae,uo,go,Me,L,H,se,mt,_o,re,vo,Ae,qt,$o,De,C,J,ne,lt,bo,ie,yo,Pe,B,xo,Bt,wo,To,Lt,jo,ko,Ie,Ct,zo,qe,pt,Be,Nt,Eo,Le,ft,Ce,N,U,me,dt,Mo,le,Ao,Ne,M,Do,St,Po,Io,Rt,qo,Bo,Ft,Lo,Co,Se,Gt,No,Re,ct,Fe,S,K,pe,ht,So,fe,Ro,Ge,Q,Fo,Ot,Go,Oo,Oe,ut,We,R,X,de,gt,Wo,ce,Vo,Ve,F,Y,he,_t,Ho,ue,Jo,He,j,vt,Uo,ge,Ko,Qo,$t,Xo,Wt,Yo,Zo,ta,Vt,bt,ea,Z,yt,oa,_e,aa,sa,Ht,xt,ra,tt,wt,na,ve,ia,Je,k,Tt,ma,$e,la,pa,G,fa,Jt,da,ca,Ut,ha,ua,ga,Kt,jt,_a,et,kt,va,be,$a,ba,Qt,zt,Ue,P,Et,ya,ye,xa,wa,ot,Ke,O,at,xe,Mt,Ta,we,ja,Qe,I,At,ka,Te,za,Ea,st,Xe,q,Dt,Ma,je,Aa,Da,rt,Ye;return l=new it({}),mt=new it({}),lt=new it({}),pt=new It({props:{code:`from optimum.fx.optimization import Transformation

class ChangeMulToAdd(Transformation):
    def transform(self, graph_module):
        for node in graph_module.graph.nodes:
            if node.op == "call_function" and node.target == operator.mul:
                node.target = operator.add
        return graph_module`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> optimum.fx.optimization <span class="hljs-keyword">import</span> Transformation

<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">class</span> <span class="hljs-title class_">ChangeMulToAdd</span>(<span class="hljs-title class_ inherited__">Transformation</span>):
<span class="hljs-meta">&gt;&gt;&gt; </span>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">transform</span>(<span class="hljs-params">self, graph_module</span>):
<span class="hljs-meta">&gt;&gt;&gt; </span>        <span class="hljs-keyword">for</span> node <span class="hljs-keyword">in</span> graph_module.graph.nodes:
<span class="hljs-meta">&gt;&gt;&gt; </span>            <span class="hljs-keyword">if</span> node.op == <span class="hljs-string">&quot;call_function&quot;</span> <span class="hljs-keyword">and</span> node.target == operator.mul:
<span class="hljs-meta">&gt;&gt;&gt; </span>                node.target = operator.add
<span class="hljs-meta">&gt;&gt;&gt; </span>        <span class="hljs-keyword">return</span> graph_module`}}),ft=new It({props:{code:`from transformers import BertModel
from transformers.utils.fx import symbolic_trace

model = BertModel.from_pretrained("bert-base-uncased")
traced = symbolic_trace(
    model,
    input_names=["input_ids", "attention_mask", "token_type_ids"],
)

transformation = ChangeMulToAdd()
transformed_model = transformation(traced)`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> BertModel
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers.utils.fx <span class="hljs-keyword">import</span> symbolic_trace

<span class="hljs-meta">&gt;&gt;&gt; </span>model = BertModel.from_pretrained(<span class="hljs-string">&quot;bert-base-uncased&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>traced = symbolic_trace(
<span class="hljs-meta">&gt;&gt;&gt; </span>    model,
<span class="hljs-meta">&gt;&gt;&gt; </span>    input_names=[<span class="hljs-string">&quot;input_ids&quot;</span>, <span class="hljs-string">&quot;attention_mask&quot;</span>, <span class="hljs-string">&quot;token_type_ids&quot;</span>],
<span class="hljs-meta">&gt;&gt;&gt; </span>)

<span class="hljs-meta">&gt;&gt;&gt; </span>transformation = ChangeMulToAdd()
<span class="hljs-meta">&gt;&gt;&gt; </span>transformed_model = transformation(traced)`}}),dt=new it({}),ct=new It({props:{code:`from optimum.fx.optimization import ReversibleTransformation

class MulToMulTimesTwo(ReversibleTransformation):
    def transform(self, graph_module):
        for node in graph_module.graph.nodes:
            if node.op == "call_function" and node.target == operator.mul:
                x, y = node.args
                node.args = (2 * x, y)
        return graph_module

    def reverse(self, graph_module):
        for node in graph_module.graph.nodes:
            if node.op == "call_function" and node.target == operator.mul:
                x, y = node.args
                node.args = (x / 2, y)
        return graph_module`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> optimum.fx.optimization <span class="hljs-keyword">import</span> ReversibleTransformation

<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">class</span> <span class="hljs-title class_">MulToMulTimesTwo</span>(<span class="hljs-title class_ inherited__">ReversibleTransformation</span>):
<span class="hljs-meta">&gt;&gt;&gt; </span>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">transform</span>(<span class="hljs-params">self, graph_module</span>):
<span class="hljs-meta">&gt;&gt;&gt; </span>        <span class="hljs-keyword">for</span> node <span class="hljs-keyword">in</span> graph_module.graph.nodes:
<span class="hljs-meta">&gt;&gt;&gt; </span>            <span class="hljs-keyword">if</span> node.op == <span class="hljs-string">&quot;call_function&quot;</span> <span class="hljs-keyword">and</span> node.target == operator.mul:
<span class="hljs-meta">&gt;&gt;&gt; </span>                x, y = node.args
<span class="hljs-meta">&gt;&gt;&gt; </span>                node.args = (<span class="hljs-number">2</span> * x, y)
<span class="hljs-meta">&gt;&gt;&gt; </span>        <span class="hljs-keyword">return</span> graph_module

<span class="hljs-meta">&gt;&gt;&gt; </span>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">reverse</span>(<span class="hljs-params">self, graph_module</span>):
<span class="hljs-meta">&gt;&gt;&gt; </span>        <span class="hljs-keyword">for</span> node <span class="hljs-keyword">in</span> graph_module.graph.nodes:
<span class="hljs-meta">&gt;&gt;&gt; </span>            <span class="hljs-keyword">if</span> node.op == <span class="hljs-string">&quot;call_function&quot;</span> <span class="hljs-keyword">and</span> node.target == operator.mul:
<span class="hljs-meta">&gt;&gt;&gt; </span>                x, y = node.args
<span class="hljs-meta">&gt;&gt;&gt; </span>                node.args = (x / <span class="hljs-number">2</span>, y)
<span class="hljs-meta">&gt;&gt;&gt; </span>        <span class="hljs-keyword">return</span> graph_module`}}),ht=new it({}),ut=new It({props:{code:`from optimum.fx.optimization import compose
composition = compose(MulToMulTimesTwo(), ChangeMulToAdd())`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> optimum.fx.optimization <span class="hljs-keyword">import</span> compose
<span class="hljs-meta">&gt;&gt;&gt; </span>composition = compose(MulToMulTimesTwo(), ChangeMulToAdd())`}}),gt=new it({}),_t=new it({}),vt=new D({props:{name:"class optimum.fx.optimization.Transformation",anchor:"optimum.fx.optimization.Transformation",parameters:[],parametersDescription:[{anchor:"optimum.fx.optimization.Transformation.preserves_computation",description:`<strong>preserves_computation</strong> (<code>bool</code>, defaults to <code>False</code>) &#x2014;
Whether the transformation preserves the graph computation or not. If <code>True</code>, the original and the
transformed graph should produce the same outputs.`,name:"preserves_computation"}],source:"https://github.com/huggingface/optimum/blob/vr_267/src/optimum/fx/optimization/transformations.py#L87"}}),bt=new D({props:{name:"__call__",anchor:"optimum.fx.optimization.Transformation.__call__",parameters:[{name:"graph_module",val:": GraphModule"},{name:"lint_and_recompile",val:": bool = True"}],parametersDescription:[{anchor:"optimum.fx.optimization.Transformation.__call__.graph_module",description:`<strong>graph_module</strong> (<code>torch.fx.GraphModule</code>) &#x2014;
The module to transform.`,name:"graph_module"},{anchor:"optimum.fx.optimization.Transformation.__call__.lint_and_recompile",description:`<strong>lint_and_recompile</strong> (<code>bool</code>, defaults to <code>True</code>) &#x2014;
Whether the transformed module should be linted and recompiled.
This can be set to <code>False</code> when chaining transformations together to perform this operation only once.`,name:"lint_and_recompile"}],source:"https://github.com/huggingface/optimum/blob/vr_267/src/optimum/fx/optimization/transformations.py#L110",returnDescription:`
<p>The transformed module.</p>
`,returnType:`
<p><code>torch.fx.GraphModule</code></p>
`}}),yt=new D({props:{name:"mark_as_transformed",anchor:"optimum.fx.optimization.Transformation.mark_as_transformed",parameters:[{name:"node",val:": Node"}],parametersDescription:[{anchor:"optimum.fx.optimization.Transformation.mark_as_transformed.node",description:`<strong>node</strong> (<code>torch.fx.Node</code>) &#x2014;
The node to mark as transformed.`,name:"node"}],source:"https://github.com/huggingface/optimum/blob/vr_267/src/optimum/fx/optimization/transformations.py#L139"}}),xt=new D({props:{name:"transform",anchor:"optimum.fx.optimization.Transformation.transform",parameters:[{name:"graph_module",val:": GraphModule"}],parametersDescription:[{anchor:"optimum.fx.optimization.Transformation.transform.graph_module",description:`<strong>graph_module</strong> (<code>torch.fx.GraphModule</code>) &#x2014;
The module to transform.`,name:"graph_module"}],source:"https://github.com/huggingface/optimum/blob/vr_267/src/optimum/fx/optimization/transformations.py#L97",returnDescription:`
<p>The transformed module.</p>
`,returnType:`
<p><code>torch.fx.GraphModule</code></p>
`}}),wt=new D({props:{name:"transformed",anchor:"optimum.fx.optimization.Transformation.transformed",parameters:[{name:"node",val:": Node"}],parametersDescription:[{anchor:"optimum.fx.optimization.Transformation.transformed.node",description:`<strong>node</strong> (<code>torch.fx.Node</code>) &#x2014;
The node to check.`,name:"node"}],source:"https://github.com/huggingface/optimum/blob/vr_267/src/optimum/fx/optimization/transformations.py#L151",returnDescription:`
<p>True if the node was transformed by this transformation, and False otherwise.</p>
`,returnType:`
<p><code>bool</code></p>
`}}),Tt=new D({props:{name:"class optimum.fx.optimization.ReversibleTransformation",anchor:"optimum.fx.optimization.ReversibleTransformation",parameters:[],parametersDescription:[{anchor:"optimum.fx.optimization.ReversibleTransformation.preserves_computation",description:`<strong>preserves_computation</strong> (<code>bool</code>, defaults to <code>False</code>) &#x2014;
Whether the transformation preserves the graph computation or not. If <code>True</code>, the original and the
transformed graph should produce the same outputs.`,name:"preserves_computation"}],source:"https://github.com/huggingface/optimum/blob/vr_267/src/optimum/fx/optimization/transformations.py#L167"}}),jt=new D({props:{name:"__call__",anchor:"optimum.fx.optimization.ReversibleTransformation.__call__",parameters:[{name:"graph_module",val:": GraphModule"},{name:"lint_and_recompile",val:": bool = True"},{name:"reverse",val:": bool = False"}],parametersDescription:[{anchor:"optimum.fx.optimization.ReversibleTransformation.__call__.graph_module",description:`<strong>graph_module</strong> (<code>torch.fx.GraphModule</code>) &#x2014;
The module to transform.`,name:"graph_module"},{anchor:"optimum.fx.optimization.ReversibleTransformation.__call__.lint_and_recompile",description:`<strong>lint_and_recompile</strong> (<code>bool</code>, defaults to <code>True</code>) &#x2014;
Whether the transformed module should be linted and recompiled.
This can be set to <code>False</code> when chaining transformations together to perform this operation only once.`,name:"lint_and_recompile"},{anchor:"optimum.fx.optimization.ReversibleTransformation.__call__.reverse",description:`<strong>reverse</strong> (<code>bool</code>, defaults to <code>False</code>) &#x2014;
If <code>True</code>, the reverse transformation is performed.`,name:"reverse"}],source:"https://github.com/huggingface/optimum/blob/vr_267/src/optimum/fx/optimization/transformations.py#L188",returnDescription:`
<p>The transformed module.</p>
`,returnType:`
<p><code>torch.fx.GraphModule</code></p>
`}}),kt=new D({props:{name:"mark_as_restored",anchor:"optimum.fx.optimization.ReversibleTransformation.mark_as_restored",parameters:[{name:"node",val:": Node"}],parametersDescription:[{anchor:"optimum.fx.optimization.ReversibleTransformation.mark_as_restored.node",description:`<strong>node</strong> (<code>torch.fx.Node</code>) &#x2014;
The node to mark as restored.`,name:"node"}],source:"https://github.com/huggingface/optimum/blob/vr_267/src/optimum/fx/optimization/transformations.py#L213"}}),zt=new D({props:{name:"reverse",anchor:"optimum.fx.optimization.ReversibleTransformation.reverse",parameters:[{name:"graph_module",val:": GraphModule"}],parametersDescription:[{anchor:"optimum.fx.optimization.ReversibleTransformation.reverse.graph_module",description:`<strong>graph_module</strong> (<code>torch.fx.GraphModule</code>) &#x2014;
The module to transform.`,name:"graph_module"}],source:"https://github.com/huggingface/optimum/blob/vr_267/src/optimum/fx/optimization/transformations.py#L175",returnDescription:`
<p>The reverse transformed module.</p>
`,returnType:`
<p><code>torch.fx.GraphModule</code></p>
`}}),Et=new D({props:{name:"optimum.fx.optimization.compose",anchor:"optimum.fx.optimization.compose",parameters:[{name:"*args",val:": Transformation"},{name:"inplace",val:": bool = True"}],parametersDescription:[{anchor:"optimum.fx.optimization.compose.args",description:`<strong>args</strong> (<a href="/docs/optimum/pr_267/en/fx/optimization#optimum.fx.optimization.Transformation">Transformation</a>) &#x2014;
The transformations to compose together.`,name:"args"},{anchor:"optimum.fx.optimization.compose.inplace",description:`<strong>inplace</strong> (<code>bool</code>, defaults to <code>True</code>) &#x2014;
Whether the resulting transformation should be inplace, or create a new graph module.`,name:"inplace"}],source:"https://github.com/huggingface/optimum/blob/vr_267/src/optimum/fx/optimization/transformations.py#L424",returnDescription:`
<p>The composition transformation object.</p>
`}}),ot=new Pa({props:{anchor:"optimum.fx.optimization.compose.example",$$slots:{default:[Is]},$$scope:{ctx:W}}}),Mt=new it({}),At=new D({props:{name:"class optimum.fx.optimization.MergeLinears",anchor:"optimum.fx.optimization.MergeLinears",parameters:[],parametersDescription:[{anchor:"optimum.fx.optimization.MergeLinears.preserves_computation",description:`<strong>preserves_computation</strong> (<code>bool</code>, defaults to <code>False</code>) &#x2014;
Whether the transformation preserves the graph computation or not. If <code>True</code>, the original and the
transformed graph should produce the same outputs.`,name:"preserves_computation"}],source:"https://github.com/huggingface/optimum/blob/vr_267/src/optimum/fx/optimization/transformations.py#L228"}}),st=new Pa({props:{anchor:"optimum.fx.optimization.MergeLinears.example",$$slots:{default:[qs]},$$scope:{ctx:W}}}),Dt=new D({props:{name:"class optimum.fx.optimization.ChangeTrueDivToMulByInverse",anchor:"optimum.fx.optimization.ChangeTrueDivToMulByInverse",parameters:[],parametersDescription:[{anchor:"optimum.fx.optimization.ChangeTrueDivToMulByInverse.preserves_computation",description:`<strong>preserves_computation</strong> (<code>bool</code>, defaults to <code>False</code>) &#x2014;
Whether the transformation preserves the graph computation or not. If <code>True</code>, the original and the
transformed graph should produce the same outputs.`,name:"preserves_computation"}],source:"https://github.com/huggingface/optimum/blob/vr_267/src/optimum/fx/optimization/transformations.py#L355"}}),rt=new Pa({props:{anchor:"optimum.fx.optimization.ChangeTrueDivToMulByInverse.example",$$slots:{default:[Bs]},$$scope:{ctx:W}}}),{c(){u=a("meta"),z=i(),x=a("h1"),h=a("a"),T=a("span"),g(l.$$.fragment),w=i(),oe=a("span"),co=d("Optimization"),Ee=i(),V=a("p"),ho=d("The "),ae=a("code"),uo=d("optimum.fx.optimization"),go=d(" module provides a set of torch.fx graph transformations, along with classes and functions to write your own transformations and compose them."),Me=i(),L=a("h2"),H=a("a"),se=a("span"),g(mt.$$.fragment),_o=i(),re=a("span"),vo=d("The transformation guide"),Ae=i(),qt=a("p"),$o=d("In \u{1F917} Optimum, there are two kinds of transformations: reversible and non-reversible transformations."),De=i(),C=a("h3"),J=a("a"),ne=a("span"),g(lt.$$.fragment),bo=i(),ie=a("span"),yo=d("Write a non-reversible transformation"),Pe=i(),B=a("p"),xo=d("The most basic case of transformations is non-reversible transformations. Those transformations cannot be reversed, meaning that after applying them to a graph module, there is no way to get the original model back. To implement such transformations in \u{1F917} Optimum, it is very easy: you just need to subclass "),Bt=a("a"),wo=d("Transformation"),To=d(" and implement the "),Lt=a("a"),jo=d("transform()"),ko=d(" method."),Ie=i(),Ct=a("p"),zo=d("For instance, the following transformation changes all the multiplications to additions:"),qe=i(),g(pt.$$.fragment),Be=i(),Nt=a("p"),Eo=d("After implementing it, your transformation can be used as a regular function:"),Le=i(),g(ft.$$.fragment),Ce=i(),N=a("h3"),U=a("a"),me=a("span"),g(dt.$$.fragment),Mo=i(),le=a("span"),Ao=d("Write a reversible transformation"),Ne=i(),M=a("p"),Do=d("A reversible transformation implements both the transformation and its reverse, allowing to retrieve the original model from the transformed one. To implement such transformation, you need to subclass "),St=a("a"),Po=d("ReversibleTransformation"),Io=d(" and implement the "),Rt=a("a"),qo=d("transform()"),Bo=d(" and "),Ft=a("a"),Lo=d("reverse()"),Co=d(" methods."),Se=i(),Gt=a("p"),No=d("For instance, the following transformation is reversible:"),Re=i(),g(ct.$$.fragment),Fe=i(),S=a("h3"),K=a("a"),pe=a("span"),g(ht.$$.fragment),So=i(),fe=a("span"),Ro=d("Composing transformations together"),Ge=i(),Q=a("p"),Fo=d("As applying mutilple transformations in chain is needed more often that not, "),Ot=a("a"),Go=d("compose()"),Oo=d(" is provided. It is an utility function that allows you to create a transformation by chaining multiple other transformations."),Oe=i(),g(ut.$$.fragment),We=i(),R=a("h2"),X=a("a"),de=a("span"),g(gt.$$.fragment),Wo=i(),ce=a("span"),Vo=d("The Optimization API"),Ve=i(),F=a("h3"),Y=a("a"),he=a("span"),g(_t.$$.fragment),Ho=i(),ue=a("span"),Jo=d("Main classes and functions"),He=i(),j=a("div"),g(vt.$$.fragment),Uo=i(),ge=a("p"),Ko=d("A torch.fx graph transformation."),Qo=i(),$t=a("p"),Xo=d("It  must implemement the "),Wt=a("a"),Yo=d("transform()"),Zo=d(` method, and be used as a
callable.`),ta=i(),Vt=a("div"),g(bt.$$.fragment),ea=i(),Z=a("div"),g(yt.$$.fragment),oa=i(),_e=a("p"),aa=d("Marks a node as transformed by this transformation."),sa=i(),Ht=a("div"),g(xt.$$.fragment),ra=i(),tt=a("div"),g(wt.$$.fragment),na=i(),ve=a("p"),ia=d("Specifies whether this transformation transformed node or not."),Je=i(),k=a("div"),g(Tt.$$.fragment),ma=i(),$e=a("p"),la=d("A torch.fx graph transformation that is reversible."),pa=i(),G=a("p"),fa=d("It must implemement the "),Jt=a("a"),da=d("transform()"),ca=d(` and
`),Ut=a("a"),ha=d("reverse()"),ua=d(" methods, and be used as a callable."),ga=i(),Kt=a("div"),g(jt.$$.fragment),_a=i(),et=a("div"),g(kt.$$.fragment),va=i(),be=a("p"),$a=d("Marks a node as restored back to its original state."),ba=i(),Qt=a("div"),g(zt.$$.fragment),Ue=i(),P=a("div"),g(Et.$$.fragment),ya=i(),ye=a("p"),xa=d("Composes a list of transformations together."),wa=i(),g(ot.$$.fragment),Ke=i(),O=a("h3"),at=a("a"),xe=a("span"),g(Mt.$$.fragment),Ta=i(),we=a("span"),ja=d("Transformations"),Qe=i(),I=a("div"),g(At.$$.fragment),ka=i(),Te=a("p"),za=d("Transformation that merges linear layers that take the same input into one big linear layer."),Ea=i(),g(st.$$.fragment),Xe=i(),q=a("div"),g(Dt.$$.fragment),Ma=i(),je=a("p"),Aa=d(`Transformation that changes truediv nodes to multiplication by the inverse nodes when the denominator is static.
For example, that is sometimes the case for the scaling factor in attention layers.`),Da=i(),g(rt.$$.fragment),this.h()},l(t){const n=Ds('[data-svelte="svelte-1phssyn"]',document.head);u=s(n,"META",{name:!0,content:!0}),n.forEach(o),z=m(t),x=s(t,"H1",{class:!0});var Pt=r(x);h=s(Pt,"A",{id:!0,class:!0,href:!0});var ke=r(h);T=s(ke,"SPAN",{});var ze=r(T);_(l.$$.fragment,ze),ze.forEach(o),ke.forEach(o),w=m(Pt),oe=s(Pt,"SPAN",{});var qa=r(oe);co=c(qa,"Optimization"),qa.forEach(o),Pt.forEach(o),Ee=m(t),V=s(t,"P",{});var Ze=r(V);ho=c(Ze,"The "),ae=s(Ze,"CODE",{});var Ba=r(ae);uo=c(Ba,"optimum.fx.optimization"),Ba.forEach(o),go=c(Ze," module provides a set of torch.fx graph transformations, along with classes and functions to write your own transformations and compose them."),Ze.forEach(o),Me=m(t),L=s(t,"H2",{class:!0});var to=r(L);H=s(to,"A",{id:!0,class:!0,href:!0});var La=r(H);se=s(La,"SPAN",{});var Ca=r(se);_(mt.$$.fragment,Ca),Ca.forEach(o),La.forEach(o),_o=m(to),re=s(to,"SPAN",{});var Na=r(re);vo=c(Na,"The transformation guide"),Na.forEach(o),to.forEach(o),Ae=m(t),qt=s(t,"P",{});var Sa=r(qt);$o=c(Sa,"In \u{1F917} Optimum, there are two kinds of transformations: reversible and non-reversible transformations."),Sa.forEach(o),De=m(t),C=s(t,"H3",{class:!0});var eo=r(C);J=s(eo,"A",{id:!0,class:!0,href:!0});var Ra=r(J);ne=s(Ra,"SPAN",{});var Fa=r(ne);_(lt.$$.fragment,Fa),Fa.forEach(o),Ra.forEach(o),bo=m(eo),ie=s(eo,"SPAN",{});var Ga=r(ie);yo=c(Ga,"Write a non-reversible transformation"),Ga.forEach(o),eo.forEach(o),Pe=m(t),B=s(t,"P",{});var Xt=r(B);xo=c(Xt,"The most basic case of transformations is non-reversible transformations. Those transformations cannot be reversed, meaning that after applying them to a graph module, there is no way to get the original model back. To implement such transformations in \u{1F917} Optimum, it is very easy: you just need to subclass "),Bt=s(Xt,"A",{href:!0});var Oa=r(Bt);wo=c(Oa,"Transformation"),Oa.forEach(o),To=c(Xt," and implement the "),Lt=s(Xt,"A",{href:!0});var Wa=r(Lt);jo=c(Wa,"transform()"),Wa.forEach(o),ko=c(Xt," method."),Xt.forEach(o),Ie=m(t),Ct=s(t,"P",{});var Va=r(Ct);zo=c(Va,"For instance, the following transformation changes all the multiplications to additions:"),Va.forEach(o),qe=m(t),_(pt.$$.fragment,t),Be=m(t),Nt=s(t,"P",{});var Ha=r(Nt);Eo=c(Ha,"After implementing it, your transformation can be used as a regular function:"),Ha.forEach(o),Le=m(t),_(ft.$$.fragment,t),Ce=m(t),N=s(t,"H3",{class:!0});var oo=r(N);U=s(oo,"A",{id:!0,class:!0,href:!0});var Ja=r(U);me=s(Ja,"SPAN",{});var Ua=r(me);_(dt.$$.fragment,Ua),Ua.forEach(o),Ja.forEach(o),Mo=m(oo),le=s(oo,"SPAN",{});var Ka=r(le);Ao=c(Ka,"Write a reversible transformation"),Ka.forEach(o),oo.forEach(o),Ne=m(t),M=s(t,"P",{});var nt=r(M);Do=c(nt,"A reversible transformation implements both the transformation and its reverse, allowing to retrieve the original model from the transformed one. To implement such transformation, you need to subclass "),St=s(nt,"A",{href:!0});var Qa=r(St);Po=c(Qa,"ReversibleTransformation"),Qa.forEach(o),Io=c(nt," and implement the "),Rt=s(nt,"A",{href:!0});var Xa=r(Rt);qo=c(Xa,"transform()"),Xa.forEach(o),Bo=c(nt," and "),Ft=s(nt,"A",{href:!0});var Ya=r(Ft);Lo=c(Ya,"reverse()"),Ya.forEach(o),Co=c(nt," methods."),nt.forEach(o),Se=m(t),Gt=s(t,"P",{});var Za=r(Gt);No=c(Za,"For instance, the following transformation is reversible:"),Za.forEach(o),Re=m(t),_(ct.$$.fragment,t),Fe=m(t),S=s(t,"H3",{class:!0});var ao=r(S);K=s(ao,"A",{id:!0,class:!0,href:!0});var ts=r(K);pe=s(ts,"SPAN",{});var es=r(pe);_(ht.$$.fragment,es),es.forEach(o),ts.forEach(o),So=m(ao),fe=s(ao,"SPAN",{});var os=r(fe);Ro=c(os,"Composing transformations together"),os.forEach(o),ao.forEach(o),Ge=m(t),Q=s(t,"P",{});var so=r(Q);Fo=c(so,"As applying mutilple transformations in chain is needed more often that not, "),Ot=s(so,"A",{href:!0});var as=r(Ot);Go=c(as,"compose()"),as.forEach(o),Oo=c(so," is provided. It is an utility function that allows you to create a transformation by chaining multiple other transformations."),so.forEach(o),Oe=m(t),_(ut.$$.fragment,t),We=m(t),R=s(t,"H2",{class:!0});var ro=r(R);X=s(ro,"A",{id:!0,class:!0,href:!0});var ss=r(X);de=s(ss,"SPAN",{});var rs=r(de);_(gt.$$.fragment,rs),rs.forEach(o),ss.forEach(o),Wo=m(ro),ce=s(ro,"SPAN",{});var ns=r(ce);Vo=c(ns,"The Optimization API"),ns.forEach(o),ro.forEach(o),Ve=m(t),F=s(t,"H3",{class:!0});var no=r(F);Y=s(no,"A",{id:!0,class:!0,href:!0});var is=r(Y);he=s(is,"SPAN",{});var ms=r(he);_(_t.$$.fragment,ms),ms.forEach(o),is.forEach(o),Ho=m(no),ue=s(no,"SPAN",{});var ls=r(ue);Jo=c(ls,"Main classes and functions"),ls.forEach(o),no.forEach(o),He=m(t),j=s(t,"DIV",{class:!0});var E=r(j);_(vt.$$.fragment,E),Uo=m(E),ge=s(E,"P",{});var ps=r(ge);Ko=c(ps,"A torch.fx graph transformation."),ps.forEach(o),Qo=m(E),$t=s(E,"P",{});var io=r($t);Xo=c(io,"It  must implemement the "),Wt=s(io,"A",{href:!0});var fs=r(Wt);Yo=c(fs,"transform()"),fs.forEach(o),Zo=c(io,` method, and be used as a
callable.`),io.forEach(o),ta=m(E),Vt=s(E,"DIV",{class:!0});var ds=r(Vt);_(bt.$$.fragment,ds),ds.forEach(o),ea=m(E),Z=s(E,"DIV",{class:!0});var mo=r(Z);_(yt.$$.fragment,mo),oa=m(mo),_e=s(mo,"P",{});var cs=r(_e);aa=c(cs,"Marks a node as transformed by this transformation."),cs.forEach(o),mo.forEach(o),sa=m(E),Ht=s(E,"DIV",{class:!0});var hs=r(Ht);_(xt.$$.fragment,hs),hs.forEach(o),ra=m(E),tt=s(E,"DIV",{class:!0});var lo=r(tt);_(wt.$$.fragment,lo),na=m(lo),ve=s(lo,"P",{});var us=r(ve);ia=c(us,"Specifies whether this transformation transformed node or not."),us.forEach(o),lo.forEach(o),E.forEach(o),Je=m(t),k=s(t,"DIV",{class:!0});var A=r(k);_(Tt.$$.fragment,A),ma=m(A),$e=s(A,"P",{});var gs=r($e);la=c(gs,"A torch.fx graph transformation that is reversible."),gs.forEach(o),pa=m(A),G=s(A,"P",{});var Yt=r(G);fa=c(Yt,"It must implemement the "),Jt=s(Yt,"A",{href:!0});var _s=r(Jt);da=c(_s,"transform()"),_s.forEach(o),ca=c(Yt,` and
`),Ut=s(Yt,"A",{href:!0});var vs=r(Ut);ha=c(vs,"reverse()"),vs.forEach(o),ua=c(Yt," methods, and be used as a callable."),Yt.forEach(o),ga=m(A),Kt=s(A,"DIV",{class:!0});var $s=r(Kt);_(jt.$$.fragment,$s),$s.forEach(o),_a=m(A),et=s(A,"DIV",{class:!0});var po=r(et);_(kt.$$.fragment,po),va=m(po),be=s(po,"P",{});var bs=r(be);$a=c(bs,"Marks a node as restored back to its original state."),bs.forEach(o),po.forEach(o),ba=m(A),Qt=s(A,"DIV",{class:!0});var ys=r(Qt);_(zt.$$.fragment,ys),ys.forEach(o),A.forEach(o),Ue=m(t),P=s(t,"DIV",{class:!0});var Zt=r(P);_(Et.$$.fragment,Zt),ya=m(Zt),ye=s(Zt,"P",{});var xs=r(ye);xa=c(xs,"Composes a list of transformations together."),xs.forEach(o),wa=m(Zt),_(ot.$$.fragment,Zt),Zt.forEach(o),Ke=m(t),O=s(t,"H3",{class:!0});var fo=r(O);at=s(fo,"A",{id:!0,class:!0,href:!0});var ws=r(at);xe=s(ws,"SPAN",{});var Ts=r(xe);_(Mt.$$.fragment,Ts),Ts.forEach(o),ws.forEach(o),Ta=m(fo),we=s(fo,"SPAN",{});var js=r(we);ja=c(js,"Transformations"),js.forEach(o),fo.forEach(o),Qe=m(t),I=s(t,"DIV",{class:!0});var te=r(I);_(At.$$.fragment,te),ka=m(te),Te=s(te,"P",{});var ks=r(Te);za=c(ks,"Transformation that merges linear layers that take the same input into one big linear layer."),ks.forEach(o),Ea=m(te),_(st.$$.fragment,te),te.forEach(o),Xe=m(t),q=s(t,"DIV",{class:!0});var ee=r(q);_(Dt.$$.fragment,ee),Ma=m(ee),je=s(ee,"P",{});var zs=r(je);Aa=c(zs,`Transformation that changes truediv nodes to multiplication by the inverse nodes when the denominator is static.
For example, that is sometimes the case for the scaling factor in attention layers.`),zs.forEach(o),Da=m(ee),_(rt.$$.fragment,ee),ee.forEach(o),this.h()},h(){p(u,"name","hf:doc:metadata"),p(u,"content",JSON.stringify(Cs)),p(h,"id","optimization"),p(h,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),p(h,"href","#optimization"),p(x,"class","relative group"),p(H,"id","the-transformation-guide"),p(H,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),p(H,"href","#the-transformation-guide"),p(L,"class","relative group"),p(J,"id","write-a-nonreversible-transformation"),p(J,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),p(J,"href","#write-a-nonreversible-transformation"),p(C,"class","relative group"),p(Bt,"href","/docs/optimum/pr_267/en/fx/optimization#optimum.fx.optimization.Transformation"),p(Lt,"href","/docs/optimum/pr_267/en/fx/optimization#optimum.fx.optimization.Transformation.transform"),p(U,"id","write-a-reversible-transformation"),p(U,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),p(U,"href","#write-a-reversible-transformation"),p(N,"class","relative group"),p(St,"href","/docs/optimum/pr_267/en/fx/optimization#optimum.fx.optimization.ReversibleTransformation"),p(Rt,"href","/docs/optimum/pr_267/en/fx/optimization#optimum.fx.optimization.Transformation.transform"),p(Ft,"href","/docs/optimum/pr_267/en/fx/optimization#optimum.fx.optimization.ReversibleTransformation.reverse"),p(K,"id","composing-transformations-together"),p(K,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),p(K,"href","#composing-transformations-together"),p(S,"class","relative group"),p(Ot,"href","/docs/optimum/pr_267/en/fx/optimization#optimum.fx.optimization.compose"),p(X,"id","the-optimization-api"),p(X,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),p(X,"href","#the-optimization-api"),p(R,"class","relative group"),p(Y,"id","optimum.fx.optimization.Transformation"),p(Y,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),p(Y,"href","#optimum.fx.optimization.Transformation"),p(F,"class","relative group"),p(Wt,"href","/docs/optimum/pr_267/en/fx/optimization#optimum.fx.optimization.Transformation.transform"),p(Vt,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),p(Z,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),p(Ht,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),p(tt,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),p(j,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),p(Jt,"href","/docs/optimum/pr_267/en/fx/optimization#optimum.fx.optimization.Transformation.transform"),p(Ut,"href","/docs/optimum/pr_267/en/fx/optimization#optimum.fx.optimization.ReversibleTransformation.reverse"),p(Kt,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),p(et,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),p(Qt,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),p(k,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),p(P,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),p(at,"id","optimum.fx.optimization.MergeLinears"),p(at,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),p(at,"href","#optimum.fx.optimization.MergeLinears"),p(O,"class","relative group"),p(I,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),p(q,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8")},m(t,n){e(document.head,u),f(t,z,n),f(t,x,n),e(x,h),e(h,T),v(l,T,null),e(x,w),e(x,oe),e(oe,co),f(t,Ee,n),f(t,V,n),e(V,ho),e(V,ae),e(ae,uo),e(V,go),f(t,Me,n),f(t,L,n),e(L,H),e(H,se),v(mt,se,null),e(L,_o),e(L,re),e(re,vo),f(t,Ae,n),f(t,qt,n),e(qt,$o),f(t,De,n),f(t,C,n),e(C,J),e(J,ne),v(lt,ne,null),e(C,bo),e(C,ie),e(ie,yo),f(t,Pe,n),f(t,B,n),e(B,xo),e(B,Bt),e(Bt,wo),e(B,To),e(B,Lt),e(Lt,jo),e(B,ko),f(t,Ie,n),f(t,Ct,n),e(Ct,zo),f(t,qe,n),v(pt,t,n),f(t,Be,n),f(t,Nt,n),e(Nt,Eo),f(t,Le,n),v(ft,t,n),f(t,Ce,n),f(t,N,n),e(N,U),e(U,me),v(dt,me,null),e(N,Mo),e(N,le),e(le,Ao),f(t,Ne,n),f(t,M,n),e(M,Do),e(M,St),e(St,Po),e(M,Io),e(M,Rt),e(Rt,qo),e(M,Bo),e(M,Ft),e(Ft,Lo),e(M,Co),f(t,Se,n),f(t,Gt,n),e(Gt,No),f(t,Re,n),v(ct,t,n),f(t,Fe,n),f(t,S,n),e(S,K),e(K,pe),v(ht,pe,null),e(S,So),e(S,fe),e(fe,Ro),f(t,Ge,n),f(t,Q,n),e(Q,Fo),e(Q,Ot),e(Ot,Go),e(Q,Oo),f(t,Oe,n),v(ut,t,n),f(t,We,n),f(t,R,n),e(R,X),e(X,de),v(gt,de,null),e(R,Wo),e(R,ce),e(ce,Vo),f(t,Ve,n),f(t,F,n),e(F,Y),e(Y,he),v(_t,he,null),e(F,Ho),e(F,ue),e(ue,Jo),f(t,He,n),f(t,j,n),v(vt,j,null),e(j,Uo),e(j,ge),e(ge,Ko),e(j,Qo),e(j,$t),e($t,Xo),e($t,Wt),e(Wt,Yo),e($t,Zo),e(j,ta),e(j,Vt),v(bt,Vt,null),e(j,ea),e(j,Z),v(yt,Z,null),e(Z,oa),e(Z,_e),e(_e,aa),e(j,sa),e(j,Ht),v(xt,Ht,null),e(j,ra),e(j,tt),v(wt,tt,null),e(tt,na),e(tt,ve),e(ve,ia),f(t,Je,n),f(t,k,n),v(Tt,k,null),e(k,ma),e(k,$e),e($e,la),e(k,pa),e(k,G),e(G,fa),e(G,Jt),e(Jt,da),e(G,ca),e(G,Ut),e(Ut,ha),e(G,ua),e(k,ga),e(k,Kt),v(jt,Kt,null),e(k,_a),e(k,et),v(kt,et,null),e(et,va),e(et,be),e(be,$a),e(k,ba),e(k,Qt),v(zt,Qt,null),f(t,Ue,n),f(t,P,n),v(Et,P,null),e(P,ya),e(P,ye),e(ye,xa),e(P,wa),v(ot,P,null),f(t,Ke,n),f(t,O,n),e(O,at),e(at,xe),v(Mt,xe,null),e(O,Ta),e(O,we),e(we,ja),f(t,Qe,n),f(t,I,n),v(At,I,null),e(I,ka),e(I,Te),e(Te,za),e(I,Ea),v(st,I,null),f(t,Xe,n),f(t,q,n),v(Dt,q,null),e(q,Ma),e(q,je),e(je,Aa),e(q,Da),v(rt,q,null),Ye=!0},p(t,[n]){const Pt={};n&2&&(Pt.$$scope={dirty:n,ctx:t}),ot.$set(Pt);const ke={};n&2&&(ke.$$scope={dirty:n,ctx:t}),st.$set(ke);const ze={};n&2&&(ze.$$scope={dirty:n,ctx:t}),rt.$set(ze)},i(t){Ye||($(l.$$.fragment,t),$(mt.$$.fragment,t),$(lt.$$.fragment,t),$(pt.$$.fragment,t),$(ft.$$.fragment,t),$(dt.$$.fragment,t),$(ct.$$.fragment,t),$(ht.$$.fragment,t),$(ut.$$.fragment,t),$(gt.$$.fragment,t),$(_t.$$.fragment,t),$(vt.$$.fragment,t),$(bt.$$.fragment,t),$(yt.$$.fragment,t),$(xt.$$.fragment,t),$(wt.$$.fragment,t),$(Tt.$$.fragment,t),$(jt.$$.fragment,t),$(kt.$$.fragment,t),$(zt.$$.fragment,t),$(Et.$$.fragment,t),$(ot.$$.fragment,t),$(Mt.$$.fragment,t),$(At.$$.fragment,t),$(st.$$.fragment,t),$(Dt.$$.fragment,t),$(rt.$$.fragment,t),Ye=!0)},o(t){b(l.$$.fragment,t),b(mt.$$.fragment,t),b(lt.$$.fragment,t),b(pt.$$.fragment,t),b(ft.$$.fragment,t),b(dt.$$.fragment,t),b(ct.$$.fragment,t),b(ht.$$.fragment,t),b(ut.$$.fragment,t),b(gt.$$.fragment,t),b(_t.$$.fragment,t),b(vt.$$.fragment,t),b(bt.$$.fragment,t),b(yt.$$.fragment,t),b(xt.$$.fragment,t),b(wt.$$.fragment,t),b(Tt.$$.fragment,t),b(jt.$$.fragment,t),b(kt.$$.fragment,t),b(zt.$$.fragment,t),b(Et.$$.fragment,t),b(ot.$$.fragment,t),b(Mt.$$.fragment,t),b(At.$$.fragment,t),b(st.$$.fragment,t),b(Dt.$$.fragment,t),b(rt.$$.fragment,t),Ye=!1},d(t){o(u),t&&o(z),t&&o(x),y(l),t&&o(Ee),t&&o(V),t&&o(Me),t&&o(L),y(mt),t&&o(Ae),t&&o(qt),t&&o(De),t&&o(C),y(lt),t&&o(Pe),t&&o(B),t&&o(Ie),t&&o(Ct),t&&o(qe),y(pt,t),t&&o(Be),t&&o(Nt),t&&o(Le),y(ft,t),t&&o(Ce),t&&o(N),y(dt),t&&o(Ne),t&&o(M),t&&o(Se),t&&o(Gt),t&&o(Re),y(ct,t),t&&o(Fe),t&&o(S),y(ht),t&&o(Ge),t&&o(Q),t&&o(Oe),y(ut,t),t&&o(We),t&&o(R),y(gt),t&&o(Ve),t&&o(F),y(_t),t&&o(He),t&&o(j),y(vt),y(bt),y(yt),y(xt),y(wt),t&&o(Je),t&&o(k),y(Tt),y(jt),y(kt),y(zt),t&&o(Ue),t&&o(P),y(Et),y(ot),t&&o(Ke),t&&o(O),y(Mt),t&&o(Qe),t&&o(I),y(At),y(st),t&&o(Xe),t&&o(q),y(Dt),y(rt)}}}const Cs={local:"optimization",sections:[{local:"the-transformation-guide",sections:[{local:"write-a-nonreversible-transformation",title:"Write a non-reversible transformation"},{local:"write-a-reversible-transformation",title:"Write a reversible transformation"},{local:"composing-transformations-together",title:"Composing transformations together"}],title:"The transformation guide"},{local:"the-optimization-api",sections:[{local:"optimum.fx.optimization.Transformation",title:"Main classes and functions"},{local:"optimum.fx.optimization.MergeLinears",title:"Transformations"}],title:"The Optimization API"}],title:"Optimization"};function Ns(W){return Ps(()=>{new URLSearchParams(window.location.search).get("fw")}),[]}class Ws extends Es{constructor(u){super();Ms(this,u,Ns,Ls,As,{})}}export{Ws as default,Cs as metadata};
