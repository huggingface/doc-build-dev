import{S as f0,i as g0,s as u0,e as o,k as c,w as f,t as a,M as h0,c as n,d as t,m as l,a as s,x as g,h as i,b as d,G as r,g as m,y as u,q as h,o as _,B as b,v as _0,L as b0}from"../../chunks/vendor-hf-doc-builder.js";import{D as v}from"../../chunks/Docstring-hf-doc-builder.js";import{C as YT}from"../../chunks/CodeBlock-hf-doc-builder.js";import{I as Ie}from"../../chunks/IconCopyLink-hf-doc-builder.js";import{E as v0}from"../../chunks/ExampleCodeBlock-hf-doc-builder.js";function T0(bd){let w,He;return w=new YT({props:{code:`completed = False
while not completed:
    _, completed = constraint.update(constraint.advance())`,highlighted:`completed = <span class="hljs-literal">False</span>
<span class="hljs-keyword">while</span> <span class="hljs-keyword">not</span> completed:
    _, completed = constraint.update(constraint.advance())`}}),{c(){f(w.$$.fragment)},l(k){g(w.$$.fragment,k)},m(k,Ce){u(w,k,Ce),He=!0},p:b0,i(k){He||(h(w.$$.fragment,k),He=!0)},o(k){_(w.$$.fragment,k),He=!1},d(k){b(w,k)}}}function $0(bd){let w,He,k,Ce,cc,st,Rm,lc,Km,vd,y,Um,Rn,Ym,Xm,Kn,Jm,Qm,Un,Zm,ef,Yn,rf,tf,Xn,of,nf,Jn,sf,af,Qn,cf,lf,Td,Zn,df,$d,Re,_r,dc,at,pf,pc,mf,yd,V,ff,es,gf,uf,rs,hf,_f,ts,bf,vf,kd,os,Tf,xd,it,wd,We,$f,mc,yf,kf,ns,xf,wf,Ld,M,ss,fc,Lf,Ef,Pf,as,gc,Ff,Df,zf,is,uc,Sf,Of,qf,cs,hc,Bf,If,Ed,x,Cf,_c,Wf,Af,bc,Nf,Vf,vc,Mf,Gf,Tc,jf,Hf,$c,Rf,Kf,yc,Uf,Yf,Pd,z,Xf,kc,Jf,Qf,xc,Zf,eg,wc,rg,tg,Lc,og,ng,Fd,S,sg,Ec,ag,ig,Pc,cg,lg,Fc,dg,pg,Dc,mg,fg,Dd,ct,zd,br,gg,zc,ug,hg,Sd,O,_g,Sc,bg,vg,Oc,Tg,$g,qc,yg,kg,Bc,xg,wg,Od,ls,Lg,qd,Ke,vr,Ic,lt,Eg,Cc,Pg,Bd,Ue,dt,Fg,Wc,Dg,Id,Ye,pt,zg,Ac,Sg,Cd,R,mt,Og,Nc,qg,Bg,Tr,ft,Ig,Vc,Cg,Wd,Xe,$r,Mc,gt,Wg,Gc,Ag,Ad,Je,ut,Ng,jc,Vg,Nd,Qe,ht,Mg,Hc,Gg,Vd,K,_t,jg,Rc,Hg,Rg,yr,bt,Kg,Kc,Ug,Md,Ze,kr,Uc,vt,Yg,Yc,Xg,Gd,er,Tt,Jg,Xc,Qg,jd,rr,$t,Zg,Jc,eu,Hd,tr,xr,Qc,yt,ru,Zc,tu,Rd,or,kt,ou,el,nu,Kd,nr,xt,su,rl,au,Ud,sr,wr,tl,wt,iu,ol,cu,Yd,Lr,lu,ds,du,pu,Xd,U,Lt,mu,nl,fu,gu,Er,Et,uu,sl,hu,Jd,Y,Pt,_u,L,bu,ps,vu,Tu,ms,$u,yu,al,ku,xu,il,cl,wu,Lu,fs,Eu,Pu,gs,Fu,Du,zu,us,Ft,Qd,X,Dt,Su,ll,Ou,qu,Pr,zt,Bu,dl,Iu,Zd,J,St,Cu,hs,_s,Wu,Au,Nu,bs,Ot,ep,Q,qt,Vu,vs,Ts,Mu,Gu,ju,$s,Bt,rp,Z,It,Hu,ys,ks,Ru,Ku,Uu,xs,Ct,tp,ee,Wt,Yu,ws,Ls,Xu,Ju,Qu,Es,At,op,re,Nt,Zu,Ps,Fs,eh,rh,th,Ds,Vt,np,ar,Mt,oh,zs,Gt,sp,te,jt,nh,Fr,Ss,sh,ah,Ht,ih,ch,lh,Os,Rt,ap,oe,Kt,dh,qs,Bs,ph,mh,fh,Is,Ut,ip,ne,Yt,gh,Dr,Cs,uh,hh,Xt,_h,bh,vh,Ws,Jt,cp,se,Qt,Th,Ae,As,$h,yh,Ns,kh,xh,Zt,wh,Lh,Eh,Vs,eo,lp,ae,ro,Ph,Ms,Gs,Fh,Dh,zh,js,to,dp,ie,oo,Sh,zr,Hs,Oh,qh,pl,Bh,Ih,Ch,Rs,no,pp,ce,so,Wh,G,Ks,Ah,Nh,ml,Vh,Mh,fl,Gh,jh,gl,Hh,Rh,Kh,Us,ao,mp,le,io,Uh,ul,Yh,Xh,Sr,co,Jh,hl,Qh,fp,de,lo,Zh,C,e_,Ys,r_,t_,_l,o_,n_,bl,vl,s_,a_,Xs,i_,c_,l_,Js,po,gp,pe,mo,d_,Tl,p_,m_,Or,fo,f_,$l,g_,up,me,go,u_,Qs,Zs,h_,__,b_,ea,uo,hp,fe,ho,v_,ra,ta,T_,$_,y_,oa,_o,_p,ge,bo,k_,na,sa,x_,w_,L_,aa,vo,bp,ue,To,E_,ia,ca,P_,F_,D_,la,$o,vp,he,yo,z_,da,pa,S_,O_,q_,ma,ko,Tp,_e,xo,B_,qr,fa,I_,C_,wo,W_,A_,N_,ga,Lo,$p,be,Eo,V_,ua,ha,M_,G_,j_,_a,Po,yp,ve,Fo,H_,ba,va,R_,K_,U_,Ta,Do,kp,Te,zo,Y_,Br,$a,X_,J_,yl,Q_,Z_,eb,ya,So,xp,$e,Oo,rb,kl,tb,ob,Ir,qo,nb,xl,sb,wp,ye,Bo,ab,E,ib,ka,cb,lb,xa,db,pb,wl,mb,fb,Ll,El,gb,ub,wa,hb,_b,La,bb,vb,Tb,Ea,Io,Lp,ke,Co,$b,Pl,yb,kb,Cr,Wo,xb,Fl,wb,Ep,xe,Ao,Lb,Pa,Fa,Eb,Pb,Fb,Da,No,Pp,we,Vo,Db,za,Sa,zb,Sb,Ob,Oa,Mo,Fp,Le,Go,qb,qa,Ba,Bb,Ib,Cb,Ia,jo,Dp,Ee,Ho,Wb,Ca,Wa,Ab,Nb,Vb,Aa,Ro,zp,Pe,Ko,Mb,Wr,Na,Gb,jb,Dl,Hb,Rb,Kb,Va,Uo,Sp,Fe,Yo,Ub,Ma,Ga,Yb,Xb,Jb,ja,Xo,Op,ir,Ar,zl,Jo,Qb,Sl,Zb,qp,Nr,ev,Ha,rv,tv,Bp,De,Qo,ov,Ol,nv,sv,Ra,Zo,Ip,cr,en,av,Ka,rn,Cp,ze,tn,iv,on,cv,ql,lv,dv,pv,Ua,nn,Wp,Se,sn,mv,an,fv,Bl,gv,uv,hv,Ya,cn,Ap,lr,Vr,Il,ln,_v,Cl,bv,Np,Mr,vv,Xa,Tv,$v,Vp,T,dn,yv,Wl,kv,xv,Al,wv,Lv,Gr,Ev,Nl,Pv,Fv,jr,pn,Dv,Vl,zv,Sv,Hr,mn,Ov,Ml,qv,Bv,Rr,fn,Iv,Gl,Cv,Wv,Kr,gn,Av,un,Nv,jl,Vv,Mv,Gv,Ur,hn,jv,Hl,Hv,Rv,Yr,_n,Kv,Rl,Uv,Yv,Ne,bn,Xv,vn,Jv,Kl,Qv,Zv,e1,Ul,r1,Mp,dr,Tn,t1,Ja,Qa,o1,n1,Gp,pr,$n,s1,yn,a1,Za,i1,c1,jp,W,kn,l1,Yl,d1,p1,F,xn,m1,Xl,f1,g1,mr,u1,Jl,h1,_1,Ql,b1,v1,T1,Zl,ed,$1,y1,Oe,k1,rd,x1,w1,td,L1,E1,od,P1,F1,D1,nd,z1,S1,Xr,wn,O1,sd,q1,Hp,fr,Jr,ad,Ln,B1,id,I1,Rp,A,En,C1,gr,W1,ei,A1,N1,ri,V1,M1,G1,ti,Pn,j1,oi,Fn,Kp,P,Dn,H1,ni,si,R1,K1,U1,zn,Y1,Sn,X1,J1,Q1,ai,Z1,On,eT,rT,ii,qn,tT,ci,Bn,Up,N,In,oT,li,di,nT,sT,aT,pi,Cn,iT,mi,Wn,Yp,ur,Qr,cd,An,cT,ld,lT,Xp,qe,Nn,dT,dd,pT,mT,fi,fT,Vn,gT,Jp,Be,Mn,uT,pd,hT,_T,gi,bT,Gn,vT,Qp;return st=new Ie({}),at=new Ie({}),it=new YT({props:{code:`from transformers import GPT2Tokenizer, GPT2LMHeadModel

tokenizer = GPT2Tokenizer.from_pretrained("gpt2")
model = GPT2LMHeadModel.from_pretrained("gpt2")

inputs = tokenizer("Hello, my dog is cute and ", return_tensors="pt")
generation_output = model.generate(**inputs, return_dict_in_generate=True, output_scores=True)`,highlighted:`<span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> GPT2Tokenizer, GPT2LMHeadModel

tokenizer = GPT2Tokenizer.from_pretrained(<span class="hljs-string">&quot;gpt2&quot;</span>)
model = GPT2LMHeadModel.from_pretrained(<span class="hljs-string">&quot;gpt2&quot;</span>)

inputs = tokenizer(<span class="hljs-string">&quot;Hello, my dog is cute and &quot;</span>, return_tensors=<span class="hljs-string">&quot;pt&quot;</span>)
generation_output = model.generate(**inputs, return_dict_in_generate=<span class="hljs-literal">True</span>, output_scores=<span class="hljs-literal">True</span>)`}}),ct=new YT({props:{code:"generation_output[:2]",highlighted:'generation_output[:<span class="hljs-number">2</span>]'}}),lt=new Ie({}),dt=new v({props:{name:"class transformers.generation_utils.GreedySearchDecoderOnlyOutput",anchor:"transformers.generation_utils.GreedySearchDecoderOnlyOutput",parameters:[{name:"sequences",val:": LongTensor = None"},{name:"scores",val:": typing.Optional[typing.Tuple[torch.FloatTensor]] = None"},{name:"attentions",val:": typing.Optional[typing.Tuple[typing.Tuple[torch.FloatTensor]]] = None"},{name:"hidden_states",val:": typing.Optional[typing.Tuple[typing.Tuple[torch.FloatTensor]]] = None"},{name:"past_key_values",val:": typing.Optional[typing.Tuple[typing.Tuple[typing.Tuple[torch.Tensor]]]] = None"}],parametersDescription:[{anchor:"transformers.generation_utils.GreedySearchDecoderOnlyOutput.sequences",description:`<strong>sequences</strong> (<code>torch.LongTensor</code> of shape <code>(batch_size, sequence_length)</code>) &#x2014;
The generated sequences. The second dimension (sequence_length) is either equal to <code>max_length</code> or shorter
if all batches finished early due to the <code>eos_token_id</code>.`,name:"sequences"},{anchor:"transformers.generation_utils.GreedySearchDecoderOnlyOutput.scores",description:`<strong>scores</strong> (<code>tuple(torch.FloatTensor)</code> <em>optional</em>, returned when <code>output_scores=True</code> is passed or when <code>config.output_scores=True</code>) &#x2014;
Processed prediction scores of the language modeling head (scores for each vocabulary token before SoftMax)
at each generation step. <code>(max_length-input_ids.shape[-1],)</code>-shaped tuple of <code>torch.FloatTensor</code> with each
tensor of shape <code>(batch_size, config.vocab_size)</code>).`,name:"scores"},{anchor:"transformers.generation_utils.GreedySearchDecoderOnlyOutput.attentions",description:`<strong>attentions</strong> (<code>tuple(tuple(torch.FloatTensor))</code>, <em>optional</em>, returned when <code>output_attentions=True</code> is passed or <code>config.output_attentions=True</code>) &#x2014;
Tuple (one element for each generated token) of tuples (one element for each layer of the decoder) of
<code>torch.FloatTensor</code> of shape <code>(batch_size, num_heads, generated_length, sequence_length)</code>.`,name:"attentions"},{anchor:"transformers.generation_utils.GreedySearchDecoderOnlyOutput.hidden_states",description:`<strong>hidden_states</strong> (<code>tuple(tuple(torch.FloatTensor))</code>, <em>optional</em>, returned when <code>output_hidden_states=True</code> is passed or when <code>config.output_hidden_states=True</code>) &#x2014;
Tuple (one element for each generated token) of tuples (one element for each layer of the decoder) of
<code>torch.FloatTensor</code> of shape <code>(batch_size, generated_length, hidden_size)</code>.`,name:"hidden_states"},{anchor:"transformers.generation_utils.GreedySearchDecoderOnlyOutput.past_key_values",description:`<strong>past_key_values</strong> (<code>Tuple[Tuple[Tuple[torch.Tensor]]]</code> returned when <code>use_cache=True</code> is passed or when <code>config.use_cache=True</code>) &#x2014;
Tuple (one element for each generated token) of tuples (one element for each layer of the decoder) of
tuples (two elements, key tensor and value tensor). The second Tuple is of length <code>config.n_layers</code>, with
each tuple having 2 tensors of shape <code>(batch_size, num_heads, sequence_length, embed_size_per_head)</code>) and
optionally if <code>config.is_encoder_decoder=True</code> 2 additional tensors of shape <code>(batch_size, num_heads, encoder_sequence_length, embed_size_per_head)</code>.`,name:"past_key_values"}],source:"https://github.com/huggingface/transformers/blob/vr_17574/src/transformers/generation_utils.py#L62"}}),pt=new v({props:{name:"class transformers.generation_utils.GreedySearchEncoderDecoderOutput",anchor:"transformers.generation_utils.GreedySearchEncoderDecoderOutput",parameters:[{name:"sequences",val:": LongTensor = None"},{name:"scores",val:": typing.Optional[typing.Tuple[torch.FloatTensor]] = None"},{name:"encoder_attentions",val:": typing.Optional[typing.Tuple[torch.FloatTensor]] = None"},{name:"encoder_hidden_states",val:": typing.Optional[typing.Tuple[torch.FloatTensor]] = None"},{name:"decoder_attentions",val:": typing.Optional[typing.Tuple[typing.Tuple[torch.FloatTensor]]] = None"},{name:"cross_attentions",val:": typing.Optional[typing.Tuple[typing.Tuple[torch.FloatTensor]]] = None"},{name:"decoder_hidden_states",val:": typing.Optional[typing.Tuple[typing.Tuple[torch.FloatTensor]]] = None"},{name:"past_key_values",val:": typing.Optional[typing.Tuple[typing.Tuple[typing.Tuple[torch.Tensor]]]] = None"}],parametersDescription:[{anchor:"transformers.generation_utils.GreedySearchEncoderDecoderOutput.sequences",description:`<strong>sequences</strong> (<code>torch.LongTensor</code> of shape <code>(batch_size, sequence_length)</code>) &#x2014;
The generated sequences. The second dimension (sequence_length) is either equal to <code>max_length</code> or shorter
if all batches finished early due to the <code>eos_token_id</code>.`,name:"sequences"},{anchor:"transformers.generation_utils.GreedySearchEncoderDecoderOutput.scores",description:`<strong>scores</strong> (<code>tuple(torch.FloatTensor)</code> <em>optional</em>, returned when <code>output_scores=True</code> is passed or when <code>config.output_scores=True</code>) &#x2014;
Processed prediction scores of the language modeling head (scores for each vocabulary token before SoftMax)
at each generation step. <code>(max_length-1,)</code>-shaped tuple of <code>torch.FloatTensor</code> with each tensor of shape
<code>(batch_size, config.vocab_size)</code>).`,name:"scores"},{anchor:"transformers.generation_utils.GreedySearchEncoderDecoderOutput.encoder_attentions",description:`<strong>encoder_attentions</strong> (<code>tuple(torch.FloatTensor)</code>, <em>optional</em>, returned when <code>output_attentions=True</code> is passed or <code>config.output_attentions=True</code>) &#x2014;
Tuple of <code>torch.FloatTensor</code> (one for each layer of the decoder) of shape <code>(batch_size, num_heads, sequence_length, sequence_length)</code>.`,name:"encoder_attentions"},{anchor:"transformers.generation_utils.GreedySearchEncoderDecoderOutput.encoder_hidden_states",description:`<strong>encoder_hidden_states</strong> (<code>tuple(torch.FloatTensor)</code>, <em>optional</em>, returned when <code>output_hidden_states=True</code> is passed or when <code>config.output_hidden_states=True</code>) &#x2014;
Tuple of <code>torch.FloatTensor</code> (one for the output of the embeddings + one for the output of each layer) of
shape <code>(batch_size, sequence_length, hidden_size)</code>.`,name:"encoder_hidden_states"},{anchor:"transformers.generation_utils.GreedySearchEncoderDecoderOutput.decoder_attentions",description:`<strong>decoder_attentions</strong> (<code>tuple(tuple(torch.FloatTensor))</code>, <em>optional</em>, returned when <code>output_attentions=True</code> is passed or <code>config.output_attentions=True</code>) &#x2014;
Tuple (one element for each generated token) of tuples (one element for each layer of the decoder) of
<code>torch.FloatTensor</code> of shape <code>(batch_size, num_heads, generated_length, sequence_length)</code>.`,name:"decoder_attentions"},{anchor:"transformers.generation_utils.GreedySearchEncoderDecoderOutput.cross_attentions",description:`<strong>cross_attentions</strong> (<code>tuple(tuple(torch.FloatTensor))</code>, <em>optional</em>, returned when <code>output_attentions=True</code> is passed or <code>config.output_attentions=True</code>) &#x2014;
Tuple (one element for each generated token) of tuples (one element for each layer of the decoder) of
<code>torch.FloatTensor</code> of shape <code>(batch_size, num_heads, generated_length, sequence_length)</code>.`,name:"cross_attentions"},{anchor:"transformers.generation_utils.GreedySearchEncoderDecoderOutput.decoder_hidden_states",description:`<strong>decoder_hidden_states</strong> (<code>tuple(tuple(torch.FloatTensor))</code>, <em>optional</em>, returned when <code>output_hidden_states=True</code> is passed or when <code>config.output_hidden_states=True</code>) &#x2014;
Tuple (one element for each generated token) of tuples (one element for each layer of the decoder) of
<code>torch.FloatTensor</code> of shape <code>(batch_size, generated_length, hidden_size)</code>.`,name:"decoder_hidden_states"},{anchor:"transformers.generation_utils.GreedySearchEncoderDecoderOutput.past_key_values",description:`<strong>past_key_values</strong> (<code>Tuple[Tuple[Tuple[torch.Tensor]]]</code> returned when <code>use_cache=True</code> is passed or when <code>config.use_cache=True</code>) &#x2014;
Tuple (one element for each generated token) of tuples (one element for each layer of the decoder) of
tuples (two elements, key tensor and value tensor). The second Tuple is of length <code>config.n_layers</code>, with
each tuple having 2 tensors of shape <code>(batch_size, num_heads, sequence_length, embed_size_per_head)</code>) and
optionally if <code>config.is_encoder_decoder=True</code> 2 additional tensors of shape <code>(batch_size, num_heads, encoder_sequence_length, embed_size_per_head)</code>.`,name:"past_key_values"}],source:"https://github.com/huggingface/transformers/blob/vr_17574/src/transformers/generation_utils.py#L97"}}),mt=new v({props:{name:"class transformers.generation_flax_utils.FlaxGreedySearchOutput",anchor:"transformers.generation_flax_utils.FlaxGreedySearchOutput",parameters:[{name:"sequences",val:": ndarray = None"}],parametersDescription:[{anchor:"transformers.generation_flax_utils.FlaxGreedySearchOutput.sequences",description:`<strong>sequences</strong> (<code>jnp.ndarray</code> of shape <code>(batch_size, max_length)</code>) &#x2014;
The generated sequences.`,name:"sequences"}],source:"https://github.com/huggingface/transformers/blob/vr_17574/src/transformers/generation_flax_utils.py#L44"}}),ft=new v({props:{name:"replace",anchor:"transformers.generation_flax_utils.FlaxGreedySearchOutput.replace",parameters:[{name:"**updates",val:""}],source:"https://github.com/huggingface/transformers/blob/vr_17574/src/flax/struct.py#L120"}}),gt=new Ie({}),ut=new v({props:{name:"class transformers.generation_utils.SampleDecoderOnlyOutput",anchor:"transformers.generation_utils.SampleDecoderOnlyOutput",parameters:[{name:"sequences",val:": LongTensor = None"},{name:"scores",val:": typing.Optional[typing.Tuple[torch.FloatTensor]] = None"},{name:"attentions",val:": typing.Optional[typing.Tuple[typing.Tuple[torch.FloatTensor]]] = None"},{name:"hidden_states",val:": typing.Optional[typing.Tuple[typing.Tuple[torch.FloatTensor]]] = None"},{name:"past_key_values",val:": typing.Optional[typing.Tuple[typing.Tuple[typing.Tuple[torch.Tensor]]]] = None"}],parametersDescription:[{anchor:"transformers.generation_utils.SampleDecoderOnlyOutput.sequences",description:`<strong>sequences</strong> (<code>torch.LongTensor</code> of shape <code>(batch_size*num_return_sequences, sequence_length)</code>) &#x2014;
The generated sequences. The second dimension (sequence_length) is either equal to <code>max_length</code> or shorter
if all batches finished early due to the <code>eos_token_id</code>.`,name:"sequences"},{anchor:"transformers.generation_utils.SampleDecoderOnlyOutput.scores",description:`<strong>scores</strong> (<code>tuple(torch.FloatTensor)</code> <em>optional</em>, returned when <code>output_scores=True</code> is passed or when <code>config.output_scores=True</code>) &#x2014;
Processed prediction scores of the language modeling head (scores for each vocabulary token before SoftMax)
at each generation step. <code>(max_length-input_ids.shape[-1],)</code>-shaped tuple of <code>torch.FloatTensor</code> with each
tensor of shape <code>(batch_size*num_return_sequences, config.vocab_size)</code>).`,name:"scores"},{anchor:"transformers.generation_utils.SampleDecoderOnlyOutput.attentions",description:`<strong>attentions</strong> (<code>tuple(tuple(torch.FloatTensor))</code>, <em>optional</em>, returned when <code>output_attentions=True</code> is passed or <code>config.output_attentions=True</code>) &#x2014;
Tuple (one element for each generated token) of tuples (one element for each layer of the decoder) of
<code>torch.FloatTensor</code> of shape <code>(num_return_sequences*batch_size, num_heads, generated_length, sequence_length)</code>.`,name:"attentions"},{anchor:"transformers.generation_utils.SampleDecoderOnlyOutput.hidden_states",description:`<strong>hidden_states</strong> (<code>tuple(tuple(torch.FloatTensor))</code>, <em>optional</em>, returned when <code>output_hidden_states=True</code> is passed or when <code>config.output_hidden_states=True</code>) &#x2014;
Tuple (one element for each generated token) of tuples (one element for each layer of the decoder) of
<code>torch.FloatTensor</code> of shape <code>(num_return_sequences*batch_size, generated_length, hidden_size)</code>.`,name:"hidden_states"},{anchor:"transformers.generation_utils.SampleDecoderOnlyOutput.past_key_values",description:`<strong>past_key_values</strong> (<code>Tuple[Tuple[Tuple[torch.Tensor]]]</code> returned when <code>use_cache=True</code> is passed or when <code>config.use_cache=True</code>) &#x2014;
Tuple (one element for each generated token) of tuples (one element for each layer of the decoder) of
tuples (two elements, key tensor and value tensor). The second Tuple is of length <code>config.n_layers</code>, with
each tuple having 2 tensors of shape <code>(batch_size, num_heads, sequence_length, embed_size_per_head)</code>) and
optionally if <code>config.is_encoder_decoder=True</code> 2 additional tensors of shape <code>(batch_size, num_heads, encoder_sequence_length, embed_size_per_head)</code>.`,name:"past_key_values"}],source:"https://github.com/huggingface/transformers/blob/vr_17574/src/transformers/generation_utils.py#L146"}}),ht=new v({props:{name:"class transformers.generation_utils.SampleEncoderDecoderOutput",anchor:"transformers.generation_utils.SampleEncoderDecoderOutput",parameters:[{name:"sequences",val:": LongTensor = None"},{name:"scores",val:": typing.Optional[typing.Tuple[torch.FloatTensor]] = None"},{name:"encoder_attentions",val:": typing.Optional[typing.Tuple[torch.FloatTensor]] = None"},{name:"encoder_hidden_states",val:": typing.Optional[typing.Tuple[torch.FloatTensor]] = None"},{name:"decoder_attentions",val:": typing.Optional[typing.Tuple[typing.Tuple[torch.FloatTensor]]] = None"},{name:"cross_attentions",val:": typing.Optional[typing.Tuple[typing.Tuple[torch.FloatTensor]]] = None"},{name:"decoder_hidden_states",val:": typing.Optional[typing.Tuple[typing.Tuple[torch.FloatTensor]]] = None"},{name:"past_key_values",val:": typing.Optional[typing.Tuple[typing.Tuple[typing.Tuple[torch.Tensor]]]] = None"}],parametersDescription:[{anchor:"transformers.generation_utils.SampleEncoderDecoderOutput.sequences",description:`<strong>sequences</strong> (<code>torch.LongTensor</code> of shape <code>(batch_size*num_return_sequences, sequence_length)</code>) &#x2014;
The generated sequences. The second dimension (sequence_length) is either equal to <code>max_length</code> or shorter
if all batches finished early due to the <code>eos_token_id</code>.`,name:"sequences"},{anchor:"transformers.generation_utils.SampleEncoderDecoderOutput.scores",description:`<strong>scores</strong> (<code>tuple(torch.FloatTensor)</code> <em>optional</em>, returned when <code>output_scores=True</code> is passed or when <code>config.output_scores=True</code>) &#x2014;
Processed prediction scores of the language modeling head (scores for each vocabulary token before SoftMax)
at each generation step. <code>(max_length-1,)</code>-shaped tuple of <code>torch.FloatTensor</code> with each tensor of shape
<code>(batch_size*num_return_sequences, config.vocab_size)</code>).`,name:"scores"},{anchor:"transformers.generation_utils.SampleEncoderDecoderOutput.encoder_attentions",description:`<strong>encoder_attentions</strong> (<code>tuple(torch.FloatTensor)</code>, <em>optional</em>, returned when <code>output_attentions=True</code> is passed or <code>config.output_attentions=True</code>) &#x2014;
Tuple of <code>torch.FloatTensor</code> (one for each layer of the decoder) of shape
<code>(batch_size*num_return_sequences, num_heads, sequence_length, sequence_length)</code>.`,name:"encoder_attentions"},{anchor:"transformers.generation_utils.SampleEncoderDecoderOutput.encoder_hidden_states",description:`<strong>encoder_hidden_states</strong> (<code>tuple(torch.FloatTensor)</code>, <em>optional</em>, returned when <code>output_hidden_states=True</code> is passed or when <code>config.output_hidden_states=True</code>) &#x2014;
Tuple of <code>torch.FloatTensor</code> (one for the output of the embeddings + one for the output of each layer) of
shape <code>(batch_size*num_return_sequences, sequence_length, hidden_size)</code>.`,name:"encoder_hidden_states"},{anchor:"transformers.generation_utils.SampleEncoderDecoderOutput.decoder_attentions",description:`<strong>decoder_attentions</strong> (<code>tuple(tuple(torch.FloatTensor))</code>, <em>optional</em>, returned when <code>output_attentions=True</code> is passed or <code>config.output_attentions=True</code>) &#x2014;
Tuple (one element for each generated token) of tuples (one element for each layer of the decoder) of
<code>torch.FloatTensor</code> of shape <code>(batch_size*num_return_sequences, num_heads, generated_length, sequence_length)</code>.`,name:"decoder_attentions"},{anchor:"transformers.generation_utils.SampleEncoderDecoderOutput.cross_attentions",description:`<strong>cross_attentions</strong> (<code>tuple(tuple(torch.FloatTensor))</code>, <em>optional</em>, returned when <code>output_attentions=True</code> is passed or <code>config.output_attentions=True</code>) &#x2014;
Tuple (one element for each generated token) of tuples (one element for each layer of the decoder) of
<code>torch.FloatTensor</code> of shape <code>(batch_size, num_heads, generated_length, sequence_length)</code>.`,name:"cross_attentions"},{anchor:"transformers.generation_utils.SampleEncoderDecoderOutput.decoder_hidden_states",description:`<strong>decoder_hidden_states</strong> (<code>tuple(tuple(torch.FloatTensor))</code>, <em>optional</em>, returned when <code>output_hidden_states=True</code> is passed or when <code>config.output_hidden_states=True</code>) &#x2014;
Tuple (one element for each generated token) of tuples (one element for each layer of the decoder) of
<code>torch.FloatTensor</code> of shape <code>(batch_size*num_return_sequences, generated_length, hidden_size)</code>.`,name:"decoder_hidden_states"},{anchor:"transformers.generation_utils.SampleEncoderDecoderOutput.past_key_values",description:`<strong>past_key_values</strong> (<code>Tuple[Tuple[Tuple[torch.Tensor]]]</code> returned when <code>use_cache=True</code> is passed or when <code>config.use_cache=True</code>) &#x2014;
Tuple (one element for each generated token) of tuples (one element for each layer of the decoder) of
tuples (two elements, key tensor and value tensor). The second Tuple is of length <code>config.n_layers</code>, with
each tuple having 2 tensors of shape <code>(batch_size, num_heads, sequence_length, embed_size_per_head)</code>) and
optionally if <code>config.is_encoder_decoder=True</code> 2 additional tensors of shape <code>(batch_size, num_heads, encoder_sequence_length, embed_size_per_head)</code>.`,name:"past_key_values"}],source:"https://github.com/huggingface/transformers/blob/vr_17574/src/transformers/generation_utils.py#L182"}}),_t=new v({props:{name:"class transformers.generation_flax_utils.FlaxSampleOutput",anchor:"transformers.generation_flax_utils.FlaxSampleOutput",parameters:[{name:"sequences",val:": ndarray = None"}],parametersDescription:[{anchor:"transformers.generation_flax_utils.FlaxSampleOutput.sequences",description:`<strong>sequences</strong> (<code>jnp.ndarray</code> of shape <code>(batch_size, max_length)</code>) &#x2014;
The generated sequences.`,name:"sequences"}],source:"https://github.com/huggingface/transformers/blob/vr_17574/src/transformers/generation_flax_utils.py#L58"}}),bt=new v({props:{name:"replace",anchor:"transformers.generation_flax_utils.FlaxSampleOutput.replace",parameters:[{name:"**updates",val:""}],source:"https://github.com/huggingface/transformers/blob/vr_17574/src/flax/struct.py#L120"}}),vt=new Ie({}),Tt=new v({props:{name:"class transformers.generation_utils.BeamSearchDecoderOnlyOutput",anchor:"transformers.generation_utils.BeamSearchDecoderOnlyOutput",parameters:[{name:"sequences",val:": LongTensor = None"},{name:"sequences_scores",val:": typing.Optional[torch.FloatTensor] = None"},{name:"scores",val:": typing.Optional[typing.Tuple[torch.FloatTensor]] = None"},{name:"beam_indices",val:": typing.Optional[torch.LongTensor] = None"},{name:"attentions",val:": typing.Optional[typing.Tuple[typing.Tuple[torch.FloatTensor]]] = None"},{name:"hidden_states",val:": typing.Optional[typing.Tuple[typing.Tuple[torch.FloatTensor]]] = None"},{name:"past_key_values",val:": typing.Optional[typing.Tuple[typing.Tuple[typing.Tuple[torch.Tensor]]]] = None"}],parametersDescription:[{anchor:"transformers.generation_utils.BeamSearchDecoderOnlyOutput.sequences",description:`<strong>sequences</strong> (<code>torch.LongTensor</code> of shape <code>(batch_size*num_return_sequences, sequence_length)</code>) &#x2014;
The generated sequences. The second dimension (sequence_length) is either equal to <code>max_length</code> or shorter
if all batches finished early due to the <code>eos_token_id</code>.`,name:"sequences"},{anchor:"transformers.generation_utils.BeamSearchDecoderOnlyOutput.sequences_scores",description:`<strong>sequences_scores</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size*num_return_sequences)</code>, <em>optional</em>, returned when <code>output_scores=True</code> is passed or when <code>config.output_scores=True</code>) &#x2014;
Final beam scores of the generated <code>sequences</code>.`,name:"sequences_scores"},{anchor:"transformers.generation_utils.BeamSearchDecoderOnlyOutput.scores",description:`<strong>scores</strong> (<code>tuple(torch.FloatTensor)</code> <em>optional</em>, returned when <code>output_scores=True</code> is passed or when <code>config.output_scores=True</code>) &#x2014;
Beam transition scores for each vocabulary token at each generation step. Beam transition scores consisting
of log probabilities of tokens conditioned on log softmax of previously generated tokens in this beam.
<code>(max_length-input_ids.shape[-1],)</code>-shaped tuple of <code>torch.FloatTensor</code> with each tensor of shape
<code>(batch_size*num_beams*num_return_sequences, config.vocab_size)</code>).`,name:"scores"},{anchor:"transformers.generation_utils.BeamSearchDecoderOnlyOutput.beam_indices",description:`<strong>beam_indices</strong> (<code>tuple(tuple(torch.LongTensor))</code>, <em>optional</em>, returned when <code>output_scores=True</code> is passed or when <code>config.output_scores=True</code>) &#x2014;
Beam indices of generated token id at each generation step. <code>torch.LongTensor</code> of shape
<code>(batch_size*num_return_sequences, input_ids.shape[-1])</code>.`,name:"beam_indices"},{anchor:"transformers.generation_utils.BeamSearchDecoderOnlyOutput.attentions",description:`<strong>attentions</strong> (<code>tuple(tuple(torch.FloatTensor))</code>, <em>optional</em>, returned when <code>output_attentions=True</code> is passed or <code>config.output_attentions=True</code>) &#x2014;
Tuple (one element for each generated token) of tuples (one element for each layer of the decoder) of
<code>torch.FloatTensor</code> of shape <code>(batch_size*num_beams, num_heads, generated_length, sequence_length)</code>.`,name:"attentions"},{anchor:"transformers.generation_utils.BeamSearchDecoderOnlyOutput.hidden_states",description:`<strong>hidden_states</strong> (<code>tuple(tuple(torch.FloatTensor))</code>, <em>optional</em>, returned when <code>output_hidden_states=True</code> is passed or when <code>config.output_hidden_states=True</code>) &#x2014;
Tuple (one element for each generated token) of tuples (one element for each layer of the decoder) of
<code>torch.FloatTensor</code> of shape <code>(batch_size*num_beams*num_return_sequences, generated_length, hidden_size)</code>.`,name:"hidden_states"},{anchor:"transformers.generation_utils.BeamSearchDecoderOnlyOutput.past_key_values",description:`<strong>past_key_values</strong> (<code>Tuple[Tuple[Tuple[torch.Tensor]]]</code> returned when <code>use_cache=True</code> is passed or when <code>config.use_cache=True</code>) &#x2014;
Tuple (one element for each generated token) of tuples (one element for each layer of the decoder) of
tuples (two elements, key tensor and value tensor). The second Tuple is of length <code>config.n_layers</code>, with
each tuple having 2 tensors of shape <code>(batch_size, num_heads, sequence_length, embed_size_per_head)</code>) and
optionally if <code>config.is_encoder_decoder=True</code> 2 additional tensors of shape <code>(batch_size, num_heads, encoder_sequence_length, embed_size_per_head)</code>.`,name:"past_key_values"}],source:"https://github.com/huggingface/transformers/blob/vr_17574/src/transformers/generation_utils.py#L232"}}),$t=new v({props:{name:"class transformers.generation_utils.BeamSearchEncoderDecoderOutput",anchor:"transformers.generation_utils.BeamSearchEncoderDecoderOutput",parameters:[{name:"sequences",val:": LongTensor = None"},{name:"sequences_scores",val:": typing.Optional[torch.FloatTensor] = None"},{name:"scores",val:": typing.Optional[typing.Tuple[torch.FloatTensor]] = None"},{name:"beam_indices",val:": typing.Optional[torch.LongTensor] = None"},{name:"encoder_attentions",val:": typing.Optional[typing.Tuple[torch.FloatTensor]] = None"},{name:"encoder_hidden_states",val:": typing.Optional[typing.Tuple[torch.FloatTensor]] = None"},{name:"decoder_attentions",val:": typing.Optional[typing.Tuple[typing.Tuple[torch.FloatTensor]]] = None"},{name:"cross_attentions",val:": typing.Optional[typing.Tuple[typing.Tuple[torch.FloatTensor]]] = None"},{name:"decoder_hidden_states",val:": typing.Optional[typing.Tuple[typing.Tuple[torch.FloatTensor]]] = None"},{name:"past_key_values",val:": typing.Optional[typing.Tuple[typing.Tuple[typing.Tuple[torch.Tensor]]]] = None"}],parametersDescription:[{anchor:"transformers.generation_utils.BeamSearchEncoderDecoderOutput.sequences",description:`<strong>sequences</strong> (<code>torch.LongTensor</code> of shape <code>(batch_size*num_return_sequences, sequence_length)</code>) &#x2014;
The generated sequences. The second dimension (sequence_length) is either equal to <code>max_length</code> or shorter
if all batches finished early due to the <code>eos_token_id</code>.`,name:"sequences"},{anchor:"transformers.generation_utils.BeamSearchEncoderDecoderOutput.sequences_scores",description:`<strong>sequences_scores</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size*num_return_sequences)</code>, <em>optional</em>, returned when <code>output_scores=True</code> is passed or when <code>config.output_scores=True</code>) &#x2014;
Final beam scores of the generated <code>sequences</code>.`,name:"sequences_scores"},{anchor:"transformers.generation_utils.BeamSearchEncoderDecoderOutput.scores",description:`<strong>scores</strong> (<code>tuple(torch.FloatTensor)</code> <em>optional</em>, returned when <code>output_scores=True</code> is passed or when <code>config.output_scores=True</code>) &#x2014;
Beam transition scores for each vocabulary token at each generation step. Beam transition scores consisting
of log probabilities of tokens conditioned on log softmax of previously generated tokens in this beam.
<code>(max_length-1,)</code>-shaped tuple of <code>torch.FloatTensor</code> with each tensor of shape <code>(batch_size*num_beams, config.vocab_size)</code>).`,name:"scores"},{anchor:"transformers.generation_utils.BeamSearchEncoderDecoderOutput.beam_indices",description:`<strong>beam_indices</strong> (<code>tuple(tuple(torch.LongTensor))</code>, <em>optional</em>, returned when <code>output_scores=True</code> is passed or when <code>config.output_scores=True</code>) &#x2014;
Beam indices of generated token id at each generation step. <code>torch.LongTensor</code> of shape
<code>(batch_size*num_return_sequences, max_length-1)</code>.`,name:"beam_indices"},{anchor:"transformers.generation_utils.BeamSearchEncoderDecoderOutput.attentions",description:"<strong>attentions</strong> (<code>tuple(tuple(torch.FloatTensor))</code>, <em>optional</em>, returned when <code>output_attentions=True</code> is passed or <code>config.output_attentions=True</code>) &#x2014;",name:"attentions"},{anchor:"transformers.generation_utils.BeamSearchEncoderDecoderOutput.encoder_attentions",description:`<strong>encoder_attentions</strong> (<code>tuple(torch.FloatTensor)</code>, <em>optional</em>, returned when <code>output_attentions=True</code> is passed or <code>config.output_attentions=True</code>) &#x2014;
Tuple of <code>torch.FloatTensor</code> (one for each layer of the decoder) of shape <code>(batch_size, num_heads, sequence_length, sequence_length)</code>.`,name:"encoder_attentions"},{anchor:"transformers.generation_utils.BeamSearchEncoderDecoderOutput.encoder_hidden_states",description:`<strong>encoder_hidden_states</strong> (<code>tuple(torch.FloatTensor)</code>, <em>optional</em>, returned when <code>output_hidden_states=True</code> is passed or when <code>config.output_hidden_states=True</code>) &#x2014;
Tuple of <code>torch.FloatTensor</code> (one for the output of the embeddings + one for the output of each layer) of
shape <code>(batch_size*num_beams*num_return_sequences, sequence_length, hidden_size)</code>.`,name:"encoder_hidden_states"},{anchor:"transformers.generation_utils.BeamSearchEncoderDecoderOutput.decoder_attentions",description:`<strong>decoder_attentions</strong> (<code>tuple(tuple(torch.FloatTensor))</code>, <em>optional</em>, returned when <code>output_attentions=True</code> is passed or <code>config.output_attentions=True</code>) &#x2014;
Tuple (one element for each generated token) of tuples (one element for each layer of the decoder) of
<code>torch.FloatTensor</code> of shape <code>(batch_size*num_beams*num_return_sequences, num_heads, generated_length, sequence_length)</code>.`,name:"decoder_attentions"},{anchor:"transformers.generation_utils.BeamSearchEncoderDecoderOutput.cross_attentions",description:`<strong>cross_attentions</strong> (<code>tuple(tuple(torch.FloatTensor))</code>, <em>optional</em>, returned when <code>output_attentions=True</code> is passed or <code>config.output_attentions=True</code>) &#x2014;
Tuple (one element for each generated token) of tuples (one element for each layer of the decoder) of
<code>torch.FloatTensor</code> of shape <code>(batch_size, num_heads, generated_length, sequence_length)</code>.`,name:"cross_attentions"},{anchor:"transformers.generation_utils.BeamSearchEncoderDecoderOutput.decoder_hidden_states",description:`<strong>decoder_hidden_states</strong> (<code>tuple(tuple(torch.FloatTensor))</code>, <em>optional</em>, returned when <code>output_hidden_states=True</code> is passed or when <code>config.output_hidden_states=True</code>) &#x2014;
Tuple (one element for each generated token) of tuples (one element for each layer of the decoder) of
<code>torch.FloatTensor</code> of shape <code>(batch_size*num_beams*num_return_sequences, generated_length, hidden_size)</code>.`,name:"decoder_hidden_states"},{anchor:"transformers.generation_utils.BeamSearchEncoderDecoderOutput.past_key_values",description:`<strong>past_key_values</strong> (<code>Tuple[Tuple[Tuple[torch.Tensor]]]</code> returned when <code>use_cache=True</code> is passed or when <code>config.use_cache=True</code>) &#x2014;
Tuple (one element for each generated token) of tuples (one element for each layer of the decoder) of
tuples (two elements, key tensor and value tensor). The second Tuple is of length <code>config.n_layers</code>, with
each tuple having 2 tensors of shape <code>(batch_size, num_heads, sequence_length, embed_size_per_head)</code>) and
optionally if <code>config.is_encoder_decoder=True</code> 2 additional tensors of shape <code>(batch_size, num_heads, encoder_sequence_length, embed_size_per_head)</code>.`,name:"past_key_values"}],source:"https://github.com/huggingface/transformers/blob/vr_17574/src/transformers/generation_utils.py#L274"}}),yt=new Ie({}),kt=new v({props:{name:"class transformers.generation_utils.BeamSampleDecoderOnlyOutput",anchor:"transformers.generation_utils.BeamSampleDecoderOnlyOutput",parameters:[{name:"sequences",val:": LongTensor = None"},{name:"sequences_scores",val:": typing.Optional[torch.FloatTensor] = None"},{name:"scores",val:": typing.Optional[typing.Tuple[torch.FloatTensor]] = None"},{name:"beam_indices",val:": typing.Optional[torch.LongTensor] = None"},{name:"attentions",val:": typing.Optional[typing.Tuple[typing.Tuple[torch.FloatTensor]]] = None"},{name:"hidden_states",val:": typing.Optional[typing.Tuple[typing.Tuple[torch.FloatTensor]]] = None"},{name:"past_key_values",val:": typing.Optional[typing.Tuple[typing.Tuple[typing.Tuple[torch.Tensor]]]] = None"}],parametersDescription:[{anchor:"transformers.generation_utils.BeamSampleDecoderOnlyOutput.sequences",description:`<strong>sequences</strong> (<code>torch.LongTensor</code> of shape <code>(batch_size*num_return_sequences, sequence_length)</code>) &#x2014;
The generated sequences. The second dimension (sequence_length) is either equal to <code>max_length</code> or shorter
if all batches finished early due to the <code>eos_token_id</code>.`,name:"sequences"},{anchor:"transformers.generation_utils.BeamSampleDecoderOnlyOutput.sequences_scores",description:`<strong>sequences_scores</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size * num_return_sequence)</code>, <em>optional</em>, returned when <code>output_scores=True</code> is passed or when <code>config.output_scores=True</code>) &#x2014;
Final beam scores of the generated <code>sequences</code>.`,name:"sequences_scores"},{anchor:"transformers.generation_utils.BeamSampleDecoderOnlyOutput.scores",description:`<strong>scores</strong> (<code>tuple(torch.FloatTensor)</code> <em>optional</em>, returned when <code>output_scores=True</code> is passed or when <code>config.output_scores=True</code>) &#x2014;
Beam transition scores for each vocabulary token at each generation step. Beam transition scores consisting
of log probabilities of tokens conditioned on log softmax of previously generated tokens in this beam.
<code>(max_length-input_ids.shape[-1],)</code>-shaped tuple of <code>torch.FloatTensor</code> with each tensor of shape
<code>(batch_size*num_beams*num_return_sequences, config.vocab_size)</code>).`,name:"scores"},{anchor:"transformers.generation_utils.BeamSampleDecoderOnlyOutput.beam_indices",description:`<strong>beam_indices</strong> (<code>tuple(tuple(torch.LongTensor))</code>, <em>optional</em>, returned when <code>output_scores=True</code> is passed or when <code>config.output_scores=True</code>) &#x2014;
Beam indices of generated token id at each generation step. <code>torch.LongTensor</code> of shape
<code>(batch_size*num_return_sequences, input_ids.shape[-1])</code>.`,name:"beam_indices"},{anchor:"transformers.generation_utils.BeamSampleDecoderOnlyOutput.attentions",description:`<strong>attentions</strong> (<code>tuple(tuple(torch.FloatTensor))</code>, <em>optional</em>, returned when <code>output_attentions=True</code> is passed or <code>config.output_attentions=True</code>) &#x2014;
Tuple (one element for each generated token) of tuples (one element for each layer of the decoder) of
<code>torch.FloatTensor</code> of shape <code>(batch_size*num_beams, num_heads, generated_length, sequence_length)</code>.`,name:"attentions"},{anchor:"transformers.generation_utils.BeamSampleDecoderOnlyOutput.hidden_states",description:`<strong>hidden_states</strong> (<code>tuple(tuple(torch.FloatTensor))</code>, <em>optional</em>, returned when <code>output_hidden_states=True</code> is passed or when <code>config.output_hidden_states=True</code>) &#x2014;
Tuple (one element for each generated token) of tuples (one element for each layer of the decoder) of
<code>torch.FloatTensor</code> of shape <code>(batch_size*num_beams, generated_length, hidden_size)</code>.`,name:"hidden_states"},{anchor:"transformers.generation_utils.BeamSampleDecoderOnlyOutput.past_key_values",description:`<strong>past_key_values</strong> (<code>Tuple[Tuple[Tuple[torch.Tensor]]]</code> returned when <code>use_cache=True</code> is passed or when <code>config.use_cache=True</code>) &#x2014;
Tuple (one element for each generated token) of tuples (one element for each layer of the decoder) of
tuples (two elements, key tensor and value tensor). The second Tuple is of length <code>config.n_layers</code>, with
each tuple having 2 tensors of shape <code>(batch_size, num_heads, sequence_length, embed_size_per_head)</code>) and
optionally if <code>config.is_encoder_decoder=True</code> 2 additional tensors of shape <code>(batch_size, num_heads, encoder_sequence_length, embed_size_per_head)</code>.`,name:"past_key_values"}],source:"https://github.com/huggingface/transformers/blob/vr_17574/src/transformers/generation_utils.py#L332"}}),xt=new v({props:{name:"class transformers.generation_utils.BeamSampleEncoderDecoderOutput",anchor:"transformers.generation_utils.BeamSampleEncoderDecoderOutput",parameters:[{name:"sequences",val:": LongTensor = None"},{name:"sequences_scores",val:": typing.Optional[torch.FloatTensor] = None"},{name:"scores",val:": typing.Optional[typing.Tuple[torch.FloatTensor]] = None"},{name:"beam_indices",val:": typing.Optional[torch.LongTensor] = None"},{name:"encoder_attentions",val:": typing.Optional[typing.Tuple[torch.FloatTensor]] = None"},{name:"encoder_hidden_states",val:": typing.Optional[typing.Tuple[torch.FloatTensor]] = None"},{name:"decoder_attentions",val:": typing.Optional[typing.Tuple[typing.Tuple[torch.FloatTensor]]] = None"},{name:"cross_attentions",val:": typing.Optional[typing.Tuple[typing.Tuple[torch.FloatTensor]]] = None"},{name:"decoder_hidden_states",val:": typing.Optional[typing.Tuple[typing.Tuple[torch.FloatTensor]]] = None"},{name:"past_key_values",val:": typing.Optional[typing.Tuple[typing.Tuple[typing.Tuple[torch.Tensor]]]] = None"}],parametersDescription:[{anchor:"transformers.generation_utils.BeamSampleEncoderDecoderOutput.sequences",description:`<strong>sequences</strong> (<code>torch.LongTensor</code> of shape <code>(batch_size*num_beams, sequence_length)</code>) &#x2014;
The generated sequences. The second dimension (sequence_length) is either equal to <code>max_length</code> or shorter
if all batches finished early due to the <code>eos_token_id</code>.`,name:"sequences"},{anchor:"transformers.generation_utils.BeamSampleEncoderDecoderOutput.sequences_scores",description:`<strong>sequences_scores</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size * num_return_sequence)</code>, <em>optional</em>, returned when <code>output_scores=True</code> is passed or when <code>config.output_scores=True</code>) &#x2014;
Final beam scores of the generated <code>sequences</code>.`,name:"sequences_scores"},{anchor:"transformers.generation_utils.BeamSampleEncoderDecoderOutput.scores",description:`<strong>scores</strong> (<code>tuple(torch.FloatTensor)</code> <em>optional</em>, returned when <code>output_scores=True</code> is passed or when <code>config.output_scores=True</code>) &#x2014;
Beam transition scores for each vocabulary token at each generation step. Beam transition scores consisting
of log probabilities of tokens conditioned on log softmax of previously generated tokens in this beam.
<code>(max_length-1,)</code>-shaped tuple of <code>torch.FloatTensor</code> with each tensor of shape <code>(batch_size*num_beams, config.vocab_size)</code>).`,name:"scores"},{anchor:"transformers.generation_utils.BeamSampleEncoderDecoderOutput.beam_indices",description:`<strong>beam_indices</strong> (<code>torch.LongTensor</code>, <em>optional</em>, returned when <code>output_scores=True</code> is passed or when <code>config.output_scores=True</code>) &#x2014;
Beam indices of generated token id at each generation step. <code>torch.LongTensor</code> of shape
<code>(batch_size*num_return_sequences, max_length-1)</code>.`,name:"beam_indices"},{anchor:"transformers.generation_utils.BeamSampleEncoderDecoderOutput.encoder_attentions",description:`<strong>encoder_attentions</strong> (<code>tuple(torch.FloatTensor)</code>, <em>optional</em>, returned when <code>output_attentions=True</code> is passed or <code>config.output_attentions=True</code>) &#x2014;
Tuple of <code>torch.FloatTensor</code> (one for each layer of the decoder) of shape <code>(batch_size, num_heads, sequence_length, sequence_length)</code>.`,name:"encoder_attentions"},{anchor:"transformers.generation_utils.BeamSampleEncoderDecoderOutput.encoder_hidden_states",description:`<strong>encoder_hidden_states</strong> (<code>tuple(torch.FloatTensor)</code>, <em>optional</em>, returned when <code>output_hidden_states=True</code> is passed or when <code>config.output_hidden_states=True</code>) &#x2014;
Tuple of <code>torch.FloatTensor</code> (one for the output of the embeddings + one for the output of each layer) of
shape <code>(batch_size*num_beams, sequence_length, hidden_size)</code>.`,name:"encoder_hidden_states"},{anchor:"transformers.generation_utils.BeamSampleEncoderDecoderOutput.decoder_attentions",description:`<strong>decoder_attentions</strong> (<code>tuple(tuple(torch.FloatTensor))</code>, <em>optional</em>, returned when <code>output_attentions=True</code> is passed or <code>config.output_attentions=True</code>) &#x2014;
Tuple (one element for each generated token) of tuples (one element for each layer of the decoder) of
<code>torch.FloatTensor</code> of shape <code>(batch_size*num_beams, num_heads, generated_length, sequence_length)</code>.`,name:"decoder_attentions"},{anchor:"transformers.generation_utils.BeamSampleEncoderDecoderOutput.cross_attentions",description:`<strong>cross_attentions</strong> (<code>tuple(tuple(torch.FloatTensor))</code>, <em>optional</em>, returned when <code>output_attentions=True</code> is passed or <code>config.output_attentions=True</code>) &#x2014;
Tuple (one element for each generated token) of tuples (one element for each layer of the decoder) of
<code>torch.FloatTensor</code> of shape <code>(batch_size, num_heads, generated_length, sequence_length)</code>.`,name:"cross_attentions"},{anchor:"transformers.generation_utils.BeamSampleEncoderDecoderOutput.decoder_hidden_states",description:`<strong>decoder_hidden_states</strong> (<code>tuple(tuple(torch.FloatTensor))</code>, <em>optional</em>, returned when <code>output_hidden_states=True</code> is passed or when <code>config.output_hidden_states=True</code>) &#x2014;
Tuple (one element for each generated token) of tuples (one element for each layer of the decoder) of
<code>torch.FloatTensor</code> of shape <code>(batch_size*num_beams, generated_length, hidden_size)</code>.`,name:"decoder_hidden_states"},{anchor:"transformers.generation_utils.BeamSampleEncoderDecoderOutput.past_key_values",description:`<strong>past_key_values</strong> (<code>Tuple[Tuple[Tuple[torch.Tensor]]]</code> returned when <code>use_cache=True</code> is passed or when <code>config.use_cache=True</code>) &#x2014;
Tuple (one element for each generated token) of tuples (one element for each layer of the decoder) of
tuples (two elements, key tensor and value tensor). The second Tuple is of length <code>config.n_layers</code>, with
each tuple having 2 tensors of shape <code>(batch_size, num_heads, sequence_length, embed_size_per_head)</code>) and
optionally if <code>config.is_encoder_decoder=True</code> 2 additional tensors of shape <code>(batch_size, num_heads, encoder_sequence_length, embed_size_per_head)</code>.`,name:"past_key_values"}],source:"https://github.com/huggingface/transformers/blob/vr_17574/src/transformers/generation_utils.py#L374"}}),wt=new Ie({}),Lt=new v({props:{name:"class transformers.LogitsProcessor",anchor:"transformers.LogitsProcessor",parameters:[],source:"https://github.com/huggingface/transformers/blob/vr_17574/src/transformers/generation_logits_process.py#L51"}}),Et=new v({props:{name:"__call__",anchor:"transformers.LogitsProcessor.__call__",parameters:[{name:"input_ids",val:": LongTensor"},{name:"scores",val:": FloatTensor"}],parametersDescription:[{anchor:"transformers.LogitsProcessor.__call__.input_ids",description:`<strong>input_ids</strong> (<code>torch.LongTensor</code> of shape <code>(batch_size, sequence_length)</code>) &#x2014;
Indices of input sequence tokens in the vocabulary.</p>
<p>Indices can be obtained using <a href="/docs/transformers/pr_17574/en/model_doc/bert#transformers.BertTokenizer">BertTokenizer</a>. See <a href="/docs/transformers/pr_17574/en/internal/tokenization_utils#transformers.PreTrainedTokenizerBase.encode">PreTrainedTokenizer.encode()</a> and
<a href="/docs/transformers/pr_17574/en/model_doc/wav2vec2#transformers.Wav2Vec2CTCTokenizer.__call__">PreTrainedTokenizer.<strong>call</strong>()</a> for details.</p>
<p><a href="../glossary#input-ids">What are input IDs?</a>`,name:"input_ids"},{anchor:"transformers.LogitsProcessor.__call__.scores",description:`<strong>scores</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size, config.vocab_size)</code>) &#x2014;
Prediction scores of a language modeling head. These can be logits for each vocabulary when not using beam
search or log softmax for each vocabulary token when using beam search
kwargs &#x2014;
Additional logits processor specific kwargs.`,name:"scores"}],source:"https://github.com/huggingface/transformers/blob/vr_17574/src/transformers/generation_logits_process.py#L54",returnDescription:`
<p>The processed prediction scores.</p>
`,returnType:`
<p><code>torch.FloatTensor</code> of shape <code>(batch_size, config.vocab_size)</code></p>
`}}),Pt=new v({props:{name:"class transformers.LogitsProcessorList",anchor:"transformers.LogitsProcessorList",parameters:[{name:"iterable",val:" = ()"}],source:"https://github.com/huggingface/transformers/blob/vr_17574/src/transformers/generation_logits_process.py#L73"}}),Ft=new v({props:{name:"__call__",anchor:"transformers.LogitsProcessorList.__call__",parameters:[{name:"input_ids",val:": LongTensor"},{name:"scores",val:": FloatTensor"},{name:"**kwargs",val:""}],parametersDescription:[{anchor:"transformers.LogitsProcessorList.__call__.input_ids",description:`<strong>input_ids</strong> (<code>torch.LongTensor</code> of shape <code>(batch_size, sequence_length)</code>) &#x2014;
Indices of input sequence tokens in the vocabulary.</p>
<p>Indices can be obtained using <a href="/docs/transformers/pr_17574/en/model_doc/bert#transformers.BertTokenizer">BertTokenizer</a>. See <a href="/docs/transformers/pr_17574/en/internal/tokenization_utils#transformers.PreTrainedTokenizerBase.encode">PreTrainedTokenizer.encode()</a> and
<a href="/docs/transformers/pr_17574/en/model_doc/wav2vec2#transformers.Wav2Vec2CTCTokenizer.__call__">PreTrainedTokenizer.<strong>call</strong>()</a> for details.</p>
<p><a href="../glossary#input-ids">What are input IDs?</a>`,name:"input_ids"},{anchor:"transformers.LogitsProcessorList.__call__.scores",description:`<strong>scores</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size, config.vocab_size)</code>) &#x2014;
Prediction scores of a language modeling head. These can be logits for each vocabulary when not using beam
search or log softmax for each vocabulary token when using beam search
kwargs &#x2014;
Additional logits processor specific kwargs.`,name:"scores"}],source:"https://github.com/huggingface/transformers/blob/vr_17574/src/transformers/generation_logits_process.py#L80",returnDescription:`
<p>The processed prediction scores.</p>
`,returnType:`
<p><code>torch.FloatTensor</code> of shape <code>(batch_size, config.vocab_size)</code></p>
`}}),Dt=new v({props:{name:"class transformers.LogitsWarper",anchor:"transformers.LogitsWarper",parameters:[],source:"https://github.com/huggingface/transformers/blob/vr_17574/src/transformers/generation_logits_process.py#L62"}}),zt=new v({props:{name:"__call__",anchor:"transformers.LogitsWarper.__call__",parameters:[{name:"input_ids",val:": LongTensor"},{name:"scores",val:": FloatTensor"}],parametersDescription:[{anchor:"transformers.LogitsWarper.__call__.input_ids",description:`<strong>input_ids</strong> (<code>torch.LongTensor</code> of shape <code>(batch_size, sequence_length)</code>) &#x2014;
Indices of input sequence tokens in the vocabulary.</p>
<p>Indices can be obtained using <a href="/docs/transformers/pr_17574/en/model_doc/bert#transformers.BertTokenizer">BertTokenizer</a>. See <a href="/docs/transformers/pr_17574/en/internal/tokenization_utils#transformers.PreTrainedTokenizerBase.encode">PreTrainedTokenizer.encode()</a> and
<a href="/docs/transformers/pr_17574/en/model_doc/wav2vec2#transformers.Wav2Vec2CTCTokenizer.__call__">PreTrainedTokenizer.<strong>call</strong>()</a> for details.</p>
<p><a href="../glossary#input-ids">What are input IDs?</a>`,name:"input_ids"},{anchor:"transformers.LogitsWarper.__call__.scores",description:`<strong>scores</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size, config.vocab_size)</code>) &#x2014;
Prediction scores of a language modeling head. These can be logits for each vocabulary when not using beam
search or log softmax for each vocabulary token when using beam search
kwargs &#x2014;
Additional logits processor specific kwargs.`,name:"scores"}],source:"https://github.com/huggingface/transformers/blob/vr_17574/src/transformers/generation_logits_process.py#L65",returnDescription:`
<p>The processed prediction scores.</p>
`,returnType:`
<p><code>torch.FloatTensor</code> of shape <code>(batch_size, config.vocab_size)</code></p>
`}}),St=new v({props:{name:"class transformers.MinLengthLogitsProcessor",anchor:"transformers.MinLengthLogitsProcessor",parameters:[{name:"min_length",val:": int"},{name:"eos_token_id",val:": int"}],parametersDescription:[{anchor:"transformers.MinLengthLogitsProcessor.min_length",description:`<strong>min_length</strong> (<code>int</code>) &#x2014;
The minimum length below which the score of <code>eos_token_id</code> is set to <code>-float(&quot;Inf&quot;)</code>.`,name:"min_length"},{anchor:"transformers.MinLengthLogitsProcessor.eos_token_id",description:`<strong>eos_token_id</strong> (<code>int</code>) &#x2014;
The id of the <em>end-of-sequence</em> token.`,name:"eos_token_id"}],source:"https://github.com/huggingface/transformers/blob/vr_17574/src/transformers/generation_logits_process.py#L96"}}),Ot=new v({props:{name:"__call__",anchor:"transformers.MinLengthLogitsProcessor.__call__",parameters:[{name:"input_ids",val:": LongTensor"},{name:"scores",val:": FloatTensor"}],source:"https://github.com/huggingface/transformers/blob/vr_17574/src/transformers/generation_logits_process.py#L117"}}),qt=new v({props:{name:"class transformers.TemperatureLogitsWarper",anchor:"transformers.TemperatureLogitsWarper",parameters:[{name:"temperature",val:": float"}],parametersDescription:[{anchor:"transformers.TemperatureLogitsWarper.temperature",description:`<strong>temperature</strong> (<code>float</code>) &#x2014;
The value used to module the logits distribution.`,name:"temperature"}],source:"https://github.com/huggingface/transformers/blob/vr_17574/src/transformers/generation_logits_process.py#L124"}}),Bt=new v({props:{name:"__call__",anchor:"transformers.TemperatureLogitsWarper.__call__",parameters:[{name:"input_ids",val:": Tensor"},{name:"scores",val:": Tensor"}],source:"https://github.com/huggingface/transformers/blob/vr_17574/src/transformers/generation_logits_process.py#L139"}}),It=new v({props:{name:"class transformers.RepetitionPenaltyLogitsProcessor",anchor:"transformers.RepetitionPenaltyLogitsProcessor",parameters:[{name:"penalty",val:": float"}],parametersDescription:[{anchor:"transformers.RepetitionPenaltyLogitsProcessor.repetition_penalty",description:`<strong>repetition_penalty</strong> (<code>float</code>) &#x2014;
The parameter for repetition penalty. 1.0 means no penalty. See <a href="https://arxiv.org/pdf/1909.05858.pdf" rel="nofollow">this
paper</a> for more details.`,name:"repetition_penalty"}],source:"https://github.com/huggingface/transformers/blob/vr_17574/src/transformers/generation_logits_process.py#L144"}}),Ct=new v({props:{name:"__call__",anchor:"transformers.RepetitionPenaltyLogitsProcessor.__call__",parameters:[{name:"input_ids",val:": LongTensor"},{name:"scores",val:": FloatTensor"}],source:"https://github.com/huggingface/transformers/blob/vr_17574/src/transformers/generation_logits_process.py#L160"}}),Wt=new v({props:{name:"class transformers.TopPLogitsWarper",anchor:"transformers.TopPLogitsWarper",parameters:[{name:"top_p",val:": float"},{name:"filter_value",val:": float = -inf"},{name:"min_tokens_to_keep",val:": int = 1"}],parametersDescription:[{anchor:"transformers.TopPLogitsWarper.top_p",description:`<strong>top_p</strong> (<code>float</code>) &#x2014;
If set to &lt; 1, only the most probable tokens with probabilities that add up to <code>top_p</code> or higher are kept
for generation.`,name:"top_p"},{anchor:"transformers.TopPLogitsWarper.filter_value",description:`<strong>filter_value</strong> (<code>float</code>, <em>optional</em>, defaults to <code>-float(&quot;Inf&quot;)</code>) &#x2014;
All filtered values will be set to this float value.`,name:"filter_value"},{anchor:"transformers.TopPLogitsWarper.min_tokens_to_keep",description:`<strong>min_tokens_to_keep</strong> (<code>int</code>, <em>optional</em>, defaults to 1) &#x2014;
Minimum number of tokens that cannot be filtered.`,name:"min_tokens_to_keep"}],source:"https://github.com/huggingface/transformers/blob/vr_17574/src/transformers/generation_logits_process.py#L170"}}),At=new v({props:{name:"__call__",anchor:"transformers.TopPLogitsWarper.__call__",parameters:[{name:"input_ids",val:": LongTensor"},{name:"scores",val:": FloatTensor"}],source:"https://github.com/huggingface/transformers/blob/vr_17574/src/transformers/generation_logits_process.py#L193"}}),Nt=new v({props:{name:"class transformers.TopKLogitsWarper",anchor:"transformers.TopKLogitsWarper",parameters:[{name:"top_k",val:": int"},{name:"filter_value",val:": float = -inf"},{name:"min_tokens_to_keep",val:": int = 1"}],parametersDescription:[{anchor:"transformers.TopKLogitsWarper.top_k",description:`<strong>top_k</strong> (<code>int</code>) &#x2014;
The number of highest probability vocabulary tokens to keep for top-k-filtering.`,name:"top_k"},{anchor:"transformers.TopKLogitsWarper.filter_value",description:`<strong>filter_value</strong> (<code>float</code>, <em>optional</em>, defaults to <code>-float(&quot;Inf&quot;)</code>) &#x2014;
All filtered values will be set to this float value.`,name:"filter_value"},{anchor:"transformers.TopKLogitsWarper.min_tokens_to_keep",description:`<strong>min_tokens_to_keep</strong> (<code>int</code>, <em>optional</em>, defaults to 1) &#x2014;
Minimum number of tokens that cannot be filtered.`,name:"min_tokens_to_keep"}],source:"https://github.com/huggingface/transformers/blob/vr_17574/src/transformers/generation_logits_process.py#L212"}}),Vt=new v({props:{name:"__call__",anchor:"transformers.TopKLogitsWarper.__call__",parameters:[{name:"input_ids",val:": LongTensor"},{name:"scores",val:": FloatTensor"}],source:"https://github.com/huggingface/transformers/blob/vr_17574/src/transformers/generation_logits_process.py#L233"}}),Mt=new v({props:{name:"class transformers.TypicalLogitsWarper",anchor:"transformers.TypicalLogitsWarper",parameters:[{name:"mass",val:": float = 0.9"},{name:"filter_value",val:": float = -inf"},{name:"min_tokens_to_keep",val:": int = 1"}],source:"https://github.com/huggingface/transformers/blob/vr_17574/src/transformers/generation_logits_process.py#L241"}}),Gt=new v({props:{name:"__call__",anchor:"transformers.TypicalLogitsWarper.__call__",parameters:[{name:"input_ids",val:": LongTensor"},{name:"scores",val:": FloatTensor"}],source:"https://github.com/huggingface/transformers/blob/vr_17574/src/transformers/generation_logits_process.py#L251"}}),jt=new v({props:{name:"class transformers.NoRepeatNGramLogitsProcessor",anchor:"transformers.NoRepeatNGramLogitsProcessor",parameters:[{name:"ngram_size",val:": int"}],parametersDescription:[{anchor:"transformers.NoRepeatNGramLogitsProcessor.ngram_size",description:`<strong>ngram_size</strong> (<code>int</code>) &#x2014;
All ngrams of size <code>ngram_size</code> can only occur once.`,name:"ngram_size"}],source:"https://github.com/huggingface/transformers/blob/vr_17574/src/transformers/generation_logits_process.py#L312"}}),Rt=new v({props:{name:"__call__",anchor:"transformers.NoRepeatNGramLogitsProcessor.__call__",parameters:[{name:"input_ids",val:": LongTensor"},{name:"scores",val:": FloatTensor"}],source:"https://github.com/huggingface/transformers/blob/vr_17574/src/transformers/generation_logits_process.py#L327"}}),Kt=new v({props:{name:"class transformers.NoBadWordsLogitsProcessor",anchor:"transformers.NoBadWordsLogitsProcessor",parameters:[{name:"bad_words_ids",val:": typing.List[typing.List[int]]"},{name:"eos_token_id",val:": int"}],parametersDescription:[{anchor:"transformers.NoBadWordsLogitsProcessor.bad_words_ids",description:`<strong>bad_words_ids</strong> (<code>List[List[int]]</code>) &#x2014;
List of list of token ids that are not allowed to be generated. In order to get the token ids of the words
that should not appear in the generated text, use <code>tokenizer(bad_words, add_prefix_space=True, add_special_tokens=False).input_ids</code>.`,name:"bad_words_ids"},{anchor:"transformers.NoBadWordsLogitsProcessor.eos_token_id",description:`<strong>eos_token_id</strong> (<code>int</code>) &#x2014;
The id of the <em>end-of-sequence</em> token.`,name:"eos_token_id"}],source:"https://github.com/huggingface/transformers/blob/vr_17574/src/transformers/generation_logits_process.py#L379"}}),Ut=new v({props:{name:"__call__",anchor:"transformers.NoBadWordsLogitsProcessor.__call__",parameters:[{name:"input_ids",val:": LongTensor"},{name:"scores",val:": FloatTensor"}],source:"https://github.com/huggingface/transformers/blob/vr_17574/src/transformers/generation_logits_process.py#L421"}}),Yt=new v({props:{name:"class transformers.PrefixConstrainedLogitsProcessor",anchor:"transformers.PrefixConstrainedLogitsProcessor",parameters:[{name:"prefix_allowed_tokens_fn",val:": typing.Callable[[int, torch.Tensor], typing.List[int]]"},{name:"num_beams",val:": int"}],source:"https://github.com/huggingface/transformers/blob/vr_17574/src/transformers/generation_logits_process.py#L507"}}),Jt=new v({props:{name:"__call__",anchor:"transformers.PrefixConstrainedLogitsProcessor.__call__",parameters:[{name:"input_ids",val:": LongTensor"},{name:"scores",val:": FloatTensor"}],source:"https://github.com/huggingface/transformers/blob/vr_17574/src/transformers/generation_logits_process.py#L524"}}),Qt=new v({props:{name:"class transformers.HammingDiversityLogitsProcessor",anchor:"transformers.HammingDiversityLogitsProcessor",parameters:[{name:"diversity_penalty",val:": float"},{name:"num_beams",val:": int"},{name:"num_beam_groups",val:": int"}],parametersDescription:[{anchor:"transformers.HammingDiversityLogitsProcessor.diversity_penalty",description:`<strong>diversity_penalty</strong> (<code>float</code>) &#x2014;
This value is subtracted from a beam&#x2019;s score if it generates a token same as any beam from other group at a
particular time. Note that <code>diversity_penalty</code> is only effective if <code>group beam search</code> is enabled.`,name:"diversity_penalty"},{anchor:"transformers.HammingDiversityLogitsProcessor.num_beams",description:`<strong>num_beams</strong> (<code>int</code>) &#x2014;
Number of beams used for group beam search. See <a href="https://arxiv.org/pdf/1610.02424.pdf" rel="nofollow">this paper</a> for more
details.`,name:"num_beams"},{anchor:"transformers.HammingDiversityLogitsProcessor.num_beam_groups",description:`<strong>num_beam_groups</strong> (<code>int</code>) &#x2014;
Number of groups to divide <code>num_beams</code> into in order to ensure diversity among different groups of beams.
See <a href="https://arxiv.org/pdf/1610.02424.pdf" rel="nofollow">this paper</a> for more details.`,name:"num_beam_groups"}],source:"https://github.com/huggingface/transformers/blob/vr_17574/src/transformers/generation_logits_process.py#L533"}}),eo=new v({props:{name:"__call__",anchor:"transformers.HammingDiversityLogitsProcessor.__call__",parameters:[{name:"input_ids",val:": LongTensor"},{name:"scores",val:": FloatTensor"},{name:"current_tokens",val:": LongTensor"},{name:"beam_group_idx",val:": int"}],source:"https://github.com/huggingface/transformers/blob/vr_17574/src/transformers/generation_logits_process.py#L564"}}),ro=new v({props:{name:"class transformers.ForcedBOSTokenLogitsProcessor",anchor:"transformers.ForcedBOSTokenLogitsProcessor",parameters:[{name:"bos_token_id",val:": int"}],parametersDescription:[{anchor:"transformers.ForcedBOSTokenLogitsProcessor.bos_token_id",description:`<strong>bos_token_id</strong> (<code>int</code>) &#x2014;
The id of the token to force as the first generated token.`,name:"bos_token_id"}],source:"https://github.com/huggingface/transformers/blob/vr_17574/src/transformers/generation_logits_process.py#L593"}}),to=new v({props:{name:"__call__",anchor:"transformers.ForcedBOSTokenLogitsProcessor.__call__",parameters:[{name:"input_ids",val:": LongTensor"},{name:"scores",val:": FloatTensor"}],source:"https://github.com/huggingface/transformers/blob/vr_17574/src/transformers/generation_logits_process.py#L605"}}),oo=new v({props:{name:"class transformers.ForcedEOSTokenLogitsProcessor",anchor:"transformers.ForcedEOSTokenLogitsProcessor",parameters:[{name:"max_length",val:": int"},{name:"eos_token_id",val:": int"}],parametersDescription:[{anchor:"transformers.ForcedEOSTokenLogitsProcessor.max_length",description:`<strong>max_length</strong> (<code>int</code>) &#x2014;
The maximum length of the sequence to be generated.`,name:"max_length"},{anchor:"transformers.ForcedEOSTokenLogitsProcessor.eos_token_id",description:`<strong>eos_token_id</strong> (<code>int</code>) &#x2014;
The id of the token to force as the last generated token when <code>max_length</code> is reached.`,name:"eos_token_id"}],source:"https://github.com/huggingface/transformers/blob/vr_17574/src/transformers/generation_logits_process.py#L614"}}),no=new v({props:{name:"__call__",anchor:"transformers.ForcedEOSTokenLogitsProcessor.__call__",parameters:[{name:"input_ids",val:": LongTensor"},{name:"scores",val:": FloatTensor"}],source:"https://github.com/huggingface/transformers/blob/vr_17574/src/transformers/generation_logits_process.py#L629"}}),so=new v({props:{name:"class transformers.InfNanRemoveLogitsProcessor",anchor:"transformers.InfNanRemoveLogitsProcessor",parameters:[],source:"https://github.com/huggingface/transformers/blob/vr_17574/src/transformers/generation_logits_process.py#L638"}}),ao=new v({props:{name:"__call__",anchor:"transformers.InfNanRemoveLogitsProcessor.__call__",parameters:[{name:"input_ids",val:": LongTensor"},{name:"scores",val:": FloatTensor"}],source:"https://github.com/huggingface/transformers/blob/vr_17574/src/transformers/generation_logits_process.py#L645"}}),io=new v({props:{name:"class transformers.TFLogitsProcessor",anchor:"transformers.TFLogitsProcessor",parameters:[],source:"https://github.com/huggingface/transformers/blob/vr_17574/src/transformers/generation_tf_logits_process.py#L53"}}),co=new v({props:{name:"__call__",anchor:"transformers.TFLogitsProcessor.__call__",parameters:[{name:"input_ids",val:": Tensor"},{name:"scores",val:": Tensor"},{name:"cur_len",val:": int"}],parametersDescription:[{anchor:"transformers.TFLogitsProcessor.__call__.input_ids",description:`<strong>input_ids</strong> (<code>tf.Tensor</code> of shape <code>(batch_size, sequence_length)</code>) &#x2014;
Indices of input sequence tokens in the vocabulary.</p>
<p>Indices can be obtained using <a href="/docs/transformers/pr_17574/en/main_classes/tokenizer#transformers.PreTrainedTokenizer">PreTrainedTokenizer</a>. See <a href="/docs/transformers/pr_17574/en/internal/tokenization_utils#transformers.PreTrainedTokenizerBase.encode">PreTrainedTokenizer.encode()</a> and
<a href="/docs/transformers/pr_17574/en/model_doc/wav2vec2#transformers.Wav2Vec2CTCTokenizer.__call__">PreTrainedTokenizer.<strong>call</strong>()</a> for details.</p>
<p><a href="../glossary#input-ids">What are input IDs?</a>`,name:"input_ids"},{anchor:"transformers.TFLogitsProcessor.__call__.scores",description:`<strong>scores</strong> (<code>tf.Tensor</code> of shape <code>(batch_size, config.vocab_size)</code>) &#x2014;
Prediction scores of a language modeling head. These can be logits for each vocabulary when not using beam
search or log softmax for each vocabulary token when using beam search.`,name:"scores"},{anchor:"transformers.TFLogitsProcessor.__call__.cur_len",description:`<strong>cur_len</strong> (<code>int</code>) &#x2014;
The current length of valid input sequence tokens. In the TF implementation, the input_ids&#x2019; sequence length
is the maximum length generate can produce, and we need to know which of its tokens are valid.
kwargs &#x2014;
Additional logits processor specific kwargs.`,name:"cur_len"}],source:"https://github.com/huggingface/transformers/blob/vr_17574/src/transformers/generation_tf_logits_process.py#L56",returnDescription:`
<p>The processed prediction scores.</p>
`,returnType:`
<p><code>tf.Tensor</code> of shape <code>(batch_size, config.vocab_size)</code></p>
`}}),lo=new v({props:{name:"class transformers.TFLogitsProcessorList",anchor:"transformers.TFLogitsProcessorList",parameters:[{name:"iterable",val:" = ()"}],source:"https://github.com/huggingface/transformers/blob/vr_17574/src/transformers/generation_tf_logits_process.py#L75"}}),po=new v({props:{name:"__call__",anchor:"transformers.TFLogitsProcessorList.__call__",parameters:[{name:"input_ids",val:": Tensor"},{name:"scores",val:": Tensor"},{name:"cur_len",val:": int"},{name:"**kwargs",val:""}],parametersDescription:[{anchor:"transformers.TFLogitsProcessorList.__call__.input_ids",description:`<strong>input_ids</strong> (<code>tf.Tensor</code> of shape <code>(batch_size, sequence_length)</code>) &#x2014;
Indices of input sequence tokens in the vocabulary.</p>
<p>Indices can be obtained using <a href="/docs/transformers/pr_17574/en/main_classes/tokenizer#transformers.PreTrainedTokenizer">PreTrainedTokenizer</a>. See <a href="/docs/transformers/pr_17574/en/internal/tokenization_utils#transformers.PreTrainedTokenizerBase.encode">PreTrainedTokenizer.encode()</a> and
<a href="/docs/transformers/pr_17574/en/model_doc/wav2vec2#transformers.Wav2Vec2CTCTokenizer.__call__">PreTrainedTokenizer.<strong>call</strong>()</a> for details.</p>
<p><a href="../glossary#input-ids">What are input IDs?</a>`,name:"input_ids"},{anchor:"transformers.TFLogitsProcessorList.__call__.scores",description:`<strong>scores</strong> (<code>tf.Tensor</code> of shape <code>(batch_size, config.vocab_size)</code>) &#x2014;
Prediction scores of a language modeling head. These can be logits for each vocabulary when not using beam
search or log softmax for each vocabulary token when using beam search.`,name:"scores"},{anchor:"transformers.TFLogitsProcessorList.__call__.cur_len",description:`<strong>cur_len</strong> (<code>int</code>) &#x2014;
The current length of valid input sequence tokens. In the TF implementation, the input_ids&#x2019; sequence length
is the maximum length generate can produce, and we need to know which of its tokens are valid.
kwargs &#x2014;
Additional logits processor specific kwargs.`,name:"cur_len"}],source:"https://github.com/huggingface/transformers/blob/vr_17574/src/transformers/generation_tf_logits_process.py#L82",returnDescription:`
<p>The processed prediction scores.</p>
`,returnType:`
<p><code>tf.Tensor</code> of shape <code>(batch_size, config.vocab_size)</code></p>
`}}),mo=new v({props:{name:"class transformers.TFLogitsWarper",anchor:"transformers.TFLogitsWarper",parameters:[],source:"https://github.com/huggingface/transformers/blob/vr_17574/src/transformers/generation_tf_logits_process.py#L64"}}),fo=new v({props:{name:"__call__",anchor:"transformers.TFLogitsWarper.__call__",parameters:[{name:"input_ids",val:": Tensor"},{name:"scores",val:": Tensor"},{name:"cur_len",val:": int"}],parametersDescription:[{anchor:"transformers.TFLogitsWarper.__call__.input_ids",description:`<strong>input_ids</strong> (<code>tf.Tensor</code> of shape <code>(batch_size, sequence_length)</code>) &#x2014;
Indices of input sequence tokens in the vocabulary.</p>
<p>Indices can be obtained using <a href="/docs/transformers/pr_17574/en/main_classes/tokenizer#transformers.PreTrainedTokenizer">PreTrainedTokenizer</a>. See <a href="/docs/transformers/pr_17574/en/internal/tokenization_utils#transformers.PreTrainedTokenizerBase.encode">PreTrainedTokenizer.encode()</a> and
<a href="/docs/transformers/pr_17574/en/model_doc/wav2vec2#transformers.Wav2Vec2CTCTokenizer.__call__">PreTrainedTokenizer.<strong>call</strong>()</a> for details.</p>
<p><a href="../glossary#input-ids">What are input IDs?</a>`,name:"input_ids"},{anchor:"transformers.TFLogitsWarper.__call__.scores",description:`<strong>scores</strong> (<code>tf.Tensor</code> of shape <code>(batch_size, config.vocab_size)</code>) &#x2014;
Prediction scores of a language modeling head. These can be logits for each vocabulary when not using beam
search or log softmax for each vocabulary token when using beam search.`,name:"scores"},{anchor:"transformers.TFLogitsWarper.__call__.cur_len",description:`<strong>cur_len</strong> (<code>int</code>) &#x2014;
The current length of valid input sequence tokens. In the TF implementation, the input_ids&#x2019; sequence length
is the maximum length generate can produce, and we need to know which of its tokens are valid.
kwargs &#x2014;
Additional logits processor specific kwargs.`,name:"cur_len"}],source:"https://github.com/huggingface/transformers/blob/vr_17574/src/transformers/generation_tf_logits_process.py#L67",returnDescription:`
<p>The processed prediction scores.</p>
`,returnType:`
<p><code>tf.Tensor</code> of shape <code>(batch_size, config.vocab_size)</code></p>
`}}),go=new v({props:{name:"class transformers.TFTemperatureLogitsWarper",anchor:"transformers.TFTemperatureLogitsWarper",parameters:[{name:"temperature",val:": float"}],parametersDescription:[{anchor:"transformers.TFTemperatureLogitsWarper.temperature",description:`<strong>temperature</strong> (<code>float</code>) &#x2014;
The value used to module the logits distribution.`,name:"temperature"}],source:"https://github.com/huggingface/transformers/blob/vr_17574/src/transformers/generation_tf_logits_process.py#L98"}}),uo=new v({props:{name:"__call__",anchor:"transformers.TFTemperatureLogitsWarper.__call__",parameters:[{name:"input_ids",val:": Tensor"},{name:"scores",val:": Tensor"},{name:"cur_len",val:": int"}],source:"https://github.com/huggingface/transformers/blob/vr_17574/src/transformers/generation_tf_logits_process.py#L113"}}),ho=new v({props:{name:"class transformers.TFTopPLogitsWarper",anchor:"transformers.TFTopPLogitsWarper",parameters:[{name:"top_p",val:": float"},{name:"filter_value",val:": float = -inf"},{name:"min_tokens_to_keep",val:": int = 1"}],parametersDescription:[{anchor:"transformers.TFTopPLogitsWarper.top_p",description:`<strong>top_p</strong> (<code>float</code>) &#x2014;
If set to &lt; 1, only the most probable tokens with probabilities that add up to <code>top_p</code> or higher are kept
for generation.`,name:"top_p"},{anchor:"transformers.TFTopPLogitsWarper.filter_value",description:`<strong>filter_value</strong> (<code>float</code>, <em>optional</em>, defaults to <code>-float(&quot;Inf&quot;)</code>) &#x2014;
All filtered values will be set to this float value.`,name:"filter_value"},{anchor:"transformers.TFTopPLogitsWarper.min_tokens_to_keep",description:`<strong>min_tokens_to_keep</strong> (<code>int</code>, <em>optional</em>, defaults to 1) &#x2014;
Minimum number of tokens that cannot be filtered.`,name:"min_tokens_to_keep"}],source:"https://github.com/huggingface/transformers/blob/vr_17574/src/transformers/generation_tf_logits_process.py#L147"}}),_o=new v({props:{name:"__call__",anchor:"transformers.TFTopPLogitsWarper.__call__",parameters:[{name:"input_ids",val:": Tensor"},{name:"scores",val:": Tensor"},{name:"cur_len",val:": int"}],source:"https://github.com/huggingface/transformers/blob/vr_17574/src/transformers/generation_tf_logits_process.py#L169"}}),bo=new v({props:{name:"class transformers.TFTopKLogitsWarper",anchor:"transformers.TFTopKLogitsWarper",parameters:[{name:"top_k",val:": int"},{name:"filter_value",val:": float = -inf"},{name:"min_tokens_to_keep",val:": int = 1"}],parametersDescription:[{anchor:"transformers.TFTopKLogitsWarper.top_k",description:`<strong>top_k</strong> (<code>int</code>) &#x2014;
The number of highest probability vocabulary tokens to keep for top-k-filtering.`,name:"top_k"},{anchor:"transformers.TFTopKLogitsWarper.filter_value",description:`<strong>filter_value</strong> (<code>float</code>, <em>optional</em>, defaults to <code>-float(&quot;Inf&quot;)</code>) &#x2014;
All filtered values will be set to this float value.`,name:"filter_value"},{anchor:"transformers.TFTopKLogitsWarper.min_tokens_to_keep",description:`<strong>min_tokens_to_keep</strong> (<code>int</code>, <em>optional</em>, defaults to 1) &#x2014;
Minimum number of tokens that cannot be filtered.`,name:"min_tokens_to_keep"}],source:"https://github.com/huggingface/transformers/blob/vr_17574/src/transformers/generation_tf_logits_process.py#L118"}}),vo=new v({props:{name:"__call__",anchor:"transformers.TFTopKLogitsWarper.__call__",parameters:[{name:"input_ids",val:": Tensor"},{name:"scores",val:": Tensor"},{name:"cur_len",val:": int"}],source:"https://github.com/huggingface/transformers/blob/vr_17574/src/transformers/generation_tf_logits_process.py#L139"}}),To=new v({props:{name:"class transformers.TFMinLengthLogitsProcessor",anchor:"transformers.TFMinLengthLogitsProcessor",parameters:[{name:"min_length",val:": int"},{name:"eos_token_id",val:": int"}],parametersDescription:[{anchor:"transformers.TFMinLengthLogitsProcessor.min_length",description:`<strong>min_length</strong> (<code>int</code>) &#x2014;
The minimum length below which the score of <code>eos_token_id</code> is set to <code>-float(&quot;Inf&quot;)</code>.`,name:"min_length"},{anchor:"transformers.TFMinLengthLogitsProcessor.eos_token_id",description:`<strong>eos_token_id</strong> (<code>int</code>) &#x2014;
The id of the <em>end-of-sequence</em> token.`,name:"eos_token_id"}],source:"https://github.com/huggingface/transformers/blob/vr_17574/src/transformers/generation_tf_logits_process.py#L201"}}),$o=new v({props:{name:"__call__",anchor:"transformers.TFMinLengthLogitsProcessor.__call__",parameters:[{name:"input_ids",val:": Tensor"},{name:"scores",val:": Tensor"},{name:"cur_len",val:": int"}],source:"https://github.com/huggingface/transformers/blob/vr_17574/src/transformers/generation_tf_logits_process.py#L227"}}),yo=new v({props:{name:"class transformers.TFNoBadWordsLogitsProcessor",anchor:"transformers.TFNoBadWordsLogitsProcessor",parameters:[{name:"bad_words_ids",val:": typing.List[typing.List[int]]"},{name:"eos_token_id",val:": int"}],parametersDescription:[{anchor:"transformers.TFNoBadWordsLogitsProcessor.bad_words_ids",description:`<strong>bad_words_ids</strong> (<code>List[List[int]]</code>) &#x2014;
List of list of token ids that are not allowed to be generated. In order to get the tokens of the words
that should not appear in the generated text, use <code>tokenizer(bad_word, add_prefix_space=True).input_ids</code>.`,name:"bad_words_ids"},{anchor:"transformers.TFNoBadWordsLogitsProcessor.eos_token_id",description:`<strong>eos_token_id</strong> (<code>int</code>) &#x2014;
The id of the <em>end-of-sequence</em> token.`,name:"eos_token_id"}],source:"https://github.com/huggingface/transformers/blob/vr_17574/src/transformers/generation_tf_logits_process.py#L285"}}),ko=new v({props:{name:"__call__",anchor:"transformers.TFNoBadWordsLogitsProcessor.__call__",parameters:[{name:"input_ids",val:": Tensor"},{name:"scores",val:": Tensor"},{name:"cur_len",val:": int"}],source:"https://github.com/huggingface/transformers/blob/vr_17574/src/transformers/generation_tf_logits_process.py#L362"}}),xo=new v({props:{name:"class transformers.TFNoRepeatNGramLogitsProcessor",anchor:"transformers.TFNoRepeatNGramLogitsProcessor",parameters:[{name:"ngram_size",val:": int"}],parametersDescription:[{anchor:"transformers.TFNoRepeatNGramLogitsProcessor.ngram_size",description:`<strong>ngram_size</strong> (<code>int</code>) &#x2014;
All ngrams of size <code>ngram_size</code> can only occur once.`,name:"ngram_size"}],source:"https://github.com/huggingface/transformers/blob/vr_17574/src/transformers/generation_tf_logits_process.py#L383"}}),Lo=new v({props:{name:"__call__",anchor:"transformers.TFNoRepeatNGramLogitsProcessor.__call__",parameters:[{name:"input_ids",val:": Tensor"},{name:"scores",val:": Tensor"},{name:"cur_len",val:": int"}],source:"https://github.com/huggingface/transformers/blob/vr_17574/src/transformers/generation_tf_logits_process.py#L422"}}),Eo=new v({props:{name:"class transformers.TFRepetitionPenaltyLogitsProcessor",anchor:"transformers.TFRepetitionPenaltyLogitsProcessor",parameters:[{name:"penalty",val:": float"}],parametersDescription:[{anchor:"transformers.TFRepetitionPenaltyLogitsProcessor.repetition_penalty",description:`<strong>repetition_penalty</strong> (<code>float</code>) &#x2014;
The parameter for repetition penalty. 1.0 means no penalty. See <a href="https://arxiv.org/pdf/1909.05858.pdf" rel="nofollow">this
paper</a> for more details.`,name:"repetition_penalty"}],source:"https://github.com/huggingface/transformers/blob/vr_17574/src/transformers/generation_tf_logits_process.py#L237"}}),Po=new v({props:{name:"__call__",anchor:"transformers.TFRepetitionPenaltyLogitsProcessor.__call__",parameters:[{name:"input_ids",val:": Tensor"},{name:"scores",val:": Tensor"},{name:"cur_len",val:": int"}],source:"https://github.com/huggingface/transformers/blob/vr_17574/src/transformers/generation_tf_logits_process.py#L277"}}),Fo=new v({props:{name:"class transformers.TFForcedBOSTokenLogitsProcessor",anchor:"transformers.TFForcedBOSTokenLogitsProcessor",parameters:[{name:"bos_token_id",val:": int"}],parametersDescription:[{anchor:"transformers.TFForcedBOSTokenLogitsProcessor.bos_token_id",description:`<strong>bos_token_id</strong> (<code>int</code>) &#x2014;
The id of the token to force as the first generated token.`,name:"bos_token_id"}],source:"https://github.com/huggingface/transformers/blob/vr_17574/src/transformers/generation_tf_logits_process.py#L444"}}),Do=new v({props:{name:"__call__",anchor:"transformers.TFForcedBOSTokenLogitsProcessor.__call__",parameters:[{name:"input_ids",val:": Tensor"},{name:"scores",val:": Tensor"},{name:"cur_len",val:": int"}],source:"https://github.com/huggingface/transformers/blob/vr_17574/src/transformers/generation_tf_logits_process.py#L458"}}),zo=new v({props:{name:"class transformers.TFForcedEOSTokenLogitsProcessor",anchor:"transformers.TFForcedEOSTokenLogitsProcessor",parameters:[{name:"max_length",val:": int"},{name:"eos_token_id",val:": int"}],parametersDescription:[{anchor:"transformers.TFForcedEOSTokenLogitsProcessor.max_length",description:`<strong>max_length</strong> (<code>int</code>) &#x2014;
The maximum length of the sequence to be generated.`,name:"max_length"},{anchor:"transformers.TFForcedEOSTokenLogitsProcessor.eos_token_id",description:`<strong>eos_token_id</strong> (<code>int</code>) &#x2014;
The id of the token to force as the last generated token when <code>max_length</code> is reached.`,name:"eos_token_id"}],source:"https://github.com/huggingface/transformers/blob/vr_17574/src/transformers/generation_tf_logits_process.py#L474"}}),So=new v({props:{name:"__call__",anchor:"transformers.TFForcedEOSTokenLogitsProcessor.__call__",parameters:[{name:"input_ids",val:": Tensor"},{name:"scores",val:": Tensor"},{name:"cur_len",val:": int"}],source:"https://github.com/huggingface/transformers/blob/vr_17574/src/transformers/generation_tf_logits_process.py#L491"}}),Oo=new v({props:{name:"class transformers.FlaxLogitsProcessor",anchor:"transformers.FlaxLogitsProcessor",parameters:[],source:"https://github.com/huggingface/transformers/blob/vr_17574/src/transformers/generation_flax_logits_process.py#L50"}}),qo=new v({props:{name:"__call__",anchor:"transformers.FlaxLogitsProcessor.__call__",parameters:[{name:"input_ids",val:": ndarray"},{name:"scores",val:": ndarray"}],parametersDescription:[{anchor:"transformers.FlaxLogitsProcessor.__call__.input_ids",description:`<strong>input_ids</strong> (<code>jnp.ndarray</code> of shape <code>(batch_size, sequence_length)</code>) &#x2014;
Indices of input sequence tokens in the vocabulary.</p>
<p>Indices can be obtained using <a href="/docs/transformers/pr_17574/en/main_classes/tokenizer#transformers.PreTrainedTokenizer">PreTrainedTokenizer</a>. See <a href="/docs/transformers/pr_17574/en/internal/tokenization_utils#transformers.PreTrainedTokenizerBase.encode">PreTrainedTokenizer.encode()</a> and
<a href="/docs/transformers/pr_17574/en/model_doc/wav2vec2#transformers.Wav2Vec2CTCTokenizer.__call__">PreTrainedTokenizer.<strong>call</strong>()</a> for details.</p>
<p><a href="../glossary#input-ids">What are input IDs?</a>`,name:"input_ids"},{anchor:"transformers.FlaxLogitsProcessor.__call__.scores",description:`<strong>scores</strong> (<code>jnp.ndarray</code> of shape <code>(batch_size, config.vocab_size)</code>) &#x2014;
Prediction scores of a language modeling head. These can be logits for each vocabulary when not using beam
search or log softmax for each vocabulary token when using beam search
kwargs &#x2014;
Additional logits processor specific kwargs.`,name:"scores"}],source:"https://github.com/huggingface/transformers/blob/vr_17574/src/transformers/generation_flax_logits_process.py#L53",returnDescription:`
<p>The processed prediction scores.</p>
`,returnType:`
<p><code>jnp.ndarray</code> of shape <code>(batch_size, config.vocab_size)</code></p>
`}}),Bo=new v({props:{name:"class transformers.FlaxLogitsProcessorList",anchor:"transformers.FlaxLogitsProcessorList",parameters:[{name:"iterable",val:" = ()"}],source:"https://github.com/huggingface/transformers/blob/vr_17574/src/transformers/generation_flax_logits_process.py#L72"}}),Io=new v({props:{name:"__call__",anchor:"transformers.FlaxLogitsProcessorList.__call__",parameters:[{name:"input_ids",val:": ndarray"},{name:"scores",val:": ndarray"},{name:"cur_len",val:": int"},{name:"**kwargs",val:""}],parametersDescription:[{anchor:"transformers.FlaxLogitsProcessorList.__call__.input_ids",description:`<strong>input_ids</strong> (<code>jnp.ndarray</code> of shape <code>(batch_size, sequence_length)</code>) &#x2014;
Indices of input sequence tokens in the vocabulary.</p>
<p>Indices can be obtained using <a href="/docs/transformers/pr_17574/en/main_classes/tokenizer#transformers.PreTrainedTokenizer">PreTrainedTokenizer</a>. See <a href="/docs/transformers/pr_17574/en/internal/tokenization_utils#transformers.PreTrainedTokenizerBase.encode">PreTrainedTokenizer.encode()</a> and
<a href="/docs/transformers/pr_17574/en/model_doc/wav2vec2#transformers.Wav2Vec2CTCTokenizer.__call__">PreTrainedTokenizer.<strong>call</strong>()</a> for details.</p>
<p><a href="../glossary#input-ids">What are input IDs?</a>`,name:"input_ids"},{anchor:"transformers.FlaxLogitsProcessorList.__call__.scores",description:`<strong>scores</strong> (<code>jnp.ndarray</code> of shape <code>(batch_size, config.vocab_size)</code>) &#x2014;
Prediction scores of a language modeling head. These can be logits for each vocabulary when not using beam
search or log softmax for each vocabulary token when using beam search
kwargs &#x2014;
Additional logits processor specific kwargs.`,name:"scores"}],source:"https://github.com/huggingface/transformers/blob/vr_17574/src/transformers/generation_flax_logits_process.py#L79",returnDescription:`
<p>The processed prediction scores.</p>
`,returnType:`
<p><code>jnp.ndarray</code> of shape <code>(batch_size, config.vocab_size)</code></p>
`}}),Co=new v({props:{name:"class transformers.FlaxLogitsWarper",anchor:"transformers.FlaxLogitsWarper",parameters:[],source:"https://github.com/huggingface/transformers/blob/vr_17574/src/transformers/generation_flax_logits_process.py#L61"}}),Wo=new v({props:{name:"__call__",anchor:"transformers.FlaxLogitsWarper.__call__",parameters:[{name:"input_ids",val:": ndarray"},{name:"scores",val:": ndarray"}],parametersDescription:[{anchor:"transformers.FlaxLogitsWarper.__call__.input_ids",description:`<strong>input_ids</strong> (<code>jnp.ndarray</code> of shape <code>(batch_size, sequence_length)</code>) &#x2014;
Indices of input sequence tokens in the vocabulary.</p>
<p>Indices can be obtained using <a href="/docs/transformers/pr_17574/en/main_classes/tokenizer#transformers.PreTrainedTokenizer">PreTrainedTokenizer</a>. See <a href="/docs/transformers/pr_17574/en/internal/tokenization_utils#transformers.PreTrainedTokenizerBase.encode">PreTrainedTokenizer.encode()</a> and
<a href="/docs/transformers/pr_17574/en/model_doc/wav2vec2#transformers.Wav2Vec2CTCTokenizer.__call__">PreTrainedTokenizer.<strong>call</strong>()</a> for details.</p>
<p><a href="../glossary#input-ids">What are input IDs?</a>`,name:"input_ids"},{anchor:"transformers.FlaxLogitsWarper.__call__.scores",description:`<strong>scores</strong> (<code>jnp.ndarray</code> of shape <code>(batch_size, config.vocab_size)</code>) &#x2014;
Prediction scores of a language modeling head. These can be logits for each vocabulary when not using beam
search or log softmax for each vocabulary token when using beam search
kwargs &#x2014;
Additional logits processor specific kwargs.`,name:"scores"}],source:"https://github.com/huggingface/transformers/blob/vr_17574/src/transformers/generation_flax_logits_process.py#L64",returnDescription:`
<p>The processed prediction scores.</p>
`,returnType:`
<p><code>jnp.ndarray</code> of shape <code>(batch_size, config.vocab_size)</code></p>
`}}),Ao=new v({props:{name:"class transformers.FlaxTemperatureLogitsWarper",anchor:"transformers.FlaxTemperatureLogitsWarper",parameters:[{name:"temperature",val:": float"}],parametersDescription:[{anchor:"transformers.FlaxTemperatureLogitsWarper.temperature",description:`<strong>temperature</strong> (<code>float</code>) &#x2014;
The value used to module the logits distribution.`,name:"temperature"}],source:"https://github.com/huggingface/transformers/blob/vr_17574/src/transformers/generation_flax_logits_process.py#L95"}}),No=new v({props:{name:"__call__",anchor:"transformers.FlaxTemperatureLogitsWarper.__call__",parameters:[{name:"input_ids",val:": ndarray"},{name:"scores",val:": ndarray"},{name:"cur_len",val:": int"}],source:"https://github.com/huggingface/transformers/blob/vr_17574/src/transformers/generation_flax_logits_process.py#L110"}}),Vo=new v({props:{name:"class transformers.FlaxTopPLogitsWarper",anchor:"transformers.FlaxTopPLogitsWarper",parameters:[{name:"top_p",val:": float"},{name:"filter_value",val:": float = -inf"},{name:"min_tokens_to_keep",val:": int = 1"}],parametersDescription:[{anchor:"transformers.FlaxTopPLogitsWarper.top_p",description:`<strong>top_p</strong> (<code>float</code>) &#x2014;
If set to &lt; 1, only the most probable tokens with probabilities that add up to <code>top_p</code> or higher are kept
for generation.`,name:"top_p"},{anchor:"transformers.FlaxTopPLogitsWarper.filter_value",description:`<strong>filter_value</strong> (<code>float</code>, <em>optional</em>, defaults to <code>-float(&quot;Inf&quot;)</code>) &#x2014;
All filtered values will be set to this float value.`,name:"filter_value"},{anchor:"transformers.FlaxTopPLogitsWarper.min_tokens_to_keep",description:`<strong>min_tokens_to_keep</strong> (<code>int</code>, <em>optional</em>, defaults to 1) &#x2014;
Minimum number of tokens that cannot be filtered.`,name:"min_tokens_to_keep"}],source:"https://github.com/huggingface/transformers/blob/vr_17574/src/transformers/generation_flax_logits_process.py#L115"}}),Mo=new v({props:{name:"__call__",anchor:"transformers.FlaxTopPLogitsWarper.__call__",parameters:[{name:"input_ids",val:": ndarray"},{name:"scores",val:": ndarray"},{name:"cur_len",val:": int"}],source:"https://github.com/huggingface/transformers/blob/vr_17574/src/transformers/generation_flax_logits_process.py#L137"}}),Go=new v({props:{name:"class transformers.FlaxTopKLogitsWarper",anchor:"transformers.FlaxTopKLogitsWarper",parameters:[{name:"top_k",val:": int"},{name:"filter_value",val:": float = -inf"},{name:"min_tokens_to_keep",val:": int = 1"}],parametersDescription:[{anchor:"transformers.FlaxTopKLogitsWarper.top_k",description:`<strong>top_k</strong> (<code>int</code>) &#x2014;
The number of highest probability vocabulary tokens to keep for top-k-filtering.`,name:"top_k"},{anchor:"transformers.FlaxTopKLogitsWarper.filter_value",description:`<strong>filter_value</strong> (<code>float</code>, <em>optional</em>, defaults to <code>-float(&quot;Inf&quot;)</code>) &#x2014;
All filtered values will be set to this float value.`,name:"filter_value"},{anchor:"transformers.FlaxTopKLogitsWarper.min_tokens_to_keep",description:`<strong>min_tokens_to_keep</strong> (<code>int</code>, <em>optional</em>, defaults to 1) &#x2014;
Minimum number of tokens that cannot be filtered.`,name:"min_tokens_to_keep"}],source:"https://github.com/huggingface/transformers/blob/vr_17574/src/transformers/generation_flax_logits_process.py#L157"}}),jo=new v({props:{name:"__call__",anchor:"transformers.FlaxTopKLogitsWarper.__call__",parameters:[{name:"input_ids",val:": ndarray"},{name:"scores",val:": ndarray"},{name:"cur_len",val:": int"}],source:"https://github.com/huggingface/transformers/blob/vr_17574/src/transformers/generation_flax_logits_process.py#L178"}}),Ho=new v({props:{name:"class transformers.FlaxForcedBOSTokenLogitsProcessor",anchor:"transformers.FlaxForcedBOSTokenLogitsProcessor",parameters:[{name:"bos_token_id",val:": int"}],parametersDescription:[{anchor:"transformers.FlaxForcedBOSTokenLogitsProcessor.bos_token_id",description:`<strong>bos_token_id</strong> (<code>int</code>) &#x2014;
The id of the token to force as the first generated token.`,name:"bos_token_id"}],source:"https://github.com/huggingface/transformers/blob/vr_17574/src/transformers/generation_flax_logits_process.py#L193"}}),Ro=new v({props:{name:"__call__",anchor:"transformers.FlaxForcedBOSTokenLogitsProcessor.__call__",parameters:[{name:"input_ids",val:": ndarray"},{name:"scores",val:": ndarray"},{name:"cur_len",val:": int"}],source:"https://github.com/huggingface/transformers/blob/vr_17574/src/transformers/generation_flax_logits_process.py#L205"}}),Ko=new v({props:{name:"class transformers.FlaxForcedEOSTokenLogitsProcessor",anchor:"transformers.FlaxForcedEOSTokenLogitsProcessor",parameters:[{name:"max_length",val:": int"},{name:"eos_token_id",val:": int"}],parametersDescription:[{anchor:"transformers.FlaxForcedEOSTokenLogitsProcessor.max_length",description:`<strong>max_length</strong> (<code>int</code>) &#x2014;
The maximum length of the sequence to be generated.`,name:"max_length"},{anchor:"transformers.FlaxForcedEOSTokenLogitsProcessor.eos_token_id",description:`<strong>eos_token_id</strong> (<code>int</code>) &#x2014;
The id of the token to force as the last generated token when <code>max_length</code> is reached.`,name:"eos_token_id"}],source:"https://github.com/huggingface/transformers/blob/vr_17574/src/transformers/generation_flax_logits_process.py#L215"}}),Uo=new v({props:{name:"__call__",anchor:"transformers.FlaxForcedEOSTokenLogitsProcessor.__call__",parameters:[{name:"input_ids",val:": ndarray"},{name:"scores",val:": ndarray"},{name:"cur_len",val:": int"}],source:"https://github.com/huggingface/transformers/blob/vr_17574/src/transformers/generation_flax_logits_process.py#L230"}}),Yo=new v({props:{name:"class transformers.FlaxMinLengthLogitsProcessor",anchor:"transformers.FlaxMinLengthLogitsProcessor",parameters:[{name:"min_length",val:": int"},{name:"eos_token_id",val:": int"}],parametersDescription:[{anchor:"transformers.FlaxMinLengthLogitsProcessor.min_length",description:`<strong>min_length</strong> (<code>int</code>) &#x2014;
The minimum length below which the score of <code>eos_token_id</code> is set to <code>-float(&quot;Inf&quot;)</code>.`,name:"min_length"},{anchor:"transformers.FlaxMinLengthLogitsProcessor.eos_token_id",description:`<strong>eos_token_id</strong> (<code>int</code>) &#x2014;
The id of the <em>end-of-sequence</em> token.`,name:"eos_token_id"}],source:"https://github.com/huggingface/transformers/blob/vr_17574/src/transformers/generation_flax_logits_process.py#L240"}}),Xo=new v({props:{name:"__call__",anchor:"transformers.FlaxMinLengthLogitsProcessor.__call__",parameters:[{name:"input_ids",val:": ndarray"},{name:"scores",val:": ndarray"},{name:"cur_len",val:": int"}],source:"https://github.com/huggingface/transformers/blob/vr_17574/src/transformers/generation_flax_logits_process.py#L261"}}),Jo=new Ie({}),Qo=new v({props:{name:"class transformers.StoppingCriteria",anchor:"transformers.StoppingCriteria",parameters:[],source:"https://github.com/huggingface/transformers/blob/vr_17574/src/transformers/generation_stopping_criteria.py#L33"}}),Zo=new v({props:{name:"__call__",anchor:"transformers.StoppingCriteria.__call__",parameters:[{name:"input_ids",val:": LongTensor"},{name:"scores",val:": FloatTensor"},{name:"**kwargs",val:""}],parametersDescription:[{anchor:"transformers.StoppingCriteria.__call__.input_ids",description:`<strong>input_ids</strong> (<code>torch.LongTensor</code> of shape <code>(batch_size, sequence_length)</code>) &#x2014;
Indices of input sequence tokens in the vocabulary.</p>
<p>Indices can be obtained using <a href="/docs/transformers/pr_17574/en/model_doc/bert#transformers.BertTokenizer">BertTokenizer</a>. See <a href="/docs/transformers/pr_17574/en/internal/tokenization_utils#transformers.PreTrainedTokenizerBase.encode">PreTrainedTokenizer.encode()</a> and
<a href="/docs/transformers/pr_17574/en/model_doc/wav2vec2#transformers.Wav2Vec2CTCTokenizer.__call__">PreTrainedTokenizer.<strong>call</strong>()</a> for details.</p>
<p><a href="../glossary#input-ids">What are input IDs?</a>`,name:"input_ids"},{anchor:"transformers.StoppingCriteria.__call__.scores",description:`<strong>scores</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size, config.vocab_size)</code>) &#x2014;
Prediction scores of a language modeling head. These can be scores for each vocabulary token before SoftMax
or scores for each vocabulary token after SoftMax.
kwargs &#x2014;
Additional stopping criteria specific kwargs.`,name:"scores"}],source:"https://github.com/huggingface/transformers/blob/vr_17574/src/transformers/generation_stopping_criteria.py#L36",returnDescription:`
<p><code>bool</code>. <code>False</code> indicates we should continue, <code>True</code> indicates we should stop.</p>
`}}),en=new v({props:{name:"class transformers.StoppingCriteriaList",anchor:"transformers.StoppingCriteriaList",parameters:[{name:"iterable",val:" = ()"}],source:"https://github.com/huggingface/transformers/blob/vr_17574/src/transformers/generation_stopping_criteria.py#L110"}}),rn=new v({props:{name:"__call__",anchor:"transformers.StoppingCriteriaList.__call__",parameters:[{name:"input_ids",val:": LongTensor"},{name:"scores",val:": FloatTensor"},{name:"**kwargs",val:""}],parametersDescription:[{anchor:"transformers.StoppingCriteriaList.__call__.input_ids",description:`<strong>input_ids</strong> (<code>torch.LongTensor</code> of shape <code>(batch_size, sequence_length)</code>) &#x2014;
Indices of input sequence tokens in the vocabulary.</p>
<p>Indices can be obtained using <a href="/docs/transformers/pr_17574/en/model_doc/bert#transformers.BertTokenizer">BertTokenizer</a>. See <a href="/docs/transformers/pr_17574/en/internal/tokenization_utils#transformers.PreTrainedTokenizerBase.encode">PreTrainedTokenizer.encode()</a> and
<a href="/docs/transformers/pr_17574/en/model_doc/wav2vec2#transformers.Wav2Vec2CTCTokenizer.__call__">PreTrainedTokenizer.<strong>call</strong>()</a> for details.</p>
<p><a href="../glossary#input-ids">What are input IDs?</a>`,name:"input_ids"},{anchor:"transformers.StoppingCriteriaList.__call__.scores",description:`<strong>scores</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size, config.vocab_size)</code>) &#x2014;
Prediction scores of a language modeling head. These can be scores for each vocabulary token before SoftMax
or scores for each vocabulary token after SoftMax.
kwargs &#x2014;
Additional stopping criteria specific kwargs.`,name:"scores"}],source:"https://github.com/huggingface/transformers/blob/vr_17574/src/transformers/generation_stopping_criteria.py#L111",returnDescription:`
<p><code>bool</code>. <code>False</code> indicates we should continue, <code>True</code> indicates we should stop.</p>
`}}),tn=new v({props:{name:"class transformers.MaxLengthCriteria",anchor:"transformers.MaxLengthCriteria",parameters:[{name:"max_length",val:": int"}],parametersDescription:[{anchor:"transformers.MaxLengthCriteria.max_length",description:`<strong>max_length</strong> (<code>int</code>) &#x2014;
The maximum length that the output sequence can have in number of tokens.`,name:"max_length"}],source:"https://github.com/huggingface/transformers/blob/vr_17574/src/transformers/generation_stopping_criteria.py#L41"}}),nn=new v({props:{name:"__call__",anchor:"transformers.MaxLengthCriteria.__call__",parameters:[{name:"input_ids",val:": LongTensor"},{name:"scores",val:": FloatTensor"},{name:"**kwargs",val:""}],parametersDescription:[{anchor:"transformers.MaxLengthCriteria.__call__.input_ids",description:`<strong>input_ids</strong> (<code>torch.LongTensor</code> of shape <code>(batch_size, sequence_length)</code>) &#x2014;
Indices of input sequence tokens in the vocabulary.</p>
<p>Indices can be obtained using <a href="/docs/transformers/pr_17574/en/model_doc/bert#transformers.BertTokenizer">BertTokenizer</a>. See <a href="/docs/transformers/pr_17574/en/internal/tokenization_utils#transformers.PreTrainedTokenizerBase.encode">PreTrainedTokenizer.encode()</a> and
<a href="/docs/transformers/pr_17574/en/model_doc/wav2vec2#transformers.Wav2Vec2CTCTokenizer.__call__">PreTrainedTokenizer.<strong>call</strong>()</a> for details.</p>
<p><a href="../glossary#input-ids">What are input IDs?</a>`,name:"input_ids"},{anchor:"transformers.MaxLengthCriteria.__call__.scores",description:`<strong>scores</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size, config.vocab_size)</code>) &#x2014;
Prediction scores of a language modeling head. These can be scores for each vocabulary token before SoftMax
or scores for each vocabulary token after SoftMax.
kwargs &#x2014;
Additional stopping criteria specific kwargs.`,name:"scores"}],source:"https://github.com/huggingface/transformers/blob/vr_17574/src/transformers/generation_stopping_criteria.py#L54",returnDescription:`
<p><code>bool</code>. <code>False</code> indicates we should continue, <code>True</code> indicates we should stop.</p>
`}}),sn=new v({props:{name:"class transformers.MaxTimeCriteria",anchor:"transformers.MaxTimeCriteria",parameters:[{name:"max_time",val:": float"},{name:"initial_timestamp",val:": typing.Optional[float] = None"}],parametersDescription:[{anchor:"transformers.MaxTimeCriteria.max_time",description:`<strong>max_time</strong> (<code>float</code>) &#x2014;
The maximum allowed time in seconds for the generation.`,name:"max_time"},{anchor:"transformers.MaxTimeCriteria.initial_time",description:`<strong>initial_time</strong> (<code>float</code>, <em>optional</em>, defaults to <code>time.time()</code>) &#x2014;
The start of the generation allowed time.`,name:"initial_time"}],source:"https://github.com/huggingface/transformers/blob/vr_17574/src/transformers/generation_stopping_criteria.py#L88"}}),cn=new v({props:{name:"__call__",anchor:"transformers.MaxTimeCriteria.__call__",parameters:[{name:"input_ids",val:": LongTensor"},{name:"scores",val:": FloatTensor"},{name:"**kwargs",val:""}],parametersDescription:[{anchor:"transformers.MaxTimeCriteria.__call__.input_ids",description:`<strong>input_ids</strong> (<code>torch.LongTensor</code> of shape <code>(batch_size, sequence_length)</code>) &#x2014;
Indices of input sequence tokens in the vocabulary.</p>
<p>Indices can be obtained using <a href="/docs/transformers/pr_17574/en/model_doc/bert#transformers.BertTokenizer">BertTokenizer</a>. See <a href="/docs/transformers/pr_17574/en/internal/tokenization_utils#transformers.PreTrainedTokenizerBase.encode">PreTrainedTokenizer.encode()</a> and
<a href="/docs/transformers/pr_17574/en/model_doc/wav2vec2#transformers.Wav2Vec2CTCTokenizer.__call__">PreTrainedTokenizer.<strong>call</strong>()</a> for details.</p>
<p><a href="../glossary#input-ids">What are input IDs?</a>`,name:"input_ids"},{anchor:"transformers.MaxTimeCriteria.__call__.scores",description:`<strong>scores</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size, config.vocab_size)</code>) &#x2014;
Prediction scores of a language modeling head. These can be scores for each vocabulary token before SoftMax
or scores for each vocabulary token after SoftMax.
kwargs &#x2014;
Additional stopping criteria specific kwargs.`,name:"scores"}],source:"https://github.com/huggingface/transformers/blob/vr_17574/src/transformers/generation_stopping_criteria.py#L105",returnDescription:`
<p><code>bool</code>. <code>False</code> indicates we should continue, <code>True</code> indicates we should stop.</p>
`}}),ln=new Ie({}),dn=new v({props:{name:"class transformers.Constraint",anchor:"transformers.Constraint",parameters:[],source:"https://github.com/huggingface/transformers/blob/vr_17574/src/transformers/generation_beam_constraints.py#L5"}}),Gr=new v0({props:{anchor:"transformers.Constraint.example",$$slots:{default:[T0]},$$scope:{ctx:bd}}}),pn=new v({props:{name:"advance",anchor:"transformers.Constraint.advance",parameters:[],source:"https://github.com/huggingface/transformers/blob/vr_17574/src/transformers/generation_beam_constraints.py#L48",returnDescription:`
<p>Must be a tensor of a list of indexable tokens, not some integer.</p>
`,returnType:`
<p>token_ids(<code>torch.tensor</code>)</p>
`}}),mn=new v({props:{name:"copy",anchor:"transformers.Constraint.copy",parameters:[{name:"stateful",val:" = False"}],source:"https://github.com/huggingface/transformers/blob/vr_17574/src/transformers/generation_beam_constraints.py#L113",returnDescription:`
<p>The same constraint as the one being called from.</p>
`,returnType:`
<p>constraint(<code>Constraint</code>)</p>
`}}),fn=new v({props:{name:"does_advance",anchor:"transformers.Constraint.does_advance",parameters:[{name:"token_id",val:": int"}],source:"https://github.com/huggingface/transformers/blob/vr_17574/src/transformers/generation_beam_constraints.py#L60"}}),gn=new v({props:{name:"remaining",anchor:"transformers.Constraint.remaining",parameters:[],source:"https://github.com/huggingface/transformers/blob/vr_17574/src/transformers/generation_beam_constraints.py#L104"}}),hn=new v({props:{name:"reset",anchor:"transformers.Constraint.reset",parameters:[],source:"https://github.com/huggingface/transformers/blob/vr_17574/src/transformers/generation_beam_constraints.py#L94"}}),_n=new v({props:{name:"test",anchor:"transformers.Constraint.test",parameters:[],source:"https://github.com/huggingface/transformers/blob/vr_17574/src/transformers/generation_beam_constraints.py#L24"}}),bn=new v({props:{name:"update",anchor:"transformers.Constraint.update",parameters:[{name:"token_id",val:": int"}],source:"https://github.com/huggingface/transformers/blob/vr_17574/src/transformers/generation_beam_constraints.py#L69",returnDescription:`
<p>Whether this constraint has become one step closer to being fulfuilled.
completed(<code>bool</code>):
Whether this constraint has been completely fulfilled by this token being generated.
reset (<code>bool</code>):
Whether this constraint has reset its progress by this token being generated.</p>
`,returnType:`
<p>stepped(<code>bool</code>)</p>
`}}),Tn=new v({props:{name:"class transformers.PhrasalConstraint",anchor:"transformers.PhrasalConstraint",parameters:[{name:"token_ids",val:": typing.List[int]"}],parametersDescription:[{anchor:"transformers.PhrasalConstraint.token_ids",description:`<strong>token_ids</strong> (<code>List[int]</code>) &#x2014;
The id of the token that must be generated by the output.`,name:"token_ids"}],source:"https://github.com/huggingface/transformers/blob/vr_17574/src/transformers/generation_beam_constraints.py#L129"}}),$n=new v({props:{name:"class transformers.DisjunctiveConstraint",anchor:"transformers.DisjunctiveConstraint",parameters:[{name:"nested_token_ids",val:": typing.List[typing.List[int]]"}],parametersDescription:[{anchor:"transformers.DisjunctiveConstraint.nested_token_ids",description:"<strong>nested_token_ids</strong> (<code>List[List[int]]</code>) &#x2014; a list of words, where each word is a list of ids. This constraint",name:"nested_token_ids"},{anchor:"transformers.DisjunctiveConstraint.is",description:"<strong>is</strong> fulfilled by generating just one from the list of words. &#x2014;",name:"is"}],source:"https://github.com/huggingface/transformers/blob/vr_17574/src/transformers/generation_beam_constraints.py#L261"}}),kn=new v({props:{name:"class transformers.ConstraintListState",anchor:"transformers.ConstraintListState",parameters:[{name:"constraints",val:": typing.List[transformers.generation_beam_constraints.Constraint]"}],parametersDescription:[{anchor:"transformers.ConstraintListState.constraints",description:`<strong>constraints</strong> (<code>List[Constraint]</code>) &#x2014;
A list of <a href="/docs/transformers/pr_17574/en/internal/generation_utils#transformers.Constraint">Constraint</a> objects that must be fulfilled by the beam scorer.`,name:"constraints"}],source:"https://github.com/huggingface/transformers/blob/vr_17574/src/transformers/generation_beam_constraints.py#L350"}}),xn=new v({props:{name:"advance",anchor:"transformers.ConstraintListState.advance",parameters:[],source:"https://github.com/huggingface/transformers/blob/vr_17574/src/transformers/generation_beam_constraints.py#L382"}}),wn=new v({props:{name:"reset",anchor:"transformers.ConstraintListState.reset",parameters:[{name:"token_ids",val:": typing.Optional[typing.List[int]]"}],source:"https://github.com/huggingface/transformers/blob/vr_17574/src/transformers/generation_beam_constraints.py#L417"}}),Ln=new Ie({}),En=new v({props:{name:"class transformers.BeamScorer",anchor:"transformers.BeamScorer",parameters:[],source:"https://github.com/huggingface/transformers/blob/vr_17574/src/transformers/generation_beam_search.py#L88"}}),Pn=new v({props:{name:"process",anchor:"transformers.BeamScorer.process",parameters:[{name:"input_ids",val:": LongTensor"},{name:"next_scores",val:": FloatTensor"},{name:"next_tokens",val:": LongTensor"},{name:"next_indices",val:": LongTensor"},{name:"**kwargs",val:""}],parametersDescription:[{anchor:"transformers.BeamScorer.process.input_ids",description:`<strong>input_ids</strong> (<code>torch.LongTensor</code> of shape <code>(batch_size * num_beams, sequence_length)</code>) &#x2014;
Indices of input sequence tokens in the vocabulary.</p>
<p>Indices can be obtained using any class inheriting from <a href="/docs/transformers/pr_17574/en/main_classes/tokenizer#transformers.PreTrainedTokenizer">PreTrainedTokenizer</a>. See
<a href="/docs/transformers/pr_17574/en/internal/tokenization_utils#transformers.PreTrainedTokenizerBase.encode">PreTrainedTokenizer.encode()</a> and <a href="/docs/transformers/pr_17574/en/model_doc/wav2vec2#transformers.Wav2Vec2CTCTokenizer.__call__">PreTrainedTokenizer.<strong>call</strong>()</a> for details.</p>
<p><a href="../glossary#input-ids">What are input IDs?</a>`,name:"input_ids"},{anchor:"transformers.BeamScorer.process.next_scores",description:`<strong>next_scores</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size, 2 * num_beams)</code>) &#x2014;
Current scores of the top <code>2 * num_beams</code> non-finished beam hypotheses.`,name:"next_scores"},{anchor:"transformers.BeamScorer.process.next_tokens",description:`<strong>next_tokens</strong> (<code>torch.LongTensor</code> of shape <code>(batch_size, 2 * num_beams)</code>) &#x2014;
<code>input_ids</code> of the tokens corresponding to the top <code>2 * num_beams</code> non-finished beam hypotheses.`,name:"next_tokens"},{anchor:"transformers.BeamScorer.process.next_indices",description:`<strong>next_indices</strong> (<code>torch.LongTensor</code> of shape <code>(batch_size, 2 * num_beams)</code>) &#x2014;
Beam indices indicating to which beam hypothesis the <code>next_tokens</code> correspond.`,name:"next_indices"},{anchor:"transformers.BeamScorer.process.pad_token_id",description:`<strong>pad_token_id</strong> (<code>int</code>, <em>optional</em>) &#x2014;
The id of the <em>padding</em> token.`,name:"pad_token_id"},{anchor:"transformers.BeamScorer.process.eos_token_id",description:`<strong>eos_token_id</strong> (<code>int</code>, <em>optional</em>) &#x2014;
The id of the <em>end-of-sequence</em> token.`,name:"eos_token_id"}],source:"https://github.com/huggingface/transformers/blob/vr_17574/src/transformers/generation_beam_search.py#L94",returnDescription:`
<p>A dictionary composed of the fields as defined above:</p>
<ul>
<li><strong>next_beam_scores</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size * num_beams)</code>) \u2014 Updated scores of all
non-finished beams.</li>
<li><strong>next_beam_tokens</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size * num_beams)</code>) \u2014 Next tokens to be added
to the non-finished beam_hypotheses.</li>
<li><strong>next_beam_indices</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size * num_beams)</code>) \u2014 Beam indices
indicating to which beam the next tokens shall be added.</li>
</ul>
`,returnType:`
<p><code>UserDict</code></p>
`}}),Fn=new v({props:{name:"finalize",anchor:"transformers.BeamScorer.finalize",parameters:[{name:"input_ids",val:": LongTensor"},{name:"next_scores",val:": FloatTensor"},{name:"next_tokens",val:": LongTensor"},{name:"next_indices",val:": LongTensor"},{name:"max_length",val:": int"},{name:"**kwargs",val:""}],parametersDescription:[{anchor:"transformers.BeamScorer.finalize.input_ids",description:`<strong>input_ids</strong> (<code>torch.LongTensor</code> of shape <code>(batch_size * num_beams, sequence_length)</code>) &#x2014;
Indices of input sequence tokens in the vocabulary.</p>
<p>Indices can be obtained using any class inheriting from <a href="/docs/transformers/pr_17574/en/main_classes/tokenizer#transformers.PreTrainedTokenizer">PreTrainedTokenizer</a>. See
<a href="/docs/transformers/pr_17574/en/internal/tokenization_utils#transformers.PreTrainedTokenizerBase.encode">PreTrainedTokenizer.encode()</a> and <a href="/docs/transformers/pr_17574/en/model_doc/wav2vec2#transformers.Wav2Vec2CTCTokenizer.__call__">PreTrainedTokenizer.<strong>call</strong>()</a> for details.</p>
<p><a href="../glossary#input-ids">What are input IDs?</a>`,name:"input_ids"},{anchor:"transformers.BeamScorer.finalize.final_beam_scores",description:`<strong>final_beam_scores</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size * num_beams)</code>) &#x2014;
The final scores of all non-finished beams.`,name:"final_beam_scores"},{anchor:"transformers.BeamScorer.finalize.final_beam_tokens",description:`<strong>final_beam_tokens</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size * num_beams)</code>) &#x2014;
The last tokens to be added to the non-finished beam_hypotheses.`,name:"final_beam_tokens"},{anchor:"transformers.BeamScorer.finalize.final_beam_indices",description:`<strong>final_beam_indices</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size * num_beams)</code>) &#x2014;
The beam indices indicating to which beam the <code>final_beam_tokens</code> shall be added.`,name:"final_beam_indices"},{anchor:"transformers.BeamScorer.finalize.pad_token_id",description:`<strong>pad_token_id</strong> (<code>int</code>, <em>optional</em>) &#x2014;
The id of the <em>padding</em> token.`,name:"pad_token_id"},{anchor:"transformers.BeamScorer.finalize.eos_token_id",description:`<strong>eos_token_id</strong> (<code>int</code>, <em>optional</em>) &#x2014;
The id of the <em>end-of-sequence</em> token.`,name:"eos_token_id"}],source:"https://github.com/huggingface/transformers/blob/vr_17574/src/transformers/generation_beam_search.py#L106",returnDescription:`
<p>The generated sequences.
The second dimension (sequence_length) is either equal to <code>max_length</code> or shorter if all batches finished early
due to the <code>eos_token_id</code>.</p>
`,returnType:`
<p><code>torch.LongTensor</code> of shape <code>(batch_size * num_return_sequences, sequence_length)</code></p>
`}}),Dn=new v({props:{name:"class transformers.BeamSearchScorer",anchor:"transformers.BeamSearchScorer",parameters:[{name:"batch_size",val:": int"},{name:"num_beams",val:": int"},{name:"device",val:": device"},{name:"length_penalty",val:": typing.Optional[float] = 1.0"},{name:"do_early_stopping",val:": typing.Optional[bool] = False"},{name:"num_beam_hyps_to_keep",val:": typing.Optional[int] = 1"},{name:"num_beam_groups",val:": typing.Optional[int] = 1"},{name:"**kwargs",val:""}],parametersDescription:[{anchor:"transformers.BeamSearchScorer.batch_size",description:`<strong>batch_size</strong> (<code>int</code>) &#x2014;
Batch Size of <code>input_ids</code> for which standard beam search decoding is run in parallel.`,name:"batch_size"},{anchor:"transformers.BeamSearchScorer.max_length",description:`<strong>max_length</strong> (<code>int</code>) &#x2014;
The maximum length of the sequence to be generated.`,name:"max_length"},{anchor:"transformers.BeamSearchScorer.num_beams",description:`<strong>num_beams</strong> (<code>int</code>) &#x2014;
Number of beams for beam search.`,name:"num_beams"},{anchor:"transformers.BeamSearchScorer.device",description:`<strong>device</strong> (<code>torch.device</code>) &#x2014;
Defines the device type (<em>e.g.</em>, <code>&quot;cpu&quot;</code> or <code>&quot;cuda&quot;</code>) on which this instance of <code>BeamSearchScorer</code> will be
allocated.`,name:"device"},{anchor:"transformers.BeamSearchScorer.length_penalty",description:`<strong>length_penalty</strong> (<code>float</code>, <em>optional</em>, defaults to 1.0) &#x2014;
Exponential penalty to the length. 1.0 means no penalty. Set to values &lt; 1.0 in order to encourage the
model to generate shorter sequences, to a value &gt; 1.0 in order to encourage the model to produce longer
sequences.`,name:"length_penalty"},{anchor:"transformers.BeamSearchScorer.do_early_stopping",description:`<strong>do_early_stopping</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether to stop the beam search when at least <code>num_beams</code> sentences are finished per batch or not.`,name:"do_early_stopping"},{anchor:"transformers.BeamSearchScorer.num_beam_hyps_to_keep",description:`<strong>num_beam_hyps_to_keep</strong> (<code>int</code>, <em>optional</em>, defaults to 1) &#x2014;
The number of beam hypotheses that shall be returned upon calling
<code>finalize</code>.`,name:"num_beam_hyps_to_keep"},{anchor:"transformers.BeamSearchScorer.num_beam_groups",description:`<strong>num_beam_groups</strong> (<code>int</code>) &#x2014;
Number of groups to divide <code>num_beams</code> into in order to ensure diversity among different groups of beams.
See <a href="https://arxiv.org/pdf/1610.02424.pdf" rel="nofollow">this paper</a> for more details.`,name:"num_beam_groups"}],source:"https://github.com/huggingface/transformers/blob/vr_17574/src/transformers/generation_beam_search.py#L120"}}),qn=new v({props:{name:"process",anchor:"transformers.BeamSearchScorer.process",parameters:[{name:"input_ids",val:": LongTensor"},{name:"next_scores",val:": FloatTensor"},{name:"next_tokens",val:": LongTensor"},{name:"next_indices",val:": LongTensor"},{name:"pad_token_id",val:": typing.Optional[int] = None"},{name:"eos_token_id",val:": typing.Optional[int] = None"},{name:"beam_indices",val:": typing.Optional[torch.LongTensor] = None"}],source:"https://github.com/huggingface/transformers/blob/vr_17574/src/transformers/generation_beam_search.py#L207"}}),Bn=new v({props:{name:"finalize",anchor:"transformers.BeamSearchScorer.finalize",parameters:[{name:"input_ids",val:": LongTensor"},{name:"final_beam_scores",val:": FloatTensor"},{name:"final_beam_tokens",val:": LongTensor"},{name:"final_beam_indices",val:": LongTensor"},{name:"max_length",val:": int"},{name:"pad_token_id",val:": typing.Optional[int] = None"},{name:"eos_token_id",val:": typing.Optional[int] = None"},{name:"beam_indices",val:": typing.Optional[torch.LongTensor] = None"}],source:"https://github.com/huggingface/transformers/blob/vr_17574/src/transformers/generation_beam_search.py#L301"}}),In=new v({props:{name:"class transformers.ConstrainedBeamSearchScorer",anchor:"transformers.ConstrainedBeamSearchScorer",parameters:[{name:"batch_size",val:": int"},{name:"num_beams",val:": int"},{name:"constraints",val:": typing.List[transformers.generation_beam_constraints.Constraint]"},{name:"device",val:": device"},{name:"length_penalty",val:": typing.Optional[float] = 1.0"},{name:"do_early_stopping",val:": typing.Optional[bool] = False"},{name:"num_beam_hyps_to_keep",val:": typing.Optional[int] = 1"},{name:"num_beam_groups",val:": typing.Optional[int] = 1"},{name:"**kwargs",val:""}],parametersDescription:[{anchor:"transformers.ConstrainedBeamSearchScorer.batch_size",description:`<strong>batch_size</strong> (<code>int</code>) &#x2014;
Batch Size of <code>input_ids</code> for which standard beam search decoding is run in parallel.`,name:"batch_size"},{anchor:"transformers.ConstrainedBeamSearchScorer.max_length",description:`<strong>max_length</strong> (<code>int</code>) &#x2014;
The maximum length of the sequence to be generated.`,name:"max_length"},{anchor:"transformers.ConstrainedBeamSearchScorer.num_beams",description:`<strong>num_beams</strong> (<code>int</code>) &#x2014;
Number of beams for beam search.`,name:"num_beams"},{anchor:"transformers.ConstrainedBeamSearchScorer.constraints",description:`<strong>constraints</strong> (<code>List[Constraint]</code>) &#x2014;
A list of positive constraints represented as <code>Constraint</code> objects that must be fulfilled in the generation
output. For more information, the documentation of <a href="/docs/transformers/pr_17574/en/internal/generation_utils#transformers.Constraint">Constraint</a> should be read.`,name:"constraints"},{anchor:"transformers.ConstrainedBeamSearchScorer.device",description:`<strong>device</strong> (<code>torch.device</code>) &#x2014;
Defines the device type (<em>e.g.</em>, <code>&quot;cpu&quot;</code> or <code>&quot;cuda&quot;</code>) on which this instance of <code>BeamSearchScorer</code> will be
allocated.`,name:"device"},{anchor:"transformers.ConstrainedBeamSearchScorer.length_penalty",description:`<strong>length_penalty</strong> (<code>float</code>, <em>optional</em>, defaults to 1.0) &#x2014;
Exponential penalty to the length. 1.0 means no penalty. Set to values &lt; 1.0 in order to encourage the
model to generate shorter sequences, to a value &gt; 1.0 in order to encourage the model to produce longer
sequences.`,name:"length_penalty"},{anchor:"transformers.ConstrainedBeamSearchScorer.do_early_stopping",description:`<strong>do_early_stopping</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether to stop the beam search when at least <code>num_beams</code> sentences are finished per batch or not.`,name:"do_early_stopping"},{anchor:"transformers.ConstrainedBeamSearchScorer.num_beam_hyps_to_keep",description:`<strong>num_beam_hyps_to_keep</strong> (<code>int</code>, <em>optional</em>, defaults to 1) &#x2014;
The number of beam hypotheses that shall be returned upon calling
<code>finalize</code>.`,name:"num_beam_hyps_to_keep"},{anchor:"transformers.ConstrainedBeamSearchScorer.num_beam_groups",description:`<strong>num_beam_groups</strong> (<code>int</code>) &#x2014;
Number of groups to divide <code>num_beams</code> into in order to ensure diversity among different groups of beams.
See <a href="https://arxiv.org/pdf/1610.02424.pdf" rel="nofollow">this paper</a> for more details.`,name:"num_beam_groups"}],source:"https://github.com/huggingface/transformers/blob/vr_17574/src/transformers/generation_beam_search.py#L389"}}),Cn=new v({props:{name:"process",anchor:"transformers.ConstrainedBeamSearchScorer.process",parameters:[{name:"input_ids",val:": LongTensor"},{name:"next_scores",val:": FloatTensor"},{name:"next_tokens",val:": LongTensor"},{name:"next_indices",val:": LongTensor"},{name:"scores_for_all_vocab",val:": FloatTensor"},{name:"pad_token_id",val:": typing.Optional[int] = None"},{name:"eos_token_id",val:": typing.Optional[int] = None"}],parametersDescription:[{anchor:"transformers.ConstrainedBeamSearchScorer.process.input_ids",description:`<strong>input_ids</strong> (<code>torch.LongTensor</code> of shape <code>(batch_size * num_beams, sequence_length)</code>) &#x2014;
Indices of input sequence tokens in the vocabulary.</p>
<p>Indices can be obtained using any class inheriting from <a href="/docs/transformers/pr_17574/en/main_classes/tokenizer#transformers.PreTrainedTokenizer">PreTrainedTokenizer</a>. See
<a href="/docs/transformers/pr_17574/en/internal/tokenization_utils#transformers.PreTrainedTokenizerBase.encode">PreTrainedTokenizer.encode()</a> and <a href="/docs/transformers/pr_17574/en/model_doc/wav2vec2#transformers.Wav2Vec2CTCTokenizer.__call__">PreTrainedTokenizer.<strong>call</strong>()</a> for details.</p>
<p><a href="../glossary#input-ids">What are input IDs?</a>`,name:"input_ids"},{anchor:"transformers.ConstrainedBeamSearchScorer.process.next_scores",description:`<strong>next_scores</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size, 2 * num_beams)</code>) &#x2014;
Current scores of the top <code>2 * num_beams</code> non-finished beam hypotheses.`,name:"next_scores"},{anchor:"transformers.ConstrainedBeamSearchScorer.process.next_tokens",description:`<strong>next_tokens</strong> (<code>torch.LongTensor</code> of shape <code>(batch_size, 2 * num_beams)</code>) &#x2014;
<code>input_ids</code> of the tokens corresponding to the top <code>2 * num_beams</code> non-finished beam hypotheses.`,name:"next_tokens"},{anchor:"transformers.ConstrainedBeamSearchScorer.process.next_indices",description:`<strong>next_indices</strong> (<code>torch.LongTensor</code> of shape <code>(batch_size, 2 * num_beams)</code>) &#x2014;
Beam indices indicating to which beam hypothesis the <code>next_tokens</code> correspond.`,name:"next_indices"},{anchor:"transformers.ConstrainedBeamSearchScorer.process.scores_for_all_vocab",description:`<strong>scores_for_all_vocab</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size * num_beams, sequence_length)</code>) &#x2014;
The scores of all tokens in the vocabulary for each of the beam hypotheses.`,name:"scores_for_all_vocab"},{anchor:"transformers.ConstrainedBeamSearchScorer.process.pad_token_id",description:`<strong>pad_token_id</strong> (<code>int</code>, <em>optional</em>) &#x2014;
The id of the <em>padding</em> token.`,name:"pad_token_id"},{anchor:"transformers.ConstrainedBeamSearchScorer.process.eos_token_id",description:`<strong>eos_token_id</strong> (<code>int</code>, <em>optional</em>) &#x2014;
The id of the <em>end-of-sequence</em> token.`,name:"eos_token_id"}],source:"https://github.com/huggingface/transformers/blob/vr_17574/src/transformers/generation_beam_search.py#L484",returnDescription:`
<p>A dictionary composed of the fields as defined above:</p>
<ul>
<li>
<p><strong>next_beam_scores</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size * num_beams)</code>) \u2014 Updated scores of
all
non-finished beams.</p>
</li>
<li>
<p><strong>next_beam_tokens</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size * num_beams)</code>) \u2014 Next tokens to be
added
to the non-finished beam_hypotheses.</p>
</li>
<li>
<p><strong>next_beam_indices</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size * num_beams)</code>) \u2014 Beam indices
indicating to which beam the next tokens shall be added.</p>
</li>
</ul>
`,returnType:`
<p><code>UserDict</code></p>
`}}),Wn=new v({props:{name:"finalize",anchor:"transformers.ConstrainedBeamSearchScorer.finalize",parameters:[{name:"input_ids",val:": LongTensor"},{name:"final_beam_scores",val:": FloatTensor"},{name:"final_beam_tokens",val:": LongTensor"},{name:"final_beam_indices",val:": LongTensor"},{name:"max_length",val:": int"},{name:"pad_token_id",val:": typing.Optional[int] = None"},{name:"eos_token_id",val:": typing.Optional[int] = None"}],source:"https://github.com/huggingface/transformers/blob/vr_17574/src/transformers/generation_beam_search.py#L760"}}),An=new Ie({}),Nn=new v({props:{name:"transformers.top_k_top_p_filtering",anchor:"transformers.top_k_top_p_filtering",parameters:[{name:"logits",val:": FloatTensor"},{name:"top_k",val:": int = 0"},{name:"top_p",val:": float = 1.0"},{name:"filter_value",val:": float = -inf"},{name:"min_tokens_to_keep",val:": int = 1"}],parametersDescription:[{anchor:"transformers.top_k_top_p_filtering.top_k",description:`<strong>top_k</strong> (<code>int</code>, <em>optional</em>, defaults to 0) &#x2014;
If &gt; 0, only keep the top k tokens with highest probability (top-k filtering)`,name:"top_k"},{anchor:"transformers.top_k_top_p_filtering.top_p",description:`<strong>top_p</strong> (<code>float</code>, <em>optional</em>, defaults to 1.0) &#x2014;
If &lt; 1.0, only keep the top tokens with cumulative probability &gt;= top_p (nucleus filtering). Nucleus
filtering is described in Holtzman et al. (<a href="http://arxiv.org/abs/1904.09751" rel="nofollow">http://arxiv.org/abs/1904.09751</a>)`,name:"top_p"},{anchor:"transformers.top_k_top_p_filtering.min_tokens_to_keep",description:`<strong>min_tokens_to_keep</strong> (<code>int</code>, <em>optional</em>, defaults to 1) &#x2014;
Minimumber of tokens we keep per batch example in the output.`,name:"min_tokens_to_keep"}],source:"https://github.com/huggingface/transformers/blob/vr_17574/src/transformers/generation_utils.py#L3425"}}),Mn=new v({props:{name:"transformers.tf_top_k_top_p_filtering",anchor:"transformers.tf_top_k_top_p_filtering",parameters:[{name:"logits",val:""},{name:"top_k",val:" = 0"},{name:"top_p",val:" = 1.0"},{name:"filter_value",val:" = -inf"},{name:"min_tokens_to_keep",val:" = 1"}],parametersDescription:[{anchor:"transformers.tf_top_k_top_p_filtering.top_k",description:`<strong>top_k</strong> (<code>int</code>, <em>optional</em>, defaults to 0) &#x2014;
If &gt; 0, only keep the top k tokens with highest probability (top-k filtering)`,name:"top_k"},{anchor:"transformers.tf_top_k_top_p_filtering.top_p",description:`<strong>top_p</strong> (<code>float</code>, <em>optional</em>, defaults to 1.0) &#x2014;
If &lt; 1.0, only keep the top tokens with cumulative probability &gt;= top_p (nucleus filtering). Nucleus
filtering is described in Holtzman et al. (<a href="http://arxiv.org/abs/1904.09751" rel="nofollow">http://arxiv.org/abs/1904.09751</a>)`,name:"top_p"},{anchor:"transformers.tf_top_k_top_p_filtering.min_tokens_to_keep",description:`<strong>min_tokens_to_keep</strong> (<code>int</code>, <em>optional</em>, defaults to 1) &#x2014;
Minimumber of tokens we keep per batch example in the output.`,name:"min_tokens_to_keep"}],source:"https://github.com/huggingface/transformers/blob/vr_17574/src/transformers/generation_tf_utils.py#L3043"}}),{c(){w=o("meta"),He=c(),k=o("h1"),Ce=o("a"),cc=o("span"),f(st.$$.fragment),Rm=c(),lc=o("span"),Km=a("Utilities for Generation"),vd=c(),y=o("p"),Um=a("This page lists all the utility functions used by "),Rn=o("a"),Ym=a("generate()"),Xm=a(`,
`),Kn=o("a"),Jm=a("greedy_search()"),Qm=a(`,
`),Un=o("a"),Zm=a("sample()"),ef=a(`,
`),Yn=o("a"),rf=a("beam_search()"),tf=a(`,
`),Xn=o("a"),of=a("beam_sample()"),nf=a(`,
`),Jn=o("a"),sf=a("group_beam_search()"),af=a(`, and
`),Qn=o("a"),cf=a("constrained_beam_search()"),lf=a("."),Td=c(),Zn=o("p"),df=a("Most of those are only useful if you are studying the code of the generate methods in the library."),$d=c(),Re=o("h2"),_r=o("a"),dc=o("span"),f(at.$$.fragment),pf=c(),pc=o("span"),mf=a("Generate Outputs"),yd=c(),V=o("p"),ff=a("The output of "),es=o("a"),gf=a("generate()"),uf=a(` is an instance of a subclass of
`),rs=o("a"),hf=a("ModelOutput"),_f=a(`. This output is a data structure containing all the information returned
by `),ts=o("a"),bf=a("generate()"),vf=a(", but that can also be used as tuple or dictionary."),kd=c(),os=o("p"),Tf=a("Here\u2019s an example:"),xd=c(),f(it.$$.fragment),wd=c(),We=o("p"),$f=a("The "),mc=o("code"),yf=a("generation_output"),kf=a(" object is a "),ns=o("a"),xf=a("GreedySearchDecoderOnlyOutput"),wf=a(`, as we can
see in the documentation of that class below, it means it has the following attributes:`),Ld=c(),M=o("ul"),ss=o("li"),fc=o("code"),Lf=a("sequences"),Ef=a(": the generated sequences of tokens"),Pf=c(),as=o("li"),gc=o("code"),Ff=a("scores"),Df=a(" (optional): the prediction scores of the language modelling head, for each generation step"),zf=c(),is=o("li"),uc=o("code"),Sf=a("hidden_states"),Of=a(" (optional): the hidden states of the model, for each generation step"),qf=c(),cs=o("li"),hc=o("code"),Bf=a("attentions"),If=a(" (optional): the attention weights of the model, for each generation step"),Ed=c(),x=o("p"),Cf=a("Here we have the "),_c=o("code"),Wf=a("scores"),Af=a(" since we passed along "),bc=o("code"),Nf=a("output_scores=True"),Vf=a(", but we don\u2019t have "),vc=o("code"),Mf=a("hidden_states"),Gf=a(` and
`),Tc=o("code"),jf=a("attentions"),Hf=a(" because we didn\u2019t pass "),$c=o("code"),Rf=a("output_hidden_states=True"),Kf=a(" or "),yc=o("code"),Uf=a("output_attentions=True"),Yf=a("."),Pd=c(),z=o("p"),Xf=a(`You can access each attribute as you would usually do, and if that attribute has not been returned by the model, you
will get `),kc=o("code"),Jf=a("None"),Qf=a(". Here for instance "),xc=o("code"),Zf=a("generation_output.scores"),eg=a(` are all the generated prediction scores of the
language modeling head, and `),wc=o("code"),rg=a("generation_output.attentions"),tg=a(" is "),Lc=o("code"),og=a("None"),ng=a("."),Fd=c(),S=o("p"),sg=a("When using our "),Ec=o("code"),ag=a("generation_output"),ig=a(" object as a tuple, it only keeps the attributes that don\u2019t have "),Pc=o("code"),cg=a("None"),lg=a(` values.
Here, for instance, it has two elements, `),Fc=o("code"),dg=a("loss"),pg=a(" then "),Dc=o("code"),mg=a("logits"),fg=a(", so"),Dd=c(),f(ct.$$.fragment),zd=c(),br=o("p"),gg=a("will return the tuple "),zc=o("code"),ug=a("(generation_output.sequences, generation_output.scores)"),hg=a(" for instance."),Sd=c(),O=o("p"),_g=a("When using our "),Sc=o("code"),bg=a("generation_output"),vg=a(" object as a dictionary, it only keeps the attributes that don\u2019t have "),Oc=o("code"),Tg=a("None"),$g=a(`
values. Here, for instance, it has two keys that are `),qc=o("code"),yg=a("sequences"),kg=a(" and "),Bc=o("code"),xg=a("scores"),wg=a("."),Od=c(),ls=o("p"),Lg=a("We document here all output types."),qd=c(),Ke=o("h3"),vr=o("a"),Ic=o("span"),f(lt.$$.fragment),Eg=c(),Cc=o("span"),Pg=a("GreedySearchOutput"),Bd=c(),Ue=o("div"),f(dt.$$.fragment),Fg=c(),Wc=o("p"),Dg=a("Base class for outputs of decoder-only generation models using greedy search."),Id=c(),Ye=o("div"),f(pt.$$.fragment),zg=c(),Ac=o("p"),Sg=a(`Base class for outputs of encoder-decoder generation models using greedy search. Hidden states and attention
weights of the decoder (respectively the encoder) can be accessed via the encoder_attentions and the
encoder_hidden_states attributes (respectively the decoder_attentions and the decoder_hidden_states attributes)`),Cd=c(),R=o("div"),f(mt.$$.fragment),Og=c(),Nc=o("p"),qg=a("Flax Base class for outputs of decoder-only generation models using greedy search."),Bg=c(),Tr=o("div"),f(ft.$$.fragment),Ig=c(),Vc=o("p"),Cg=a("\u201CReturns a new object replacing the specified fields with new values."),Wd=c(),Xe=o("h3"),$r=o("a"),Mc=o("span"),f(gt.$$.fragment),Wg=c(),Gc=o("span"),Ag=a("SampleOutput"),Ad=c(),Je=o("div"),f(ut.$$.fragment),Ng=c(),jc=o("p"),Vg=a("Base class for outputs of decoder-only generation models using sampling."),Nd=c(),Qe=o("div"),f(ht.$$.fragment),Mg=c(),Hc=o("p"),Gg=a(`Base class for outputs of encoder-decoder generation models using sampling. Hidden states and attention weights of
the decoder (respectively the encoder) can be accessed via the encoder_attentions and the encoder_hidden_states
attributes (respectively the decoder_attentions and the decoder_hidden_states attributes)`),Vd=c(),K=o("div"),f(_t.$$.fragment),jg=c(),Rc=o("p"),Hg=a("Flax Base class for outputs of decoder-only generation models using sampling."),Rg=c(),yr=o("div"),f(bt.$$.fragment),Kg=c(),Kc=o("p"),Ug=a("\u201CReturns a new object replacing the specified fields with new values."),Md=c(),Ze=o("h3"),kr=o("a"),Uc=o("span"),f(vt.$$.fragment),Yg=c(),Yc=o("span"),Xg=a("BeamSearchOutput"),Gd=c(),er=o("div"),f(Tt.$$.fragment),Jg=c(),Xc=o("p"),Qg=a("Base class for outputs of decoder-only generation models using beam search."),jd=c(),rr=o("div"),f($t.$$.fragment),Zg=c(),Jc=o("p"),eu=a(`Base class for outputs of encoder-decoder generation models using beam search. Hidden states and attention weights
of the decoder (respectively the encoder) can be accessed via the encoder_attentions and the encoder_hidden_states
attributes (respectively the decoder_attentions and the decoder_hidden_states attributes)`),Hd=c(),tr=o("h3"),xr=o("a"),Qc=o("span"),f(yt.$$.fragment),ru=c(),Zc=o("span"),tu=a("BeamSampleOutput"),Rd=c(),or=o("div"),f(kt.$$.fragment),ou=c(),el=o("p"),nu=a("Base class for outputs of decoder-only generation models using beam sample."),Kd=c(),nr=o("div"),f(xt.$$.fragment),su=c(),rl=o("p"),au=a(`Base class for outputs of encoder-decoder generation models using beam sampling. Hidden states and attention
weights of the decoder (respectively the encoder) can be accessed via the encoder_attentions and the
encoder_hidden_states attributes (respectively the decoder_attentions and the decoder_hidden_states attributes)`),Ud=c(),sr=o("h2"),wr=o("a"),tl=o("span"),f(wt.$$.fragment),iu=c(),ol=o("span"),cu=a("LogitsProcessor"),Yd=c(),Lr=o("p"),lu=a("A "),ds=o("a"),du=a("LogitsProcessor"),pu=a(` can be used to modify the prediction scores of a language model head for
generation.`),Xd=c(),U=o("div"),f(Lt.$$.fragment),mu=c(),nl=o("p"),fu=a("Abstract base class for all logit processors that can be applied during generation."),gu=c(),Er=o("div"),f(Et.$$.fragment),uu=c(),sl=o("p"),hu=a("Torch method for processing logits."),Jd=c(),Y=o("div"),f(Pt.$$.fragment),_u=c(),L=o("p"),bu=a("This class can be used to create a list of "),ps=o("a"),vu=a("LogitsProcessor"),Tu=a(" or "),ms=o("a"),$u=a("LogitsWarper"),yu=a(` to subsequently process a
`),al=o("code"),ku=a("scores"),xu=a(" input tensor. This class inherits from list and adds a specific "),il=o("em"),cl=o("strong"),wu=a("call"),Lu=a(` method to apply each
`),fs=o("a"),Eu=a("LogitsProcessor"),Pu=a(" or "),gs=o("a"),Fu=a("LogitsWarper"),Du=a(" to the inputs."),zu=c(),us=o("div"),f(Ft.$$.fragment),Qd=c(),X=o("div"),f(Dt.$$.fragment),Su=c(),ll=o("p"),Ou=a("Abstract base class for all logit warpers that can be applied during generation with multinomial sampling."),qu=c(),Pr=o("div"),f(zt.$$.fragment),Bu=c(),dl=o("p"),Iu=a("Torch method for warping logits."),Zd=c(),J=o("div"),f(St.$$.fragment),Cu=c(),hs=o("p"),_s=o("a"),Wu=a("LogitsProcessor"),Au=a(" enforcing a min-length by setting EOS probability to 0."),Nu=c(),bs=o("div"),f(Ot.$$.fragment),ep=c(),Q=o("div"),f(qt.$$.fragment),Vu=c(),vs=o("p"),Ts=o("a"),Mu=a("LogitsWarper"),Gu=a(" for temperature (exponential scaling output probability distribution)."),ju=c(),$s=o("div"),f(Bt.$$.fragment),rp=c(),Z=o("div"),f(It.$$.fragment),Hu=c(),ys=o("p"),ks=o("a"),Ru=a("LogitsProcessor"),Ku=a(" enforcing an exponential penalty on repeated sequences."),Uu=c(),xs=o("div"),f(Ct.$$.fragment),tp=c(),ee=o("div"),f(Wt.$$.fragment),Yu=c(),ws=o("p"),Ls=o("a"),Xu=a("LogitsWarper"),Ju=a(" that performs top-p, i.e. restricting to top tokens summing to prob_cut_off <= prob_cut_off."),Qu=c(),Es=o("div"),f(At.$$.fragment),op=c(),re=o("div"),f(Nt.$$.fragment),Zu=c(),Ps=o("p"),Fs=o("a"),eh=a("LogitsWarper"),rh=a(" that performs top-k, i.e. restricting to the k highest probability elements."),th=c(),Ds=o("div"),f(Vt.$$.fragment),np=c(),ar=o("div"),f(Mt.$$.fragment),oh=c(),zs=o("div"),f(Gt.$$.fragment),sp=c(),te=o("div"),f(jt.$$.fragment),nh=c(),Fr=o("p"),Ss=o("a"),sh=a("LogitsProcessor"),ah=a(` that enforces no repetition of n-grams. See
`),Ht=o("a"),ih=a("Fairseq"),ch=a("."),lh=c(),Os=o("div"),f(Rt.$$.fragment),ap=c(),oe=o("div"),f(Kt.$$.fragment),dh=c(),qs=o("p"),Bs=o("a"),ph=a("LogitsProcessor"),mh=a(" that enforces that specified sequences will never be sampled."),fh=c(),Is=o("div"),f(Ut.$$.fragment),ip=c(),ne=o("div"),f(Yt.$$.fragment),gh=c(),Dr=o("p"),Cs=o("a"),uh=a("LogitsProcessor"),hh=a(` that enforces constrained generation and is useful for prefix-conditioned constrained
generation. See `),Xt=o("a"),_h=a("Autoregressive Entity Retrieval"),bh=a(" for more information."),vh=c(),Ws=o("div"),f(Jt.$$.fragment),cp=c(),se=o("div"),f(Qt.$$.fragment),Th=c(),Ae=o("p"),As=o("a"),$h=a("LogitsProcessor"),yh=a(` that enforces diverse beam search. Note that this logits processor is only effective for
`),Ns=o("a"),kh=a("PreTrainedModel.group_beam_search()"),xh=a(". See "),Zt=o("a"),wh=a(`Diverse Beam Search: Decoding Diverse Solutions from Neural Sequence
Models`),Lh=a(" for more details."),Eh=c(),Vs=o("div"),f(eo.$$.fragment),lp=c(),ae=o("div"),f(ro.$$.fragment),Ph=c(),Ms=o("p"),Gs=o("a"),Fh=a("LogitsProcessor"),Dh=a(" that enforces the specified token as the first generated token."),zh=c(),js=o("div"),f(to.$$.fragment),dp=c(),ie=o("div"),f(oo.$$.fragment),Sh=c(),zr=o("p"),Hs=o("a"),Oh=a("LogitsProcessor"),qh=a(" that enforces the specified token as the last generated token when "),pl=o("code"),Bh=a("max_length"),Ih=a(" is reached."),Ch=c(),Rs=o("div"),f(no.$$.fragment),pp=c(),ce=o("div"),f(so.$$.fragment),Wh=c(),G=o("p"),Ks=o("a"),Ah=a("LogitsProcessor"),Nh=a(" that removes all "),ml=o("code"),Vh=a("nan"),Mh=a(" and "),fl=o("code"),Gh=a("inf"),jh=a(` values to avoid the generation method to fail. Note that using
the logits processor should only be used if necessary since it can slow down the generation method. `),gl=o("code"),Hh=a("max_length"),Rh=a(` is
reached.`),Kh=c(),Us=o("div"),f(ao.$$.fragment),mp=c(),le=o("div"),f(io.$$.fragment),Uh=c(),ul=o("p"),Yh=a("Abstract base class for all logit processors that can be applied during generation."),Xh=c(),Sr=o("div"),f(co.$$.fragment),Jh=c(),hl=o("p"),Qh=a("TF method for processing logits."),fp=c(),de=o("div"),f(lo.$$.fragment),Zh=c(),C=o("p"),e_=a("This class can be used to create a list of "),Ys=o("a"),r_=a("TFLogitsProcessor"),t_=a(" to subsequently process a "),_l=o("code"),o_=a("scores"),n_=a(` input tensor.
This class inherits from list and adds a specific `),bl=o("em"),vl=o("strong"),s_=a("call"),a_=a(" method to apply each "),Xs=o("a"),i_=a("TFLogitsProcessor"),c_=a(` to the
inputs.`),l_=c(),Js=o("div"),f(po.$$.fragment),gp=c(),pe=o("div"),f(mo.$$.fragment),d_=c(),Tl=o("p"),p_=a("Abstract base class for all logit warpers that can be applied during generation with multinomial sampling."),m_=c(),Or=o("div"),f(fo.$$.fragment),f_=c(),$l=o("p"),g_=a("TF method for warping logits."),up=c(),me=o("div"),f(go.$$.fragment),u_=c(),Qs=o("p"),Zs=o("a"),h_=a("TFLogitsWarper"),__=a(" for temperature (exponential scaling output probability distribution)."),b_=c(),ea=o("div"),f(uo.$$.fragment),hp=c(),fe=o("div"),f(ho.$$.fragment),v_=c(),ra=o("p"),ta=o("a"),T_=a("TFLogitsWarper"),$_=a(" that performs top-p, i.e. restricting to top tokens summing to <= prob_cut_off."),y_=c(),oa=o("div"),f(_o.$$.fragment),_p=c(),ge=o("div"),f(bo.$$.fragment),k_=c(),na=o("p"),sa=o("a"),x_=a("TFLogitsWarper"),w_=a(" that performs top-k, i.e. restricting to the k highest probability elements."),L_=c(),aa=o("div"),f(vo.$$.fragment),bp=c(),ue=o("div"),f(To.$$.fragment),E_=c(),ia=o("p"),ca=o("a"),P_=a("TFLogitsProcessor"),F_=a(" enforcing a min-length by setting EOS probability to 0."),D_=c(),la=o("div"),f($o.$$.fragment),vp=c(),he=o("div"),f(yo.$$.fragment),z_=c(),da=o("p"),pa=o("a"),S_=a("TFLogitsProcessor"),O_=a(" that enforces that specified sequences will never be sampled."),q_=c(),ma=o("div"),f(ko.$$.fragment),Tp=c(),_e=o("div"),f(xo.$$.fragment),B_=c(),qr=o("p"),fa=o("a"),I_=a("TFLogitsProcessor"),C_=a(` that enforces no repetition of n-grams. See
`),wo=o("a"),W_=a("Fairseq"),A_=a("."),N_=c(),ga=o("div"),f(Lo.$$.fragment),$p=c(),be=o("div"),f(Eo.$$.fragment),V_=c(),ua=o("p"),ha=o("a"),M_=a("TFLogitsProcessor"),G_=a(" enforcing an exponential penalty on repeated sequences."),j_=c(),_a=o("div"),f(Po.$$.fragment),yp=c(),ve=o("div"),f(Fo.$$.fragment),H_=c(),ba=o("p"),va=o("a"),R_=a("TFLogitsProcessor"),K_=a(" that enforces the specified token as the first generated token."),U_=c(),Ta=o("div"),f(Do.$$.fragment),kp=c(),Te=o("div"),f(zo.$$.fragment),Y_=c(),Br=o("p"),$a=o("a"),X_=a("TFLogitsProcessor"),J_=a(" that enforces the specified token as the last generated token when "),yl=o("code"),Q_=a("max_length"),Z_=a(" is reached."),eb=c(),ya=o("div"),f(So.$$.fragment),xp=c(),$e=o("div"),f(Oo.$$.fragment),rb=c(),kl=o("p"),tb=a("Abstract base class for all logit processors that can be applied during generation."),ob=c(),Ir=o("div"),f(qo.$$.fragment),nb=c(),xl=o("p"),sb=a("Flax method for processing logits."),wp=c(),ye=o("div"),f(Bo.$$.fragment),ab=c(),E=o("p"),ib=a("This class can be used to create a list of "),ka=o("a"),cb=a("FlaxLogitsProcessor"),lb=a(" or "),xa=o("a"),db=a("FlaxLogitsWarper"),pb=a(` to subsequently process
a `),wl=o("code"),mb=a("scores"),fb=a(" input tensor. This class inherits from list and adds a specific "),Ll=o("em"),El=o("strong"),gb=a("call"),ub=a(` method to apply each
`),wa=o("a"),hb=a("FlaxLogitsProcessor"),_b=a(" or "),La=o("a"),bb=a("FlaxLogitsWarper"),vb=a(" to the inputs."),Tb=c(),Ea=o("div"),f(Io.$$.fragment),Lp=c(),ke=o("div"),f(Co.$$.fragment),$b=c(),Pl=o("p"),yb=a("Abstract base class for all logit warpers that can be applied during generation with multinomial sampling."),kb=c(),Cr=o("div"),f(Wo.$$.fragment),xb=c(),Fl=o("p"),wb=a("Flax method for warping logits."),Ep=c(),xe=o("div"),f(Ao.$$.fragment),Lb=c(),Pa=o("p"),Fa=o("a"),Eb=a("FlaxLogitsWarper"),Pb=a(" for temperature (exponential scaling output probability distribution)."),Fb=c(),Da=o("div"),f(No.$$.fragment),Pp=c(),we=o("div"),f(Vo.$$.fragment),Db=c(),za=o("p"),Sa=o("a"),zb=a("FlaxLogitsWarper"),Sb=a(" that performs top-p, i.e. restricting to top tokens summing to prob_cut_off <= prob_cut_off."),Ob=c(),Oa=o("div"),f(Mo.$$.fragment),Fp=c(),Le=o("div"),f(Go.$$.fragment),qb=c(),qa=o("p"),Ba=o("a"),Bb=a("FlaxLogitsWarper"),Ib=a(" that performs top-k, i.e. restricting to the k highest probability elements."),Cb=c(),Ia=o("div"),f(jo.$$.fragment),Dp=c(),Ee=o("div"),f(Ho.$$.fragment),Wb=c(),Ca=o("p"),Wa=o("a"),Ab=a("FlaxLogitsProcessor"),Nb=a(" that enforces the specified token as the first generated token."),Vb=c(),Aa=o("div"),f(Ro.$$.fragment),zp=c(),Pe=o("div"),f(Ko.$$.fragment),Mb=c(),Wr=o("p"),Na=o("a"),Gb=a("FlaxLogitsProcessor"),jb=a(" that enforces the specified token as the last generated token when "),Dl=o("code"),Hb=a("max_length"),Rb=a(" is reached."),Kb=c(),Va=o("div"),f(Uo.$$.fragment),Sp=c(),Fe=o("div"),f(Yo.$$.fragment),Ub=c(),Ma=o("p"),Ga=o("a"),Yb=a("FlaxLogitsProcessor"),Xb=a(" enforcing a min-length by setting EOS probability to 0."),Jb=c(),ja=o("div"),f(Xo.$$.fragment),Op=c(),ir=o("h2"),Ar=o("a"),zl=o("span"),f(Jo.$$.fragment),Qb=c(),Sl=o("span"),Zb=a("StoppingCriteria"),qp=c(),Nr=o("p"),ev=a("A "),Ha=o("a"),rv=a("StoppingCriteria"),tv=a(" can be used to change when to stop generation (other than EOS token)."),Bp=c(),De=o("div"),f(Qo.$$.fragment),ov=c(),Ol=o("p"),nv=a("Abstract base class for all stopping criteria that can be applied during generation."),sv=c(),Ra=o("div"),f(Zo.$$.fragment),Ip=c(),cr=o("div"),f(en.$$.fragment),av=c(),Ka=o("div"),f(rn.$$.fragment),Cp=c(),ze=o("div"),f(tn.$$.fragment),iv=c(),on=o("p"),cv=a("This class can be used to stop generation whenever the full generated number of tokens exceeds "),ql=o("code"),lv=a("max_length"),dv=a(`. Keep
in mind for decoder-only type of transformers, this will include the initial prompted tokens.`),pv=c(),Ua=o("div"),f(nn.$$.fragment),Wp=c(),Se=o("div"),f(sn.$$.fragment),mv=c(),an=o("p"),fv=a(`This class can be used to stop generation whenever the full generation exceeds some amount of time. By default, the
time will start being counted when you initialize this function. You can override this by passing an
`),Bl=o("code"),gv=a("initial_time"),uv=a("."),hv=c(),Ya=o("div"),f(cn.$$.fragment),Ap=c(),lr=o("h2"),Vr=o("a"),Il=o("span"),f(ln.$$.fragment),_v=c(),Cl=o("span"),bv=a("Constraints"),Np=c(),Mr=o("p"),vv=a("A "),Xa=o("a"),Tv=a("Constraint"),$v=a(" can be used to force the generation to include specific tokens or sequences in the output."),Vp=c(),T=o("div"),f(dn.$$.fragment),yv=c(),Wl=o("p"),kv=a(`Abstract base class for all constraints that can be applied during generation.
It must define how the constraint can be satisfied.`),xv=c(),Al=o("p"),wv=a("All classes that inherit Constraint must follow the requirement that"),Lv=c(),f(Gr.$$.fragment),Ev=c(),Nl=o("p"),Pv=a("will always terminate (halt)."),Fv=c(),jr=o("div"),f(pn.$$.fragment),Dv=c(),Vl=o("p"),zv=a("When called, returns the token that would take this constraint one step closer to being fulfilled."),Sv=c(),Hr=o("div"),f(mn.$$.fragment),Ov=c(),Ml=o("p"),qv=a("Creates a new instance of this constraint."),Bv=c(),Rr=o("div"),f(fn.$$.fragment),Iv=c(),Gl=o("p"),Cv=a("Reads in a token and returns whether it creates progress."),Wv=c(),Kr=o("div"),f(gn.$$.fragment),Av=c(),un=o("p"),Nv=a("Returns the number of remaining steps of "),jl=o("code"),Vv=a("advance()"),Mv=a(" in order to complete this constraint."),Gv=c(),Ur=o("div"),f(hn.$$.fragment),jv=c(),Hl=o("p"),Hv=a(`Resets the state of this constraint to its initialization. We would call this in cases where the fulfillment of
a constraint is abrupted by an unwanted token.`),Rv=c(),Yr=o("div"),f(_n.$$.fragment),Kv=c(),Rl=o("p"),Uv=a("Tests whether this constraint has been properly defined."),Yv=c(),Ne=o("div"),f(bn.$$.fragment),Xv=c(),vn=o("p"),Jv=a(`Reads in a token and returns booleans that indicate the progress made by it. This function will update the
state of this object unlikes `),Kl=o("code"),Qv=a("does_advance(self, token_id: int)"),Zv=a("."),e1=c(),Ul=o("p"),r1=a(`This isn\u2019t to test whether a certain token will advance the progress; it\u2019s to update its state as if it has
been generated. This becomes important if token_id != desired token (refer to else statement in
PhrasalConstraint)`),Mp=c(),dr=o("div"),f(Tn.$$.fragment),t1=c(),Ja=o("p"),Qa=o("a"),o1=a("Constraint"),n1=a(" enforcing that an ordered sequence of tokens is included in the output."),Gp=c(),pr=o("div"),f($n.$$.fragment),s1=c(),yn=o("p"),a1=a("A special "),Za=o("a"),i1=a("Constraint"),c1=a(" that is fulfilled by fulfilling just one of several constraints."),jp=c(),W=o("div"),f(kn.$$.fragment),l1=c(),Yl=o("p"),d1=a("A class for beam scorers to track its progress through a list of constraints."),p1=c(),F=o("div"),f(xn.$$.fragment),m1=c(),Xl=o("p"),f1=a(`The list of tokens to generate such that we can make progress.
By \u201Clist\u201D we don\u2019t mean the list of token that will fully fulfill a constraint.`),g1=c(),mr=o("p"),u1=a("Given constraints "),Jl=o("code"),h1=a("c_i = {t_ij | j == # of tokens}"),_1=a(`, If we\u2019re not in the middle of progressing through a
specific constraint `),Ql=o("code"),b1=a("c_i"),v1=a(", we return:"),T1=c(),Zl=o("p"),ed=o("code"),$1=a("[t_k1 for k in indices of unfulfilled constraints]"),y1=c(),Oe=o("p"),k1=a(`If we are in the middle of a constraint, then we return:
`),rd=o("code"),x1=a("[t_ij]"),w1=a(", where "),td=o("code"),L1=a("i"),E1=a(" is the index of the inprogress constraint, "),od=o("code"),P1=a("j"),F1=a(" is the next step for the constraint."),D1=c(),nd=o("p"),z1=a(`Though we don\u2019t care which constraint is fulfilled first, if we are in the progress of fulfilling a constraint,
that\u2019s the only one we\u2019ll return.`),S1=c(),Xr=o("div"),f(wn.$$.fragment),O1=c(),sd=o("p"),q1=a("token_ids: the tokens generated thus far to reset the state of the progress through constraints."),Hp=c(),fr=o("h2"),Jr=o("a"),ad=o("span"),f(Ln.$$.fragment),B1=c(),id=o("span"),I1=a("BeamSearch"),Rp=c(),A=o("div"),f(En.$$.fragment),C1=c(),gr=o("p"),W1=a("Abstract base class for all beam scorers that are used for "),ei=o("a"),A1=a("beam_search()"),N1=a(` and
`),ri=o("a"),V1=a("beam_sample()"),M1=a("."),G1=c(),ti=o("div"),f(Pn.$$.fragment),j1=c(),oi=o("div"),f(Fn.$$.fragment),Kp=c(),P=o("div"),f(Dn.$$.fragment),H1=c(),ni=o("p"),si=o("a"),R1=a("BeamScorer"),K1=a(" implementing standard beam search decoding."),U1=c(),zn=o("p"),Y1=a("Adapted in part from "),Sn=o("a"),X1=a(`Facebook\u2019s XLM beam search
code`),J1=a("."),Q1=c(),ai=o("p"),Z1=a("Reference for the diverse beam search algorithm and implementation "),On=o("a"),eT=a(`Ashwin Kalyan\u2019s DBS
implementation`),rT=c(),ii=o("div"),f(qn.$$.fragment),tT=c(),ci=o("div"),f(Bn.$$.fragment),Up=c(),N=o("div"),f(In.$$.fragment),oT=c(),li=o("p"),di=o("a"),nT=a("BeamScorer"),sT=a(" implementing constrained beam search decoding."),aT=c(),pi=o("div"),f(Cn.$$.fragment),iT=c(),mi=o("div"),f(Wn.$$.fragment),Yp=c(),ur=o("h2"),Qr=o("a"),cd=o("span"),f(An.$$.fragment),cT=c(),ld=o("span"),lT=a("Utilities"),Xp=c(),qe=o("div"),f(Nn.$$.fragment),dT=c(),dd=o("p"),pT=a("Filter a distribution of logits using top-k and/or nucleus (top-p) filtering"),mT=c(),fi=o("p"),fT=a("From: "),Vn=o("a"),gT=a("https://gist.github.com/thomwolf/1a5a29f6962089e871b94cbd09daf317"),Jp=c(),Be=o("div"),f(Mn.$$.fragment),uT=c(),pd=o("p"),hT=a("Filter a distribution of logits using top-k and/or nucleus (top-p) filtering"),_T=c(),gi=o("p"),bT=a("From: "),Gn=o("a"),vT=a("https://gist.github.com/thomwolf/1a5a29f6962089e871b94cbd09daf317"),this.h()},l(e){const p=h0('[data-svelte="svelte-1phssyn"]',document.head);w=n(p,"META",{name:!0,content:!0}),p.forEach(t),He=l(e),k=n(e,"H1",{class:!0});var jn=s(k);Ce=n(jn,"A",{id:!0,class:!0,href:!0});var XT=s(Ce);cc=n(XT,"SPAN",{});var JT=s(cc);g(st.$$.fragment,JT),JT.forEach(t),XT.forEach(t),Rm=l(jn),lc=n(jn,"SPAN",{});var QT=s(lc);Km=i(QT,"Utilities for Generation"),QT.forEach(t),jn.forEach(t),vd=l(e),y=n(e,"P",{});var D=s(y);Um=i(D,"This page lists all the utility functions used by "),Rn=n(D,"A",{href:!0});var ZT=s(Rn);Ym=i(ZT,"generate()"),ZT.forEach(t),Xm=i(D,`,
`),Kn=n(D,"A",{href:!0});var e$=s(Kn);Jm=i(e$,"greedy_search()"),e$.forEach(t),Qm=i(D,`,
`),Un=n(D,"A",{href:!0});var r$=s(Un);Zm=i(r$,"sample()"),r$.forEach(t),ef=i(D,`,
`),Yn=n(D,"A",{href:!0});var t$=s(Yn);rf=i(t$,"beam_search()"),t$.forEach(t),tf=i(D,`,
`),Xn=n(D,"A",{href:!0});var o$=s(Xn);of=i(o$,"beam_sample()"),o$.forEach(t),nf=i(D,`,
`),Jn=n(D,"A",{href:!0});var n$=s(Jn);sf=i(n$,"group_beam_search()"),n$.forEach(t),af=i(D,`, and
`),Qn=n(D,"A",{href:!0});var s$=s(Qn);cf=i(s$,"constrained_beam_search()"),s$.forEach(t),lf=i(D,"."),D.forEach(t),Td=l(e),Zn=n(e,"P",{});var a$=s(Zn);df=i(a$,"Most of those are only useful if you are studying the code of the generate methods in the library."),a$.forEach(t),$d=l(e),Re=n(e,"H2",{class:!0});var Zp=s(Re);_r=n(Zp,"A",{id:!0,class:!0,href:!0});var i$=s(_r);dc=n(i$,"SPAN",{});var c$=s(dc);g(at.$$.fragment,c$),c$.forEach(t),i$.forEach(t),pf=l(Zp),pc=n(Zp,"SPAN",{});var l$=s(pc);mf=i(l$,"Generate Outputs"),l$.forEach(t),Zp.forEach(t),yd=l(e),V=n(e,"P",{});var Zr=s(V);ff=i(Zr,"The output of "),es=n(Zr,"A",{href:!0});var d$=s(es);gf=i(d$,"generate()"),d$.forEach(t),uf=i(Zr,` is an instance of a subclass of
`),rs=n(Zr,"A",{href:!0});var p$=s(rs);hf=i(p$,"ModelOutput"),p$.forEach(t),_f=i(Zr,`. This output is a data structure containing all the information returned
by `),ts=n(Zr,"A",{href:!0});var m$=s(ts);bf=i(m$,"generate()"),m$.forEach(t),vf=i(Zr,", but that can also be used as tuple or dictionary."),Zr.forEach(t),kd=l(e),os=n(e,"P",{});var f$=s(os);Tf=i(f$,"Here\u2019s an example:"),f$.forEach(t),xd=l(e),g(it.$$.fragment,e),wd=l(e),We=n(e,"P",{});var ui=s(We);$f=i(ui,"The "),mc=n(ui,"CODE",{});var g$=s(mc);yf=i(g$,"generation_output"),g$.forEach(t),kf=i(ui," object is a "),ns=n(ui,"A",{href:!0});var u$=s(ns);xf=i(u$,"GreedySearchDecoderOnlyOutput"),u$.forEach(t),wf=i(ui,`, as we can
see in the documentation of that class below, it means it has the following attributes:`),ui.forEach(t),Ld=l(e),M=n(e,"UL",{});var et=s(M);ss=n(et,"LI",{});var TT=s(ss);fc=n(TT,"CODE",{});var h$=s(fc);Lf=i(h$,"sequences"),h$.forEach(t),Ef=i(TT,": the generated sequences of tokens"),TT.forEach(t),Pf=l(et),as=n(et,"LI",{});var $T=s(as);gc=n($T,"CODE",{});var _$=s(gc);Ff=i(_$,"scores"),_$.forEach(t),Df=i($T," (optional): the prediction scores of the language modelling head, for each generation step"),$T.forEach(t),zf=l(et),is=n(et,"LI",{});var yT=s(is);uc=n(yT,"CODE",{});var b$=s(uc);Sf=i(b$,"hidden_states"),b$.forEach(t),Of=i(yT," (optional): the hidden states of the model, for each generation step"),yT.forEach(t),qf=l(et),cs=n(et,"LI",{});var kT=s(cs);hc=n(kT,"CODE",{});var v$=s(hc);Bf=i(v$,"attentions"),v$.forEach(t),If=i(kT," (optional): the attention weights of the model, for each generation step"),kT.forEach(t),et.forEach(t),Ed=l(e),x=n(e,"P",{});var q=s(x);Cf=i(q,"Here we have the "),_c=n(q,"CODE",{});var T$=s(_c);Wf=i(T$,"scores"),T$.forEach(t),Af=i(q," since we passed along "),bc=n(q,"CODE",{});var $$=s(bc);Nf=i($$,"output_scores=True"),$$.forEach(t),Vf=i(q,", but we don\u2019t have "),vc=n(q,"CODE",{});var y$=s(vc);Mf=i(y$,"hidden_states"),y$.forEach(t),Gf=i(q,` and
`),Tc=n(q,"CODE",{});var k$=s(Tc);jf=i(k$,"attentions"),k$.forEach(t),Hf=i(q," because we didn\u2019t pass "),$c=n(q,"CODE",{});var x$=s($c);Rf=i(x$,"output_hidden_states=True"),x$.forEach(t),Kf=i(q," or "),yc=n(q,"CODE",{});var w$=s(yc);Uf=i(w$,"output_attentions=True"),w$.forEach(t),Yf=i(q,"."),q.forEach(t),Pd=l(e),z=n(e,"P",{});var Ve=s(z);Xf=i(Ve,`You can access each attribute as you would usually do, and if that attribute has not been returned by the model, you
will get `),kc=n(Ve,"CODE",{});var L$=s(kc);Jf=i(L$,"None"),L$.forEach(t),Qf=i(Ve,". Here for instance "),xc=n(Ve,"CODE",{});var E$=s(xc);Zf=i(E$,"generation_output.scores"),E$.forEach(t),eg=i(Ve,` are all the generated prediction scores of the
language modeling head, and `),wc=n(Ve,"CODE",{});var P$=s(wc);rg=i(P$,"generation_output.attentions"),P$.forEach(t),tg=i(Ve," is "),Lc=n(Ve,"CODE",{});var F$=s(Lc);og=i(F$,"None"),F$.forEach(t),ng=i(Ve,"."),Ve.forEach(t),Fd=l(e),S=n(e,"P",{});var Me=s(S);sg=i(Me,"When using our "),Ec=n(Me,"CODE",{});var D$=s(Ec);ag=i(D$,"generation_output"),D$.forEach(t),ig=i(Me," object as a tuple, it only keeps the attributes that don\u2019t have "),Pc=n(Me,"CODE",{});var z$=s(Pc);cg=i(z$,"None"),z$.forEach(t),lg=i(Me,` values.
Here, for instance, it has two elements, `),Fc=n(Me,"CODE",{});var S$=s(Fc);dg=i(S$,"loss"),S$.forEach(t),pg=i(Me," then "),Dc=n(Me,"CODE",{});var O$=s(Dc);mg=i(O$,"logits"),O$.forEach(t),fg=i(Me,", so"),Me.forEach(t),Dd=l(e),g(ct.$$.fragment,e),zd=l(e),br=n(e,"P",{});var em=s(br);gg=i(em,"will return the tuple "),zc=n(em,"CODE",{});var q$=s(zc);ug=i(q$,"(generation_output.sequences, generation_output.scores)"),q$.forEach(t),hg=i(em," for instance."),em.forEach(t),Sd=l(e),O=n(e,"P",{});var Ge=s(O);_g=i(Ge,"When using our "),Sc=n(Ge,"CODE",{});var B$=s(Sc);bg=i(B$,"generation_output"),B$.forEach(t),vg=i(Ge," object as a dictionary, it only keeps the attributes that don\u2019t have "),Oc=n(Ge,"CODE",{});var I$=s(Oc);Tg=i(I$,"None"),I$.forEach(t),$g=i(Ge,`
values. Here, for instance, it has two keys that are `),qc=n(Ge,"CODE",{});var C$=s(qc);yg=i(C$,"sequences"),C$.forEach(t),kg=i(Ge," and "),Bc=n(Ge,"CODE",{});var W$=s(Bc);xg=i(W$,"scores"),W$.forEach(t),wg=i(Ge,"."),Ge.forEach(t),Od=l(e),ls=n(e,"P",{});var A$=s(ls);Lg=i(A$,"We document here all output types."),A$.forEach(t),qd=l(e),Ke=n(e,"H3",{class:!0});var rm=s(Ke);vr=n(rm,"A",{id:!0,class:!0,href:!0});var N$=s(vr);Ic=n(N$,"SPAN",{});var V$=s(Ic);g(lt.$$.fragment,V$),V$.forEach(t),N$.forEach(t),Eg=l(rm),Cc=n(rm,"SPAN",{});var M$=s(Cc);Pg=i(M$,"GreedySearchOutput"),M$.forEach(t),rm.forEach(t),Bd=l(e),Ue=n(e,"DIV",{class:!0});var tm=s(Ue);g(dt.$$.fragment,tm),Fg=l(tm),Wc=n(tm,"P",{});var G$=s(Wc);Dg=i(G$,"Base class for outputs of decoder-only generation models using greedy search."),G$.forEach(t),tm.forEach(t),Id=l(e),Ye=n(e,"DIV",{class:!0});var om=s(Ye);g(pt.$$.fragment,om),zg=l(om),Ac=n(om,"P",{});var j$=s(Ac);Sg=i(j$,`Base class for outputs of encoder-decoder generation models using greedy search. Hidden states and attention
weights of the decoder (respectively the encoder) can be accessed via the encoder_attentions and the
encoder_hidden_states attributes (respectively the decoder_attentions and the decoder_hidden_states attributes)`),j$.forEach(t),om.forEach(t),Cd=l(e),R=n(e,"DIV",{class:!0});var hi=s(R);g(mt.$$.fragment,hi),Og=l(hi),Nc=n(hi,"P",{});var H$=s(Nc);qg=i(H$,"Flax Base class for outputs of decoder-only generation models using greedy search."),H$.forEach(t),Bg=l(hi),Tr=n(hi,"DIV",{class:!0});var nm=s(Tr);g(ft.$$.fragment,nm),Ig=l(nm),Vc=n(nm,"P",{});var R$=s(Vc);Cg=i(R$,"\u201CReturns a new object replacing the specified fields with new values."),R$.forEach(t),nm.forEach(t),hi.forEach(t),Wd=l(e),Xe=n(e,"H3",{class:!0});var sm=s(Xe);$r=n(sm,"A",{id:!0,class:!0,href:!0});var K$=s($r);Mc=n(K$,"SPAN",{});var U$=s(Mc);g(gt.$$.fragment,U$),U$.forEach(t),K$.forEach(t),Wg=l(sm),Gc=n(sm,"SPAN",{});var Y$=s(Gc);Ag=i(Y$,"SampleOutput"),Y$.forEach(t),sm.forEach(t),Ad=l(e),Je=n(e,"DIV",{class:!0});var am=s(Je);g(ut.$$.fragment,am),Ng=l(am),jc=n(am,"P",{});var X$=s(jc);Vg=i(X$,"Base class for outputs of decoder-only generation models using sampling."),X$.forEach(t),am.forEach(t),Nd=l(e),Qe=n(e,"DIV",{class:!0});var im=s(Qe);g(ht.$$.fragment,im),Mg=l(im),Hc=n(im,"P",{});var J$=s(Hc);Gg=i(J$,`Base class for outputs of encoder-decoder generation models using sampling. Hidden states and attention weights of
the decoder (respectively the encoder) can be accessed via the encoder_attentions and the encoder_hidden_states
attributes (respectively the decoder_attentions and the decoder_hidden_states attributes)`),J$.forEach(t),im.forEach(t),Vd=l(e),K=n(e,"DIV",{class:!0});var _i=s(K);g(_t.$$.fragment,_i),jg=l(_i),Rc=n(_i,"P",{});var Q$=s(Rc);Hg=i(Q$,"Flax Base class for outputs of decoder-only generation models using sampling."),Q$.forEach(t),Rg=l(_i),yr=n(_i,"DIV",{class:!0});var cm=s(yr);g(bt.$$.fragment,cm),Kg=l(cm),Kc=n(cm,"P",{});var Z$=s(Kc);Ug=i(Z$,"\u201CReturns a new object replacing the specified fields with new values."),Z$.forEach(t),cm.forEach(t),_i.forEach(t),Md=l(e),Ze=n(e,"H3",{class:!0});var lm=s(Ze);kr=n(lm,"A",{id:!0,class:!0,href:!0});var e2=s(kr);Uc=n(e2,"SPAN",{});var r2=s(Uc);g(vt.$$.fragment,r2),r2.forEach(t),e2.forEach(t),Yg=l(lm),Yc=n(lm,"SPAN",{});var t2=s(Yc);Xg=i(t2,"BeamSearchOutput"),t2.forEach(t),lm.forEach(t),Gd=l(e),er=n(e,"DIV",{class:!0});var dm=s(er);g(Tt.$$.fragment,dm),Jg=l(dm),Xc=n(dm,"P",{});var o2=s(Xc);Qg=i(o2,"Base class for outputs of decoder-only generation models using beam search."),o2.forEach(t),dm.forEach(t),jd=l(e),rr=n(e,"DIV",{class:!0});var pm=s(rr);g($t.$$.fragment,pm),Zg=l(pm),Jc=n(pm,"P",{});var n2=s(Jc);eu=i(n2,`Base class for outputs of encoder-decoder generation models using beam search. Hidden states and attention weights
of the decoder (respectively the encoder) can be accessed via the encoder_attentions and the encoder_hidden_states
attributes (respectively the decoder_attentions and the decoder_hidden_states attributes)`),n2.forEach(t),pm.forEach(t),Hd=l(e),tr=n(e,"H3",{class:!0});var mm=s(tr);xr=n(mm,"A",{id:!0,class:!0,href:!0});var s2=s(xr);Qc=n(s2,"SPAN",{});var a2=s(Qc);g(yt.$$.fragment,a2),a2.forEach(t),s2.forEach(t),ru=l(mm),Zc=n(mm,"SPAN",{});var i2=s(Zc);tu=i(i2,"BeamSampleOutput"),i2.forEach(t),mm.forEach(t),Rd=l(e),or=n(e,"DIV",{class:!0});var fm=s(or);g(kt.$$.fragment,fm),ou=l(fm),el=n(fm,"P",{});var c2=s(el);nu=i(c2,"Base class for outputs of decoder-only generation models using beam sample."),c2.forEach(t),fm.forEach(t),Kd=l(e),nr=n(e,"DIV",{class:!0});var gm=s(nr);g(xt.$$.fragment,gm),su=l(gm),rl=n(gm,"P",{});var l2=s(rl);au=i(l2,`Base class for outputs of encoder-decoder generation models using beam sampling. Hidden states and attention
weights of the decoder (respectively the encoder) can be accessed via the encoder_attentions and the
encoder_hidden_states attributes (respectively the decoder_attentions and the decoder_hidden_states attributes)`),l2.forEach(t),gm.forEach(t),Ud=l(e),sr=n(e,"H2",{class:!0});var um=s(sr);wr=n(um,"A",{id:!0,class:!0,href:!0});var d2=s(wr);tl=n(d2,"SPAN",{});var p2=s(tl);g(wt.$$.fragment,p2),p2.forEach(t),d2.forEach(t),iu=l(um),ol=n(um,"SPAN",{});var m2=s(ol);cu=i(m2,"LogitsProcessor"),m2.forEach(t),um.forEach(t),Yd=l(e),Lr=n(e,"P",{});var hm=s(Lr);lu=i(hm,"A "),ds=n(hm,"A",{href:!0});var f2=s(ds);du=i(f2,"LogitsProcessor"),f2.forEach(t),pu=i(hm,` can be used to modify the prediction scores of a language model head for
generation.`),hm.forEach(t),Xd=l(e),U=n(e,"DIV",{class:!0});var bi=s(U);g(Lt.$$.fragment,bi),mu=l(bi),nl=n(bi,"P",{});var g2=s(nl);fu=i(g2,"Abstract base class for all logit processors that can be applied during generation."),g2.forEach(t),gu=l(bi),Er=n(bi,"DIV",{class:!0});var _m=s(Er);g(Et.$$.fragment,_m),uu=l(_m),sl=n(_m,"P",{});var u2=s(sl);hu=i(u2,"Torch method for processing logits."),u2.forEach(t),_m.forEach(t),bi.forEach(t),Jd=l(e),Y=n(e,"DIV",{class:!0});var vi=s(Y);g(Pt.$$.fragment,vi),_u=l(vi),L=n(vi,"P",{});var B=s(L);bu=i(B,"This class can be used to create a list of "),ps=n(B,"A",{href:!0});var h2=s(ps);vu=i(h2,"LogitsProcessor"),h2.forEach(t),Tu=i(B," or "),ms=n(B,"A",{href:!0});var _2=s(ms);$u=i(_2,"LogitsWarper"),_2.forEach(t),yu=i(B,` to subsequently process a
`),al=n(B,"CODE",{});var b2=s(al);ku=i(b2,"scores"),b2.forEach(t),xu=i(B," input tensor. This class inherits from list and adds a specific "),il=n(B,"EM",{});var v2=s(il);cl=n(v2,"STRONG",{});var T2=s(cl);wu=i(T2,"call"),T2.forEach(t),v2.forEach(t),Lu=i(B,` method to apply each
`),fs=n(B,"A",{href:!0});var $2=s(fs);Eu=i($2,"LogitsProcessor"),$2.forEach(t),Pu=i(B," or "),gs=n(B,"A",{href:!0});var y2=s(gs);Fu=i(y2,"LogitsWarper"),y2.forEach(t),Du=i(B," to the inputs."),B.forEach(t),zu=l(vi),us=n(vi,"DIV",{class:!0});var k2=s(us);g(Ft.$$.fragment,k2),k2.forEach(t),vi.forEach(t),Qd=l(e),X=n(e,"DIV",{class:!0});var Ti=s(X);g(Dt.$$.fragment,Ti),Su=l(Ti),ll=n(Ti,"P",{});var x2=s(ll);Ou=i(x2,"Abstract base class for all logit warpers that can be applied during generation with multinomial sampling."),x2.forEach(t),qu=l(Ti),Pr=n(Ti,"DIV",{class:!0});var bm=s(Pr);g(zt.$$.fragment,bm),Bu=l(bm),dl=n(bm,"P",{});var w2=s(dl);Iu=i(w2,"Torch method for warping logits."),w2.forEach(t),bm.forEach(t),Ti.forEach(t),Zd=l(e),J=n(e,"DIV",{class:!0});var $i=s(J);g(St.$$.fragment,$i),Cu=l($i),hs=n($i,"P",{});var xT=s(hs);_s=n(xT,"A",{href:!0});var L2=s(_s);Wu=i(L2,"LogitsProcessor"),L2.forEach(t),Au=i(xT," enforcing a min-length by setting EOS probability to 0."),xT.forEach(t),Nu=l($i),bs=n($i,"DIV",{class:!0});var E2=s(bs);g(Ot.$$.fragment,E2),E2.forEach(t),$i.forEach(t),ep=l(e),Q=n(e,"DIV",{class:!0});var yi=s(Q);g(qt.$$.fragment,yi),Vu=l(yi),vs=n(yi,"P",{});var wT=s(vs);Ts=n(wT,"A",{href:!0});var P2=s(Ts);Mu=i(P2,"LogitsWarper"),P2.forEach(t),Gu=i(wT," for temperature (exponential scaling output probability distribution)."),wT.forEach(t),ju=l(yi),$s=n(yi,"DIV",{class:!0});var F2=s($s);g(Bt.$$.fragment,F2),F2.forEach(t),yi.forEach(t),rp=l(e),Z=n(e,"DIV",{class:!0});var ki=s(Z);g(It.$$.fragment,ki),Hu=l(ki),ys=n(ki,"P",{});var LT=s(ys);ks=n(LT,"A",{href:!0});var D2=s(ks);Ru=i(D2,"LogitsProcessor"),D2.forEach(t),Ku=i(LT," enforcing an exponential penalty on repeated sequences."),LT.forEach(t),Uu=l(ki),xs=n(ki,"DIV",{class:!0});var z2=s(xs);g(Ct.$$.fragment,z2),z2.forEach(t),ki.forEach(t),tp=l(e),ee=n(e,"DIV",{class:!0});var xi=s(ee);g(Wt.$$.fragment,xi),Yu=l(xi),ws=n(xi,"P",{});var ET=s(ws);Ls=n(ET,"A",{href:!0});var S2=s(Ls);Xu=i(S2,"LogitsWarper"),S2.forEach(t),Ju=i(ET," that performs top-p, i.e. restricting to top tokens summing to prob_cut_off <= prob_cut_off."),ET.forEach(t),Qu=l(xi),Es=n(xi,"DIV",{class:!0});var O2=s(Es);g(At.$$.fragment,O2),O2.forEach(t),xi.forEach(t),op=l(e),re=n(e,"DIV",{class:!0});var wi=s(re);g(Nt.$$.fragment,wi),Zu=l(wi),Ps=n(wi,"P",{});var PT=s(Ps);Fs=n(PT,"A",{href:!0});var q2=s(Fs);eh=i(q2,"LogitsWarper"),q2.forEach(t),rh=i(PT," that performs top-k, i.e. restricting to the k highest probability elements."),PT.forEach(t),th=l(wi),Ds=n(wi,"DIV",{class:!0});var B2=s(Ds);g(Vt.$$.fragment,B2),B2.forEach(t),wi.forEach(t),np=l(e),ar=n(e,"DIV",{class:!0});var vm=s(ar);g(Mt.$$.fragment,vm),oh=l(vm),zs=n(vm,"DIV",{class:!0});var I2=s(zs);g(Gt.$$.fragment,I2),I2.forEach(t),vm.forEach(t),sp=l(e),te=n(e,"DIV",{class:!0});var Li=s(te);g(jt.$$.fragment,Li),nh=l(Li),Fr=n(Li,"P",{});var md=s(Fr);Ss=n(md,"A",{href:!0});var C2=s(Ss);sh=i(C2,"LogitsProcessor"),C2.forEach(t),ah=i(md,` that enforces no repetition of n-grams. See
`),Ht=n(md,"A",{href:!0,rel:!0});var W2=s(Ht);ih=i(W2,"Fairseq"),W2.forEach(t),ch=i(md,"."),md.forEach(t),lh=l(Li),Os=n(Li,"DIV",{class:!0});var A2=s(Os);g(Rt.$$.fragment,A2),A2.forEach(t),Li.forEach(t),ap=l(e),oe=n(e,"DIV",{class:!0});var Ei=s(oe);g(Kt.$$.fragment,Ei),dh=l(Ei),qs=n(Ei,"P",{});var FT=s(qs);Bs=n(FT,"A",{href:!0});var N2=s(Bs);ph=i(N2,"LogitsProcessor"),N2.forEach(t),mh=i(FT," that enforces that specified sequences will never be sampled."),FT.forEach(t),fh=l(Ei),Is=n(Ei,"DIV",{class:!0});var V2=s(Is);g(Ut.$$.fragment,V2),V2.forEach(t),Ei.forEach(t),ip=l(e),ne=n(e,"DIV",{class:!0});var Pi=s(ne);g(Yt.$$.fragment,Pi),gh=l(Pi),Dr=n(Pi,"P",{});var fd=s(Dr);Cs=n(fd,"A",{href:!0});var M2=s(Cs);uh=i(M2,"LogitsProcessor"),M2.forEach(t),hh=i(fd,` that enforces constrained generation and is useful for prefix-conditioned constrained
generation. See `),Xt=n(fd,"A",{href:!0,rel:!0});var G2=s(Xt);_h=i(G2,"Autoregressive Entity Retrieval"),G2.forEach(t),bh=i(fd," for more information."),fd.forEach(t),vh=l(Pi),Ws=n(Pi,"DIV",{class:!0});var j2=s(Ws);g(Jt.$$.fragment,j2),j2.forEach(t),Pi.forEach(t),cp=l(e),se=n(e,"DIV",{class:!0});var Fi=s(se);g(Qt.$$.fragment,Fi),Th=l(Fi),Ae=n(Fi,"P",{});var Hn=s(Ae);As=n(Hn,"A",{href:!0});var H2=s(As);$h=i(H2,"LogitsProcessor"),H2.forEach(t),yh=i(Hn,` that enforces diverse beam search. Note that this logits processor is only effective for
`),Ns=n(Hn,"A",{href:!0});var R2=s(Ns);kh=i(R2,"PreTrainedModel.group_beam_search()"),R2.forEach(t),xh=i(Hn,". See "),Zt=n(Hn,"A",{href:!0,rel:!0});var K2=s(Zt);wh=i(K2,`Diverse Beam Search: Decoding Diverse Solutions from Neural Sequence
Models`),K2.forEach(t),Lh=i(Hn," for more details."),Hn.forEach(t),Eh=l(Fi),Vs=n(Fi,"DIV",{class:!0});var U2=s(Vs);g(eo.$$.fragment,U2),U2.forEach(t),Fi.forEach(t),lp=l(e),ae=n(e,"DIV",{class:!0});var Di=s(ae);g(ro.$$.fragment,Di),Ph=l(Di),Ms=n(Di,"P",{});var DT=s(Ms);Gs=n(DT,"A",{href:!0});var Y2=s(Gs);Fh=i(Y2,"LogitsProcessor"),Y2.forEach(t),Dh=i(DT," that enforces the specified token as the first generated token."),DT.forEach(t),zh=l(Di),js=n(Di,"DIV",{class:!0});var X2=s(js);g(to.$$.fragment,X2),X2.forEach(t),Di.forEach(t),dp=l(e),ie=n(e,"DIV",{class:!0});var zi=s(ie);g(oo.$$.fragment,zi),Sh=l(zi),zr=n(zi,"P",{});var gd=s(zr);Hs=n(gd,"A",{href:!0});var J2=s(Hs);Oh=i(J2,"LogitsProcessor"),J2.forEach(t),qh=i(gd," that enforces the specified token as the last generated token when "),pl=n(gd,"CODE",{});var Q2=s(pl);Bh=i(Q2,"max_length"),Q2.forEach(t),Ih=i(gd," is reached."),gd.forEach(t),Ch=l(zi),Rs=n(zi,"DIV",{class:!0});var Z2=s(Rs);g(no.$$.fragment,Z2),Z2.forEach(t),zi.forEach(t),pp=l(e),ce=n(e,"DIV",{class:!0});var Si=s(ce);g(so.$$.fragment,Si),Wh=l(Si),G=n(Si,"P",{});var hr=s(G);Ks=n(hr,"A",{href:!0});var ey=s(Ks);Ah=i(ey,"LogitsProcessor"),ey.forEach(t),Nh=i(hr," that removes all "),ml=n(hr,"CODE",{});var ry=s(ml);Vh=i(ry,"nan"),ry.forEach(t),Mh=i(hr," and "),fl=n(hr,"CODE",{});var ty=s(fl);Gh=i(ty,"inf"),ty.forEach(t),jh=i(hr,` values to avoid the generation method to fail. Note that using
the logits processor should only be used if necessary since it can slow down the generation method. `),gl=n(hr,"CODE",{});var oy=s(gl);Hh=i(oy,"max_length"),oy.forEach(t),Rh=i(hr,` is
reached.`),hr.forEach(t),Kh=l(Si),Us=n(Si,"DIV",{class:!0});var ny=s(Us);g(ao.$$.fragment,ny),ny.forEach(t),Si.forEach(t),mp=l(e),le=n(e,"DIV",{class:!0});var Oi=s(le);g(io.$$.fragment,Oi),Uh=l(Oi),ul=n(Oi,"P",{});var sy=s(ul);Yh=i(sy,"Abstract base class for all logit processors that can be applied during generation."),sy.forEach(t),Xh=l(Oi),Sr=n(Oi,"DIV",{class:!0});var Tm=s(Sr);g(co.$$.fragment,Tm),Jh=l(Tm),hl=n(Tm,"P",{});var ay=s(hl);Qh=i(ay,"TF method for processing logits."),ay.forEach(t),Tm.forEach(t),Oi.forEach(t),fp=l(e),de=n(e,"DIV",{class:!0});var qi=s(de);g(lo.$$.fragment,qi),Zh=l(qi),C=n(qi,"P",{});var je=s(C);e_=i(je,"This class can be used to create a list of "),Ys=n(je,"A",{href:!0});var iy=s(Ys);r_=i(iy,"TFLogitsProcessor"),iy.forEach(t),t_=i(je," to subsequently process a "),_l=n(je,"CODE",{});var cy=s(_l);o_=i(cy,"scores"),cy.forEach(t),n_=i(je,` input tensor.
This class inherits from list and adds a specific `),bl=n(je,"EM",{});var ly=s(bl);vl=n(ly,"STRONG",{});var dy=s(vl);s_=i(dy,"call"),dy.forEach(t),ly.forEach(t),a_=i(je," method to apply each "),Xs=n(je,"A",{href:!0});var py=s(Xs);i_=i(py,"TFLogitsProcessor"),py.forEach(t),c_=i(je,` to the
inputs.`),je.forEach(t),l_=l(qi),Js=n(qi,"DIV",{class:!0});var my=s(Js);g(po.$$.fragment,my),my.forEach(t),qi.forEach(t),gp=l(e),pe=n(e,"DIV",{class:!0});var Bi=s(pe);g(mo.$$.fragment,Bi),d_=l(Bi),Tl=n(Bi,"P",{});var fy=s(Tl);p_=i(fy,"Abstract base class for all logit warpers that can be applied during generation with multinomial sampling."),fy.forEach(t),m_=l(Bi),Or=n(Bi,"DIV",{class:!0});var $m=s(Or);g(fo.$$.fragment,$m),f_=l($m),$l=n($m,"P",{});var gy=s($l);g_=i(gy,"TF method for warping logits."),gy.forEach(t),$m.forEach(t),Bi.forEach(t),up=l(e),me=n(e,"DIV",{class:!0});var Ii=s(me);g(go.$$.fragment,Ii),u_=l(Ii),Qs=n(Ii,"P",{});var zT=s(Qs);Zs=n(zT,"A",{href:!0});var uy=s(Zs);h_=i(uy,"TFLogitsWarper"),uy.forEach(t),__=i(zT," for temperature (exponential scaling output probability distribution)."),zT.forEach(t),b_=l(Ii),ea=n(Ii,"DIV",{class:!0});var hy=s(ea);g(uo.$$.fragment,hy),hy.forEach(t),Ii.forEach(t),hp=l(e),fe=n(e,"DIV",{class:!0});var Ci=s(fe);g(ho.$$.fragment,Ci),v_=l(Ci),ra=n(Ci,"P",{});var ST=s(ra);ta=n(ST,"A",{href:!0});var _y=s(ta);T_=i(_y,"TFLogitsWarper"),_y.forEach(t),$_=i(ST," that performs top-p, i.e. restricting to top tokens summing to <= prob_cut_off."),ST.forEach(t),y_=l(Ci),oa=n(Ci,"DIV",{class:!0});var by=s(oa);g(_o.$$.fragment,by),by.forEach(t),Ci.forEach(t),_p=l(e),ge=n(e,"DIV",{class:!0});var Wi=s(ge);g(bo.$$.fragment,Wi),k_=l(Wi),na=n(Wi,"P",{});var OT=s(na);sa=n(OT,"A",{href:!0});var vy=s(sa);x_=i(vy,"TFLogitsWarper"),vy.forEach(t),w_=i(OT," that performs top-k, i.e. restricting to the k highest probability elements."),OT.forEach(t),L_=l(Wi),aa=n(Wi,"DIV",{class:!0});var Ty=s(aa);g(vo.$$.fragment,Ty),Ty.forEach(t),Wi.forEach(t),bp=l(e),ue=n(e,"DIV",{class:!0});var Ai=s(ue);g(To.$$.fragment,Ai),E_=l(Ai),ia=n(Ai,"P",{});var qT=s(ia);ca=n(qT,"A",{href:!0});var $y=s(ca);P_=i($y,"TFLogitsProcessor"),$y.forEach(t),F_=i(qT," enforcing a min-length by setting EOS probability to 0."),qT.forEach(t),D_=l(Ai),la=n(Ai,"DIV",{class:!0});var yy=s(la);g($o.$$.fragment,yy),yy.forEach(t),Ai.forEach(t),vp=l(e),he=n(e,"DIV",{class:!0});var Ni=s(he);g(yo.$$.fragment,Ni),z_=l(Ni),da=n(Ni,"P",{});var BT=s(da);pa=n(BT,"A",{href:!0});var ky=s(pa);S_=i(ky,"TFLogitsProcessor"),ky.forEach(t),O_=i(BT," that enforces that specified sequences will never be sampled."),BT.forEach(t),q_=l(Ni),ma=n(Ni,"DIV",{class:!0});var xy=s(ma);g(ko.$$.fragment,xy),xy.forEach(t),Ni.forEach(t),Tp=l(e),_e=n(e,"DIV",{class:!0});var Vi=s(_e);g(xo.$$.fragment,Vi),B_=l(Vi),qr=n(Vi,"P",{});var ud=s(qr);fa=n(ud,"A",{href:!0});var wy=s(fa);I_=i(wy,"TFLogitsProcessor"),wy.forEach(t),C_=i(ud,` that enforces no repetition of n-grams. See
`),wo=n(ud,"A",{href:!0,rel:!0});var Ly=s(wo);W_=i(Ly,"Fairseq"),Ly.forEach(t),A_=i(ud,"."),ud.forEach(t),N_=l(Vi),ga=n(Vi,"DIV",{class:!0});var Ey=s(ga);g(Lo.$$.fragment,Ey),Ey.forEach(t),Vi.forEach(t),$p=l(e),be=n(e,"DIV",{class:!0});var Mi=s(be);g(Eo.$$.fragment,Mi),V_=l(Mi),ua=n(Mi,"P",{});var IT=s(ua);ha=n(IT,"A",{href:!0});var Py=s(ha);M_=i(Py,"TFLogitsProcessor"),Py.forEach(t),G_=i(IT," enforcing an exponential penalty on repeated sequences."),IT.forEach(t),j_=l(Mi),_a=n(Mi,"DIV",{class:!0});var Fy=s(_a);g(Po.$$.fragment,Fy),Fy.forEach(t),Mi.forEach(t),yp=l(e),ve=n(e,"DIV",{class:!0});var Gi=s(ve);g(Fo.$$.fragment,Gi),H_=l(Gi),ba=n(Gi,"P",{});var CT=s(ba);va=n(CT,"A",{href:!0});var Dy=s(va);R_=i(Dy,"TFLogitsProcessor"),Dy.forEach(t),K_=i(CT," that enforces the specified token as the first generated token."),CT.forEach(t),U_=l(Gi),Ta=n(Gi,"DIV",{class:!0});var zy=s(Ta);g(Do.$$.fragment,zy),zy.forEach(t),Gi.forEach(t),kp=l(e),Te=n(e,"DIV",{class:!0});var ji=s(Te);g(zo.$$.fragment,ji),Y_=l(ji),Br=n(ji,"P",{});var hd=s(Br);$a=n(hd,"A",{href:!0});var Sy=s($a);X_=i(Sy,"TFLogitsProcessor"),Sy.forEach(t),J_=i(hd," that enforces the specified token as the last generated token when "),yl=n(hd,"CODE",{});var Oy=s(yl);Q_=i(Oy,"max_length"),Oy.forEach(t),Z_=i(hd," is reached."),hd.forEach(t),eb=l(ji),ya=n(ji,"DIV",{class:!0});var qy=s(ya);g(So.$$.fragment,qy),qy.forEach(t),ji.forEach(t),xp=l(e),$e=n(e,"DIV",{class:!0});var Hi=s($e);g(Oo.$$.fragment,Hi),rb=l(Hi),kl=n(Hi,"P",{});var By=s(kl);tb=i(By,"Abstract base class for all logit processors that can be applied during generation."),By.forEach(t),ob=l(Hi),Ir=n(Hi,"DIV",{class:!0});var ym=s(Ir);g(qo.$$.fragment,ym),nb=l(ym),xl=n(ym,"P",{});var Iy=s(xl);sb=i(Iy,"Flax method for processing logits."),Iy.forEach(t),ym.forEach(t),Hi.forEach(t),wp=l(e),ye=n(e,"DIV",{class:!0});var Ri=s(ye);g(Bo.$$.fragment,Ri),ab=l(Ri),E=n(Ri,"P",{});var I=s(E);ib=i(I,"This class can be used to create a list of "),ka=n(I,"A",{href:!0});var Cy=s(ka);cb=i(Cy,"FlaxLogitsProcessor"),Cy.forEach(t),lb=i(I," or "),xa=n(I,"A",{href:!0});var Wy=s(xa);db=i(Wy,"FlaxLogitsWarper"),Wy.forEach(t),pb=i(I,` to subsequently process
a `),wl=n(I,"CODE",{});var Ay=s(wl);mb=i(Ay,"scores"),Ay.forEach(t),fb=i(I," input tensor. This class inherits from list and adds a specific "),Ll=n(I,"EM",{});var Ny=s(Ll);El=n(Ny,"STRONG",{});var Vy=s(El);gb=i(Vy,"call"),Vy.forEach(t),Ny.forEach(t),ub=i(I,` method to apply each
`),wa=n(I,"A",{href:!0});var My=s(wa);hb=i(My,"FlaxLogitsProcessor"),My.forEach(t),_b=i(I," or "),La=n(I,"A",{href:!0});var Gy=s(La);bb=i(Gy,"FlaxLogitsWarper"),Gy.forEach(t),vb=i(I," to the inputs."),I.forEach(t),Tb=l(Ri),Ea=n(Ri,"DIV",{class:!0});var jy=s(Ea);g(Io.$$.fragment,jy),jy.forEach(t),Ri.forEach(t),Lp=l(e),ke=n(e,"DIV",{class:!0});var Ki=s(ke);g(Co.$$.fragment,Ki),$b=l(Ki),Pl=n(Ki,"P",{});var Hy=s(Pl);yb=i(Hy,"Abstract base class for all logit warpers that can be applied during generation with multinomial sampling."),Hy.forEach(t),kb=l(Ki),Cr=n(Ki,"DIV",{class:!0});var km=s(Cr);g(Wo.$$.fragment,km),xb=l(km),Fl=n(km,"P",{});var Ry=s(Fl);wb=i(Ry,"Flax method for warping logits."),Ry.forEach(t),km.forEach(t),Ki.forEach(t),Ep=l(e),xe=n(e,"DIV",{class:!0});var Ui=s(xe);g(Ao.$$.fragment,Ui),Lb=l(Ui),Pa=n(Ui,"P",{});var WT=s(Pa);Fa=n(WT,"A",{href:!0});var Ky=s(Fa);Eb=i(Ky,"FlaxLogitsWarper"),Ky.forEach(t),Pb=i(WT," for temperature (exponential scaling output probability distribution)."),WT.forEach(t),Fb=l(Ui),Da=n(Ui,"DIV",{class:!0});var Uy=s(Da);g(No.$$.fragment,Uy),Uy.forEach(t),Ui.forEach(t),Pp=l(e),we=n(e,"DIV",{class:!0});var Yi=s(we);g(Vo.$$.fragment,Yi),Db=l(Yi),za=n(Yi,"P",{});var AT=s(za);Sa=n(AT,"A",{href:!0});var Yy=s(Sa);zb=i(Yy,"FlaxLogitsWarper"),Yy.forEach(t),Sb=i(AT," that performs top-p, i.e. restricting to top tokens summing to prob_cut_off <= prob_cut_off."),AT.forEach(t),Ob=l(Yi),Oa=n(Yi,"DIV",{class:!0});var Xy=s(Oa);g(Mo.$$.fragment,Xy),Xy.forEach(t),Yi.forEach(t),Fp=l(e),Le=n(e,"DIV",{class:!0});var Xi=s(Le);g(Go.$$.fragment,Xi),qb=l(Xi),qa=n(Xi,"P",{});var NT=s(qa);Ba=n(NT,"A",{href:!0});var Jy=s(Ba);Bb=i(Jy,"FlaxLogitsWarper"),Jy.forEach(t),Ib=i(NT," that performs top-k, i.e. restricting to the k highest probability elements."),NT.forEach(t),Cb=l(Xi),Ia=n(Xi,"DIV",{class:!0});var Qy=s(Ia);g(jo.$$.fragment,Qy),Qy.forEach(t),Xi.forEach(t),Dp=l(e),Ee=n(e,"DIV",{class:!0});var Ji=s(Ee);g(Ho.$$.fragment,Ji),Wb=l(Ji),Ca=n(Ji,"P",{});var VT=s(Ca);Wa=n(VT,"A",{href:!0});var Zy=s(Wa);Ab=i(Zy,"FlaxLogitsProcessor"),Zy.forEach(t),Nb=i(VT," that enforces the specified token as the first generated token."),VT.forEach(t),Vb=l(Ji),Aa=n(Ji,"DIV",{class:!0});var e4=s(Aa);g(Ro.$$.fragment,e4),e4.forEach(t),Ji.forEach(t),zp=l(e),Pe=n(e,"DIV",{class:!0});var Qi=s(Pe);g(Ko.$$.fragment,Qi),Mb=l(Qi),Wr=n(Qi,"P",{});var _d=s(Wr);Na=n(_d,"A",{href:!0});var r4=s(Na);Gb=i(r4,"FlaxLogitsProcessor"),r4.forEach(t),jb=i(_d," that enforces the specified token as the last generated token when "),Dl=n(_d,"CODE",{});var t4=s(Dl);Hb=i(t4,"max_length"),t4.forEach(t),Rb=i(_d," is reached."),_d.forEach(t),Kb=l(Qi),Va=n(Qi,"DIV",{class:!0});var o4=s(Va);g(Uo.$$.fragment,o4),o4.forEach(t),Qi.forEach(t),Sp=l(e),Fe=n(e,"DIV",{class:!0});var Zi=s(Fe);g(Yo.$$.fragment,Zi),Ub=l(Zi),Ma=n(Zi,"P",{});var MT=s(Ma);Ga=n(MT,"A",{href:!0});var n4=s(Ga);Yb=i(n4,"FlaxLogitsProcessor"),n4.forEach(t),Xb=i(MT," enforcing a min-length by setting EOS probability to 0."),MT.forEach(t),Jb=l(Zi),ja=n(Zi,"DIV",{class:!0});var s4=s(ja);g(Xo.$$.fragment,s4),s4.forEach(t),Zi.forEach(t),Op=l(e),ir=n(e,"H2",{class:!0});var xm=s(ir);Ar=n(xm,"A",{id:!0,class:!0,href:!0});var a4=s(Ar);zl=n(a4,"SPAN",{});var i4=s(zl);g(Jo.$$.fragment,i4),i4.forEach(t),a4.forEach(t),Qb=l(xm),Sl=n(xm,"SPAN",{});var c4=s(Sl);Zb=i(c4,"StoppingCriteria"),c4.forEach(t),xm.forEach(t),qp=l(e),Nr=n(e,"P",{});var wm=s(Nr);ev=i(wm,"A "),Ha=n(wm,"A",{href:!0});var l4=s(Ha);rv=i(l4,"StoppingCriteria"),l4.forEach(t),tv=i(wm," can be used to change when to stop generation (other than EOS token)."),wm.forEach(t),Bp=l(e),De=n(e,"DIV",{class:!0});var ec=s(De);g(Qo.$$.fragment,ec),ov=l(ec),Ol=n(ec,"P",{});var d4=s(Ol);nv=i(d4,"Abstract base class for all stopping criteria that can be applied during generation."),d4.forEach(t),sv=l(ec),Ra=n(ec,"DIV",{class:!0});var p4=s(Ra);g(Zo.$$.fragment,p4),p4.forEach(t),ec.forEach(t),Ip=l(e),cr=n(e,"DIV",{class:!0});var Lm=s(cr);g(en.$$.fragment,Lm),av=l(Lm),Ka=n(Lm,"DIV",{class:!0});var m4=s(Ka);g(rn.$$.fragment,m4),m4.forEach(t),Lm.forEach(t),Cp=l(e),ze=n(e,"DIV",{class:!0});var rc=s(ze);g(tn.$$.fragment,rc),iv=l(rc),on=n(rc,"P",{});var Em=s(on);cv=i(Em,"This class can be used to stop generation whenever the full generated number of tokens exceeds "),ql=n(Em,"CODE",{});var f4=s(ql);lv=i(f4,"max_length"),f4.forEach(t),dv=i(Em,`. Keep
in mind for decoder-only type of transformers, this will include the initial prompted tokens.`),Em.forEach(t),pv=l(rc),Ua=n(rc,"DIV",{class:!0});var g4=s(Ua);g(nn.$$.fragment,g4),g4.forEach(t),rc.forEach(t),Wp=l(e),Se=n(e,"DIV",{class:!0});var tc=s(Se);g(sn.$$.fragment,tc),mv=l(tc),an=n(tc,"P",{});var Pm=s(an);fv=i(Pm,`This class can be used to stop generation whenever the full generation exceeds some amount of time. By default, the
time will start being counted when you initialize this function. You can override this by passing an
`),Bl=n(Pm,"CODE",{});var u4=s(Bl);gv=i(u4,"initial_time"),u4.forEach(t),uv=i(Pm,"."),Pm.forEach(t),hv=l(tc),Ya=n(tc,"DIV",{class:!0});var h4=s(Ya);g(cn.$$.fragment,h4),h4.forEach(t),tc.forEach(t),Ap=l(e),lr=n(e,"H2",{class:!0});var Fm=s(lr);Vr=n(Fm,"A",{id:!0,class:!0,href:!0});var _4=s(Vr);Il=n(_4,"SPAN",{});var b4=s(Il);g(ln.$$.fragment,b4),b4.forEach(t),_4.forEach(t),_v=l(Fm),Cl=n(Fm,"SPAN",{});var v4=s(Cl);bv=i(v4,"Constraints"),v4.forEach(t),Fm.forEach(t),Np=l(e),Mr=n(e,"P",{});var Dm=s(Mr);vv=i(Dm,"A "),Xa=n(Dm,"A",{href:!0});var T4=s(Xa);Tv=i(T4,"Constraint"),T4.forEach(t),$v=i(Dm," can be used to force the generation to include specific tokens or sequences in the output."),Dm.forEach(t),Vp=l(e),T=n(e,"DIV",{class:!0});var $=s(T);g(dn.$$.fragment,$),yv=l($),Wl=n($,"P",{});var $4=s(Wl);kv=i($4,`Abstract base class for all constraints that can be applied during generation.
It must define how the constraint can be satisfied.`),$4.forEach(t),xv=l($),Al=n($,"P",{});var y4=s(Al);wv=i(y4,"All classes that inherit Constraint must follow the requirement that"),y4.forEach(t),Lv=l($),g(Gr.$$.fragment,$),Ev=l($),Nl=n($,"P",{});var k4=s(Nl);Pv=i(k4,"will always terminate (halt)."),k4.forEach(t),Fv=l($),jr=n($,"DIV",{class:!0});var zm=s(jr);g(pn.$$.fragment,zm),Dv=l(zm),Vl=n(zm,"P",{});var x4=s(Vl);zv=i(x4,"When called, returns the token that would take this constraint one step closer to being fulfilled."),x4.forEach(t),zm.forEach(t),Sv=l($),Hr=n($,"DIV",{class:!0});var Sm=s(Hr);g(mn.$$.fragment,Sm),Ov=l(Sm),Ml=n(Sm,"P",{});var w4=s(Ml);qv=i(w4,"Creates a new instance of this constraint."),w4.forEach(t),Sm.forEach(t),Bv=l($),Rr=n($,"DIV",{class:!0});var Om=s(Rr);g(fn.$$.fragment,Om),Iv=l(Om),Gl=n(Om,"P",{});var L4=s(Gl);Cv=i(L4,"Reads in a token and returns whether it creates progress."),L4.forEach(t),Om.forEach(t),Wv=l($),Kr=n($,"DIV",{class:!0});var qm=s(Kr);g(gn.$$.fragment,qm),Av=l(qm),un=n(qm,"P",{});var Bm=s(un);Nv=i(Bm,"Returns the number of remaining steps of "),jl=n(Bm,"CODE",{});var E4=s(jl);Vv=i(E4,"advance()"),E4.forEach(t),Mv=i(Bm," in order to complete this constraint."),Bm.forEach(t),qm.forEach(t),Gv=l($),Ur=n($,"DIV",{class:!0});var Im=s(Ur);g(hn.$$.fragment,Im),jv=l(Im),Hl=n(Im,"P",{});var P4=s(Hl);Hv=i(P4,`Resets the state of this constraint to its initialization. We would call this in cases where the fulfillment of
a constraint is abrupted by an unwanted token.`),P4.forEach(t),Im.forEach(t),Rv=l($),Yr=n($,"DIV",{class:!0});var Cm=s(Yr);g(_n.$$.fragment,Cm),Kv=l(Cm),Rl=n(Cm,"P",{});var F4=s(Rl);Uv=i(F4,"Tests whether this constraint has been properly defined."),F4.forEach(t),Cm.forEach(t),Yv=l($),Ne=n($,"DIV",{class:!0});var oc=s(Ne);g(bn.$$.fragment,oc),Xv=l(oc),vn=n(oc,"P",{});var Wm=s(vn);Jv=i(Wm,`Reads in a token and returns booleans that indicate the progress made by it. This function will update the
state of this object unlikes `),Kl=n(Wm,"CODE",{});var D4=s(Kl);Qv=i(D4,"does_advance(self, token_id: int)"),D4.forEach(t),Zv=i(Wm,"."),Wm.forEach(t),e1=l(oc),Ul=n(oc,"P",{});var z4=s(Ul);r1=i(z4,`This isn\u2019t to test whether a certain token will advance the progress; it\u2019s to update its state as if it has
been generated. This becomes important if token_id != desired token (refer to else statement in
PhrasalConstraint)`),z4.forEach(t),oc.forEach(t),$.forEach(t),Mp=l(e),dr=n(e,"DIV",{class:!0});var Am=s(dr);g(Tn.$$.fragment,Am),t1=l(Am),Ja=n(Am,"P",{});var GT=s(Ja);Qa=n(GT,"A",{href:!0});var S4=s(Qa);o1=i(S4,"Constraint"),S4.forEach(t),n1=i(GT," enforcing that an ordered sequence of tokens is included in the output."),GT.forEach(t),Am.forEach(t),Gp=l(e),pr=n(e,"DIV",{class:!0});var Nm=s(pr);g($n.$$.fragment,Nm),s1=l(Nm),yn=n(Nm,"P",{});var Vm=s(yn);a1=i(Vm,"A special "),Za=n(Vm,"A",{href:!0});var O4=s(Za);i1=i(O4,"Constraint"),O4.forEach(t),c1=i(Vm," that is fulfilled by fulfilling just one of several constraints."),Vm.forEach(t),Nm.forEach(t),jp=l(e),W=n(e,"DIV",{class:!0});var rt=s(W);g(kn.$$.fragment,rt),l1=l(rt),Yl=n(rt,"P",{});var q4=s(Yl);d1=i(q4,"A class for beam scorers to track its progress through a list of constraints."),q4.forEach(t),p1=l(rt),F=n(rt,"DIV",{class:!0});var j=s(F);g(xn.$$.fragment,j),m1=l(j),Xl=n(j,"P",{});var B4=s(Xl);f1=i(B4,`The list of tokens to generate such that we can make progress.
By \u201Clist\u201D we don\u2019t mean the list of token that will fully fulfill a constraint.`),B4.forEach(t),g1=l(j),mr=n(j,"P",{});var nc=s(mr);u1=i(nc,"Given constraints "),Jl=n(nc,"CODE",{});var I4=s(Jl);h1=i(I4,"c_i = {t_ij | j == # of tokens}"),I4.forEach(t),_1=i(nc,`, If we\u2019re not in the middle of progressing through a
specific constraint `),Ql=n(nc,"CODE",{});var C4=s(Ql);b1=i(C4,"c_i"),C4.forEach(t),v1=i(nc,", we return:"),nc.forEach(t),T1=l(j),Zl=n(j,"P",{});var W4=s(Zl);ed=n(W4,"CODE",{});var A4=s(ed);$1=i(A4,"[t_k1 for k in indices of unfulfilled constraints]"),A4.forEach(t),W4.forEach(t),y1=l(j),Oe=n(j,"P",{});var tt=s(Oe);k1=i(tt,`If we are in the middle of a constraint, then we return:
`),rd=n(tt,"CODE",{});var N4=s(rd);x1=i(N4,"[t_ij]"),N4.forEach(t),w1=i(tt,", where "),td=n(tt,"CODE",{});var V4=s(td);L1=i(V4,"i"),V4.forEach(t),E1=i(tt," is the index of the inprogress constraint, "),od=n(tt,"CODE",{});var M4=s(od);P1=i(M4,"j"),M4.forEach(t),F1=i(tt," is the next step for the constraint."),tt.forEach(t),D1=l(j),nd=n(j,"P",{});var G4=s(nd);z1=i(G4,`Though we don\u2019t care which constraint is fulfilled first, if we are in the progress of fulfilling a constraint,
that\u2019s the only one we\u2019ll return.`),G4.forEach(t),j.forEach(t),S1=l(rt),Xr=n(rt,"DIV",{class:!0});var Mm=s(Xr);g(wn.$$.fragment,Mm),O1=l(Mm),sd=n(Mm,"P",{});var j4=s(sd);q1=i(j4,"token_ids: the tokens generated thus far to reset the state of the progress through constraints."),j4.forEach(t),Mm.forEach(t),rt.forEach(t),Hp=l(e),fr=n(e,"H2",{class:!0});var Gm=s(fr);Jr=n(Gm,"A",{id:!0,class:!0,href:!0});var H4=s(Jr);ad=n(H4,"SPAN",{});var R4=s(ad);g(Ln.$$.fragment,R4),R4.forEach(t),H4.forEach(t),B1=l(Gm),id=n(Gm,"SPAN",{});var K4=s(id);I1=i(K4,"BeamSearch"),K4.forEach(t),Gm.forEach(t),Rp=l(e),A=n(e,"DIV",{class:!0});var ot=s(A);g(En.$$.fragment,ot),C1=l(ot),gr=n(ot,"P",{});var sc=s(gr);W1=i(sc,"Abstract base class for all beam scorers that are used for "),ei=n(sc,"A",{href:!0});var U4=s(ei);A1=i(U4,"beam_search()"),U4.forEach(t),N1=i(sc,` and
`),ri=n(sc,"A",{href:!0});var Y4=s(ri);V1=i(Y4,"beam_sample()"),Y4.forEach(t),M1=i(sc,"."),sc.forEach(t),G1=l(ot),ti=n(ot,"DIV",{class:!0});var X4=s(ti);g(Pn.$$.fragment,X4),X4.forEach(t),j1=l(ot),oi=n(ot,"DIV",{class:!0});var J4=s(oi);g(Fn.$$.fragment,J4),J4.forEach(t),ot.forEach(t),Kp=l(e),P=n(e,"DIV",{class:!0});var H=s(P);g(Dn.$$.fragment,H),H1=l(H),ni=n(H,"P",{});var jT=s(ni);si=n(jT,"A",{href:!0});var Q4=s(si);R1=i(Q4,"BeamScorer"),Q4.forEach(t),K1=i(jT," implementing standard beam search decoding."),jT.forEach(t),U1=l(H),zn=n(H,"P",{});var jm=s(zn);Y1=i(jm,"Adapted in part from "),Sn=n(jm,"A",{href:!0,rel:!0});var Z4=s(Sn);X1=i(Z4,`Facebook\u2019s XLM beam search
code`),Z4.forEach(t),J1=i(jm,"."),jm.forEach(t),Q1=l(H),ai=n(H,"P",{});var HT=s(ai);Z1=i(HT,"Reference for the diverse beam search algorithm and implementation "),On=n(HT,"A",{href:!0,rel:!0});var e0=s(On);eT=i(e0,`Ashwin Kalyan\u2019s DBS
implementation`),e0.forEach(t),HT.forEach(t),rT=l(H),ii=n(H,"DIV",{class:!0});var r0=s(ii);g(qn.$$.fragment,r0),r0.forEach(t),tT=l(H),ci=n(H,"DIV",{class:!0});var t0=s(ci);g(Bn.$$.fragment,t0),t0.forEach(t),H.forEach(t),Up=l(e),N=n(e,"DIV",{class:!0});var nt=s(N);g(In.$$.fragment,nt),oT=l(nt),li=n(nt,"P",{});var RT=s(li);di=n(RT,"A",{href:!0});var o0=s(di);nT=i(o0,"BeamScorer"),o0.forEach(t),sT=i(RT," implementing constrained beam search decoding."),RT.forEach(t),aT=l(nt),pi=n(nt,"DIV",{class:!0});var n0=s(pi);g(Cn.$$.fragment,n0),n0.forEach(t),iT=l(nt),mi=n(nt,"DIV",{class:!0});var s0=s(mi);g(Wn.$$.fragment,s0),s0.forEach(t),nt.forEach(t),Yp=l(e),ur=n(e,"H2",{class:!0});var Hm=s(ur);Qr=n(Hm,"A",{id:!0,class:!0,href:!0});var a0=s(Qr);cd=n(a0,"SPAN",{});var i0=s(cd);g(An.$$.fragment,i0),i0.forEach(t),a0.forEach(t),cT=l(Hm),ld=n(Hm,"SPAN",{});var c0=s(ld);lT=i(c0,"Utilities"),c0.forEach(t),Hm.forEach(t),Xp=l(e),qe=n(e,"DIV",{class:!0});var ac=s(qe);g(Nn.$$.fragment,ac),dT=l(ac),dd=n(ac,"P",{});var l0=s(dd);pT=i(l0,"Filter a distribution of logits using top-k and/or nucleus (top-p) filtering"),l0.forEach(t),mT=l(ac),fi=n(ac,"P",{});var KT=s(fi);fT=i(KT,"From: "),Vn=n(KT,"A",{href:!0,rel:!0});var d0=s(Vn);gT=i(d0,"https://gist.github.com/thomwolf/1a5a29f6962089e871b94cbd09daf317"),d0.forEach(t),KT.forEach(t),ac.forEach(t),Jp=l(e),Be=n(e,"DIV",{class:!0});var ic=s(Be);g(Mn.$$.fragment,ic),uT=l(ic),pd=n(ic,"P",{});var p0=s(pd);hT=i(p0,"Filter a distribution of logits using top-k and/or nucleus (top-p) filtering"),p0.forEach(t),_T=l(ic),gi=n(ic,"P",{});var UT=s(gi);bT=i(UT,"From: "),Gn=n(UT,"A",{href:!0,rel:!0});var m0=s(Gn);vT=i(m0,"https://gist.github.com/thomwolf/1a5a29f6962089e871b94cbd09daf317"),m0.forEach(t),UT.forEach(t),ic.forEach(t),this.h()},h(){d(w,"name","hf:doc:metadata"),d(w,"content",JSON.stringify(y0)),d(Ce,"id","utilities-for-generation"),d(Ce,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),d(Ce,"href","#utilities-for-generation"),d(k,"class","relative group"),d(Rn,"href","/docs/transformers/pr_17574/en/main_classes/text_generation#transformers.generation_utils.GenerationMixin.generate"),d(Kn,"href","/docs/transformers/pr_17574/en/main_classes/text_generation#transformers.generation_utils.GenerationMixin.greedy_search"),d(Un,"href","/docs/transformers/pr_17574/en/main_classes/text_generation#transformers.generation_utils.GenerationMixin.sample"),d(Yn,"href","/docs/transformers/pr_17574/en/main_classes/text_generation#transformers.generation_utils.GenerationMixin.beam_search"),d(Xn,"href","/docs/transformers/pr_17574/en/main_classes/text_generation#transformers.generation_utils.GenerationMixin.beam_sample"),d(Jn,"href","/docs/transformers/pr_17574/en/main_classes/text_generation#transformers.generation_utils.GenerationMixin.group_beam_search"),d(Qn,"href","/docs/transformers/pr_17574/en/main_classes/text_generation#transformers.generation_utils.GenerationMixin.constrained_beam_search"),d(_r,"id","generate-outputs"),d(_r,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),d(_r,"href","#generate-outputs"),d(Re,"class","relative group"),d(es,"href","/docs/transformers/pr_17574/en/main_classes/text_generation#transformers.generation_utils.GenerationMixin.generate"),d(rs,"href","/docs/transformers/pr_17574/en/main_classes/output#transformers.utils.ModelOutput"),d(ts,"href","/docs/transformers/pr_17574/en/main_classes/text_generation#transformers.generation_utils.GenerationMixin.generate"),d(ns,"href","/docs/transformers/pr_17574/en/internal/generation_utils#transformers.generation_utils.GreedySearchDecoderOnlyOutput"),d(vr,"id","transformers.generation_utils.GreedySearchDecoderOnlyOutput"),d(vr,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),d(vr,"href","#transformers.generation_utils.GreedySearchDecoderOnlyOutput"),d(Ke,"class","relative group"),d(Ue,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(Ye,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(Tr,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(R,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d($r,"id","transformers.generation_utils.SampleDecoderOnlyOutput"),d($r,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),d($r,"href","#transformers.generation_utils.SampleDecoderOnlyOutput"),d(Xe,"class","relative group"),d(Je,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(Qe,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(yr,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(K,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(kr,"id","transformers.generation_utils.BeamSearchDecoderOnlyOutput"),d(kr,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),d(kr,"href","#transformers.generation_utils.BeamSearchDecoderOnlyOutput"),d(Ze,"class","relative group"),d(er,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(rr,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(xr,"id","transformers.generation_utils.BeamSampleDecoderOnlyOutput"),d(xr,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),d(xr,"href","#transformers.generation_utils.BeamSampleDecoderOnlyOutput"),d(tr,"class","relative group"),d(or,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(nr,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(wr,"id","transformers.LogitsProcessor"),d(wr,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),d(wr,"href","#transformers.LogitsProcessor"),d(sr,"class","relative group"),d(ds,"href","/docs/transformers/pr_17574/en/internal/generation_utils#transformers.LogitsProcessor"),d(Er,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(U,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(ps,"href","/docs/transformers/pr_17574/en/internal/generation_utils#transformers.LogitsProcessor"),d(ms,"href","/docs/transformers/pr_17574/en/internal/generation_utils#transformers.LogitsWarper"),d(fs,"href","/docs/transformers/pr_17574/en/internal/generation_utils#transformers.LogitsProcessor"),d(gs,"href","/docs/transformers/pr_17574/en/internal/generation_utils#transformers.LogitsWarper"),d(us,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(Y,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(Pr,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(X,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(_s,"href","/docs/transformers/pr_17574/en/internal/generation_utils#transformers.LogitsProcessor"),d(bs,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(J,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(Ts,"href","/docs/transformers/pr_17574/en/internal/generation_utils#transformers.LogitsWarper"),d($s,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(Q,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(ks,"href","/docs/transformers/pr_17574/en/internal/generation_utils#transformers.LogitsProcessor"),d(xs,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(Z,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(Ls,"href","/docs/transformers/pr_17574/en/internal/generation_utils#transformers.LogitsWarper"),d(Es,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(ee,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(Fs,"href","/docs/transformers/pr_17574/en/internal/generation_utils#transformers.LogitsWarper"),d(Ds,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(re,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(zs,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(ar,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(Ss,"href","/docs/transformers/pr_17574/en/internal/generation_utils#transformers.LogitsProcessor"),d(Ht,"href","https://github.com/pytorch/fairseq/blob/a07cb6f40480928c9e0548b737aadd36ee66ac76/fairseq/sequence_generator.py#L345"),d(Ht,"rel","nofollow"),d(Os,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(te,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(Bs,"href","/docs/transformers/pr_17574/en/internal/generation_utils#transformers.LogitsProcessor"),d(Is,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(oe,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(Cs,"href","/docs/transformers/pr_17574/en/internal/generation_utils#transformers.LogitsProcessor"),d(Xt,"href","https://arxiv.org/abs/2010.00904"),d(Xt,"rel","nofollow"),d(Ws,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(ne,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(As,"href","/docs/transformers/pr_17574/en/internal/generation_utils#transformers.LogitsProcessor"),d(Ns,"href","/docs/transformers/pr_17574/en/main_classes/text_generation#transformers.generation_utils.GenerationMixin.group_beam_search"),d(Zt,"href","https://arxiv.org/pdf/1610.02424.pdf"),d(Zt,"rel","nofollow"),d(Vs,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(se,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(Gs,"href","/docs/transformers/pr_17574/en/internal/generation_utils#transformers.LogitsProcessor"),d(js,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(ae,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(Hs,"href","/docs/transformers/pr_17574/en/internal/generation_utils#transformers.LogitsProcessor"),d(Rs,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(ie,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(Ks,"href","/docs/transformers/pr_17574/en/internal/generation_utils#transformers.LogitsProcessor"),d(Us,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(ce,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(Sr,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(le,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(Ys,"href","/docs/transformers/pr_17574/en/internal/generation_utils#transformers.TFLogitsProcessor"),d(Xs,"href","/docs/transformers/pr_17574/en/internal/generation_utils#transformers.TFLogitsProcessor"),d(Js,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(de,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(Or,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(pe,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(Zs,"href","/docs/transformers/pr_17574/en/internal/generation_utils#transformers.TFLogitsWarper"),d(ea,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(me,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(ta,"href","/docs/transformers/pr_17574/en/internal/generation_utils#transformers.TFLogitsWarper"),d(oa,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(fe,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(sa,"href","/docs/transformers/pr_17574/en/internal/generation_utils#transformers.TFLogitsWarper"),d(aa,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(ge,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(ca,"href","/docs/transformers/pr_17574/en/internal/generation_utils#transformers.TFLogitsProcessor"),d(la,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(ue,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(pa,"href","/docs/transformers/pr_17574/en/internal/generation_utils#transformers.TFLogitsProcessor"),d(ma,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(he,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(fa,"href","/docs/transformers/pr_17574/en/internal/generation_utils#transformers.TFLogitsProcessor"),d(wo,"href","https://github.com/pytorch/fairseq/blob/a07cb6f40480928c9e0548b737aadd36ee66ac76/fairseq/sequence_generator.py#L345"),d(wo,"rel","nofollow"),d(ga,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(_e,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(ha,"href","/docs/transformers/pr_17574/en/internal/generation_utils#transformers.TFLogitsProcessor"),d(_a,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(be,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(va,"href","/docs/transformers/pr_17574/en/internal/generation_utils#transformers.TFLogitsProcessor"),d(Ta,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(ve,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d($a,"href","/docs/transformers/pr_17574/en/internal/generation_utils#transformers.TFLogitsProcessor"),d(ya,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(Te,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(Ir,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d($e,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(ka,"href","/docs/transformers/pr_17574/en/internal/generation_utils#transformers.FlaxLogitsProcessor"),d(xa,"href","/docs/transformers/pr_17574/en/internal/generation_utils#transformers.FlaxLogitsWarper"),d(wa,"href","/docs/transformers/pr_17574/en/internal/generation_utils#transformers.FlaxLogitsProcessor"),d(La,"href","/docs/transformers/pr_17574/en/internal/generation_utils#transformers.FlaxLogitsWarper"),d(Ea,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(ye,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(Cr,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(ke,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(Fa,"href","/docs/transformers/pr_17574/en/internal/generation_utils#transformers.FlaxLogitsWarper"),d(Da,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(xe,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(Sa,"href","/docs/transformers/pr_17574/en/internal/generation_utils#transformers.FlaxLogitsWarper"),d(Oa,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(we,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(Ba,"href","/docs/transformers/pr_17574/en/internal/generation_utils#transformers.FlaxLogitsWarper"),d(Ia,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(Le,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(Wa,"href","/docs/transformers/pr_17574/en/internal/generation_utils#transformers.FlaxLogitsProcessor"),d(Aa,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(Ee,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(Na,"href","/docs/transformers/pr_17574/en/internal/generation_utils#transformers.FlaxLogitsProcessor"),d(Va,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(Pe,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(Ga,"href","/docs/transformers/pr_17574/en/internal/generation_utils#transformers.FlaxLogitsProcessor"),d(ja,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(Fe,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(Ar,"id","transformers.StoppingCriteria"),d(Ar,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),d(Ar,"href","#transformers.StoppingCriteria"),d(ir,"class","relative group"),d(Ha,"href","/docs/transformers/pr_17574/en/internal/generation_utils#transformers.StoppingCriteria"),d(Ra,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(De,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(Ka,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(cr,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(Ua,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(ze,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(Ya,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(Se,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(Vr,"id","transformers.Constraint"),d(Vr,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),d(Vr,"href","#transformers.Constraint"),d(lr,"class","relative group"),d(Xa,"href","/docs/transformers/pr_17574/en/internal/generation_utils#transformers.Constraint"),d(jr,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(Hr,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(Rr,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(Kr,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(Ur,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(Yr,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(Ne,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(T,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(Qa,"href","/docs/transformers/pr_17574/en/internal/generation_utils#transformers.Constraint"),d(dr,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(Za,"href","/docs/transformers/pr_17574/en/internal/generation_utils#transformers.Constraint"),d(pr,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(F,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(Xr,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(W,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(Jr,"id","transformers.BeamScorer"),d(Jr,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),d(Jr,"href","#transformers.BeamScorer"),d(fr,"class","relative group"),d(ei,"href","/docs/transformers/pr_17574/en/main_classes/text_generation#transformers.generation_utils.GenerationMixin.beam_search"),d(ri,"href","/docs/transformers/pr_17574/en/main_classes/text_generation#transformers.generation_utils.GenerationMixin.beam_sample"),d(ti,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(oi,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(A,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(si,"href","/docs/transformers/pr_17574/en/internal/generation_utils#transformers.BeamScorer"),d(Sn,"href","https://github.com/facebookresearch/XLM/blob/9e6f6814d17be4fe5b15f2e6c43eb2b2d76daeb4/src/model/transformer.py#L529"),d(Sn,"rel","nofollow"),d(On,"href","https://github.com/ashwinkalyan/dbs/blob/master/dbs/beam_utils.lua"),d(On,"rel","nofollow"),d(ii,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(ci,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(P,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(di,"href","/docs/transformers/pr_17574/en/internal/generation_utils#transformers.BeamScorer"),d(pi,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(mi,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(N,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(Qr,"id","transformers.top_k_top_p_filtering"),d(Qr,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),d(Qr,"href","#transformers.top_k_top_p_filtering"),d(ur,"class","relative group"),d(Vn,"href","https://gist.github.com/thomwolf/1a5a29f6962089e871b94cbd09daf317"),d(Vn,"rel","nofollow"),d(qe,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),d(Gn,"href","https://gist.github.com/thomwolf/1a5a29f6962089e871b94cbd09daf317"),d(Gn,"rel","nofollow"),d(Be,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8")},m(e,p){r(document.head,w),m(e,He,p),m(e,k,p),r(k,Ce),r(Ce,cc),u(st,cc,null),r(k,Rm),r(k,lc),r(lc,Km),m(e,vd,p),m(e,y,p),r(y,Um),r(y,Rn),r(Rn,Ym),r(y,Xm),r(y,Kn),r(Kn,Jm),r(y,Qm),r(y,Un),r(Un,Zm),r(y,ef),r(y,Yn),r(Yn,rf),r(y,tf),r(y,Xn),r(Xn,of),r(y,nf),r(y,Jn),r(Jn,sf),r(y,af),r(y,Qn),r(Qn,cf),r(y,lf),m(e,Td,p),m(e,Zn,p),r(Zn,df),m(e,$d,p),m(e,Re,p),r(Re,_r),r(_r,dc),u(at,dc,null),r(Re,pf),r(Re,pc),r(pc,mf),m(e,yd,p),m(e,V,p),r(V,ff),r(V,es),r(es,gf),r(V,uf),r(V,rs),r(rs,hf),r(V,_f),r(V,ts),r(ts,bf),r(V,vf),m(e,kd,p),m(e,os,p),r(os,Tf),m(e,xd,p),u(it,e,p),m(e,wd,p),m(e,We,p),r(We,$f),r(We,mc),r(mc,yf),r(We,kf),r(We,ns),r(ns,xf),r(We,wf),m(e,Ld,p),m(e,M,p),r(M,ss),r(ss,fc),r(fc,Lf),r(ss,Ef),r(M,Pf),r(M,as),r(as,gc),r(gc,Ff),r(as,Df),r(M,zf),r(M,is),r(is,uc),r(uc,Sf),r(is,Of),r(M,qf),r(M,cs),r(cs,hc),r(hc,Bf),r(cs,If),m(e,Ed,p),m(e,x,p),r(x,Cf),r(x,_c),r(_c,Wf),r(x,Af),r(x,bc),r(bc,Nf),r(x,Vf),r(x,vc),r(vc,Mf),r(x,Gf),r(x,Tc),r(Tc,jf),r(x,Hf),r(x,$c),r($c,Rf),r(x,Kf),r(x,yc),r(yc,Uf),r(x,Yf),m(e,Pd,p),m(e,z,p),r(z,Xf),r(z,kc),r(kc,Jf),r(z,Qf),r(z,xc),r(xc,Zf),r(z,eg),r(z,wc),r(wc,rg),r(z,tg),r(z,Lc),r(Lc,og),r(z,ng),m(e,Fd,p),m(e,S,p),r(S,sg),r(S,Ec),r(Ec,ag),r(S,ig),r(S,Pc),r(Pc,cg),r(S,lg),r(S,Fc),r(Fc,dg),r(S,pg),r(S,Dc),r(Dc,mg),r(S,fg),m(e,Dd,p),u(ct,e,p),m(e,zd,p),m(e,br,p),r(br,gg),r(br,zc),r(zc,ug),r(br,hg),m(e,Sd,p),m(e,O,p),r(O,_g),r(O,Sc),r(Sc,bg),r(O,vg),r(O,Oc),r(Oc,Tg),r(O,$g),r(O,qc),r(qc,yg),r(O,kg),r(O,Bc),r(Bc,xg),r(O,wg),m(e,Od,p),m(e,ls,p),r(ls,Lg),m(e,qd,p),m(e,Ke,p),r(Ke,vr),r(vr,Ic),u(lt,Ic,null),r(Ke,Eg),r(Ke,Cc),r(Cc,Pg),m(e,Bd,p),m(e,Ue,p),u(dt,Ue,null),r(Ue,Fg),r(Ue,Wc),r(Wc,Dg),m(e,Id,p),m(e,Ye,p),u(pt,Ye,null),r(Ye,zg),r(Ye,Ac),r(Ac,Sg),m(e,Cd,p),m(e,R,p),u(mt,R,null),r(R,Og),r(R,Nc),r(Nc,qg),r(R,Bg),r(R,Tr),u(ft,Tr,null),r(Tr,Ig),r(Tr,Vc),r(Vc,Cg),m(e,Wd,p),m(e,Xe,p),r(Xe,$r),r($r,Mc),u(gt,Mc,null),r(Xe,Wg),r(Xe,Gc),r(Gc,Ag),m(e,Ad,p),m(e,Je,p),u(ut,Je,null),r(Je,Ng),r(Je,jc),r(jc,Vg),m(e,Nd,p),m(e,Qe,p),u(ht,Qe,null),r(Qe,Mg),r(Qe,Hc),r(Hc,Gg),m(e,Vd,p),m(e,K,p),u(_t,K,null),r(K,jg),r(K,Rc),r(Rc,Hg),r(K,Rg),r(K,yr),u(bt,yr,null),r(yr,Kg),r(yr,Kc),r(Kc,Ug),m(e,Md,p),m(e,Ze,p),r(Ze,kr),r(kr,Uc),u(vt,Uc,null),r(Ze,Yg),r(Ze,Yc),r(Yc,Xg),m(e,Gd,p),m(e,er,p),u(Tt,er,null),r(er,Jg),r(er,Xc),r(Xc,Qg),m(e,jd,p),m(e,rr,p),u($t,rr,null),r(rr,Zg),r(rr,Jc),r(Jc,eu),m(e,Hd,p),m(e,tr,p),r(tr,xr),r(xr,Qc),u(yt,Qc,null),r(tr,ru),r(tr,Zc),r(Zc,tu),m(e,Rd,p),m(e,or,p),u(kt,or,null),r(or,ou),r(or,el),r(el,nu),m(e,Kd,p),m(e,nr,p),u(xt,nr,null),r(nr,su),r(nr,rl),r(rl,au),m(e,Ud,p),m(e,sr,p),r(sr,wr),r(wr,tl),u(wt,tl,null),r(sr,iu),r(sr,ol),r(ol,cu),m(e,Yd,p),m(e,Lr,p),r(Lr,lu),r(Lr,ds),r(ds,du),r(Lr,pu),m(e,Xd,p),m(e,U,p),u(Lt,U,null),r(U,mu),r(U,nl),r(nl,fu),r(U,gu),r(U,Er),u(Et,Er,null),r(Er,uu),r(Er,sl),r(sl,hu),m(e,Jd,p),m(e,Y,p),u(Pt,Y,null),r(Y,_u),r(Y,L),r(L,bu),r(L,ps),r(ps,vu),r(L,Tu),r(L,ms),r(ms,$u),r(L,yu),r(L,al),r(al,ku),r(L,xu),r(L,il),r(il,cl),r(cl,wu),r(L,Lu),r(L,fs),r(fs,Eu),r(L,Pu),r(L,gs),r(gs,Fu),r(L,Du),r(Y,zu),r(Y,us),u(Ft,us,null),m(e,Qd,p),m(e,X,p),u(Dt,X,null),r(X,Su),r(X,ll),r(ll,Ou),r(X,qu),r(X,Pr),u(zt,Pr,null),r(Pr,Bu),r(Pr,dl),r(dl,Iu),m(e,Zd,p),m(e,J,p),u(St,J,null),r(J,Cu),r(J,hs),r(hs,_s),r(_s,Wu),r(hs,Au),r(J,Nu),r(J,bs),u(Ot,bs,null),m(e,ep,p),m(e,Q,p),u(qt,Q,null),r(Q,Vu),r(Q,vs),r(vs,Ts),r(Ts,Mu),r(vs,Gu),r(Q,ju),r(Q,$s),u(Bt,$s,null),m(e,rp,p),m(e,Z,p),u(It,Z,null),r(Z,Hu),r(Z,ys),r(ys,ks),r(ks,Ru),r(ys,Ku),r(Z,Uu),r(Z,xs),u(Ct,xs,null),m(e,tp,p),m(e,ee,p),u(Wt,ee,null),r(ee,Yu),r(ee,ws),r(ws,Ls),r(Ls,Xu),r(ws,Ju),r(ee,Qu),r(ee,Es),u(At,Es,null),m(e,op,p),m(e,re,p),u(Nt,re,null),r(re,Zu),r(re,Ps),r(Ps,Fs),r(Fs,eh),r(Ps,rh),r(re,th),r(re,Ds),u(Vt,Ds,null),m(e,np,p),m(e,ar,p),u(Mt,ar,null),r(ar,oh),r(ar,zs),u(Gt,zs,null),m(e,sp,p),m(e,te,p),u(jt,te,null),r(te,nh),r(te,Fr),r(Fr,Ss),r(Ss,sh),r(Fr,ah),r(Fr,Ht),r(Ht,ih),r(Fr,ch),r(te,lh),r(te,Os),u(Rt,Os,null),m(e,ap,p),m(e,oe,p),u(Kt,oe,null),r(oe,dh),r(oe,qs),r(qs,Bs),r(Bs,ph),r(qs,mh),r(oe,fh),r(oe,Is),u(Ut,Is,null),m(e,ip,p),m(e,ne,p),u(Yt,ne,null),r(ne,gh),r(ne,Dr),r(Dr,Cs),r(Cs,uh),r(Dr,hh),r(Dr,Xt),r(Xt,_h),r(Dr,bh),r(ne,vh),r(ne,Ws),u(Jt,Ws,null),m(e,cp,p),m(e,se,p),u(Qt,se,null),r(se,Th),r(se,Ae),r(Ae,As),r(As,$h),r(Ae,yh),r(Ae,Ns),r(Ns,kh),r(Ae,xh),r(Ae,Zt),r(Zt,wh),r(Ae,Lh),r(se,Eh),r(se,Vs),u(eo,Vs,null),m(e,lp,p),m(e,ae,p),u(ro,ae,null),r(ae,Ph),r(ae,Ms),r(Ms,Gs),r(Gs,Fh),r(Ms,Dh),r(ae,zh),r(ae,js),u(to,js,null),m(e,dp,p),m(e,ie,p),u(oo,ie,null),r(ie,Sh),r(ie,zr),r(zr,Hs),r(Hs,Oh),r(zr,qh),r(zr,pl),r(pl,Bh),r(zr,Ih),r(ie,Ch),r(ie,Rs),u(no,Rs,null),m(e,pp,p),m(e,ce,p),u(so,ce,null),r(ce,Wh),r(ce,G),r(G,Ks),r(Ks,Ah),r(G,Nh),r(G,ml),r(ml,Vh),r(G,Mh),r(G,fl),r(fl,Gh),r(G,jh),r(G,gl),r(gl,Hh),r(G,Rh),r(ce,Kh),r(ce,Us),u(ao,Us,null),m(e,mp,p),m(e,le,p),u(io,le,null),r(le,Uh),r(le,ul),r(ul,Yh),r(le,Xh),r(le,Sr),u(co,Sr,null),r(Sr,Jh),r(Sr,hl),r(hl,Qh),m(e,fp,p),m(e,de,p),u(lo,de,null),r(de,Zh),r(de,C),r(C,e_),r(C,Ys),r(Ys,r_),r(C,t_),r(C,_l),r(_l,o_),r(C,n_),r(C,bl),r(bl,vl),r(vl,s_),r(C,a_),r(C,Xs),r(Xs,i_),r(C,c_),r(de,l_),r(de,Js),u(po,Js,null),m(e,gp,p),m(e,pe,p),u(mo,pe,null),r(pe,d_),r(pe,Tl),r(Tl,p_),r(pe,m_),r(pe,Or),u(fo,Or,null),r(Or,f_),r(Or,$l),r($l,g_),m(e,up,p),m(e,me,p),u(go,me,null),r(me,u_),r(me,Qs),r(Qs,Zs),r(Zs,h_),r(Qs,__),r(me,b_),r(me,ea),u(uo,ea,null),m(e,hp,p),m(e,fe,p),u(ho,fe,null),r(fe,v_),r(fe,ra),r(ra,ta),r(ta,T_),r(ra,$_),r(fe,y_),r(fe,oa),u(_o,oa,null),m(e,_p,p),m(e,ge,p),u(bo,ge,null),r(ge,k_),r(ge,na),r(na,sa),r(sa,x_),r(na,w_),r(ge,L_),r(ge,aa),u(vo,aa,null),m(e,bp,p),m(e,ue,p),u(To,ue,null),r(ue,E_),r(ue,ia),r(ia,ca),r(ca,P_),r(ia,F_),r(ue,D_),r(ue,la),u($o,la,null),m(e,vp,p),m(e,he,p),u(yo,he,null),r(he,z_),r(he,da),r(da,pa),r(pa,S_),r(da,O_),r(he,q_),r(he,ma),u(ko,ma,null),m(e,Tp,p),m(e,_e,p),u(xo,_e,null),r(_e,B_),r(_e,qr),r(qr,fa),r(fa,I_),r(qr,C_),r(qr,wo),r(wo,W_),r(qr,A_),r(_e,N_),r(_e,ga),u(Lo,ga,null),m(e,$p,p),m(e,be,p),u(Eo,be,null),r(be,V_),r(be,ua),r(ua,ha),r(ha,M_),r(ua,G_),r(be,j_),r(be,_a),u(Po,_a,null),m(e,yp,p),m(e,ve,p),u(Fo,ve,null),r(ve,H_),r(ve,ba),r(ba,va),r(va,R_),r(ba,K_),r(ve,U_),r(ve,Ta),u(Do,Ta,null),m(e,kp,p),m(e,Te,p),u(zo,Te,null),r(Te,Y_),r(Te,Br),r(Br,$a),r($a,X_),r(Br,J_),r(Br,yl),r(yl,Q_),r(Br,Z_),r(Te,eb),r(Te,ya),u(So,ya,null),m(e,xp,p),m(e,$e,p),u(Oo,$e,null),r($e,rb),r($e,kl),r(kl,tb),r($e,ob),r($e,Ir),u(qo,Ir,null),r(Ir,nb),r(Ir,xl),r(xl,sb),m(e,wp,p),m(e,ye,p),u(Bo,ye,null),r(ye,ab),r(ye,E),r(E,ib),r(E,ka),r(ka,cb),r(E,lb),r(E,xa),r(xa,db),r(E,pb),r(E,wl),r(wl,mb),r(E,fb),r(E,Ll),r(Ll,El),r(El,gb),r(E,ub),r(E,wa),r(wa,hb),r(E,_b),r(E,La),r(La,bb),r(E,vb),r(ye,Tb),r(ye,Ea),u(Io,Ea,null),m(e,Lp,p),m(e,ke,p),u(Co,ke,null),r(ke,$b),r(ke,Pl),r(Pl,yb),r(ke,kb),r(ke,Cr),u(Wo,Cr,null),r(Cr,xb),r(Cr,Fl),r(Fl,wb),m(e,Ep,p),m(e,xe,p),u(Ao,xe,null),r(xe,Lb),r(xe,Pa),r(Pa,Fa),r(Fa,Eb),r(Pa,Pb),r(xe,Fb),r(xe,Da),u(No,Da,null),m(e,Pp,p),m(e,we,p),u(Vo,we,null),r(we,Db),r(we,za),r(za,Sa),r(Sa,zb),r(za,Sb),r(we,Ob),r(we,Oa),u(Mo,Oa,null),m(e,Fp,p),m(e,Le,p),u(Go,Le,null),r(Le,qb),r(Le,qa),r(qa,Ba),r(Ba,Bb),r(qa,Ib),r(Le,Cb),r(Le,Ia),u(jo,Ia,null),m(e,Dp,p),m(e,Ee,p),u(Ho,Ee,null),r(Ee,Wb),r(Ee,Ca),r(Ca,Wa),r(Wa,Ab),r(Ca,Nb),r(Ee,Vb),r(Ee,Aa),u(Ro,Aa,null),m(e,zp,p),m(e,Pe,p),u(Ko,Pe,null),r(Pe,Mb),r(Pe,Wr),r(Wr,Na),r(Na,Gb),r(Wr,jb),r(Wr,Dl),r(Dl,Hb),r(Wr,Rb),r(Pe,Kb),r(Pe,Va),u(Uo,Va,null),m(e,Sp,p),m(e,Fe,p),u(Yo,Fe,null),r(Fe,Ub),r(Fe,Ma),r(Ma,Ga),r(Ga,Yb),r(Ma,Xb),r(Fe,Jb),r(Fe,ja),u(Xo,ja,null),m(e,Op,p),m(e,ir,p),r(ir,Ar),r(Ar,zl),u(Jo,zl,null),r(ir,Qb),r(ir,Sl),r(Sl,Zb),m(e,qp,p),m(e,Nr,p),r(Nr,ev),r(Nr,Ha),r(Ha,rv),r(Nr,tv),m(e,Bp,p),m(e,De,p),u(Qo,De,null),r(De,ov),r(De,Ol),r(Ol,nv),r(De,sv),r(De,Ra),u(Zo,Ra,null),m(e,Ip,p),m(e,cr,p),u(en,cr,null),r(cr,av),r(cr,Ka),u(rn,Ka,null),m(e,Cp,p),m(e,ze,p),u(tn,ze,null),r(ze,iv),r(ze,on),r(on,cv),r(on,ql),r(ql,lv),r(on,dv),r(ze,pv),r(ze,Ua),u(nn,Ua,null),m(e,Wp,p),m(e,Se,p),u(sn,Se,null),r(Se,mv),r(Se,an),r(an,fv),r(an,Bl),r(Bl,gv),r(an,uv),r(Se,hv),r(Se,Ya),u(cn,Ya,null),m(e,Ap,p),m(e,lr,p),r(lr,Vr),r(Vr,Il),u(ln,Il,null),r(lr,_v),r(lr,Cl),r(Cl,bv),m(e,Np,p),m(e,Mr,p),r(Mr,vv),r(Mr,Xa),r(Xa,Tv),r(Mr,$v),m(e,Vp,p),m(e,T,p),u(dn,T,null),r(T,yv),r(T,Wl),r(Wl,kv),r(T,xv),r(T,Al),r(Al,wv),r(T,Lv),u(Gr,T,null),r(T,Ev),r(T,Nl),r(Nl,Pv),r(T,Fv),r(T,jr),u(pn,jr,null),r(jr,Dv),r(jr,Vl),r(Vl,zv),r(T,Sv),r(T,Hr),u(mn,Hr,null),r(Hr,Ov),r(Hr,Ml),r(Ml,qv),r(T,Bv),r(T,Rr),u(fn,Rr,null),r(Rr,Iv),r(Rr,Gl),r(Gl,Cv),r(T,Wv),r(T,Kr),u(gn,Kr,null),r(Kr,Av),r(Kr,un),r(un,Nv),r(un,jl),r(jl,Vv),r(un,Mv),r(T,Gv),r(T,Ur),u(hn,Ur,null),r(Ur,jv),r(Ur,Hl),r(Hl,Hv),r(T,Rv),r(T,Yr),u(_n,Yr,null),r(Yr,Kv),r(Yr,Rl),r(Rl,Uv),r(T,Yv),r(T,Ne),u(bn,Ne,null),r(Ne,Xv),r(Ne,vn),r(vn,Jv),r(vn,Kl),r(Kl,Qv),r(vn,Zv),r(Ne,e1),r(Ne,Ul),r(Ul,r1),m(e,Mp,p),m(e,dr,p),u(Tn,dr,null),r(dr,t1),r(dr,Ja),r(Ja,Qa),r(Qa,o1),r(Ja,n1),m(e,Gp,p),m(e,pr,p),u($n,pr,null),r(pr,s1),r(pr,yn),r(yn,a1),r(yn,Za),r(Za,i1),r(yn,c1),m(e,jp,p),m(e,W,p),u(kn,W,null),r(W,l1),r(W,Yl),r(Yl,d1),r(W,p1),r(W,F),u(xn,F,null),r(F,m1),r(F,Xl),r(Xl,f1),r(F,g1),r(F,mr),r(mr,u1),r(mr,Jl),r(Jl,h1),r(mr,_1),r(mr,Ql),r(Ql,b1),r(mr,v1),r(F,T1),r(F,Zl),r(Zl,ed),r(ed,$1),r(F,y1),r(F,Oe),r(Oe,k1),r(Oe,rd),r(rd,x1),r(Oe,w1),r(Oe,td),r(td,L1),r(Oe,E1),r(Oe,od),r(od,P1),r(Oe,F1),r(F,D1),r(F,nd),r(nd,z1),r(W,S1),r(W,Xr),u(wn,Xr,null),r(Xr,O1),r(Xr,sd),r(sd,q1),m(e,Hp,p),m(e,fr,p),r(fr,Jr),r(Jr,ad),u(Ln,ad,null),r(fr,B1),r(fr,id),r(id,I1),m(e,Rp,p),m(e,A,p),u(En,A,null),r(A,C1),r(A,gr),r(gr,W1),r(gr,ei),r(ei,A1),r(gr,N1),r(gr,ri),r(ri,V1),r(gr,M1),r(A,G1),r(A,ti),u(Pn,ti,null),r(A,j1),r(A,oi),u(Fn,oi,null),m(e,Kp,p),m(e,P,p),u(Dn,P,null),r(P,H1),r(P,ni),r(ni,si),r(si,R1),r(ni,K1),r(P,U1),r(P,zn),r(zn,Y1),r(zn,Sn),r(Sn,X1),r(zn,J1),r(P,Q1),r(P,ai),r(ai,Z1),r(ai,On),r(On,eT),r(P,rT),r(P,ii),u(qn,ii,null),r(P,tT),r(P,ci),u(Bn,ci,null),m(e,Up,p),m(e,N,p),u(In,N,null),r(N,oT),r(N,li),r(li,di),r(di,nT),r(li,sT),r(N,aT),r(N,pi),u(Cn,pi,null),r(N,iT),r(N,mi),u(Wn,mi,null),m(e,Yp,p),m(e,ur,p),r(ur,Qr),r(Qr,cd),u(An,cd,null),r(ur,cT),r(ur,ld),r(ld,lT),m(e,Xp,p),m(e,qe,p),u(Nn,qe,null),r(qe,dT),r(qe,dd),r(dd,pT),r(qe,mT),r(qe,fi),r(fi,fT),r(fi,Vn),r(Vn,gT),m(e,Jp,p),m(e,Be,p),u(Mn,Be,null),r(Be,uT),r(Be,pd),r(pd,hT),r(Be,_T),r(Be,gi),r(gi,bT),r(gi,Gn),r(Gn,vT),Qp=!0},p(e,[p]){const jn={};p&2&&(jn.$$scope={dirty:p,ctx:e}),Gr.$set(jn)},i(e){Qp||(h(st.$$.fragment,e),h(at.$$.fragment,e),h(it.$$.fragment,e),h(ct.$$.fragment,e),h(lt.$$.fragment,e),h(dt.$$.fragment,e),h(pt.$$.fragment,e),h(mt.$$.fragment,e),h(ft.$$.fragment,e),h(gt.$$.fragment,e),h(ut.$$.fragment,e),h(ht.$$.fragment,e),h(_t.$$.fragment,e),h(bt.$$.fragment,e),h(vt.$$.fragment,e),h(Tt.$$.fragment,e),h($t.$$.fragment,e),h(yt.$$.fragment,e),h(kt.$$.fragment,e),h(xt.$$.fragment,e),h(wt.$$.fragment,e),h(Lt.$$.fragment,e),h(Et.$$.fragment,e),h(Pt.$$.fragment,e),h(Ft.$$.fragment,e),h(Dt.$$.fragment,e),h(zt.$$.fragment,e),h(St.$$.fragment,e),h(Ot.$$.fragment,e),h(qt.$$.fragment,e),h(Bt.$$.fragment,e),h(It.$$.fragment,e),h(Ct.$$.fragment,e),h(Wt.$$.fragment,e),h(At.$$.fragment,e),h(Nt.$$.fragment,e),h(Vt.$$.fragment,e),h(Mt.$$.fragment,e),h(Gt.$$.fragment,e),h(jt.$$.fragment,e),h(Rt.$$.fragment,e),h(Kt.$$.fragment,e),h(Ut.$$.fragment,e),h(Yt.$$.fragment,e),h(Jt.$$.fragment,e),h(Qt.$$.fragment,e),h(eo.$$.fragment,e),h(ro.$$.fragment,e),h(to.$$.fragment,e),h(oo.$$.fragment,e),h(no.$$.fragment,e),h(so.$$.fragment,e),h(ao.$$.fragment,e),h(io.$$.fragment,e),h(co.$$.fragment,e),h(lo.$$.fragment,e),h(po.$$.fragment,e),h(mo.$$.fragment,e),h(fo.$$.fragment,e),h(go.$$.fragment,e),h(uo.$$.fragment,e),h(ho.$$.fragment,e),h(_o.$$.fragment,e),h(bo.$$.fragment,e),h(vo.$$.fragment,e),h(To.$$.fragment,e),h($o.$$.fragment,e),h(yo.$$.fragment,e),h(ko.$$.fragment,e),h(xo.$$.fragment,e),h(Lo.$$.fragment,e),h(Eo.$$.fragment,e),h(Po.$$.fragment,e),h(Fo.$$.fragment,e),h(Do.$$.fragment,e),h(zo.$$.fragment,e),h(So.$$.fragment,e),h(Oo.$$.fragment,e),h(qo.$$.fragment,e),h(Bo.$$.fragment,e),h(Io.$$.fragment,e),h(Co.$$.fragment,e),h(Wo.$$.fragment,e),h(Ao.$$.fragment,e),h(No.$$.fragment,e),h(Vo.$$.fragment,e),h(Mo.$$.fragment,e),h(Go.$$.fragment,e),h(jo.$$.fragment,e),h(Ho.$$.fragment,e),h(Ro.$$.fragment,e),h(Ko.$$.fragment,e),h(Uo.$$.fragment,e),h(Yo.$$.fragment,e),h(Xo.$$.fragment,e),h(Jo.$$.fragment,e),h(Qo.$$.fragment,e),h(Zo.$$.fragment,e),h(en.$$.fragment,e),h(rn.$$.fragment,e),h(tn.$$.fragment,e),h(nn.$$.fragment,e),h(sn.$$.fragment,e),h(cn.$$.fragment,e),h(ln.$$.fragment,e),h(dn.$$.fragment,e),h(Gr.$$.fragment,e),h(pn.$$.fragment,e),h(mn.$$.fragment,e),h(fn.$$.fragment,e),h(gn.$$.fragment,e),h(hn.$$.fragment,e),h(_n.$$.fragment,e),h(bn.$$.fragment,e),h(Tn.$$.fragment,e),h($n.$$.fragment,e),h(kn.$$.fragment,e),h(xn.$$.fragment,e),h(wn.$$.fragment,e),h(Ln.$$.fragment,e),h(En.$$.fragment,e),h(Pn.$$.fragment,e),h(Fn.$$.fragment,e),h(Dn.$$.fragment,e),h(qn.$$.fragment,e),h(Bn.$$.fragment,e),h(In.$$.fragment,e),h(Cn.$$.fragment,e),h(Wn.$$.fragment,e),h(An.$$.fragment,e),h(Nn.$$.fragment,e),h(Mn.$$.fragment,e),Qp=!0)},o(e){_(st.$$.fragment,e),_(at.$$.fragment,e),_(it.$$.fragment,e),_(ct.$$.fragment,e),_(lt.$$.fragment,e),_(dt.$$.fragment,e),_(pt.$$.fragment,e),_(mt.$$.fragment,e),_(ft.$$.fragment,e),_(gt.$$.fragment,e),_(ut.$$.fragment,e),_(ht.$$.fragment,e),_(_t.$$.fragment,e),_(bt.$$.fragment,e),_(vt.$$.fragment,e),_(Tt.$$.fragment,e),_($t.$$.fragment,e),_(yt.$$.fragment,e),_(kt.$$.fragment,e),_(xt.$$.fragment,e),_(wt.$$.fragment,e),_(Lt.$$.fragment,e),_(Et.$$.fragment,e),_(Pt.$$.fragment,e),_(Ft.$$.fragment,e),_(Dt.$$.fragment,e),_(zt.$$.fragment,e),_(St.$$.fragment,e),_(Ot.$$.fragment,e),_(qt.$$.fragment,e),_(Bt.$$.fragment,e),_(It.$$.fragment,e),_(Ct.$$.fragment,e),_(Wt.$$.fragment,e),_(At.$$.fragment,e),_(Nt.$$.fragment,e),_(Vt.$$.fragment,e),_(Mt.$$.fragment,e),_(Gt.$$.fragment,e),_(jt.$$.fragment,e),_(Rt.$$.fragment,e),_(Kt.$$.fragment,e),_(Ut.$$.fragment,e),_(Yt.$$.fragment,e),_(Jt.$$.fragment,e),_(Qt.$$.fragment,e),_(eo.$$.fragment,e),_(ro.$$.fragment,e),_(to.$$.fragment,e),_(oo.$$.fragment,e),_(no.$$.fragment,e),_(so.$$.fragment,e),_(ao.$$.fragment,e),_(io.$$.fragment,e),_(co.$$.fragment,e),_(lo.$$.fragment,e),_(po.$$.fragment,e),_(mo.$$.fragment,e),_(fo.$$.fragment,e),_(go.$$.fragment,e),_(uo.$$.fragment,e),_(ho.$$.fragment,e),_(_o.$$.fragment,e),_(bo.$$.fragment,e),_(vo.$$.fragment,e),_(To.$$.fragment,e),_($o.$$.fragment,e),_(yo.$$.fragment,e),_(ko.$$.fragment,e),_(xo.$$.fragment,e),_(Lo.$$.fragment,e),_(Eo.$$.fragment,e),_(Po.$$.fragment,e),_(Fo.$$.fragment,e),_(Do.$$.fragment,e),_(zo.$$.fragment,e),_(So.$$.fragment,e),_(Oo.$$.fragment,e),_(qo.$$.fragment,e),_(Bo.$$.fragment,e),_(Io.$$.fragment,e),_(Co.$$.fragment,e),_(Wo.$$.fragment,e),_(Ao.$$.fragment,e),_(No.$$.fragment,e),_(Vo.$$.fragment,e),_(Mo.$$.fragment,e),_(Go.$$.fragment,e),_(jo.$$.fragment,e),_(Ho.$$.fragment,e),_(Ro.$$.fragment,e),_(Ko.$$.fragment,e),_(Uo.$$.fragment,e),_(Yo.$$.fragment,e),_(Xo.$$.fragment,e),_(Jo.$$.fragment,e),_(Qo.$$.fragment,e),_(Zo.$$.fragment,e),_(en.$$.fragment,e),_(rn.$$.fragment,e),_(tn.$$.fragment,e),_(nn.$$.fragment,e),_(sn.$$.fragment,e),_(cn.$$.fragment,e),_(ln.$$.fragment,e),_(dn.$$.fragment,e),_(Gr.$$.fragment,e),_(pn.$$.fragment,e),_(mn.$$.fragment,e),_(fn.$$.fragment,e),_(gn.$$.fragment,e),_(hn.$$.fragment,e),_(_n.$$.fragment,e),_(bn.$$.fragment,e),_(Tn.$$.fragment,e),_($n.$$.fragment,e),_(kn.$$.fragment,e),_(xn.$$.fragment,e),_(wn.$$.fragment,e),_(Ln.$$.fragment,e),_(En.$$.fragment,e),_(Pn.$$.fragment,e),_(Fn.$$.fragment,e),_(Dn.$$.fragment,e),_(qn.$$.fragment,e),_(Bn.$$.fragment,e),_(In.$$.fragment,e),_(Cn.$$.fragment,e),_(Wn.$$.fragment,e),_(An.$$.fragment,e),_(Nn.$$.fragment,e),_(Mn.$$.fragment,e),Qp=!1},d(e){t(w),e&&t(He),e&&t(k),b(st),e&&t(vd),e&&t(y),e&&t(Td),e&&t(Zn),e&&t($d),e&&t(Re),b(at),e&&t(yd),e&&t(V),e&&t(kd),e&&t(os),e&&t(xd),b(it,e),e&&t(wd),e&&t(We),e&&t(Ld),e&&t(M),e&&t(Ed),e&&t(x),e&&t(Pd),e&&t(z),e&&t(Fd),e&&t(S),e&&t(Dd),b(ct,e),e&&t(zd),e&&t(br),e&&t(Sd),e&&t(O),e&&t(Od),e&&t(ls),e&&t(qd),e&&t(Ke),b(lt),e&&t(Bd),e&&t(Ue),b(dt),e&&t(Id),e&&t(Ye),b(pt),e&&t(Cd),e&&t(R),b(mt),b(ft),e&&t(Wd),e&&t(Xe),b(gt),e&&t(Ad),e&&t(Je),b(ut),e&&t(Nd),e&&t(Qe),b(ht),e&&t(Vd),e&&t(K),b(_t),b(bt),e&&t(Md),e&&t(Ze),b(vt),e&&t(Gd),e&&t(er),b(Tt),e&&t(jd),e&&t(rr),b($t),e&&t(Hd),e&&t(tr),b(yt),e&&t(Rd),e&&t(or),b(kt),e&&t(Kd),e&&t(nr),b(xt),e&&t(Ud),e&&t(sr),b(wt),e&&t(Yd),e&&t(Lr),e&&t(Xd),e&&t(U),b(Lt),b(Et),e&&t(Jd),e&&t(Y),b(Pt),b(Ft),e&&t(Qd),e&&t(X),b(Dt),b(zt),e&&t(Zd),e&&t(J),b(St),b(Ot),e&&t(ep),e&&t(Q),b(qt),b(Bt),e&&t(rp),e&&t(Z),b(It),b(Ct),e&&t(tp),e&&t(ee),b(Wt),b(At),e&&t(op),e&&t(re),b(Nt),b(Vt),e&&t(np),e&&t(ar),b(Mt),b(Gt),e&&t(sp),e&&t(te),b(jt),b(Rt),e&&t(ap),e&&t(oe),b(Kt),b(Ut),e&&t(ip),e&&t(ne),b(Yt),b(Jt),e&&t(cp),e&&t(se),b(Qt),b(eo),e&&t(lp),e&&t(ae),b(ro),b(to),e&&t(dp),e&&t(ie),b(oo),b(no),e&&t(pp),e&&t(ce),b(so),b(ao),e&&t(mp),e&&t(le),b(io),b(co),e&&t(fp),e&&t(de),b(lo),b(po),e&&t(gp),e&&t(pe),b(mo),b(fo),e&&t(up),e&&t(me),b(go),b(uo),e&&t(hp),e&&t(fe),b(ho),b(_o),e&&t(_p),e&&t(ge),b(bo),b(vo),e&&t(bp),e&&t(ue),b(To),b($o),e&&t(vp),e&&t(he),b(yo),b(ko),e&&t(Tp),e&&t(_e),b(xo),b(Lo),e&&t($p),e&&t(be),b(Eo),b(Po),e&&t(yp),e&&t(ve),b(Fo),b(Do),e&&t(kp),e&&t(Te),b(zo),b(So),e&&t(xp),e&&t($e),b(Oo),b(qo),e&&t(wp),e&&t(ye),b(Bo),b(Io),e&&t(Lp),e&&t(ke),b(Co),b(Wo),e&&t(Ep),e&&t(xe),b(Ao),b(No),e&&t(Pp),e&&t(we),b(Vo),b(Mo),e&&t(Fp),e&&t(Le),b(Go),b(jo),e&&t(Dp),e&&t(Ee),b(Ho),b(Ro),e&&t(zp),e&&t(Pe),b(Ko),b(Uo),e&&t(Sp),e&&t(Fe),b(Yo),b(Xo),e&&t(Op),e&&t(ir),b(Jo),e&&t(qp),e&&t(Nr),e&&t(Bp),e&&t(De),b(Qo),b(Zo),e&&t(Ip),e&&t(cr),b(en),b(rn),e&&t(Cp),e&&t(ze),b(tn),b(nn),e&&t(Wp),e&&t(Se),b(sn),b(cn),e&&t(Ap),e&&t(lr),b(ln),e&&t(Np),e&&t(Mr),e&&t(Vp),e&&t(T),b(dn),b(Gr),b(pn),b(mn),b(fn),b(gn),b(hn),b(_n),b(bn),e&&t(Mp),e&&t(dr),b(Tn),e&&t(Gp),e&&t(pr),b($n),e&&t(jp),e&&t(W),b(kn),b(xn),b(wn),e&&t(Hp),e&&t(fr),b(Ln),e&&t(Rp),e&&t(A),b(En),b(Pn),b(Fn),e&&t(Kp),e&&t(P),b(Dn),b(qn),b(Bn),e&&t(Up),e&&t(N),b(In),b(Cn),b(Wn),e&&t(Yp),e&&t(ur),b(An),e&&t(Xp),e&&t(qe),b(Nn),e&&t(Jp),e&&t(Be),b(Mn)}}}const y0={local:"utilities-for-generation",sections:[{local:"generate-outputs",sections:[{local:"transformers.generation_utils.GreedySearchDecoderOnlyOutput",title:"GreedySearchOutput"},{local:"transformers.generation_utils.SampleDecoderOnlyOutput",title:"SampleOutput"},{local:"transformers.generation_utils.BeamSearchDecoderOnlyOutput",title:"BeamSearchOutput"},{local:"transformers.generation_utils.BeamSampleDecoderOnlyOutput",title:"BeamSampleOutput"}],title:"Generate Outputs"},{local:"transformers.LogitsProcessor",title:"LogitsProcessor"},{local:"transformers.StoppingCriteria",title:"StoppingCriteria"},{local:"transformers.Constraint",title:"Constraints"},{local:"transformers.BeamScorer",title:"BeamSearch"},{local:"transformers.top_k_top_p_filtering",title:"Utilities"}],title:"Utilities for Generation"};function k0(bd){return _0(()=>{new URLSearchParams(window.location.search).get("fw")}),[]}class F0 extends f0{constructor(w){super();g0(this,w,k0,$0,u0,{})}}export{F0 as default,y0 as metadata};
