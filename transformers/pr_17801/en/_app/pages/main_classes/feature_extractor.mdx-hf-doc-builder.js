import{S as Ko,i as Qo,s as Xo,e as a,k as c,w as h,t as s,M as Zo,c as o,d as r,m as d,a as n,x as g,h as i,b as l,G as e,g as $,y as _,q as v,o as x,B as y,v as en,L as tn}from"../../chunks/vendor-hf-doc-builder.js";import{T as Yo}from"../../chunks/Tip-hf-doc-builder.js";import{D as k}from"../../chunks/Docstring-hf-doc-builder.js";import{C as rn}from"../../chunks/CodeBlock-hf-doc-builder.js";import{I as St}from"../../chunks/IconCopyLink-hf-doc-builder.js";import{E as an}from"../../chunks/ExampleCodeBlock-hf-doc-builder.js";function on(Y){let m,T,f,b,F;return{c(){m=a("p"),T=s("Passing "),f=a("code"),b=s("use_auth_token=True"),F=s(" is required when you want to use a private model.")},l(p){m=o(p,"P",{});var w=n(m);T=i(w,"Passing "),f=o(w,"CODE",{});var L=n(f);b=i(L,"use_auth_token=True"),L.forEach(r),F=i(w," is required when you want to use a private model."),w.forEach(r)},m(p,w){$(p,m,w),e(m,T),e(m,f),e(f,b),e(m,F)},d(p){p&&r(m)}}}function nn(Y){let m,T,f,b,F;return b=new rn({props:{code:`# We can't instantiate directly the base class *FeatureExtractionMixin* nor *SequenceFeatureExtractor* so let's show the examples on a
# derived class: *Wav2Vec2FeatureExtractor*
feature_extractor = Wav2Vec2FeatureExtractor.from_pretrained(
    "facebook/wav2vec2-base-960h"
)  # Download feature_extraction_config from huggingface.co and cache.
feature_extractor = Wav2Vec2FeatureExtractor.from_pretrained(
    "./test/saved_model/"
)  # E.g. feature_extractor (or model) was saved using *save_pretrained('./test/saved_model/')*
feature_extractor = Wav2Vec2FeatureExtractor.from_pretrained("./test/saved_model/preprocessor_config.json")
feature_extractor = Wav2Vec2FeatureExtractor.from_pretrained(
    "facebook/wav2vec2-base-960h", return_attention_mask=False, foo=False
)
assert feature_extractor.return_attention_mask is False
feature_extractor, unused_kwargs = Wav2Vec2FeatureExtractor.from_pretrained(
    "facebook/wav2vec2-base-960h", return_attention_mask=False, foo=False, return_unused_kwargs=True
)
assert feature_extractor.return_attention_mask is False
assert unused_kwargs == {"foo": False}`,highlighted:`<span class="hljs-comment"># We can&#x27;t instantiate directly the base class *FeatureExtractionMixin* nor *SequenceFeatureExtractor* so let&#x27;s show the examples on a</span>
<span class="hljs-comment"># derived class: *Wav2Vec2FeatureExtractor*</span>
feature_extractor = Wav2Vec2FeatureExtractor.from_pretrained(
    <span class="hljs-string">&quot;facebook/wav2vec2-base-960h&quot;</span>
)  <span class="hljs-comment"># Download feature_extraction_config from huggingface.co and cache.</span>
feature_extractor = Wav2Vec2FeatureExtractor.from_pretrained(
    <span class="hljs-string">&quot;./test/saved_model/&quot;</span>
)  <span class="hljs-comment"># E.g. feature_extractor (or model) was saved using *save_pretrained(&#x27;./test/saved_model/&#x27;)*</span>
feature_extractor = Wav2Vec2FeatureExtractor.from_pretrained(<span class="hljs-string">&quot;./test/saved_model/preprocessor_config.json&quot;</span>)
feature_extractor = Wav2Vec2FeatureExtractor.from_pretrained(
    <span class="hljs-string">&quot;facebook/wav2vec2-base-960h&quot;</span>, return_attention_mask=<span class="hljs-literal">False</span>, foo=<span class="hljs-literal">False</span>
)
<span class="hljs-keyword">assert</span> feature_extractor.return_attention_mask <span class="hljs-keyword">is</span> <span class="hljs-literal">False</span>
feature_extractor, unused_kwargs = Wav2Vec2FeatureExtractor.from_pretrained(
    <span class="hljs-string">&quot;facebook/wav2vec2-base-960h&quot;</span>, return_attention_mask=<span class="hljs-literal">False</span>, foo=<span class="hljs-literal">False</span>, return_unused_kwargs=<span class="hljs-literal">True</span>
)
<span class="hljs-keyword">assert</span> feature_extractor.return_attention_mask <span class="hljs-keyword">is</span> <span class="hljs-literal">False</span>
<span class="hljs-keyword">assert</span> unused_kwargs == {<span class="hljs-string">&quot;foo&quot;</span>: <span class="hljs-literal">False</span>}`}}),{c(){m=a("p"),T=s("Examples:"),f=c(),h(b.$$.fragment)},l(p){m=o(p,"P",{});var w=n(m);T=i(w,"Examples:"),w.forEach(r),f=d(p),g(b.$$.fragment,p)},m(p,w){$(p,m,w),e(m,T),$(p,f,w),_(b,p,w),F=!0},p:tn,i(p){F||(v(b.$$.fragment,p),F=!0)},o(p){x(b.$$.fragment,p),F=!1},d(p){p&&r(m),p&&r(f),y(b,p)}}}function sn(Y){let m,T,f,b,F,p,w,L;return{c(){m=a("p"),T=s("If the "),f=a("code"),b=s("processed_features"),F=s(` passed are dictionary of numpy arrays, PyTorch tensors or TensorFlow tensors, the
result will use the same type unless you provide a different tensor type with `),p=a("code"),w=s("return_tensors"),L=s(`. In the case of
PyTorch tensors, you will lose the specific device of your tensors however.`)},l(V){m=o(V,"P",{});var z=n(m);T=i(z,"If the "),f=o(z,"CODE",{});var M=n(f);b=i(M,"processed_features"),M.forEach(r),F=i(z,` passed are dictionary of numpy arrays, PyTorch tensors or TensorFlow tensors, the
result will use the same type unless you provide a different tensor type with `),p=o(z,"CODE",{});var He=n(p);w=i(He,"return_tensors"),He.forEach(r),L=i(z,`. In the case of
PyTorch tensors, you will lose the specific device of your tensors however.`),z.forEach(r)},m(V,z){$(V,m,z),e(m,T),e(m,f),e(f,b),e(m,F),e(m,p),e(p,w),e(m,L)},d(V){V&&r(m)}}}function cn(Y){let m,T,f,b,F,p,w,L,V,z,M,He,tt,pr,ur,rt,fr,hr,Nt,O,K,at,_e,gr,ot,_r,Bt,q,ve,vr,nt,xr,yr,S,xe,br,B,$r,Ue,Er,wr,st,Fr,Ir,Ge,Tr,kr,Pr,Q,zr,X,Mr,Z,ye,qr,W,Dr,it,Lr,Sr,Je,Nr,Br,At,R,ee,ct,be,Ar,dt,Cr,Ct,A,$e,jr,lt,Vr,Or,N,Ee,Wr,mt,Rr,Hr,H,Ur,pt,Gr,Jr,ut,Yr,Kr,Qr,te,jt,U,re,ft,we,Xr,ht,Zr,Vt,P,Fe,ea,G,ta,Ye,ra,aa,gt,oa,na,sa,_t,ia,ca,ae,Ie,da,vt,la,ma,oe,Te,pa,ke,ua,xt,fa,ha,Ot,J,ne,yt,Pe,ga,bt,_a,Wt,E,ze,va,$t,xa,ya,se,Me,ba,qe,$a,Et,Ea,wa,Fa,ie,De,Ia,Le,Ta,wt,ka,Pa,za,ce,Se,Ma,Ne,qa,Ft,Da,La,Sa,de,Be,Na,D,Ba,It,Aa,Ca,Tt,ja,Va,kt,Oa,Wa,Pt,Ra,Ha,Ua,le,Ae,Ga,Ce,Ja,zt,Ya,Ka,Qa,me,je,Xa,Ve,Za,Mt,eo,to,ro,pe,Oe,ao,We,oo,qt,no,so,Rt;return p=new St({}),_e=new St({}),ve=new k({props:{name:"class transformers.FeatureExtractionMixin",anchor:"transformers.FeatureExtractionMixin",parameters:[{name:"**kwargs",val:""}],source:"https://github.com/huggingface/transformers/blob/vr_17801/src/transformers/feature_extraction_utils.py#L204"}}),xe=new k({props:{name:"from_pretrained",anchor:"transformers.FeatureExtractionMixin.from_pretrained",parameters:[{name:"pretrained_model_name_or_path",val:": typing.Union[str, os.PathLike]"},{name:"**kwargs",val:""}],parametersDescription:[{anchor:"transformers.FeatureExtractionMixin.from_pretrained.pretrained_model_name_or_path",description:`<strong>pretrained_model_name_or_path</strong> (<code>str</code> or <code>os.PathLike</code>) &#x2014;
This can be either:</p>
<ul>
<li>a string, the <em>model id</em> of a pretrained feature_extractor hosted inside a model repo on
huggingface.co. Valid model ids can be located at the root-level, like <code>bert-base-uncased</code>, or
namespaced under a user or organization name, like <code>dbmdz/bert-base-german-cased</code>.</li>
<li>a path to a <em>directory</em> containing a feature extractor file saved using the
<a href="/docs/transformers/pr_17801/en/main_classes/feature_extractor#transformers.FeatureExtractionMixin.save_pretrained">save_pretrained()</a> method, e.g.,
<code>./my_model_directory/</code>.</li>
<li>a path or url to a saved feature extractor JSON <em>file</em>, e.g.,
<code>./my_model_directory/preprocessor_config.json</code>.</li>
</ul>`,name:"pretrained_model_name_or_path"},{anchor:"transformers.FeatureExtractionMixin.from_pretrained.cache_dir",description:`<strong>cache_dir</strong> (<code>str</code> or <code>os.PathLike</code>, <em>optional</em>) &#x2014;
Path to a directory in which a downloaded pretrained model feature extractor should be cached if the
standard cache should not be used.`,name:"cache_dir"},{anchor:"transformers.FeatureExtractionMixin.from_pretrained.force_download",description:`<strong>force_download</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether or not to force to (re-)download the feature extractor files and override the cached versions
if they exist.`,name:"force_download"},{anchor:"transformers.FeatureExtractionMixin.from_pretrained.resume_download",description:`<strong>resume_download</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether or not to delete incompletely received file. Attempts to resume the download if such a file
exists.`,name:"resume_download"},{anchor:"transformers.FeatureExtractionMixin.from_pretrained.proxies",description:`<strong>proxies</strong> (<code>Dict[str, str]</code>, <em>optional</em>) &#x2014;
A dictionary of proxy servers to use by protocol or endpoint, e.g., <code>{&apos;http&apos;: &apos;foo.bar:3128&apos;, &apos;http://hostname&apos;: &apos;foo.bar:4012&apos;}.</code> The proxies are used on each request.`,name:"proxies"},{anchor:"transformers.FeatureExtractionMixin.from_pretrained.use_auth_token",description:`<strong>use_auth_token</strong> (<code>str</code> or <em>bool</em>, <em>optional</em>) &#x2014;
The token to use as HTTP bearer authorization for remote files. If <code>True</code>, will use the token generated
when running <code>transformers-cli login</code> (stored in <code>~/.huggingface</code>).`,name:"use_auth_token"},{anchor:"transformers.FeatureExtractionMixin.from_pretrained.revision",description:`<strong>revision</strong> (<code>str</code>, <em>optional</em>, defaults to <code>&quot;main&quot;</code>) &#x2014;
The specific model version to use. It can be a branch name, a tag name, or a commit id, since we use a
git-based system for storing models and other artifacts on huggingface.co, so <code>revision</code> can be any
identifier allowed by git.`,name:"revision"},{anchor:"transformers.FeatureExtractionMixin.from_pretrained.return_unused_kwargs",description:`<strong>return_unused_kwargs</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
If <code>False</code>, then this function returns just the final feature extractor object. If <code>True</code>, then this
functions returns a <code>Tuple(feature_extractor, unused_kwargs)</code> where <em>unused_kwargs</em> is a dictionary
consisting of the key/value pairs whose keys are not feature extractor attributes: i.e., the part of
<code>kwargs</code> which has not been used to update <code>feature_extractor</code> and is otherwise ignored.`,name:"return_unused_kwargs"},{anchor:"transformers.FeatureExtractionMixin.from_pretrained.kwargs",description:`<strong>kwargs</strong> (<code>Dict[str, Any]</code>, <em>optional</em>) &#x2014;
The values in kwargs of any keys which are feature extractor attributes will be used to override the
loaded values. Behavior concerning key/value pairs whose keys are <em>not</em> feature extractor attributes is
controlled by the <code>return_unused_kwargs</code> keyword parameter.`,name:"kwargs"}],source:"https://github.com/huggingface/transformers/blob/vr_17801/src/transformers/feature_extraction_utils.py#L228",returnDescription:`
<p>A feature extractor of type <a
  href="/docs/transformers/pr_17801/en/main_classes/feature_extractor#transformers.FeatureExtractionMixin"
>FeatureExtractionMixin</a>.</p>
`}}),Q=new Yo({props:{$$slots:{default:[on]},$$scope:{ctx:Y}}}),X=new an({props:{anchor:"transformers.FeatureExtractionMixin.from_pretrained.example",$$slots:{default:[nn]},$$scope:{ctx:Y}}}),ye=new k({props:{name:"save_pretrained",anchor:"transformers.FeatureExtractionMixin.save_pretrained",parameters:[{name:"save_directory",val:": typing.Union[str, os.PathLike]"},{name:"push_to_hub",val:": bool = False"},{name:"**kwargs",val:""}],parametersDescription:[{anchor:"transformers.FeatureExtractionMixin.save_pretrained.save_directory",description:`<strong>save_directory</strong> (<code>str</code> or <code>os.PathLike</code>) &#x2014;
Directory where the feature extractor JSON file will be saved (will be created if it does not exist).`,name:"save_directory"},{anchor:"transformers.FeatureExtractionMixin.save_pretrained.push_to_hub",description:`<strong>push_to_hub</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether or not to push your feature extractor to the Hugging Face model hub after saving it.</p>
<div class="course-tip course-tip-orange bg-gradient-to-br dark:bg-gradient-to-r before:border-orange-500 dark:before:border-orange-800 from-orange-50 dark:from-gray-900 to-white dark:to-gray-950 border border-orange-50 text-orange-700 dark:text-gray-400">
						
<p>Using <code>push_to_hub=True</code> will synchronize the repository you are pushing to with <code>save_directory</code>,
which requires <code>save_directory</code> to be a local clone of the repo you are pushing to if it&#x2019;s an existing
folder. Pass along <code>temp_dir=True</code> to use a temporary directory instead.</p>

					</div>
<p>kwargs &#x2014;
Additional key word arguments passed along to the <a href="/docs/transformers/pr_17801/en/main_classes/model#transformers.utils.PushToHubMixin.push_to_hub">push_to_hub()</a> method.`,name:"push_to_hub"}],source:"https://github.com/huggingface/transformers/blob/vr_17801/src/transformers/feature_extraction_utils.py#L312"}}),be=new St({}),$e=new k({props:{name:"class transformers.SequenceFeatureExtractor",anchor:"transformers.SequenceFeatureExtractor",parameters:[{name:"feature_size",val:": int"},{name:"sampling_rate",val:": int"},{name:"padding_value",val:": float"},{name:"**kwargs",val:""}],parametersDescription:[{anchor:"transformers.SequenceFeatureExtractor.feature_size",description:`<strong>feature_size</strong> (<code>int</code>) &#x2014;
The feature dimension of the extracted features.`,name:"feature_size"},{anchor:"transformers.SequenceFeatureExtractor.sampling_rate",description:`<strong>sampling_rate</strong> (<code>int</code>) &#x2014;
The sampling rate at which the audio files should be digitalized expressed in Hertz per second (Hz).`,name:"sampling_rate"},{anchor:"transformers.SequenceFeatureExtractor.padding_value",description:`<strong>padding_value</strong> (<code>float</code>) &#x2014;
The value that is used to fill the padding values / vectors.`,name:"padding_value"}],source:"https://github.com/huggingface/transformers/blob/vr_17801/src/transformers/feature_extraction_sequence_utils.py#L30"}}),Ee=new k({props:{name:"pad",anchor:"transformers.SequenceFeatureExtractor.pad",parameters:[{name:"processed_features",val:": typing.Union[transformers.feature_extraction_utils.BatchFeature, typing.List[transformers.feature_extraction_utils.BatchFeature], typing.Dict[str, transformers.feature_extraction_utils.BatchFeature], typing.Dict[str, typing.List[transformers.feature_extraction_utils.BatchFeature]], typing.List[typing.Dict[str, transformers.feature_extraction_utils.BatchFeature]]]"},{name:"padding",val:": typing.Union[bool, str, transformers.utils.generic.PaddingStrategy] = True"},{name:"max_length",val:": typing.Optional[int] = None"},{name:"truncation",val:": bool = False"},{name:"pad_to_multiple_of",val:": typing.Optional[int] = None"},{name:"return_attention_mask",val:": typing.Optional[bool] = None"},{name:"return_tensors",val:": typing.Union[str, transformers.utils.generic.TensorType, NoneType] = None"}],parametersDescription:[{anchor:"transformers.SequenceFeatureExtractor.pad.processed_features",description:`<strong>processed_features</strong> (<a href="/docs/transformers/pr_17801/en/main_classes/feature_extractor#transformers.BatchFeature">BatchFeature</a>, list of <a href="/docs/transformers/pr_17801/en/main_classes/feature_extractor#transformers.BatchFeature">BatchFeature</a>, <code>Dict[str, List[float]]</code>, <code>Dict[str, List[List[float]]</code> or <code>List[Dict[str, List[float]]]</code>) &#x2014;
Processed inputs. Can represent one input (<a href="/docs/transformers/pr_17801/en/main_classes/feature_extractor#transformers.BatchFeature">BatchFeature</a> or <code>Dict[str, List[float]]</code>) or a batch of
input values / vectors (list of <a href="/docs/transformers/pr_17801/en/main_classes/feature_extractor#transformers.BatchFeature">BatchFeature</a>, <em>Dict[str, List[List[float]]]</em> or <em>List[Dict[str,
List[float]]]</em>) so you can use this method during preprocessing as well as in a PyTorch Dataloader
collate function.</p>
<p>Instead of <code>List[float]</code> you can have tensors (numpy arrays, PyTorch tensors or TensorFlow tensors),
see the note above for the return type.`,name:"processed_features"},{anchor:"transformers.SequenceFeatureExtractor.pad.padding",description:`<strong>padding</strong> (<code>bool</code>, <code>str</code> or <a href="/docs/transformers/pr_17801/en/internal/file_utils#transformers.utils.PaddingStrategy">PaddingStrategy</a>, <em>optional</em>, defaults to <code>True</code>) &#x2014;
Select a strategy to pad the returned sequences (according to the model&#x2019;s padding side and padding
index) among:</p>
<ul>
<li><code>True</code> or <code>&apos;longest&apos;</code>: Pad to the longest sequence in the batch (or no padding if only a single
sequence if provided).</li>
<li><code>&apos;max_length&apos;</code>: Pad to a maximum length specified with the argument <code>max_length</code> or to the maximum
acceptable input length for the model if that argument is not provided.</li>
<li><code>False</code> or <code>&apos;do_not_pad&apos;</code> (default): No padding (i.e., can output a batch with sequences of different
lengths).</li>
</ul>`,name:"padding"},{anchor:"transformers.SequenceFeatureExtractor.pad.max_length",description:`<strong>max_length</strong> (<code>int</code>, <em>optional</em>) &#x2014;
Maximum length of the returned list and optionally padding length (see above).`,name:"max_length"},{anchor:"transformers.SequenceFeatureExtractor.pad.truncation",description:`<strong>truncation</strong> (<code>bool</code>) &#x2014;
Activates truncation to cut input sequences longer than <code>max_length</code> to <code>max_length</code>.`,name:"truncation"},{anchor:"transformers.SequenceFeatureExtractor.pad.pad_to_multiple_of",description:`<strong>pad_to_multiple_of</strong> (<code>int</code>, <em>optional</em>) &#x2014;
If set will pad the sequence to a multiple of the provided value.</p>
<p>This is especially useful to enable the use of Tensor Cores on NVIDIA hardware with compute capability</p>
<blockquote>
<p>= 7.5 (Volta), or on TPUs which benefit from having sequence lengths be a multiple of 128.</p>
</blockquote>`,name:"pad_to_multiple_of"},{anchor:"transformers.SequenceFeatureExtractor.pad.return_attention_mask",description:`<strong>return_attention_mask</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether to return the attention mask. If left to the default, will return the attention mask according
to the specific feature_extractor&#x2019;s default.</p>
<p><a href="../glossary#attention-mask">What are attention masks?</a>`,name:"return_attention_mask"},{anchor:"transformers.SequenceFeatureExtractor.pad.return_tensors",description:`<strong>return_tensors</strong> (<code>str</code> or <a href="/docs/transformers/pr_17801/en/internal/file_utils#transformers.TensorType">TensorType</a>, <em>optional</em>) &#x2014;
If set, will return tensors instead of list of python integers. Acceptable values are:</p>
<ul>
<li><code>&apos;tf&apos;</code>: Return TensorFlow <code>tf.constant</code> objects.</li>
<li><code>&apos;pt&apos;</code>: Return PyTorch <code>torch.Tensor</code> objects.</li>
<li><code>&apos;np&apos;</code>: Return Numpy <code>np.ndarray</code> objects.</li>
</ul>`,name:"return_tensors"}],source:"https://github.com/huggingface/transformers/blob/vr_17801/src/transformers/feature_extraction_sequence_utils.py#L53"}}),te=new Yo({props:{$$slots:{default:[sn]},$$scope:{ctx:Y}}}),we=new St({}),Fe=new k({props:{name:"class transformers.BatchFeature",anchor:"transformers.BatchFeature",parameters:[{name:"data",val:": typing.Union[typing.Dict[str, typing.Any], NoneType] = None"},{name:"tensor_type",val:": typing.Union[NoneType, str, transformers.utils.generic.TensorType] = None"}],parametersDescription:[{anchor:"transformers.BatchFeature.data",description:`<strong>data</strong> (<code>dict</code>) &#x2014;
Dictionary of lists/arrays/tensors returned by the <strong>call</strong>/pad methods (&#x2018;input_values&#x2019;, &#x2018;attention_mask&#x2019;,
etc.).`,name:"data"},{anchor:"transformers.BatchFeature.tensor_type",description:`<strong>tensor_type</strong> (<code>Union[None, str, TensorType]</code>, <em>optional</em>) &#x2014;
You can give a tensor_type here to convert the lists of integers in PyTorch/TensorFlow/Numpy Tensors at
initialization.`,name:"tensor_type"}],source:"https://github.com/huggingface/transformers/blob/vr_17801/src/transformers/feature_extraction_utils.py#L62"}}),Ie=new k({props:{name:"convert_to_tensors",anchor:"transformers.BatchFeature.convert_to_tensors",parameters:[{name:"tensor_type",val:": typing.Union[str, transformers.utils.generic.TensorType, NoneType] = None"}],parametersDescription:[{anchor:"transformers.BatchFeature.convert_to_tensors.tensor_type",description:`<strong>tensor_type</strong> (<code>str</code> or <a href="/docs/transformers/pr_17801/en/internal/file_utils#transformers.TensorType">TensorType</a>, <em>optional</em>) &#x2014;
The type of tensors to use. If <code>str</code>, should be one of the values of the enum <a href="/docs/transformers/pr_17801/en/internal/file_utils#transformers.TensorType">TensorType</a>. If
<code>None</code>, no modification is done.`,name:"tensor_type"}],source:"https://github.com/huggingface/transformers/blob/vr_17801/src/transformers/feature_extraction_utils.py#L116"}}),Te=new k({props:{name:"to",anchor:"transformers.BatchFeature.to",parameters:[{name:"device",val:": typing.Union[str, ForwardRef('torch.device')]"}],parametersDescription:[{anchor:"transformers.BatchFeature.to.device",description:"<strong>device</strong> (<code>str</code> or <code>torch.device</code>) &#x2014; The device to put the tensors on.",name:"device"}],source:"https://github.com/huggingface/transformers/blob/vr_17801/src/transformers/feature_extraction_utils.py#L181",returnDescription:`
<p>The same instance after modification.</p>
`,returnType:`
<p><a
  href="/docs/transformers/pr_17801/en/main_classes/feature_extractor#transformers.BatchFeature"
>BatchFeature</a></p>
`}}),Pe=new St({}),ze=new k({props:{name:"class transformers.ImageFeatureExtractionMixin",anchor:"transformers.ImageFeatureExtractionMixin",parameters:[],source:"https://github.com/huggingface/transformers/blob/vr_17801/src/transformers/image_utils.py#L77"}}),Me=new k({props:{name:"center_crop",anchor:"transformers.ImageFeatureExtractionMixin.center_crop",parameters:[{name:"image",val:""},{name:"size",val:""}],parametersDescription:[{anchor:"transformers.ImageFeatureExtractionMixin.center_crop.image",description:`<strong>image</strong> (<code>PIL.Image.Image</code> or <code>np.ndarray</code> or <code>torch.Tensor</code> of shape (n_channels, height, width) or (height, width, n_channels)) &#x2014;
The image to resize.`,name:"image"},{anchor:"transformers.ImageFeatureExtractionMixin.center_crop.size",description:`<strong>size</strong> (<code>int</code> or <code>Tuple[int, int]</code>) &#x2014;
The size to which crop the image.`,name:"size"}],source:"https://github.com/huggingface/transformers/blob/vr_17801/src/transformers/image_utils.py#L287",returnDescription:`
<p>A center cropped <code>PIL.Image.Image</code> or <code>np.ndarray</code> or <code>torch.Tensor</code> of shape: (n_channels,
height, width).</p>
`,returnType:`
<p>new_image</p>
`}}),De=new k({props:{name:"convert_rgb",anchor:"transformers.ImageFeatureExtractionMixin.convert_rgb",parameters:[{name:"image",val:""}],parametersDescription:[{anchor:"transformers.ImageFeatureExtractionMixin.convert_rgb.image",description:`<strong>image</strong> (<code>PIL.Image.Image</code>) &#x2014;
The image to convert.`,name:"image"}],source:"https://github.com/huggingface/transformers/blob/vr_17801/src/transformers/image_utils.py#L119"}}),Se=new k({props:{name:"expand_dims",anchor:"transformers.ImageFeatureExtractionMixin.expand_dims",parameters:[{name:"image",val:""}],parametersDescription:[{anchor:"transformers.ImageFeatureExtractionMixin.expand_dims.image",description:`<strong>image</strong> (<code>PIL.Image.Image</code> or <code>np.ndarray</code> or <code>torch.Tensor</code>) &#x2014;
The image to expand.`,name:"image"}],source:"https://github.com/huggingface/transformers/blob/vr_17801/src/transformers/image_utils.py#L166"}}),Be=new k({props:{name:"normalize",anchor:"transformers.ImageFeatureExtractionMixin.normalize",parameters:[{name:"image",val:""},{name:"mean",val:""},{name:"std",val:""}],parametersDescription:[{anchor:"transformers.ImageFeatureExtractionMixin.normalize.image",description:`<strong>image</strong> (<code>PIL.Image.Image</code> or <code>np.ndarray</code> or <code>torch.Tensor</code>) &#x2014;
The image to normalize.`,name:"image"},{anchor:"transformers.ImageFeatureExtractionMixin.normalize.mean",description:`<strong>mean</strong> (<code>List[float]</code> or <code>np.ndarray</code> or <code>torch.Tensor</code>) &#x2014;
The mean (per channel) to use for normalization.`,name:"mean"},{anchor:"transformers.ImageFeatureExtractionMixin.normalize.std",description:`<strong>std</strong> (<code>List[float]</code> or <code>np.ndarray</code> or <code>torch.Tensor</code>) &#x2014;
The standard deviation (per channel) to use for normalization.`,name:"std"}],source:"https://github.com/huggingface/transformers/blob/vr_17801/src/transformers/image_utils.py#L186"}}),Ae=new k({props:{name:"resize",anchor:"transformers.ImageFeatureExtractionMixin.resize",parameters:[{name:"image",val:""},{name:"size",val:""},{name:"resample",val:" = <Resampling.BILINEAR: 2>"},{name:"default_to_square",val:" = True"},{name:"max_size",val:" = None"}],parametersDescription:[{anchor:"transformers.ImageFeatureExtractionMixin.resize.image",description:`<strong>image</strong> (<code>PIL.Image.Image</code> or <code>np.ndarray</code> or <code>torch.Tensor</code>) &#x2014;
The image to resize.`,name:"image"},{anchor:"transformers.ImageFeatureExtractionMixin.resize.size",description:`<strong>size</strong> (<code>int</code> or <code>Tuple[int, int]</code>) &#x2014;
The size to use for resizing the image. If <code>size</code> is a sequence like (h, w), output size will be
matched to this.</p>
<p>If <code>size</code> is an int and <code>default_to_square</code> is <code>True</code>, then image will be resized to (size, size). If
<code>size</code> is an int and <code>default_to_square</code> is <code>False</code>, then smaller edge of the image will be matched to
this number. i.e, if height &gt; width, then image will be rescaled to (size * height / width, size).`,name:"size"},{anchor:"transformers.ImageFeatureExtractionMixin.resize.resample",description:`<strong>resample</strong> (<code>int</code>, <em>optional</em>, defaults to <code>PIL.Image.BILINEAR</code>) &#x2014;
The filter to user for resampling.`,name:"resample"},{anchor:"transformers.ImageFeatureExtractionMixin.resize.default_to_square",description:`<strong>default_to_square</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>True</code>) &#x2014;
How to convert <code>size</code> when it is a single int. If set to <code>True</code>, the <code>size</code> will be converted to a
square (<code>size</code>,<code>size</code>). If set to <code>False</code>, will replicate
<a href="https://pytorch.org/vision/stable/transforms.html#torchvision.transforms.Resize" rel="nofollow"><code>torchvision.transforms.Resize</code></a>
with support for resizing only the smallest edge and providing an optional <code>max_size</code>.`,name:"default_to_square"},{anchor:"transformers.ImageFeatureExtractionMixin.resize.max_size",description:`<strong>max_size</strong> (<code>int</code>, <em>optional</em>, defaults to <code>None</code>) &#x2014;
The maximum allowed for the longer edge of the resized image: if the longer edge of the image is
greater than <code>max_size</code> after being resized according to <code>size</code>, then the image is resized again so
that the longer edge is equal to <code>max_size</code>. As a result, <code>size</code> might be overruled, i.e the smaller
edge may be shorter than <code>size</code>. Only used if <code>default_to_square</code> is <code>False</code>.`,name:"max_size"}],source:"https://github.com/huggingface/transformers/blob/vr_17801/src/transformers/image_utils.py#L222",returnDescription:`
<p>A resized <code>PIL.Image.Image</code>.</p>
`,returnType:`
<p>image</p>
`}}),je=new k({props:{name:"to_numpy_array",anchor:"transformers.ImageFeatureExtractionMixin.to_numpy_array",parameters:[{name:"image",val:""},{name:"rescale",val:" = None"},{name:"channel_first",val:" = True"}],parametersDescription:[{anchor:"transformers.ImageFeatureExtractionMixin.to_numpy_array.image",description:`<strong>image</strong> (<code>PIL.Image.Image</code> or <code>np.ndarray</code> or <code>torch.Tensor</code>) &#x2014;
The image to convert to a NumPy array.`,name:"image"},{anchor:"transformers.ImageFeatureExtractionMixin.to_numpy_array.rescale",description:`<strong>rescale</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to apply the scaling factor (to make pixel values floats between 0. and 1.). Will
default to <code>True</code> if the image is a PIL Image or an array/tensor of integers, <code>False</code> otherwise.`,name:"rescale"},{anchor:"transformers.ImageFeatureExtractionMixin.to_numpy_array.channel_first",description:`<strong>channel_first</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>True</code>) &#x2014;
Whether or not to permute the dimensions of the image to put the channel dimension first.`,name:"channel_first"}],source:"https://github.com/huggingface/transformers/blob/vr_17801/src/transformers/image_utils.py#L133"}}),Oe=new k({props:{name:"to_pil_image",anchor:"transformers.ImageFeatureExtractionMixin.to_pil_image",parameters:[{name:"image",val:""},{name:"rescale",val:" = None"}],parametersDescription:[{anchor:"transformers.ImageFeatureExtractionMixin.to_pil_image.image",description:`<strong>image</strong> (<code>PIL.Image.Image</code> or <code>numpy.ndarray</code> or <code>torch.Tensor</code>) &#x2014;
The image to convert to the PIL Image format.`,name:"image"},{anchor:"transformers.ImageFeatureExtractionMixin.to_pil_image.rescale",description:`<strong>rescale</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to apply the scaling factor (to make pixel values integers between 0 and 255). Will
default to <code>True</code> if the image type is a floating type, <code>False</code> otherwise.`,name:"rescale"}],source:"https://github.com/huggingface/transformers/blob/vr_17801/src/transformers/image_utils.py#L89"}}),{c(){m=a("meta"),T=c(),f=a("h1"),b=a("a"),F=a("span"),h(p.$$.fragment),w=c(),L=a("span"),V=s("Feature Extractor"),z=c(),M=a("p"),He=s(`A feature extractor is in charge of preparing input features for a multi-modal model. This includes feature extraction
from sequences, `),tt=a("em"),pr=s("e.g."),ur=s(`, pre-processing audio files to Log-Mel Spectrogram features, feature extraction from images
`),rt=a("em"),fr=s("e.g."),hr=s(` cropping image image files, but also padding, normalization, and conversion to Numpy, PyTorch, and TensorFlow
tensors.`),Nt=c(),O=a("h2"),K=a("a"),at=a("span"),h(_e.$$.fragment),gr=c(),ot=a("span"),_r=s("FeatureExtractionMixin"),Bt=c(),q=a("div"),h(ve.$$.fragment),vr=c(),nt=a("p"),xr=s(`This is a feature extraction mixin used to provide saving/loading functionality for sequential and image feature
extractors.`),yr=c(),S=a("div"),h(xe.$$.fragment),br=c(),B=a("p"),$r=s("Instantiate a type of "),Ue=a("a"),Er=s("FeatureExtractionMixin"),wr=s(" from a feature extractor, "),st=a("em"),Fr=s("e.g."),Ir=s(` a
derived class of `),Ge=a("a"),Tr=s("SequenceFeatureExtractor"),kr=s("."),Pr=c(),h(Q.$$.fragment),zr=c(),h(X.$$.fragment),Mr=c(),Z=a("div"),h(ye.$$.fragment),qr=c(),W=a("p"),Dr=s("Save a feature_extractor object to the directory "),it=a("code"),Lr=s("save_directory"),Sr=s(`, so that it can be re-loaded using the
`),Je=a("a"),Nr=s("from_pretrained()"),Br=s(" class method."),At=c(),R=a("h2"),ee=a("a"),ct=a("span"),h(be.$$.fragment),Ar=c(),dt=a("span"),Cr=s("SequenceFeatureExtractor"),Ct=c(),A=a("div"),h($e.$$.fragment),jr=c(),lt=a("p"),Vr=s("This is a general feature extraction class for speech recognition."),Or=c(),N=a("div"),h(Ee.$$.fragment),Wr=c(),mt=a("p"),Rr=s(`Pad input values / input vectors or a batch of input values / input vectors up to predefined length or to the
max sequence length in the batch.`),Hr=c(),H=a("p"),Ur=s("Padding side (left/right) padding values are defined at the feature extractor level (with "),pt=a("code"),Gr=s("self.padding_side"),Jr=s(`,
`),ut=a("code"),Yr=s("self.padding_value"),Kr=s(")"),Qr=c(),h(te.$$.fragment),jt=c(),U=a("h2"),re=a("a"),ft=a("span"),h(we.$$.fragment),Xr=c(),ht=a("span"),Zr=s("BatchFeature"),Vt=c(),P=a("div"),h(Fe.$$.fragment),ea=c(),G=a("p"),ta=s("Holds the output of the "),Ye=a("a"),ra=s("pad()"),aa=s(" and feature extractor specific "),gt=a("code"),oa=s("__call__"),na=s(" methods."),sa=c(),_t=a("p"),ia=s("This class is derived from a python dictionary and can be used as a dictionary."),ca=c(),ae=a("div"),h(Ie.$$.fragment),da=c(),vt=a("p"),la=s("Convert the inner content to tensors."),ma=c(),oe=a("div"),h(Te.$$.fragment),pa=c(),ke=a("p"),ua=s("Send all values to device by calling "),xt=a("code"),fa=s("v.to(device)"),ha=s(" (PyTorch only)."),Ot=c(),J=a("h2"),ne=a("a"),yt=a("span"),h(Pe.$$.fragment),ga=c(),bt=a("span"),_a=s("ImageFeatureExtractionMixin"),Wt=c(),E=a("div"),h(ze.$$.fragment),va=c(),$t=a("p"),xa=s("Mixin that contain utilities for preparing image features."),ya=c(),se=a("div"),h(Me.$$.fragment),ba=c(),qe=a("p"),$a=s("Crops "),Et=a("code"),Ea=s("image"),wa=s(` to the given size using a center crop. Note that if the image is too small to be cropped to the
size given, it will be padded (so the returned result has the size asked).`),Fa=c(),ie=a("div"),h(De.$$.fragment),Ia=c(),Le=a("p"),Ta=s("Converts "),wt=a("code"),ka=s("PIL.Image.Image"),Pa=s(" to RGB format."),za=c(),ce=a("div"),h(Se.$$.fragment),Ma=c(),Ne=a("p"),qa=s("Expands 2-dimensional "),Ft=a("code"),Da=s("image"),La=s(" to 3 dimensions."),Sa=c(),de=a("div"),h(Be.$$.fragment),Na=c(),D=a("p"),Ba=s("Normalizes "),It=a("code"),Aa=s("image"),Ca=s(" with "),Tt=a("code"),ja=s("mean"),Va=s(" and "),kt=a("code"),Oa=s("std"),Wa=s(". Note that this will trigger a conversion of "),Pt=a("code"),Ra=s("image"),Ha=s(` to a NumPy array
if it\u2019s a PIL Image.`),Ua=c(),le=a("div"),h(Ae.$$.fragment),Ga=c(),Ce=a("p"),Ja=s("Resizes "),zt=a("code"),Ya=s("image"),Ka=s(". Enforces conversion of input to PIL.Image."),Qa=c(),me=a("div"),h(je.$$.fragment),Xa=c(),Ve=a("p"),Za=s("Converts "),Mt=a("code"),eo=s("image"),to=s(` to a numpy array. Optionally rescales it and puts the channel dimension as the first
dimension.`),ro=c(),pe=a("div"),h(Oe.$$.fragment),ao=c(),We=a("p"),oo=s("Converts "),qt=a("code"),no=s("image"),so=s(` to a PIL Image. Optionally rescales it and puts the channel dimension back as the last axis if
needed.`),this.h()},l(t){const u=Zo('[data-svelte="svelte-1phssyn"]',document.head);m=o(u,"META",{name:!0,content:!0}),u.forEach(r),T=d(t),f=o(t,"H1",{class:!0});var Re=n(f);b=o(Re,"A",{id:!0,class:!0,href:!0});var Dt=n(b);F=o(Dt,"SPAN",{});var Lt=n(F);g(p.$$.fragment,Lt),Lt.forEach(r),Dt.forEach(r),w=d(Re),L=o(Re,"SPAN",{});var io=n(L);V=i(io,"Feature Extractor"),io.forEach(r),Re.forEach(r),z=d(t),M=o(t,"P",{});var Ke=n(M);He=i(Ke,`A feature extractor is in charge of preparing input features for a multi-modal model. This includes feature extraction
from sequences, `),tt=o(Ke,"EM",{});var co=n(tt);pr=i(co,"e.g."),co.forEach(r),ur=i(Ke,`, pre-processing audio files to Log-Mel Spectrogram features, feature extraction from images
`),rt=o(Ke,"EM",{});var lo=n(rt);fr=i(lo,"e.g."),lo.forEach(r),hr=i(Ke,` cropping image image files, but also padding, normalization, and conversion to Numpy, PyTorch, and TensorFlow
tensors.`),Ke.forEach(r),Nt=d(t),O=o(t,"H2",{class:!0});var Ht=n(O);K=o(Ht,"A",{id:!0,class:!0,href:!0});var mo=n(K);at=o(mo,"SPAN",{});var po=n(at);g(_e.$$.fragment,po),po.forEach(r),mo.forEach(r),gr=d(Ht),ot=o(Ht,"SPAN",{});var uo=n(ot);_r=i(uo,"FeatureExtractionMixin"),uo.forEach(r),Ht.forEach(r),Bt=d(t),q=o(t,"DIV",{class:!0});var ue=n(q);g(ve.$$.fragment,ue),vr=d(ue),nt=o(ue,"P",{});var fo=n(nt);xr=i(fo,`This is a feature extraction mixin used to provide saving/loading functionality for sequential and image feature
extractors.`),fo.forEach(r),yr=d(ue),S=o(ue,"DIV",{class:!0});var fe=n(S);g(xe.$$.fragment,fe),br=d(fe),B=o(fe,"P",{});var he=n(B);$r=i(he,"Instantiate a type of "),Ue=o(he,"A",{href:!0});var ho=n(Ue);Er=i(ho,"FeatureExtractionMixin"),ho.forEach(r),wr=i(he," from a feature extractor, "),st=o(he,"EM",{});var go=n(st);Fr=i(go,"e.g."),go.forEach(r),Ir=i(he,` a
derived class of `),Ge=o(he,"A",{href:!0});var _o=n(Ge);Tr=i(_o,"SequenceFeatureExtractor"),_o.forEach(r),kr=i(he,"."),he.forEach(r),Pr=d(fe),g(Q.$$.fragment,fe),zr=d(fe),g(X.$$.fragment,fe),fe.forEach(r),Mr=d(ue),Z=o(ue,"DIV",{class:!0});var Ut=n(Z);g(ye.$$.fragment,Ut),qr=d(Ut),W=o(Ut,"P",{});var Qe=n(W);Dr=i(Qe,"Save a feature_extractor object to the directory "),it=o(Qe,"CODE",{});var vo=n(it);Lr=i(vo,"save_directory"),vo.forEach(r),Sr=i(Qe,`, so that it can be re-loaded using the
`),Je=o(Qe,"A",{href:!0});var xo=n(Je);Nr=i(xo,"from_pretrained()"),xo.forEach(r),Br=i(Qe," class method."),Qe.forEach(r),Ut.forEach(r),ue.forEach(r),At=d(t),R=o(t,"H2",{class:!0});var Gt=n(R);ee=o(Gt,"A",{id:!0,class:!0,href:!0});var yo=n(ee);ct=o(yo,"SPAN",{});var bo=n(ct);g(be.$$.fragment,bo),bo.forEach(r),yo.forEach(r),Ar=d(Gt),dt=o(Gt,"SPAN",{});var $o=n(dt);Cr=i($o,"SequenceFeatureExtractor"),$o.forEach(r),Gt.forEach(r),Ct=d(t),A=o(t,"DIV",{class:!0});var Xe=n(A);g($e.$$.fragment,Xe),jr=d(Xe),lt=o(Xe,"P",{});var Eo=n(lt);Vr=i(Eo,"This is a general feature extraction class for speech recognition."),Eo.forEach(r),Or=d(Xe),N=o(Xe,"DIV",{class:!0});var ge=n(N);g(Ee.$$.fragment,ge),Wr=d(ge),mt=o(ge,"P",{});var wo=n(mt);Rr=i(wo,`Pad input values / input vectors or a batch of input values / input vectors up to predefined length or to the
max sequence length in the batch.`),wo.forEach(r),Hr=d(ge),H=o(ge,"P",{});var Ze=n(H);Ur=i(Ze,"Padding side (left/right) padding values are defined at the feature extractor level (with "),pt=o(Ze,"CODE",{});var Fo=n(pt);Gr=i(Fo,"self.padding_side"),Fo.forEach(r),Jr=i(Ze,`,
`),ut=o(Ze,"CODE",{});var Io=n(ut);Yr=i(Io,"self.padding_value"),Io.forEach(r),Kr=i(Ze,")"),Ze.forEach(r),Qr=d(ge),g(te.$$.fragment,ge),ge.forEach(r),Xe.forEach(r),jt=d(t),U=o(t,"H2",{class:!0});var Jt=n(U);re=o(Jt,"A",{id:!0,class:!0,href:!0});var To=n(re);ft=o(To,"SPAN",{});var ko=n(ft);g(we.$$.fragment,ko),ko.forEach(r),To.forEach(r),Xr=d(Jt),ht=o(Jt,"SPAN",{});var Po=n(ht);Zr=i(Po,"BatchFeature"),Po.forEach(r),Jt.forEach(r),Vt=d(t),P=o(t,"DIV",{class:!0});var C=n(P);g(Fe.$$.fragment,C),ea=d(C),G=o(C,"P",{});var et=n(G);ta=i(et,"Holds the output of the "),Ye=o(et,"A",{href:!0});var zo=n(Ye);ra=i(zo,"pad()"),zo.forEach(r),aa=i(et," and feature extractor specific "),gt=o(et,"CODE",{});var Mo=n(gt);oa=i(Mo,"__call__"),Mo.forEach(r),na=i(et," methods."),et.forEach(r),sa=d(C),_t=o(C,"P",{});var qo=n(_t);ia=i(qo,"This class is derived from a python dictionary and can be used as a dictionary."),qo.forEach(r),ca=d(C),ae=o(C,"DIV",{class:!0});var Yt=n(ae);g(Ie.$$.fragment,Yt),da=d(Yt),vt=o(Yt,"P",{});var Do=n(vt);la=i(Do,"Convert the inner content to tensors."),Do.forEach(r),Yt.forEach(r),ma=d(C),oe=o(C,"DIV",{class:!0});var Kt=n(oe);g(Te.$$.fragment,Kt),pa=d(Kt),ke=o(Kt,"P",{});var Qt=n(ke);ua=i(Qt,"Send all values to device by calling "),xt=o(Qt,"CODE",{});var Lo=n(xt);fa=i(Lo,"v.to(device)"),Lo.forEach(r),ha=i(Qt," (PyTorch only)."),Qt.forEach(r),Kt.forEach(r),C.forEach(r),Ot=d(t),J=o(t,"H2",{class:!0});var Xt=n(J);ne=o(Xt,"A",{id:!0,class:!0,href:!0});var So=n(ne);yt=o(So,"SPAN",{});var No=n(yt);g(Pe.$$.fragment,No),No.forEach(r),So.forEach(r),ga=d(Xt),bt=o(Xt,"SPAN",{});var Bo=n(bt);_a=i(Bo,"ImageFeatureExtractionMixin"),Bo.forEach(r),Xt.forEach(r),Wt=d(t),E=o(t,"DIV",{class:!0});var I=n(E);g(ze.$$.fragment,I),va=d(I),$t=o(I,"P",{});var Ao=n($t);xa=i(Ao,"Mixin that contain utilities for preparing image features."),Ao.forEach(r),ya=d(I),se=o(I,"DIV",{class:!0});var Zt=n(se);g(Me.$$.fragment,Zt),ba=d(Zt),qe=o(Zt,"P",{});var er=n(qe);$a=i(er,"Crops "),Et=o(er,"CODE",{});var Co=n(Et);Ea=i(Co,"image"),Co.forEach(r),wa=i(er,` to the given size using a center crop. Note that if the image is too small to be cropped to the
size given, it will be padded (so the returned result has the size asked).`),er.forEach(r),Zt.forEach(r),Fa=d(I),ie=o(I,"DIV",{class:!0});var tr=n(ie);g(De.$$.fragment,tr),Ia=d(tr),Le=o(tr,"P",{});var rr=n(Le);Ta=i(rr,"Converts "),wt=o(rr,"CODE",{});var jo=n(wt);ka=i(jo,"PIL.Image.Image"),jo.forEach(r),Pa=i(rr," to RGB format."),rr.forEach(r),tr.forEach(r),za=d(I),ce=o(I,"DIV",{class:!0});var ar=n(ce);g(Se.$$.fragment,ar),Ma=d(ar),Ne=o(ar,"P",{});var or=n(Ne);qa=i(or,"Expands 2-dimensional "),Ft=o(or,"CODE",{});var Vo=n(Ft);Da=i(Vo,"image"),Vo.forEach(r),La=i(or," to 3 dimensions."),or.forEach(r),ar.forEach(r),Sa=d(I),de=o(I,"DIV",{class:!0});var nr=n(de);g(Be.$$.fragment,nr),Na=d(nr),D=o(nr,"P",{});var j=n(D);Ba=i(j,"Normalizes "),It=o(j,"CODE",{});var Oo=n(It);Aa=i(Oo,"image"),Oo.forEach(r),Ca=i(j," with "),Tt=o(j,"CODE",{});var Wo=n(Tt);ja=i(Wo,"mean"),Wo.forEach(r),Va=i(j," and "),kt=o(j,"CODE",{});var Ro=n(kt);Oa=i(Ro,"std"),Ro.forEach(r),Wa=i(j,". Note that this will trigger a conversion of "),Pt=o(j,"CODE",{});var Ho=n(Pt);Ra=i(Ho,"image"),Ho.forEach(r),Ha=i(j,` to a NumPy array
if it\u2019s a PIL Image.`),j.forEach(r),nr.forEach(r),Ua=d(I),le=o(I,"DIV",{class:!0});var sr=n(le);g(Ae.$$.fragment,sr),Ga=d(sr),Ce=o(sr,"P",{});var ir=n(Ce);Ja=i(ir,"Resizes "),zt=o(ir,"CODE",{});var Uo=n(zt);Ya=i(Uo,"image"),Uo.forEach(r),Ka=i(ir,". Enforces conversion of input to PIL.Image."),ir.forEach(r),sr.forEach(r),Qa=d(I),me=o(I,"DIV",{class:!0});var cr=n(me);g(je.$$.fragment,cr),Xa=d(cr),Ve=o(cr,"P",{});var dr=n(Ve);Za=i(dr,"Converts "),Mt=o(dr,"CODE",{});var Go=n(Mt);eo=i(Go,"image"),Go.forEach(r),to=i(dr,` to a numpy array. Optionally rescales it and puts the channel dimension as the first
dimension.`),dr.forEach(r),cr.forEach(r),ro=d(I),pe=o(I,"DIV",{class:!0});var lr=n(pe);g(Oe.$$.fragment,lr),ao=d(lr),We=o(lr,"P",{});var mr=n(We);oo=i(mr,"Converts "),qt=o(mr,"CODE",{});var Jo=n(qt);no=i(Jo,"image"),Jo.forEach(r),so=i(mr,` to a PIL Image. Optionally rescales it and puts the channel dimension back as the last axis if
needed.`),mr.forEach(r),lr.forEach(r),I.forEach(r),this.h()},h(){l(m,"name","hf:doc:metadata"),l(m,"content",JSON.stringify(dn)),l(b,"id","feature-extractor"),l(b,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),l(b,"href","#feature-extractor"),l(f,"class","relative group"),l(K,"id","transformers.FeatureExtractionMixin"),l(K,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),l(K,"href","#transformers.FeatureExtractionMixin"),l(O,"class","relative group"),l(Ue,"href","/docs/transformers/pr_17801/en/main_classes/feature_extractor#transformers.FeatureExtractionMixin"),l(Ge,"href","/docs/transformers/pr_17801/en/main_classes/feature_extractor#transformers.SequenceFeatureExtractor"),l(S,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),l(Je,"href","/docs/transformers/pr_17801/en/main_classes/feature_extractor#transformers.FeatureExtractionMixin.from_pretrained"),l(Z,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),l(q,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),l(ee,"id","transformers.SequenceFeatureExtractor"),l(ee,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),l(ee,"href","#transformers.SequenceFeatureExtractor"),l(R,"class","relative group"),l(N,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),l(A,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),l(re,"id","transformers.BatchFeature"),l(re,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),l(re,"href","#transformers.BatchFeature"),l(U,"class","relative group"),l(Ye,"href","/docs/transformers/pr_17801/en/main_classes/feature_extractor#transformers.SequenceFeatureExtractor.pad"),l(ae,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),l(oe,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),l(P,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),l(ne,"id","transformers.ImageFeatureExtractionMixin"),l(ne,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),l(ne,"href","#transformers.ImageFeatureExtractionMixin"),l(J,"class","relative group"),l(se,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),l(ie,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),l(ce,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),l(de,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),l(le,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),l(me,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),l(pe,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),l(E,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8")},m(t,u){e(document.head,m),$(t,T,u),$(t,f,u),e(f,b),e(b,F),_(p,F,null),e(f,w),e(f,L),e(L,V),$(t,z,u),$(t,M,u),e(M,He),e(M,tt),e(tt,pr),e(M,ur),e(M,rt),e(rt,fr),e(M,hr),$(t,Nt,u),$(t,O,u),e(O,K),e(K,at),_(_e,at,null),e(O,gr),e(O,ot),e(ot,_r),$(t,Bt,u),$(t,q,u),_(ve,q,null),e(q,vr),e(q,nt),e(nt,xr),e(q,yr),e(q,S),_(xe,S,null),e(S,br),e(S,B),e(B,$r),e(B,Ue),e(Ue,Er),e(B,wr),e(B,st),e(st,Fr),e(B,Ir),e(B,Ge),e(Ge,Tr),e(B,kr),e(S,Pr),_(Q,S,null),e(S,zr),_(X,S,null),e(q,Mr),e(q,Z),_(ye,Z,null),e(Z,qr),e(Z,W),e(W,Dr),e(W,it),e(it,Lr),e(W,Sr),e(W,Je),e(Je,Nr),e(W,Br),$(t,At,u),$(t,R,u),e(R,ee),e(ee,ct),_(be,ct,null),e(R,Ar),e(R,dt),e(dt,Cr),$(t,Ct,u),$(t,A,u),_($e,A,null),e(A,jr),e(A,lt),e(lt,Vr),e(A,Or),e(A,N),_(Ee,N,null),e(N,Wr),e(N,mt),e(mt,Rr),e(N,Hr),e(N,H),e(H,Ur),e(H,pt),e(pt,Gr),e(H,Jr),e(H,ut),e(ut,Yr),e(H,Kr),e(N,Qr),_(te,N,null),$(t,jt,u),$(t,U,u),e(U,re),e(re,ft),_(we,ft,null),e(U,Xr),e(U,ht),e(ht,Zr),$(t,Vt,u),$(t,P,u),_(Fe,P,null),e(P,ea),e(P,G),e(G,ta),e(G,Ye),e(Ye,ra),e(G,aa),e(G,gt),e(gt,oa),e(G,na),e(P,sa),e(P,_t),e(_t,ia),e(P,ca),e(P,ae),_(Ie,ae,null),e(ae,da),e(ae,vt),e(vt,la),e(P,ma),e(P,oe),_(Te,oe,null),e(oe,pa),e(oe,ke),e(ke,ua),e(ke,xt),e(xt,fa),e(ke,ha),$(t,Ot,u),$(t,J,u),e(J,ne),e(ne,yt),_(Pe,yt,null),e(J,ga),e(J,bt),e(bt,_a),$(t,Wt,u),$(t,E,u),_(ze,E,null),e(E,va),e(E,$t),e($t,xa),e(E,ya),e(E,se),_(Me,se,null),e(se,ba),e(se,qe),e(qe,$a),e(qe,Et),e(Et,Ea),e(qe,wa),e(E,Fa),e(E,ie),_(De,ie,null),e(ie,Ia),e(ie,Le),e(Le,Ta),e(Le,wt),e(wt,ka),e(Le,Pa),e(E,za),e(E,ce),_(Se,ce,null),e(ce,Ma),e(ce,Ne),e(Ne,qa),e(Ne,Ft),e(Ft,Da),e(Ne,La),e(E,Sa),e(E,de),_(Be,de,null),e(de,Na),e(de,D),e(D,Ba),e(D,It),e(It,Aa),e(D,Ca),e(D,Tt),e(Tt,ja),e(D,Va),e(D,kt),e(kt,Oa),e(D,Wa),e(D,Pt),e(Pt,Ra),e(D,Ha),e(E,Ua),e(E,le),_(Ae,le,null),e(le,Ga),e(le,Ce),e(Ce,Ja),e(Ce,zt),e(zt,Ya),e(Ce,Ka),e(E,Qa),e(E,me),_(je,me,null),e(me,Xa),e(me,Ve),e(Ve,Za),e(Ve,Mt),e(Mt,eo),e(Ve,to),e(E,ro),e(E,pe),_(Oe,pe,null),e(pe,ao),e(pe,We),e(We,oo),e(We,qt),e(qt,no),e(We,so),Rt=!0},p(t,[u]){const Re={};u&2&&(Re.$$scope={dirty:u,ctx:t}),Q.$set(Re);const Dt={};u&2&&(Dt.$$scope={dirty:u,ctx:t}),X.$set(Dt);const Lt={};u&2&&(Lt.$$scope={dirty:u,ctx:t}),te.$set(Lt)},i(t){Rt||(v(p.$$.fragment,t),v(_e.$$.fragment,t),v(ve.$$.fragment,t),v(xe.$$.fragment,t),v(Q.$$.fragment,t),v(X.$$.fragment,t),v(ye.$$.fragment,t),v(be.$$.fragment,t),v($e.$$.fragment,t),v(Ee.$$.fragment,t),v(te.$$.fragment,t),v(we.$$.fragment,t),v(Fe.$$.fragment,t),v(Ie.$$.fragment,t),v(Te.$$.fragment,t),v(Pe.$$.fragment,t),v(ze.$$.fragment,t),v(Me.$$.fragment,t),v(De.$$.fragment,t),v(Se.$$.fragment,t),v(Be.$$.fragment,t),v(Ae.$$.fragment,t),v(je.$$.fragment,t),v(Oe.$$.fragment,t),Rt=!0)},o(t){x(p.$$.fragment,t),x(_e.$$.fragment,t),x(ve.$$.fragment,t),x(xe.$$.fragment,t),x(Q.$$.fragment,t),x(X.$$.fragment,t),x(ye.$$.fragment,t),x(be.$$.fragment,t),x($e.$$.fragment,t),x(Ee.$$.fragment,t),x(te.$$.fragment,t),x(we.$$.fragment,t),x(Fe.$$.fragment,t),x(Ie.$$.fragment,t),x(Te.$$.fragment,t),x(Pe.$$.fragment,t),x(ze.$$.fragment,t),x(Me.$$.fragment,t),x(De.$$.fragment,t),x(Se.$$.fragment,t),x(Be.$$.fragment,t),x(Ae.$$.fragment,t),x(je.$$.fragment,t),x(Oe.$$.fragment,t),Rt=!1},d(t){r(m),t&&r(T),t&&r(f),y(p),t&&r(z),t&&r(M),t&&r(Nt),t&&r(O),y(_e),t&&r(Bt),t&&r(q),y(ve),y(xe),y(Q),y(X),y(ye),t&&r(At),t&&r(R),y(be),t&&r(Ct),t&&r(A),y($e),y(Ee),y(te),t&&r(jt),t&&r(U),y(we),t&&r(Vt),t&&r(P),y(Fe),y(Ie),y(Te),t&&r(Ot),t&&r(J),y(Pe),t&&r(Wt),t&&r(E),y(ze),y(Me),y(De),y(Se),y(Be),y(Ae),y(je),y(Oe)}}}const dn={local:"feature-extractor",sections:[{local:"transformers.FeatureExtractionMixin",title:"FeatureExtractionMixin"},{local:"transformers.SequenceFeatureExtractor",title:"SequenceFeatureExtractor"},{local:"transformers.BatchFeature",title:"BatchFeature"},{local:"transformers.ImageFeatureExtractionMixin",title:"ImageFeatureExtractionMixin"}],title:"Feature Extractor"};function ln(Y){return en(()=>{new URLSearchParams(window.location.search).get("fw")}),[]}class _n extends Ko{constructor(m){super();Qo(this,m,ln,cn,Xo,{})}}export{_n as default,dn as metadata};
