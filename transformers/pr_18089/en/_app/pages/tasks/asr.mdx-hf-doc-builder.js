import{S as Ue,i as Fe,s as Ye,e as r,k as u,w,t as e,M as Ve,c as o,d as t,m as d,a as p,x as y,h as n,b as m,G as a,g as i,y as k,q as x,o as E,B as A,v as Ne}from"../../chunks/vendor-hf-doc-builder.js";import{T as ee}from"../../chunks/Tip-hf-doc-builder.js";import{Y as He}from"../../chunks/Youtube-hf-doc-builder.js";import{I as et}from"../../chunks/IconCopyLink-hf-doc-builder.js";import{C as U}from"../../chunks/CodeBlock-hf-doc-builder.js";import{F as Be,M as Ge}from"../../chunks/Markdown-hf-doc-builder.js";function Je(F){let c,j,h,$,v;return{c(){c=r("p"),j=e("See the automatic speech recognition "),h=r("a"),$=e("task page"),v=e(" for more information about its associated models, datasets, and metrics."),this.h()},l(g){c=o(g,"P",{});var q=p(c);j=n(q,"See the automatic speech recognition "),h=o(q,"A",{href:!0,rel:!0});var T=p(h);$=n(T,"task page"),T.forEach(t),v=n(q," for more information about its associated models, datasets, and metrics."),q.forEach(t),this.h()},h(){m(h,"href","https://huggingface.co/tasks/automatic-speech-recognition"),m(h,"rel","nofollow")},m(g,q){i(g,c,q),a(c,j),a(c,h),a(h,$),a(c,v)},d(g){g&&t(c)}}}function Ke(F){let c,j,h,$,v,g,q,T;return{c(){c=r("p"),j=e("If you aren\u2019t familiar with fine-tuning a model with the "),h=r("a"),$=e("Trainer"),v=e(", take a look at the basic tutorial "),g=r("a"),q=e("here"),T=e("!"),this.h()},l(P){c=o(P,"P",{});var _=p(c);j=n(_,"If you aren\u2019t familiar with fine-tuning a model with the "),h=o(_,"A",{href:!0});var D=p(h);$=n(D,"Trainer"),D.forEach(t),v=n(_,", take a look at the basic tutorial "),g=o(_,"A",{href:!0});var C=p(g);q=n(C,"here"),C.forEach(t),T=n(_,"!"),_.forEach(t),this.h()},h(){m(h,"href","/docs/transformers/pr_18089/en/main_classes/trainer#transformers.Trainer"),m(g,"href","../training#finetune-with-trainer")},m(P,_){i(P,c,_),a(c,j),a(c,h),a(h,$),a(c,v),a(c,g),a(g,q),a(c,T)},d(P){P&&t(c)}}}function Qe(F){let c,j,h,$,v,g,q,T,P,_,D,C,K,as,us,S,R,I,ys,ts,Q,ks,xs,Y,V,X,M,N,cs,L,Es,H,As,ds,W,Z,B;return _=new U({props:{code:`from transformers import AutoModelForCTC, TrainingArguments, Trainer

model = AutoModelForCTC.from_pretrained(
    "facebook/wav2vec2-base",
    ctc_loss_reduction="mean",
    pad_token_id=processor.tokenizer.pad_token_id,
)`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> AutoModelForCTC, TrainingArguments, Trainer

<span class="hljs-meta">&gt;&gt;&gt; </span>model = AutoModelForCTC.from_pretrained(
<span class="hljs-meta">... </span>    <span class="hljs-string">&quot;facebook/wav2vec2-base&quot;</span>,
<span class="hljs-meta">... </span>    ctc_loss_reduction=<span class="hljs-string">&quot;mean&quot;</span>,
<span class="hljs-meta">... </span>    pad_token_id=processor.tokenizer.pad_token_id,
<span class="hljs-meta">... </span>)`}}),C=new ee({props:{$$slots:{default:[Ke]},$$scope:{ctx:F}}}),Z=new U({props:{code:`training_args = TrainingArguments(
    output_dir="./results",
    group_by_length=True,
    per_device_train_batch_size=16,
    evaluation_strategy="steps",
    num_train_epochs=3,
    fp16=True,
    gradient_checkpointing=True,
    learning_rate=1e-4,
    weight_decay=0.005,
    save_total_limit=2,
)

trainer = Trainer(
    model=model,
    args=training_args,
    train_dataset=encoded_minds["train"],
    eval_dataset=encoded_minds["test"],
    tokenizer=processor.feature_extractor,
    data_collator=data_collator,
)

trainer.train()`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span>training_args = TrainingArguments(
<span class="hljs-meta">... </span>    output_dir=<span class="hljs-string">&quot;./results&quot;</span>,
<span class="hljs-meta">... </span>    group_by_length=<span class="hljs-literal">True</span>,
<span class="hljs-meta">... </span>    per_device_train_batch_size=<span class="hljs-number">16</span>,
<span class="hljs-meta">... </span>    evaluation_strategy=<span class="hljs-string">&quot;steps&quot;</span>,
<span class="hljs-meta">... </span>    num_train_epochs=<span class="hljs-number">3</span>,
<span class="hljs-meta">... </span>    fp16=<span class="hljs-literal">True</span>,
<span class="hljs-meta">... </span>    gradient_checkpointing=<span class="hljs-literal">True</span>,
<span class="hljs-meta">... </span>    learning_rate=<span class="hljs-number">1e-4</span>,
<span class="hljs-meta">... </span>    weight_decay=<span class="hljs-number">0.005</span>,
<span class="hljs-meta">... </span>    save_total_limit=<span class="hljs-number">2</span>,
<span class="hljs-meta">... </span>)

<span class="hljs-meta">&gt;&gt;&gt; </span>trainer = Trainer(
<span class="hljs-meta">... </span>    model=model,
<span class="hljs-meta">... </span>    args=training_args,
<span class="hljs-meta">... </span>    train_dataset=encoded_minds[<span class="hljs-string">&quot;train&quot;</span>],
<span class="hljs-meta">... </span>    eval_dataset=encoded_minds[<span class="hljs-string">&quot;test&quot;</span>],
<span class="hljs-meta">... </span>    tokenizer=processor.feature_extractor,
<span class="hljs-meta">... </span>    data_collator=data_collator,
<span class="hljs-meta">... </span>)

<span class="hljs-meta">&gt;&gt;&gt; </span>trainer.train()`}}),{c(){c=r("p"),j=e("Load Wav2Vec2 with "),h=r("a"),$=e("AutoModelForCTC"),v=e(". For "),g=r("code"),q=e("ctc_loss_reduction"),T=e(", it is often better to use the average instead of the default summation:"),P=u(),w(_.$$.fragment),D=u(),w(C.$$.fragment),K=u(),as=r("p"),us=e("At this point, only three steps remain:"),S=u(),R=r("ol"),I=r("li"),ys=e("Define your training hyperparameters in "),ts=r("a"),Q=e("TrainingArguments"),ks=e("."),xs=u(),Y=r("li"),V=e("Pass the training arguments to "),X=r("a"),M=e("Trainer"),N=e(" along with the model, datasets, tokenizer, and data collator."),cs=u(),L=r("li"),Es=e("Call "),H=r("a"),As=e("train()"),ds=e(" to fine-tune your model."),W=u(),w(Z.$$.fragment),this.h()},l(f){c=o(f,"P",{});var b=p(c);j=n(b,"Load Wav2Vec2 with "),h=o(b,"A",{href:!0});var es=p(h);$=n(es,"AutoModelForCTC"),es.forEach(t),v=n(b,". For "),g=o(b,"CODE",{});var ns=p(g);q=n(ns,"ctc_loss_reduction"),ns.forEach(t),T=n(b,", it is often better to use the average instead of the default summation:"),b.forEach(t),P=d(f),y(_.$$.fragment,f),D=d(f),y(C.$$.fragment,f),K=d(f),as=o(f,"P",{});var qs=p(as);us=n(qs,"At this point, only three steps remain:"),qs.forEach(t),S=d(f),R=o(f,"OL",{});var z=p(R);I=o(z,"LI",{});var ms=p(I);ys=n(ms,"Define your training hyperparameters in "),ts=o(ms,"A",{href:!0});var Ts=p(ts);Q=n(Ts,"TrainingArguments"),Ts.forEach(t),ks=n(ms,"."),ms.forEach(t),xs=d(z),Y=o(z,"LI",{});var G=p(Y);V=n(G,"Pass the training arguments to "),X=o(G,"A",{href:!0});var Ps=p(X);M=n(Ps,"Trainer"),Ps.forEach(t),N=n(G," along with the model, datasets, tokenizer, and data collator."),G.forEach(t),cs=d(z),L=o(z,"LI",{});var ss=p(L);Es=n(ss,"Call "),H=o(ss,"A",{href:!0});var Bs=p(H);As=n(Bs,"train()"),Bs.forEach(t),ds=n(ss," to fine-tune your model."),ss.forEach(t),z.forEach(t),W=d(f),y(Z.$$.fragment,f),this.h()},h(){m(h,"href","/docs/transformers/pr_18089/en/model_doc/auto#transformers.AutoModelForCTC"),m(ts,"href","/docs/transformers/pr_18089/en/main_classes/trainer#transformers.TrainingArguments"),m(X,"href","/docs/transformers/pr_18089/en/main_classes/trainer#transformers.Trainer"),m(H,"href","/docs/transformers/pr_18089/en/main_classes/trainer#transformers.Trainer.train")},m(f,b){i(f,c,b),a(c,j),a(c,h),a(h,$),a(c,v),a(c,g),a(g,q),a(c,T),i(f,P,b),k(_,f,b),i(f,D,b),k(C,f,b),i(f,K,b),i(f,as,b),a(as,us),i(f,S,b),i(f,R,b),a(R,I),a(I,ys),a(I,ts),a(ts,Q),a(I,ks),a(R,xs),a(R,Y),a(Y,V),a(Y,X),a(X,M),a(Y,N),a(R,cs),a(R,L),a(L,Es),a(L,H),a(H,As),a(L,ds),i(f,W,b),k(Z,f,b),B=!0},p(f,b){const es={};b&2&&(es.$$scope={dirty:b,ctx:f}),C.$set(es)},i(f){B||(x(_.$$.fragment,f),x(C.$$.fragment,f),x(Z.$$.fragment,f),B=!0)},o(f){E(_.$$.fragment,f),E(C.$$.fragment,f),E(Z.$$.fragment,f),B=!1},d(f){f&&t(c),f&&t(P),A(_,f),f&&t(D),A(C,f),f&&t(K),f&&t(as),f&&t(S),f&&t(R),f&&t(W),A(Z,f)}}}function Xe(F){let c,j;return c=new Ge({props:{$$slots:{default:[Qe]},$$scope:{ctx:F}}}),{c(){w(c.$$.fragment)},l(h){y(c.$$.fragment,h)},m(h,$){k(c,h,$),j=!0},p(h,$){const v={};$&2&&(v.$$scope={dirty:$,ctx:h}),c.$set(v)},i(h){j||(x(c.$$.fragment,h),j=!0)},o(h){E(c.$$.fragment,h),j=!1},d(h){A(c,h)}}}function Ze(F){let c,j,h,$,v,g,q,T;return{c(){c=r("p"),j=e("For a more in-depth example of how to fine-tune a model for automatic speech recognition, take a look at this blog "),h=r("a"),$=e("post"),v=e(" for English ASR and this "),g=r("a"),q=e("post"),T=e(" for multilingual ASR."),this.h()},l(P){c=o(P,"P",{});var _=p(c);j=n(_,"For a more in-depth example of how to fine-tune a model for automatic speech recognition, take a look at this blog "),h=o(_,"A",{href:!0,rel:!0});var D=p(h);$=n(D,"post"),D.forEach(t),v=n(_," for English ASR and this "),g=o(_,"A",{href:!0,rel:!0});var C=p(g);q=n(C,"post"),C.forEach(t),T=n(_," for multilingual ASR."),_.forEach(t),this.h()},h(){m(h,"href","https://huggingface.co/blog/fine-tune-wav2vec2-english"),m(h,"rel","nofollow"),m(g,"href","https://huggingface.co/blog/fine-tune-xlsr-wav2vec2"),m(g,"rel","nofollow")},m(P,_){i(P,c,_),a(c,j),a(c,h),a(h,$),a(c,v),a(c,g),a(g,q),a(c,T)},d(P){P&&t(c)}}}function sn(F){let c,j,h,$,v,g,q,T,P,_,D,C,K,as,us,S,R,I,ys,ts,Q,ks,xs,Y,V,X,M,N,cs,L,Es,H,As,ds,W,Z,B,f,b,es,ns,qs,z,ms,Ts,G,Ps,ss,Bs,ka,Cs,xa,O,nt,ea,lt,rt,na,ot,pt,la,it,ct,ra,ht,ft,Ea,Ds,Aa,Gs,ut,qa,Ss,Ta,ls,dt,oa,mt,gt,pa,_t,$t,Pa,hs,gs,ia,Is,jt,ca,bt,Ca,Js,vt,Da,Ls,Sa,_s,wt,Rs,yt,kt,Ia,Os,La,Ks,xt,Ra,rs,Ms,Et,ha,At,qt,Tt,Ws,Pt,fa,Ct,Dt,St,ua,It,Oa,zs,Ma,os,Lt,Us,Rt,Ot,da,Mt,Wt,Wa,Fs,za,J,zt,Qs,Ut,Ft,ma,Yt,Vt,ga,Nt,Ht,Ua,ps,Bt,_a,Gt,Jt,$a,Kt,Qt,Fa,Ys,Ya,$s,Xt,ja,Zt,se,Va,Vs,Na,fs,js,ba,Ns,ae,va,te,Ha,bs,Ba,vs,Ga;return g=new et({}),D=new He({props:{id:"TksaY_FDgnk"}}),V=new ee({props:{$$slots:{default:[Je]},$$scope:{ctx:F}}}),L=new et({}),ns=new U({props:{code:`from datasets import load_dataset, Audio

minds = load_dataset("PolyAI/minds14", name="en-US", split="train")`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> datasets <span class="hljs-keyword">import</span> load_dataset, Audio

<span class="hljs-meta">&gt;&gt;&gt; </span>minds = load_dataset(<span class="hljs-string">&quot;PolyAI/minds14&quot;</span>, name=<span class="hljs-string">&quot;en-US&quot;</span>, split=<span class="hljs-string">&quot;train&quot;</span>)`}}),G=new U({props:{code:"minds = minds.train_test_split(test_size=0.2)",highlighted:'<span class="hljs-meta">&gt;&gt;&gt; </span>minds = minds.train_test_split(test_size=<span class="hljs-number">0.2</span>)'}}),Cs=new U({props:{code:"minds",highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span>minds
DatasetDict({
    train: Dataset({
        features: [<span class="hljs-string">&#x27;path&#x27;</span>, <span class="hljs-string">&#x27;audio&#x27;</span>, <span class="hljs-string">&#x27;transcription&#x27;</span>, <span class="hljs-string">&#x27;english_transcription&#x27;</span>, <span class="hljs-string">&#x27;intent_class&#x27;</span>, <span class="hljs-string">&#x27;lang_id&#x27;</span>],
        num_rows: <span class="hljs-number">450</span>
    })
    test: Dataset({
        features: [<span class="hljs-string">&#x27;path&#x27;</span>, <span class="hljs-string">&#x27;audio&#x27;</span>, <span class="hljs-string">&#x27;transcription&#x27;</span>, <span class="hljs-string">&#x27;english_transcription&#x27;</span>, <span class="hljs-string">&#x27;intent_class&#x27;</span>, <span class="hljs-string">&#x27;lang_id&#x27;</span>],
        num_rows: <span class="hljs-number">113</span>
    })
})`}}),Ds=new U({props:{code:'minds = minds.remove_columns(["english_transcription", "intent_class", "lang_id"])',highlighted:'<span class="hljs-meta">&gt;&gt;&gt; </span>minds = minds.remove_columns([<span class="hljs-string">&quot;english_transcription&quot;</span>, <span class="hljs-string">&quot;intent_class&quot;</span>, <span class="hljs-string">&quot;lang_id&quot;</span>])'}}),Ss=new U({props:{code:'minds["train"][0]',highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span>minds[<span class="hljs-string">&quot;train&quot;</span>][<span class="hljs-number">0</span>]
{<span class="hljs-string">&#x27;audio&#x27;</span>: {<span class="hljs-string">&#x27;array&#x27;</span>: array([-<span class="hljs-number">0.00024414</span>,  <span class="hljs-number">0.</span>        ,  <span class="hljs-number">0.</span>        , ...,  <span class="hljs-number">0.00024414</span>,
          <span class="hljs-number">0.00024414</span>,  <span class="hljs-number">0.00024414</span>], dtype=float32),
  <span class="hljs-string">&#x27;path&#x27;</span>: <span class="hljs-string">&#x27;/root/.cache/huggingface/datasets/downloads/extracted/f14948e0e84be638dd7943ac36518a4cf3324e8b7aa331c5ab11541518e9368c/en-US~APP_ERROR/602ba9e2963e11ccd901cd4f.wav&#x27;</span>,
  <span class="hljs-string">&#x27;sampling_rate&#x27;</span>: <span class="hljs-number">8000</span>},
 <span class="hljs-string">&#x27;path&#x27;</span>: <span class="hljs-string">&#x27;/root/.cache/huggingface/datasets/downloads/extracted/f14948e0e84be638dd7943ac36518a4cf3324e8b7aa331c5ab11541518e9368c/en-US~APP_ERROR/602ba9e2963e11ccd901cd4f.wav&#x27;</span>,
 <span class="hljs-string">&#x27;transcription&#x27;</span>: <span class="hljs-string">&quot;hi I&#x27;m trying to use the banking app on my phone and currently my checking and savings account balance is not refreshing&quot;</span>}`}}),Is=new et({}),Ls=new U({props:{code:`from transformers import AutoProcessor

processor = AutoProcessor.from_pretrained("facebook/wav2vec2-base")`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> AutoProcessor

<span class="hljs-meta">&gt;&gt;&gt; </span>processor = AutoProcessor.from_pretrained(<span class="hljs-string">&quot;facebook/wav2vec2-base&quot;</span>)`}}),Os=new U({props:{code:`minds = minds.cast_column("audio", Audio(sampling_rate=16_000))
minds["train"][0]`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span>minds = minds.cast_column(<span class="hljs-string">&quot;audio&quot;</span>, Audio(sampling_rate=<span class="hljs-number">16_000</span>))
<span class="hljs-meta">&gt;&gt;&gt; </span>minds[<span class="hljs-string">&quot;train&quot;</span>][<span class="hljs-number">0</span>]
{<span class="hljs-string">&#x27;audio&#x27;</span>: {<span class="hljs-string">&#x27;array&#x27;</span>: array([-<span class="hljs-number">2.38064706e-04</span>, -<span class="hljs-number">1.58618059e-04</span>, -<span class="hljs-number">5.43987835e-06</span>, ...,
          <span class="hljs-number">2.78103951e-04</span>,  <span class="hljs-number">2.38446111e-04</span>,  <span class="hljs-number">1.18740834e-04</span>], dtype=float32),
  <span class="hljs-string">&#x27;path&#x27;</span>: <span class="hljs-string">&#x27;/root/.cache/huggingface/datasets/downloads/extracted/f14948e0e84be638dd7943ac36518a4cf3324e8b7aa331c5ab11541518e9368c/en-US~APP_ERROR/602ba9e2963e11ccd901cd4f.wav&#x27;</span>,
  <span class="hljs-string">&#x27;sampling_rate&#x27;</span>: <span class="hljs-number">16000</span>},
 <span class="hljs-string">&#x27;path&#x27;</span>: <span class="hljs-string">&#x27;/root/.cache/huggingface/datasets/downloads/extracted/f14948e0e84be638dd7943ac36518a4cf3324e8b7aa331c5ab11541518e9368c/en-US~APP_ERROR/602ba9e2963e11ccd901cd4f.wav&#x27;</span>,
 <span class="hljs-string">&#x27;transcription&#x27;</span>: <span class="hljs-string">&quot;hi I&#x27;m trying to use the banking app on my phone and currently my checking and savings account balance is not refreshing&quot;</span>}`}}),zs=new U({props:{code:`def prepare_dataset(batch):
    audio = batch["audio"]

    batch["input_values"] = processor(audio["array"], sampling_rate=audio["sampling_rate"]).input_values[0]
    batch["input_length"] = len(batch["input_values"])

    with processor.as_target_processor():
        batch["labels"] = processor(batch["transcription"]).input_ids
    return batch`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">def</span> <span class="hljs-title function_">prepare_dataset</span>(<span class="hljs-params">batch</span>):
<span class="hljs-meta">... </span>    audio = batch[<span class="hljs-string">&quot;audio&quot;</span>]

<span class="hljs-meta">... </span>    batch[<span class="hljs-string">&quot;input_values&quot;</span>] = processor(audio[<span class="hljs-string">&quot;array&quot;</span>], sampling_rate=audio[<span class="hljs-string">&quot;sampling_rate&quot;</span>]).input_values[<span class="hljs-number">0</span>]
<span class="hljs-meta">... </span>    batch[<span class="hljs-string">&quot;input_length&quot;</span>] = <span class="hljs-built_in">len</span>(batch[<span class="hljs-string">&quot;input_values&quot;</span>])

<span class="hljs-meta">... </span>    <span class="hljs-keyword">with</span> processor.as_target_processor():
<span class="hljs-meta">... </span>        batch[<span class="hljs-string">&quot;labels&quot;</span>] = processor(batch[<span class="hljs-string">&quot;transcription&quot;</span>]).input_ids
<span class="hljs-meta">... </span>    <span class="hljs-keyword">return</span> batch`}}),Fs=new U({props:{code:'encoded_minds = minds.map(prepare_dataset, remove_columns=minds.column_names["train"], num_proc=4)',highlighted:'<span class="hljs-meta">&gt;&gt;&gt; </span>encoded_minds = minds.<span class="hljs-built_in">map</span>(prepare_dataset, remove_columns=minds.column_names[<span class="hljs-string">&quot;train&quot;</span>], num_proc=<span class="hljs-number">4</span>)'}}),Ys=new U({props:{code:`import torch

from dataclasses import dataclass, field
from typing import Any, Dict, List, Optional, Union


@dataclass
class DataCollatorCTCWithPadding:

    processor: AutoProcessor
    padding: Union[bool, str] = True

    def __call__(self, features: List[Dict[str, Union[List[int], torch.Tensor]]]) -> Dict[str, torch.Tensor]:
        # split inputs and labels since they have to be of different lengths and need
        # different padding methods
        input_features = [{"input_values": feature["input_values"]} for feature in features]
        label_features = [{"input_ids": feature["labels"]} for feature in features]

        batch = self.processor.pad(
            input_features,
            padding=self.padding,
            return_tensors="pt",
        )
        with self.processor.as_target_processor():
            labels_batch = self.processor.pad(
                label_features,
                padding=self.padding,
                return_tensors="pt",
            )

        # replace padding with -100 to ignore loss correctly
        labels = labels_batch["input_ids"].masked_fill(labels_batch.attention_mask.ne(1), -100)

        batch["labels"] = labels

        return batch`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> torch

<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> dataclasses <span class="hljs-keyword">import</span> dataclass, field
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> <span class="hljs-type">Any</span>, <span class="hljs-type">Dict</span>, <span class="hljs-type">List</span>, <span class="hljs-type">Optional</span>, <span class="hljs-type">Union</span>


<span class="hljs-meta">&gt;&gt;&gt; </span>@dataclass
<span class="hljs-meta">... </span><span class="hljs-keyword">class</span> <span class="hljs-title class_">DataCollatorCTCWithPadding</span>:

<span class="hljs-meta">... </span>    processor: AutoProcessor
<span class="hljs-meta">... </span>    padding: <span class="hljs-type">Union</span>[<span class="hljs-built_in">bool</span>, <span class="hljs-built_in">str</span>] = <span class="hljs-literal">True</span>

<span class="hljs-meta">... </span>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__call__</span>(<span class="hljs-params">self, features: <span class="hljs-type">List</span>[<span class="hljs-type">Dict</span>[<span class="hljs-built_in">str</span>, <span class="hljs-type">Union</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], torch.Tensor]]]</span>) -&gt; <span class="hljs-type">Dict</span>[<span class="hljs-built_in">str</span>, torch.Tensor]:
<span class="hljs-meta">... </span>        <span class="hljs-comment"># split inputs and labels since they have to be of different lengths and need</span>
<span class="hljs-meta">... </span>        <span class="hljs-comment"># different padding methods</span>
<span class="hljs-meta">... </span>        input_features = [{<span class="hljs-string">&quot;input_values&quot;</span>: feature[<span class="hljs-string">&quot;input_values&quot;</span>]} <span class="hljs-keyword">for</span> feature <span class="hljs-keyword">in</span> features]
<span class="hljs-meta">... </span>        label_features = [{<span class="hljs-string">&quot;input_ids&quot;</span>: feature[<span class="hljs-string">&quot;labels&quot;</span>]} <span class="hljs-keyword">for</span> feature <span class="hljs-keyword">in</span> features]

<span class="hljs-meta">... </span>        batch = self.processor.pad(
<span class="hljs-meta">... </span>            input_features,
<span class="hljs-meta">... </span>            padding=self.padding,
<span class="hljs-meta">... </span>            return_tensors=<span class="hljs-string">&quot;pt&quot;</span>,
<span class="hljs-meta">... </span>        )
<span class="hljs-meta">... </span>        <span class="hljs-keyword">with</span> self.processor.as_target_processor():
<span class="hljs-meta">... </span>            labels_batch = self.processor.pad(
<span class="hljs-meta">... </span>                label_features,
<span class="hljs-meta">... </span>                padding=self.padding,
<span class="hljs-meta">... </span>                return_tensors=<span class="hljs-string">&quot;pt&quot;</span>,
<span class="hljs-meta">... </span>            )

<span class="hljs-meta">... </span>        <span class="hljs-comment"># replace padding with -100 to ignore loss correctly</span>
<span class="hljs-meta">... </span>        labels = labels_batch[<span class="hljs-string">&quot;input_ids&quot;</span>].masked_fill(labels_batch.attention_mask.ne(<span class="hljs-number">1</span>), -<span class="hljs-number">100</span>)

<span class="hljs-meta">... </span>        batch[<span class="hljs-string">&quot;labels&quot;</span>] = labels

<span class="hljs-meta">... </span>        <span class="hljs-keyword">return</span> batch`}}),Vs=new U({props:{code:"data_collator = DataCollatorCTCWithPadding(processor=processor, padding=True)",highlighted:'<span class="hljs-meta">&gt;&gt;&gt; </span>data_collator = DataCollatorCTCWithPadding(processor=processor, padding=<span class="hljs-literal">True</span>)'}}),Ns=new et({}),bs=new Be({props:{pytorch:!0,tensorflow:!1,jax:!1,$$slots:{pytorch:[Xe]},$$scope:{ctx:F}}}),vs=new ee({props:{$$slots:{default:[Ze]},$$scope:{ctx:F}}}),{c(){c=r("meta"),j=u(),h=r("h1"),$=r("a"),v=r("span"),w(g.$$.fragment),q=u(),T=r("span"),P=e("Automatic speech recognition"),_=u(),w(D.$$.fragment),C=u(),K=r("p"),as=e("Automatic speech recognition (ASR) converts a speech signal to text. It is an example of a sequence-to-sequence task, going from a sequence of audio inputs to textual outputs. Voice assistants like Siri and Alexa utilize ASR models to assist users."),us=u(),S=r("p"),R=e("This guide will show you how to fine-tune "),I=r("a"),ys=e("Wav2Vec2"),ts=e(" on the "),Q=r("a"),ks=e("MInDS-14"),xs=e(" dataset to transcribe audio to text."),Y=u(),w(V.$$.fragment),X=u(),M=r("h2"),N=r("a"),cs=r("span"),w(L.$$.fragment),Es=u(),H=r("span"),As=e("Load MInDS-14 dataset"),ds=u(),W=r("p"),Z=e("Load the "),B=r("a"),f=e("MInDS-14"),b=e(" from the \u{1F917} Datasets library:"),es=u(),w(ns.$$.fragment),qs=u(),z=r("p"),ms=e("Split this dataset into a train and test set:"),Ts=u(),w(G.$$.fragment),Ps=u(),ss=r("p"),Bs=e("Then take a look at the dataset:"),ka=u(),w(Cs.$$.fragment),xa=u(),O=r("p"),nt=e("While the dataset contains a lot of helpful information, like "),ea=r("code"),lt=e("lang_id"),rt=e(" and "),na=r("code"),ot=e("intent_class"),pt=e(", you will focus on the "),la=r("code"),it=e("audio"),ct=e(" and "),ra=r("code"),ht=e("transcription"),ft=e(" columns in this guide. Remove the other columns:"),Ea=u(),w(Ds.$$.fragment),Aa=u(),Gs=r("p"),ut=e("Take a look at the example again:"),qa=u(),w(Ss.$$.fragment),Ta=u(),ls=r("p"),dt=e("The "),oa=r("code"),mt=e("audio"),gt=e(" column contains a 1-dimensional "),pa=r("code"),_t=e("array"),$t=e(" of the speech signal that must be called to load and resample the audio file."),Pa=u(),hs=r("h2"),gs=r("a"),ia=r("span"),w(Is.$$.fragment),jt=u(),ca=r("span"),bt=e("Preprocess"),Ca=u(),Js=r("p"),vt=e("Load the Wav2Vec2 processor to process the audio signal and transcribed text:"),Da=u(),w(Ls.$$.fragment),Sa=u(),_s=r("p"),wt=e("The "),Rs=r("a"),yt=e("MInDS-14"),kt=e(" dataset has a sampling rate of 8000khz. You will need to resample the dataset to use the pretrained Wav2Vec2 model:"),Ia=u(),w(Os.$$.fragment),La=u(),Ks=r("p"),xt=e("The preprocessing function needs to:"),Ra=u(),rs=r("ol"),Ms=r("li"),Et=e("Call the "),ha=r("code"),At=e("audio"),qt=e(" column to load and resample the audio file."),Tt=u(),Ws=r("li"),Pt=e("Extract the "),fa=r("code"),Ct=e("input_values"),Dt=e(" from the audio file."),St=u(),ua=r("li"),It=e("Typically, when you call the processor, you call the feature extractor. Since you also want to tokenize text, instruct the processor to call the tokenizer instead with a context manager."),Oa=u(),w(zs.$$.fragment),Ma=u(),os=r("p"),Lt=e("Use \u{1F917} Datasets "),Us=r("a"),Rt=e("map"),Ot=e(" function to apply the preprocessing function over the entire dataset. You can speed up the map function by increasing the number of processes with "),da=r("code"),Mt=e("num_proc"),Wt=e(". Remove the columns you don\u2019t need:"),Wa=u(),w(Fs.$$.fragment),za=u(),J=r("p"),zt=e("\u{1F917} Transformers doesn\u2019t have a data collator for automatic speech recognition, so you will need to create one. You can adapt the "),Qs=r("a"),Ut=e("DataCollatorWithPadding"),Ft=e(" to create a batch of examples for automatic speech recognition. It will also dynamically pad your text and labels to the length of the longest element in its batch, so they are a uniform length. While it is possible to pad your text in the "),ma=r("code"),Yt=e("tokenizer"),Vt=e(" function by setting "),ga=r("code"),Nt=e("padding=True"),Ht=e(", dynamic padding is more efficient."),Ua=u(),ps=r("p"),Bt=e("Unlike other data collators, this specific data collator needs to apply a different padding method to "),_a=r("code"),Gt=e("input_values"),Jt=e(" and "),$a=r("code"),Kt=e("labels"),Qt=e(". You can apply a different padding method with a context manager:"),Fa=u(),w(Ys.$$.fragment),Ya=u(),$s=r("p"),Xt=e("Create a batch of examples and dynamically pad them with "),ja=r("code"),Zt=e("DataCollatorForCTCWithPadding"),se=e(":"),Va=u(),w(Vs.$$.fragment),Na=u(),fs=r("h2"),js=r("a"),ba=r("span"),w(Ns.$$.fragment),ae=u(),va=r("span"),te=e("Train"),Ha=u(),w(bs.$$.fragment),Ba=u(),w(vs.$$.fragment),this.h()},l(s){const l=Ve('[data-svelte="svelte-1phssyn"]',document.head);c=o(l,"META",{name:!0,content:!0}),l.forEach(t),j=d(s),h=o(s,"H1",{class:!0});var Hs=p(h);$=o(Hs,"A",{id:!0,class:!0,href:!0});var wa=p($);v=o(wa,"SPAN",{});var ya=p(v);y(g.$$.fragment,ya),ya.forEach(t),wa.forEach(t),q=d(Hs),T=o(Hs,"SPAN",{});var ne=p(T);P=n(ne,"Automatic speech recognition"),ne.forEach(t),Hs.forEach(t),_=d(s),y(D.$$.fragment,s),C=d(s),K=o(s,"P",{});var le=p(K);as=n(le,"Automatic speech recognition (ASR) converts a speech signal to text. It is an example of a sequence-to-sequence task, going from a sequence of audio inputs to textual outputs. Voice assistants like Siri and Alexa utilize ASR models to assist users."),le.forEach(t),us=d(s),S=o(s,"P",{});var Xs=p(S);R=n(Xs,"This guide will show you how to fine-tune "),I=o(Xs,"A",{href:!0,rel:!0});var re=p(I);ys=n(re,"Wav2Vec2"),re.forEach(t),ts=n(Xs," on the "),Q=o(Xs,"A",{href:!0,rel:!0});var oe=p(Q);ks=n(oe,"MInDS-14"),oe.forEach(t),xs=n(Xs," dataset to transcribe audio to text."),Xs.forEach(t),Y=d(s),y(V.$$.fragment,s),X=d(s),M=o(s,"H2",{class:!0});var Ja=p(M);N=o(Ja,"A",{id:!0,class:!0,href:!0});var pe=p(N);cs=o(pe,"SPAN",{});var ie=p(cs);y(L.$$.fragment,ie),ie.forEach(t),pe.forEach(t),Es=d(Ja),H=o(Ja,"SPAN",{});var ce=p(H);As=n(ce,"Load MInDS-14 dataset"),ce.forEach(t),Ja.forEach(t),ds=d(s),W=o(s,"P",{});var Ka=p(W);Z=n(Ka,"Load the "),B=o(Ka,"A",{href:!0,rel:!0});var he=p(B);f=n(he,"MInDS-14"),he.forEach(t),b=n(Ka," from the \u{1F917} Datasets library:"),Ka.forEach(t),es=d(s),y(ns.$$.fragment,s),qs=d(s),z=o(s,"P",{});var fe=p(z);ms=n(fe,"Split this dataset into a train and test set:"),fe.forEach(t),Ts=d(s),y(G.$$.fragment,s),Ps=d(s),ss=o(s,"P",{});var ue=p(ss);Bs=n(ue,"Then take a look at the dataset:"),ue.forEach(t),ka=d(s),y(Cs.$$.fragment,s),xa=d(s),O=o(s,"P",{});var is=p(O);nt=n(is,"While the dataset contains a lot of helpful information, like "),ea=o(is,"CODE",{});var de=p(ea);lt=n(de,"lang_id"),de.forEach(t),rt=n(is," and "),na=o(is,"CODE",{});var me=p(na);ot=n(me,"intent_class"),me.forEach(t),pt=n(is,", you will focus on the "),la=o(is,"CODE",{});var ge=p(la);it=n(ge,"audio"),ge.forEach(t),ct=n(is," and "),ra=o(is,"CODE",{});var _e=p(ra);ht=n(_e,"transcription"),_e.forEach(t),ft=n(is," columns in this guide. Remove the other columns:"),is.forEach(t),Ea=d(s),y(Ds.$$.fragment,s),Aa=d(s),Gs=o(s,"P",{});var $e=p(Gs);ut=n($e,"Take a look at the example again:"),$e.forEach(t),qa=d(s),y(Ss.$$.fragment,s),Ta=d(s),ls=o(s,"P",{});var Zs=p(ls);dt=n(Zs,"The "),oa=o(Zs,"CODE",{});var je=p(oa);mt=n(je,"audio"),je.forEach(t),gt=n(Zs," column contains a 1-dimensional "),pa=o(Zs,"CODE",{});var be=p(pa);_t=n(be,"array"),be.forEach(t),$t=n(Zs," of the speech signal that must be called to load and resample the audio file."),Zs.forEach(t),Pa=d(s),hs=o(s,"H2",{class:!0});var Qa=p(hs);gs=o(Qa,"A",{id:!0,class:!0,href:!0});var ve=p(gs);ia=o(ve,"SPAN",{});var we=p(ia);y(Is.$$.fragment,we),we.forEach(t),ve.forEach(t),jt=d(Qa),ca=o(Qa,"SPAN",{});var ye=p(ca);bt=n(ye,"Preprocess"),ye.forEach(t),Qa.forEach(t),Ca=d(s),Js=o(s,"P",{});var ke=p(Js);vt=n(ke,"Load the Wav2Vec2 processor to process the audio signal and transcribed text:"),ke.forEach(t),Da=d(s),y(Ls.$$.fragment,s),Sa=d(s),_s=o(s,"P",{});var Xa=p(_s);wt=n(Xa,"The "),Rs=o(Xa,"A",{href:!0,rel:!0});var xe=p(Rs);yt=n(xe,"MInDS-14"),xe.forEach(t),kt=n(Xa," dataset has a sampling rate of 8000khz. You will need to resample the dataset to use the pretrained Wav2Vec2 model:"),Xa.forEach(t),Ia=d(s),y(Os.$$.fragment,s),La=d(s),Ks=o(s,"P",{});var Ee=p(Ks);xt=n(Ee,"The preprocessing function needs to:"),Ee.forEach(t),Ra=d(s),rs=o(s,"OL",{});var sa=p(rs);Ms=o(sa,"LI",{});var Za=p(Ms);Et=n(Za,"Call the "),ha=o(Za,"CODE",{});var Ae=p(ha);At=n(Ae,"audio"),Ae.forEach(t),qt=n(Za," column to load and resample the audio file."),Za.forEach(t),Tt=d(sa),Ws=o(sa,"LI",{});var st=p(Ws);Pt=n(st,"Extract the "),fa=o(st,"CODE",{});var qe=p(fa);Ct=n(qe,"input_values"),qe.forEach(t),Dt=n(st," from the audio file."),st.forEach(t),St=d(sa),ua=o(sa,"LI",{});var Te=p(ua);It=n(Te,"Typically, when you call the processor, you call the feature extractor. Since you also want to tokenize text, instruct the processor to call the tokenizer instead with a context manager."),Te.forEach(t),sa.forEach(t),Oa=d(s),y(zs.$$.fragment,s),Ma=d(s),os=o(s,"P",{});var aa=p(os);Lt=n(aa,"Use \u{1F917} Datasets "),Us=o(aa,"A",{href:!0,rel:!0});var Pe=p(Us);Rt=n(Pe,"map"),Pe.forEach(t),Ot=n(aa," function to apply the preprocessing function over the entire dataset. You can speed up the map function by increasing the number of processes with "),da=o(aa,"CODE",{});var Ce=p(da);Mt=n(Ce,"num_proc"),Ce.forEach(t),Wt=n(aa,". Remove the columns you don\u2019t need:"),aa.forEach(t),Wa=d(s),y(Fs.$$.fragment,s),za=d(s),J=o(s,"P",{});var ws=p(J);zt=n(ws,"\u{1F917} Transformers doesn\u2019t have a data collator for automatic speech recognition, so you will need to create one. You can adapt the "),Qs=o(ws,"A",{href:!0});var De=p(Qs);Ut=n(De,"DataCollatorWithPadding"),De.forEach(t),Ft=n(ws," to create a batch of examples for automatic speech recognition. It will also dynamically pad your text and labels to the length of the longest element in its batch, so they are a uniform length. While it is possible to pad your text in the "),ma=o(ws,"CODE",{});var Se=p(ma);Yt=n(Se,"tokenizer"),Se.forEach(t),Vt=n(ws," function by setting "),ga=o(ws,"CODE",{});var Ie=p(ga);Nt=n(Ie,"padding=True"),Ie.forEach(t),Ht=n(ws,", dynamic padding is more efficient."),ws.forEach(t),Ua=d(s),ps=o(s,"P",{});var ta=p(ps);Bt=n(ta,"Unlike other data collators, this specific data collator needs to apply a different padding method to "),_a=o(ta,"CODE",{});var Le=p(_a);Gt=n(Le,"input_values"),Le.forEach(t),Jt=n(ta," and "),$a=o(ta,"CODE",{});var Re=p($a);Kt=n(Re,"labels"),Re.forEach(t),Qt=n(ta,". You can apply a different padding method with a context manager:"),ta.forEach(t),Fa=d(s),y(Ys.$$.fragment,s),Ya=d(s),$s=o(s,"P",{});var at=p($s);Xt=n(at,"Create a batch of examples and dynamically pad them with "),ja=o(at,"CODE",{});var Oe=p(ja);Zt=n(Oe,"DataCollatorForCTCWithPadding"),Oe.forEach(t),se=n(at,":"),at.forEach(t),Va=d(s),y(Vs.$$.fragment,s),Na=d(s),fs=o(s,"H2",{class:!0});var tt=p(fs);js=o(tt,"A",{id:!0,class:!0,href:!0});var Me=p(js);ba=o(Me,"SPAN",{});var We=p(ba);y(Ns.$$.fragment,We),We.forEach(t),Me.forEach(t),ae=d(tt),va=o(tt,"SPAN",{});var ze=p(va);te=n(ze,"Train"),ze.forEach(t),tt.forEach(t),Ha=d(s),y(bs.$$.fragment,s),Ba=d(s),y(vs.$$.fragment,s),this.h()},h(){m(c,"name","hf:doc:metadata"),m(c,"content",JSON.stringify(an)),m($,"id","automatic-speech-recognition"),m($,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),m($,"href","#automatic-speech-recognition"),m(h,"class","relative group"),m(I,"href","https://huggingface.co/facebook/wav2vec2-base"),m(I,"rel","nofollow"),m(Q,"href","https://huggingface.co/datasets/PolyAI/minds14"),m(Q,"rel","nofollow"),m(N,"id","load-minds14-dataset"),m(N,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),m(N,"href","#load-minds14-dataset"),m(M,"class","relative group"),m(B,"href","https://huggingface.co/datasets/PolyAI/minds14"),m(B,"rel","nofollow"),m(gs,"id","preprocess"),m(gs,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),m(gs,"href","#preprocess"),m(hs,"class","relative group"),m(Rs,"href","https://huggingface.co/datasets/PolyAI/minds14"),m(Rs,"rel","nofollow"),m(Us,"href","https://huggingface.co/docs/datasets/main/en/package_reference/main_classes#datasets.Dataset.map"),m(Us,"rel","nofollow"),m(Qs,"href","/docs/transformers/pr_18089/en/main_classes/data_collator#transformers.DataCollatorWithPadding"),m(js,"id","train"),m(js,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),m(js,"href","#train"),m(fs,"class","relative group")},m(s,l){a(document.head,c),i(s,j,l),i(s,h,l),a(h,$),a($,v),k(g,v,null),a(h,q),a(h,T),a(T,P),i(s,_,l),k(D,s,l),i(s,C,l),i(s,K,l),a(K,as),i(s,us,l),i(s,S,l),a(S,R),a(S,I),a(I,ys),a(S,ts),a(S,Q),a(Q,ks),a(S,xs),i(s,Y,l),k(V,s,l),i(s,X,l),i(s,M,l),a(M,N),a(N,cs),k(L,cs,null),a(M,Es),a(M,H),a(H,As),i(s,ds,l),i(s,W,l),a(W,Z),a(W,B),a(B,f),a(W,b),i(s,es,l),k(ns,s,l),i(s,qs,l),i(s,z,l),a(z,ms),i(s,Ts,l),k(G,s,l),i(s,Ps,l),i(s,ss,l),a(ss,Bs),i(s,ka,l),k(Cs,s,l),i(s,xa,l),i(s,O,l),a(O,nt),a(O,ea),a(ea,lt),a(O,rt),a(O,na),a(na,ot),a(O,pt),a(O,la),a(la,it),a(O,ct),a(O,ra),a(ra,ht),a(O,ft),i(s,Ea,l),k(Ds,s,l),i(s,Aa,l),i(s,Gs,l),a(Gs,ut),i(s,qa,l),k(Ss,s,l),i(s,Ta,l),i(s,ls,l),a(ls,dt),a(ls,oa),a(oa,mt),a(ls,gt),a(ls,pa),a(pa,_t),a(ls,$t),i(s,Pa,l),i(s,hs,l),a(hs,gs),a(gs,ia),k(Is,ia,null),a(hs,jt),a(hs,ca),a(ca,bt),i(s,Ca,l),i(s,Js,l),a(Js,vt),i(s,Da,l),k(Ls,s,l),i(s,Sa,l),i(s,_s,l),a(_s,wt),a(_s,Rs),a(Rs,yt),a(_s,kt),i(s,Ia,l),k(Os,s,l),i(s,La,l),i(s,Ks,l),a(Ks,xt),i(s,Ra,l),i(s,rs,l),a(rs,Ms),a(Ms,Et),a(Ms,ha),a(ha,At),a(Ms,qt),a(rs,Tt),a(rs,Ws),a(Ws,Pt),a(Ws,fa),a(fa,Ct),a(Ws,Dt),a(rs,St),a(rs,ua),a(ua,It),i(s,Oa,l),k(zs,s,l),i(s,Ma,l),i(s,os,l),a(os,Lt),a(os,Us),a(Us,Rt),a(os,Ot),a(os,da),a(da,Mt),a(os,Wt),i(s,Wa,l),k(Fs,s,l),i(s,za,l),i(s,J,l),a(J,zt),a(J,Qs),a(Qs,Ut),a(J,Ft),a(J,ma),a(ma,Yt),a(J,Vt),a(J,ga),a(ga,Nt),a(J,Ht),i(s,Ua,l),i(s,ps,l),a(ps,Bt),a(ps,_a),a(_a,Gt),a(ps,Jt),a(ps,$a),a($a,Kt),a(ps,Qt),i(s,Fa,l),k(Ys,s,l),i(s,Ya,l),i(s,$s,l),a($s,Xt),a($s,ja),a(ja,Zt),a($s,se),i(s,Va,l),k(Vs,s,l),i(s,Na,l),i(s,fs,l),a(fs,js),a(js,ba),k(Ns,ba,null),a(fs,ae),a(fs,va),a(va,te),i(s,Ha,l),k(bs,s,l),i(s,Ba,l),k(vs,s,l),Ga=!0},p(s,[l]){const Hs={};l&2&&(Hs.$$scope={dirty:l,ctx:s}),V.$set(Hs);const wa={};l&2&&(wa.$$scope={dirty:l,ctx:s}),bs.$set(wa);const ya={};l&2&&(ya.$$scope={dirty:l,ctx:s}),vs.$set(ya)},i(s){Ga||(x(g.$$.fragment,s),x(D.$$.fragment,s),x(V.$$.fragment,s),x(L.$$.fragment,s),x(ns.$$.fragment,s),x(G.$$.fragment,s),x(Cs.$$.fragment,s),x(Ds.$$.fragment,s),x(Ss.$$.fragment,s),x(Is.$$.fragment,s),x(Ls.$$.fragment,s),x(Os.$$.fragment,s),x(zs.$$.fragment,s),x(Fs.$$.fragment,s),x(Ys.$$.fragment,s),x(Vs.$$.fragment,s),x(Ns.$$.fragment,s),x(bs.$$.fragment,s),x(vs.$$.fragment,s),Ga=!0)},o(s){E(g.$$.fragment,s),E(D.$$.fragment,s),E(V.$$.fragment,s),E(L.$$.fragment,s),E(ns.$$.fragment,s),E(G.$$.fragment,s),E(Cs.$$.fragment,s),E(Ds.$$.fragment,s),E(Ss.$$.fragment,s),E(Is.$$.fragment,s),E(Ls.$$.fragment,s),E(Os.$$.fragment,s),E(zs.$$.fragment,s),E(Fs.$$.fragment,s),E(Ys.$$.fragment,s),E(Vs.$$.fragment,s),E(Ns.$$.fragment,s),E(bs.$$.fragment,s),E(vs.$$.fragment,s),Ga=!1},d(s){t(c),s&&t(j),s&&t(h),A(g),s&&t(_),A(D,s),s&&t(C),s&&t(K),s&&t(us),s&&t(S),s&&t(Y),A(V,s),s&&t(X),s&&t(M),A(L),s&&t(ds),s&&t(W),s&&t(es),A(ns,s),s&&t(qs),s&&t(z),s&&t(Ts),A(G,s),s&&t(Ps),s&&t(ss),s&&t(ka),A(Cs,s),s&&t(xa),s&&t(O),s&&t(Ea),A(Ds,s),s&&t(Aa),s&&t(Gs),s&&t(qa),A(Ss,s),s&&t(Ta),s&&t(ls),s&&t(Pa),s&&t(hs),A(Is),s&&t(Ca),s&&t(Js),s&&t(Da),A(Ls,s),s&&t(Sa),s&&t(_s),s&&t(Ia),A(Os,s),s&&t(La),s&&t(Ks),s&&t(Ra),s&&t(rs),s&&t(Oa),A(zs,s),s&&t(Ma),s&&t(os),s&&t(Wa),A(Fs,s),s&&t(za),s&&t(J),s&&t(Ua),s&&t(ps),s&&t(Fa),A(Ys,s),s&&t(Ya),s&&t($s),s&&t(Va),A(Vs,s),s&&t(Na),s&&t(fs),A(Ns),s&&t(Ha),A(bs,s),s&&t(Ba),A(vs,s)}}}const an={local:"automatic-speech-recognition",sections:[{local:"load-minds14-dataset",title:"Load MInDS-14 dataset"},{local:"preprocess",title:"Preprocess"},{local:"train",title:"Train"}],title:"Automatic speech recognition"};function tn(F){return Ne(()=>{new URLSearchParams(window.location.search).get("fw")}),[]}class cn extends Ue{constructor(c){super();Fe(this,c,tn,sn,Ye,{})}}export{cn as default,an as metadata};
