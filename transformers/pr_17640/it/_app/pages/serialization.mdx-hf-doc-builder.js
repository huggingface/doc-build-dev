import{S as EE,i as $E,s as bE,e as i,k as c,w as _,t as l,M as wE,c as a,d as o,m as d,a as n,x as z,h as s,b as u,G as t,g as p,y as E,q as $,o as b,B as w,v as kE,L as _E}from"../chunks/vendor-hf-doc-builder.js";import{C as S,T as ia}from"../chunks/CodeBlock-hf-doc-builder.js";import{I as M}from"../chunks/IconCopyLink-hf-doc-builder.js";import{F as NE,M as zE}from"../chunks/Markdown-hf-doc-builder.js";function OE(L){let f,N,m,k,x,O,y,P,A,j,C,q,D;return f=new S({props:{code:`from transformers import AutoTokenizer, AutoModelForSequenceClassification

# Load tokenizer and PyTorch weights form the Hub
tokenizer = AutoTokenizer.from_pretrained("distilbert-base-uncased")
pt_model = AutoModelForSequenceClassification.from_pretrained("distilbert-base-uncased")
# Save to disk
tokenizer.save_pretrained("local-pt-checkpoint")
pt_model.save_pretrained("local-pt-checkpoint")`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> AutoTokenizer, AutoModelForSequenceClassification

<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># Load tokenizer and PyTorch weights form the Hub</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>tokenizer = AutoTokenizer.from_pretrained(<span class="hljs-string">&quot;distilbert-base-uncased&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>pt_model = AutoModelForSequenceClassification.from_pretrained(<span class="hljs-string">&quot;distilbert-base-uncased&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># Save to disk</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>tokenizer.save_pretrained(<span class="hljs-string">&quot;local-pt-checkpoint&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>pt_model.save_pretrained(<span class="hljs-string">&quot;local-pt-checkpoint&quot;</span>)`}}),q=new S({props:{code:"python -m transformers.onnx --model=local-pt-checkpoint onnx/",highlighted:"python -m transformers.onnx --model=local-pt-checkpoint onnx/"}}),{c(){_(f.$$.fragment),N=c(),m=i("p"),k=l("Una volta salvato il checkpoint, possiamo esportarlo su ONNX puntando l\u2019argomento "),x=i("code"),O=l("--model"),y=l(`
del pacchetto `),P=i("code"),A=l("transformers.onnx"),j=l(" nella directory desiderata:"),C=c(),_(q.$$.fragment)},l(g){z(f.$$.fragment,g),N=d(g),m=a(g,"P",{});var T=n(m);k=s(T,"Una volta salvato il checkpoint, possiamo esportarlo su ONNX puntando l\u2019argomento "),x=a(T,"CODE",{});var B=n(x);O=s(B,"--model"),B.forEach(o),y=s(T,`
del pacchetto `),P=a(T,"CODE",{});var W=n(P);A=s(W,"transformers.onnx"),W.forEach(o),j=s(T," nella directory desiderata:"),T.forEach(o),C=d(g),z(q.$$.fragment,g)},m(g,T){E(f,g,T),p(g,N,T),p(g,m,T),t(m,k),t(m,x),t(x,O),t(m,y),t(m,P),t(P,A),t(m,j),p(g,C,T),E(q,g,T),D=!0},p:_E,i(g){D||($(f.$$.fragment,g),$(q.$$.fragment,g),D=!0)},o(g){b(f.$$.fragment,g),b(q.$$.fragment,g),D=!1},d(g){w(f,g),g&&o(N),g&&o(m),g&&o(C),w(q,g)}}}function xE(L){let f,N;return f=new zE({props:{$$slots:{default:[OE]},$$scope:{ctx:L}}}),{c(){_(f.$$.fragment)},l(m){z(f.$$.fragment,m)},m(m,k){E(f,m,k),N=!0},p(m,k){const x={};k&2&&(x.$$scope={dirty:k,ctx:m}),f.$set(x)},i(m){N||($(f.$$.fragment,m),N=!0)},o(m){b(f.$$.fragment,m),N=!1},d(m){w(f,m)}}}function jE(L){let f,N,m,k,x,O,y,P,A,j,C,q,D;return f=new S({props:{code:`from transformers import AutoTokenizer, TFAutoModelForSequenceClassification

# Load tokenizer and TensorFlow weights from the Hub
tokenizer = AutoTokenizer.from_pretrained("distilbert-base-uncased")
tf_model = TFAutoModelForSequenceClassification.from_pretrained("distilbert-base-uncased")
# Save to disk
tokenizer.save_pretrained("local-tf-checkpoint")
tf_model.save_pretrained("local-tf-checkpoint")`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> AutoTokenizer, TFAutoModelForSequenceClassification

<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># Load tokenizer and TensorFlow weights from the Hub</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>tokenizer = AutoTokenizer.from_pretrained(<span class="hljs-string">&quot;distilbert-base-uncased&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>tf_model = TFAutoModelForSequenceClassification.from_pretrained(<span class="hljs-string">&quot;distilbert-base-uncased&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># Save to disk</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>tokenizer.save_pretrained(<span class="hljs-string">&quot;local-tf-checkpoint&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>tf_model.save_pretrained(<span class="hljs-string">&quot;local-tf-checkpoint&quot;</span>)`}}),q=new S({props:{code:"python -m transformers.onnx --model=local-tf-checkpoint onnx/",highlighted:"python -m transformers.onnx --model=local-tf-checkpoint onnx/"}}),{c(){_(f.$$.fragment),N=c(),m=i("p"),k=l("Once the checkpoint is saved, we can export it to ONNX by pointing the "),x=i("code"),O=l("--model"),y=l(`
argument of the `),P=i("code"),A=l("transformers.onnx"),j=l(" package to the desired directory:"),C=c(),_(q.$$.fragment)},l(g){z(f.$$.fragment,g),N=d(g),m=a(g,"P",{});var T=n(m);k=s(T,"Once the checkpoint is saved, we can export it to ONNX by pointing the "),x=a(T,"CODE",{});var B=n(x);O=s(B,"--model"),B.forEach(o),y=s(T,`
argument of the `),P=a(T,"CODE",{});var W=n(P);A=s(W,"transformers.onnx"),W.forEach(o),j=s(T," package to the desired directory:"),T.forEach(o),C=d(g),z(q.$$.fragment,g)},m(g,T){E(f,g,T),p(g,N,T),p(g,m,T),t(m,k),t(m,x),t(x,O),t(m,y),t(m,P),t(P,A),t(m,j),p(g,C,T),E(q,g,T),D=!0},p:_E,i(g){D||($(f.$$.fragment,g),$(q.$$.fragment,g),D=!0)},o(g){b(f.$$.fragment,g),b(q.$$.fragment,g),D=!1},d(g){w(f,g),g&&o(N),g&&o(m),g&&o(C),w(q,g)}}}function TE(L){let f,N;return f=new zE({props:{$$slots:{default:[jE]},$$scope:{ctx:L}}}),{c(){_(f.$$.fragment)},l(m){z(f.$$.fragment,m)},m(m,k){E(f,m,k),N=!0},p(m,k){const x={};k&2&&(x.$$scope={dirty:k,ctx:m}),f.$set(x)},i(m){N||($(f.$$.fragment,m),N=!0)},o(m){b(f.$$.fragment,m),N=!1},d(m){w(f,m)}}}function AE(L){let f,N,m,k,x,O,y,P;return{c(){f=i("p"),N=l("Le caratteristiche che hanno un suffisso "),m=i("code"),k=l("wtih-past"),x=l(" (ad es. "),O=i("code"),y=l("causal-lm-with-past"),P=l(`)
corrispondono a topologie di modello con stati nascosti precalcolati (chiave e valori
nei blocchi di attenzione) che possono essere utilizzati per la decodifica autoregressiva veloce.`)},l(A){f=a(A,"P",{});var j=n(f);N=s(j,"Le caratteristiche che hanno un suffisso "),m=a(j,"CODE",{});var C=n(m);k=s(C,"wtih-past"),C.forEach(o),x=s(j," (ad es. "),O=a(j,"CODE",{});var q=n(O);y=s(q,"causal-lm-with-past"),q.forEach(o),P=s(j,`)
corrispondono a topologie di modello con stati nascosti precalcolati (chiave e valori
nei blocchi di attenzione) che possono essere utilizzati per la decodifica autoregressiva veloce.`),j.forEach(o)},m(A,j){p(A,f,j),t(f,N),t(f,m),t(m,k),t(f,x),t(f,O),t(O,y),t(f,P)},d(A){A&&o(f)}}}function qE(L){let f,N,m,k,x;return{c(){f=i("p"),N=l(`Un buon modo per implementare una configurazione ONNX personalizzata \xE8 guardare l\u2019implementazione
esistente nel file `),m=i("code"),k=l("configuration_<model_name>.py"),x=l(" di un\u2019architettura simile.")},l(O){f=a(O,"P",{});var y=n(f);N=s(y,`Un buon modo per implementare una configurazione ONNX personalizzata \xE8 guardare l\u2019implementazione
esistente nel file `),m=a(y,"CODE",{});var P=n(m);k=s(P,"configuration_<model_name>.py"),P.forEach(o),x=s(y," di un\u2019architettura simile."),y.forEach(o)},m(O,y){p(O,f,y),t(f,N),t(f,m),t(m,k),t(f,x)},d(O){O&&o(f)}}}function PE(L){let f,N,m,k,x,O,y,P,A,j,C,q,D,g,T,B,W,ge,Me,G,Q,_e,ae;return{c(){f=i("p"),N=l("Puoi notare che la propriet\xE0 "),m=i("code"),k=l("inputs"),x=l(" per "),O=i("code"),y=l("DistilBertOnnxConfig"),P=l(` restituisce un
`),A=i("code"),j=l("OrdinatoDict"),C=l(`. Ci\xF2 garantisce che gli input corrispondano alla loro posizione
relativa all\u2019interno del metodo `),q=i("code"),D=l("PreTrainedModel.forward()"),g=l(` durante il tracciamento del grafico.
Raccomandiamo di usare un `),T=i("code"),B=l("OrderedDict"),W=l(" per le propriet\xE0 "),ge=i("code"),Me=l("inputs"),G=l(" e "),Q=i("code"),_e=l("outputs"),ae=l(`
quando si implementano configurazioni ONNX personalizzate.`)},l(ze){f=a(ze,"P",{});var I=n(f);N=s(I,"Puoi notare che la propriet\xE0 "),m=a(I,"CODE",{});var ti=n(m);k=s(ti,"inputs"),ti.forEach(o),x=s(I," per "),O=a(I,"CODE",{});var Pt=n(O);y=s(Pt,"DistilBertOnnxConfig"),Pt.forEach(o),P=s(I,` restituisce un
`),A=a(I,"CODE",{});var K=n(A);j=s(K,"OrdinatoDict"),K.forEach(o),C=s(I,`. Ci\xF2 garantisce che gli input corrispondano alla loro posizione
relativa all\u2019interno del metodo `),q=a(I,"CODE",{});var oi=n(q);D=s(oi,"PreTrainedModel.forward()"),oi.forEach(o),g=s(I,` durante il tracciamento del grafico.
Raccomandiamo di usare un `),T=a(I,"CODE",{});var ne=n(T);B=s(ne,"OrderedDict"),ne.forEach(o),W=s(I," per le propriet\xE0 "),ge=a(I,"CODE",{});var ii=n(ge);Me=s(ii,"inputs"),ii.forEach(o),G=s(I," e "),Q=a(I,"CODE",{});var ai=n(Q);_e=s(ai,"outputs"),ai.forEach(o),ae=s(I,`
quando si implementano configurazioni ONNX personalizzate.`),I.forEach(o)},m(ze,I){p(ze,f,I),t(f,N),t(f,m),t(m,k),t(f,x),t(f,O),t(O,y),t(f,P),t(f,A),t(A,j),t(f,C),t(f,q),t(q,D),t(f,g),t(f,T),t(T,B),t(f,W),t(f,ge),t(ge,Me),t(f,G),t(f,Q),t(Q,_e),t(f,ae)},d(ze){ze&&o(f)}}}function yE(L){let f,N,m,k,x,O,y,P;return{c(){f=i("p"),N=l("Tutte le propriet\xE0 e i metodi di base associati a "),m=i("code"),k=l("OnnxConfig"),x=l(` e le
altre classi di configurazione possono essere sovrascritte se necessario. Guarda
`),O=i("code"),y=l("BartOnnxConfig"),P=l(" per un esempio avanzato.")},l(A){f=a(A,"P",{});var j=n(f);N=s(j,"Tutte le propriet\xE0 e i metodi di base associati a "),m=a(j,"CODE",{});var C=n(m);k=s(C,"OnnxConfig"),C.forEach(o),x=s(j,` e le
altre classi di configurazione possono essere sovrascritte se necessario. Guarda
`),O=a(j,"CODE",{});var q=n(O);y=s(q,"BartOnnxConfig"),q.forEach(o),P=s(j," per un esempio avanzato."),j.forEach(o)},m(A,j){p(A,f,j),t(f,N),t(f,m),t(m,k),t(f,x),t(f,O),t(O,y),t(f,P)},d(A){A&&o(f)}}}function CE(L){let f,N,m,k,x,O,y,P,A,j,C;return{c(){f=i("p"),N=l(`Se il tuo modello \xE8 pi\xF9 largo di 2 GB, vedrai che molti file aggiuntivi sono
creati durante l\u2019esportazione. Questo \xE8 `),m=i("em"),k=l("previsto"),x=l(" perch\xE9 ONNX utilizza "),O=i("a"),y=l(`Protocol
Buffer`),P=l(` per memorizzare il modello e
questi hanno un limite di dimensione 2 GB. Vedi la `),A=i("a"),j=l(`Documentazione
ONNX`),C=l(`
per istruzioni su come caricare modelli con dati esterni.`),this.h()},l(q){f=a(q,"P",{});var D=n(f);N=s(D,`Se il tuo modello \xE8 pi\xF9 largo di 2 GB, vedrai che molti file aggiuntivi sono
creati durante l\u2019esportazione. Questo \xE8 `),m=a(D,"EM",{});var g=n(m);k=s(g,"previsto"),g.forEach(o),x=s(D," perch\xE9 ONNX utilizza "),O=a(D,"A",{href:!0,rel:!0});var T=n(O);y=s(T,`Protocol
Buffer`),T.forEach(o),P=s(D,` per memorizzare il modello e
questi hanno un limite di dimensione 2 GB. Vedi la `),A=a(D,"A",{href:!0,rel:!0});var B=n(A);j=s(B,`Documentazione
ONNX`),B.forEach(o),C=s(D,`
per istruzioni su come caricare modelli con dati esterni.`),D.forEach(o),this.h()},h(){u(O,"href","https://developers.google.com/protocol-buffers/"),u(O,"rel","nofollow"),u(A,"href","https://github.com/onnx/onnx/blob/master/docs/ExternalData.md"),u(A,"rel","nofollow")},m(q,D){p(q,f,D),t(f,N),t(f,m),t(m,k),t(f,x),t(f,O),t(O,y),t(f,P),t(f,A),t(A,j),t(f,C)},d(q){q&&o(f)}}}function DE(L){let f,N;return{c(){f=i("p"),N=l(`Questo \xE8 l\u2019inizio dei nostri esperimenti con TorchScript e stiamo ancora esplorando le sue capacit\xE0 con
modelli con variable-input-size. \xC8 una nostra priorit\xE0 e approfondiremo le nostre analisi nelle prossime versioni,
con pi\xF9 esempi di codici, un\u2019implementazione pi\xF9 flessibile e benchmark che confrontano i codici basati su Python con quelli compilati con
TorchScript.`)},l(m){f=a(m,"P",{});var k=n(f);N=s(k,`Questo \xE8 l\u2019inizio dei nostri esperimenti con TorchScript e stiamo ancora esplorando le sue capacit\xE0 con
modelli con variable-input-size. \xC8 una nostra priorit\xE0 e approfondiremo le nostre analisi nelle prossime versioni,
con pi\xF9 esempi di codici, un\u2019implementazione pi\xF9 flessibile e benchmark che confrontano i codici basati su Python con quelli compilati con
TorchScript.`),k.forEach(o)},m(m,k){p(m,f,k),t(f,N)},d(m){m&&o(f)}}}function SE(L){let f,N,m,k,x,O,y,P,A,j,C,q,D,g,T,B,W,ge,Me,G,Q,_e,ae,ze,I,ti,Pt,K,oi,ne,ii,ai,aa,cc,dc,rs,ni,uc,ps,Xe,fc,na,mc,hc,cs,li,vc,ds,h,la,gc,_c,sa,zc,Ec,ra,$c,bc,pa,wc,kc,ca,Nc,Oc,da,xc,jc,ua,Tc,Ac,fa,qc,Pc,ma,yc,Cc,ha,Dc,Sc,va,Ic,Lc,ga,Bc,Mc,_a,Xc,Rc,za,Fc,Qc,Ea,Hc,Uc,$a,Wc,Gc,ba,Kc,Vc,wa,Jc,Yc,ka,Zc,ed,Na,td,od,Oa,id,ad,xa,nd,ld,ja,sd,rd,Ta,pd,cd,Aa,dd,ud,qa,fd,md,Pa,hd,vd,ya,gd,_d,Ca,zd,Ed,Da,$d,bd,Sa,wd,kd,Ia,Nd,Od,La,xd,jd,Ba,Td,Ad,Ma,qd,us,si,Pd,fs,Re,yt,yd,Xa,Cd,Dd,Sd,Ra,Id,ms,Ee,Fe,Fa,Ct,Ld,Qa,Bd,hs,ri,Md,vs,Dt,gs,Qe,Xd,Ha,Rd,Fd,_s,St,zs,pi,Qd,Es,It,$s,ci,Hd,bs,Lt,ws,le,Ud,Ua,Wd,Gd,Wa,Kd,Vd,ks,J,Jd,Ga,Yd,Zd,Bt,eu,tu,Mt,ou,iu,Ns,Xt,Os,He,au,Ka,nu,lu,xs,Rt,js,Ue,su,Ft,ru,pu,Ts,Qt,As,di,cu,qs,We,Ps,$e,Ge,Va,Ht,du,Ja,uu,ys,Ke,fu,Ya,mu,hu,Cs,Ve,Za,Ut,en,vu,gu,tn,_u,zu,X,Wt,Gt,on,Eu,$u,an,bu,wu,nn,ln,ku,Nu,Kt,Vt,sn,Ou,xu,rn,ju,Tu,pn,cn,Au,qu,Jt,dn,un,Pu,yu,fn,mn,Cu,Du,Yt,hn,vn,Su,Iu,gn,_n,Lu,Bu,Zt,eo,zn,Mu,Xu,En,Ru,Fu,$n,bn,Qu,Hu,to,wn,kn,Uu,Wu,Nn,On,Gu,Ku,oo,xn,jn,Vu,Ju,Tn,An,Yu,Ds,Je,Zu,qn,ef,tf,Ss,io,Is,se,of,Pn,af,nf,yn,lf,sf,Ls,ao,Bs,ui,rf,Ms,no,Xs,Y,pf,Cn,cf,df,Dn,uf,ff,Sn,mf,hf,Rs,Ye,Fs,be,Ze,In,lo,vf,Ln,gf,Qs,fi,_f,Hs,re,Bn,zf,Ef,Mn,$f,bf,Xn,wf,Us,mi,kf,Ws,we,et,Rn,so,Nf,Fn,Of,Gs,hi,xf,Ks,pe,vi,jf,Qn,Tf,Af,gi,qf,Hn,Pf,yf,_i,Cf,Un,Df,Vs,tt,Js,ot,Sf,Wn,If,Lf,Ys,ro,Zs,H,Bf,Gn,Mf,Xf,Kn,Rf,Ff,Vn,Qf,Hf,Jn,Uf,Wf,er,it,tr,zi,Gf,or,po,ir,Ei,Kf,ar,co,nr,$i,Vf,lr,uo,sr,Z,Jf,Yn,Yf,Zf,Zn,em,tm,el,om,im,rr,fo,pr,at,cr,ke,nt,tl,mo,am,ol,nm,dr,ce,lm,il,sm,rm,al,pm,cm,ur,ho,fr,R,dm,nl,um,fm,ll,mm,hm,sl,vm,gm,rl,_m,zm,pl,Em,$m,mr,vo,hr,lt,vr,Ne,st,cl,go,bm,dl,wm,gr,de,km,ul,Nm,Om,fl,xm,jm,_r,_o,zr,rt,Tm,ml,Am,qm,Er,Oe,pt,hl,zo,Pm,vl,ym,$r,bi,Cm,br,ue,wi,Dm,gl,Sm,Im,ki,Lm,_l,Bm,Mm,Ni,Xm,zl,Rm,wr,ct,Fm,Eo,Qm,Hm,kr,xe,dt,El,$o,Um,$l,Wm,Nr,ut,Or,ft,Gm,bo,Km,Vm,xr,Oi,Jm,jr,xi,Ym,Tr,mt,bl,Zm,eh,wo,th,wl,oh,ih,Ar,ji,ah,qr,je,ht,kl,ko,nh,Nl,lh,Pr,Ti,sh,yr,ee,rh,Ol,ph,ch,xl,dh,uh,jl,fh,mh,Cr,vt,hh,Tl,vh,gh,Dr,Te,gt,Al,No,_h,ql,zh,Sr,Ai,Eh,Ir,qi,$h,Lr,Pi,Pl,bh,Br,yi,wh,Mr,Ci,kh,Xr,Ae,_t,yl,Oo,Nh,Cl,Oh,Rr,Di,xh,Fr,qe,zt,Dl,xo,jh,Sl,Th,Qr,V,Ah,Il,qh,Ph,Ll,yh,Ch,Bl,Dh,Sh,Ml,Ih,Hr,jo,Ur,Pe,Et,Xl,To,Lh,Rl,Bh,Wr,te,Mh,Fl,Xh,Rh,Ql,Fh,Qh,Hl,Hh,Uh,Gr,Ao,Kr,ye,$t,Ul,qo,Wh,Wl,Gh,Vr,bt,Kh,Gl,Vh,Jh,Jr,Po,Yr,Si,Yh,Zr,fe,Zh,yo,ev,tv,Co,ov,iv,ep,me,Kl,av,nv,Ii,lv,Do,sv,rv,Ce,pv,So,cv,dv,Io,uv,fv,tp,De,wt,Vl,Lo,mv,Jl,hv,op,F,vv,Bo,gv,_v,Mo,zv,Ev,Xo,$v,bv,Ro,wv,kv,Fo,Nv,Ov,ip,Se,kt,Yl,Qo,xv,Zl,jv,ap,Li,Tv,np,Bi,Ie,Av,Ho,qv,Pv,Uo,yv,Cv,lp,Le,Nt,es,Wo,Dv,ts,Sv,sp,he,Iv,Go,Lv,Bv,os,Mv,Xv,rp,Ko,pp,Mi,Rv,cp,Xi,Fv,dp,Vo,up,Ri,Qv,fp,Jo,mp,Fi,Hv,hp,Ot,Uv,Yo,Wv,Gv,vp;return O=new M({}),ae=new M({}),Ct=new M({}),Dt=new S({props:{code:"pip install transformers[onnx]",highlighted:"pip install transformers[onnx]"}}),St=new S({props:{code:`

`,highlighted:`python -m transformers.onnx --<span class="hljs-built_in">help</span>

usage: Hugging Face Transformers ONNX exporter [-h] -m MODEL [--feature {causal-lm, ...}] [--opset OPSET] [--atol ATOL] output

positional arguments:
  output                Path indicating <span class="hljs-built_in">where</span> to store generated ONNX model.

optional arguments:
  -h, --<span class="hljs-built_in">help</span>            show this <span class="hljs-built_in">help</span> message and <span class="hljs-built_in">exit</span>
  -m MODEL, --model MODEL
                        Model ID on huggingface.co or path on disk to load model from.
  --feature {causal-lm, ...}
                        The <span class="hljs-built_in">type</span> of features to <span class="hljs-built_in">export</span> the model with.
  --opset OPSET         ONNX opset version to <span class="hljs-built_in">export</span> the model with.
  --atol ATOL           Absolute difference tolerence when validating the model.`}}),It=new S({props:{code:"python -m transformers.onnx --model=distilbert-base-uncased onnx/",highlighted:"python -m transformers.onnx --model=distilbert-base-uncased onnx/"}}),Lt=new S({props:{code:`Validating ONNX model...
        -[\u2713] ONNX model output names match reference model ({'last_hidden_state'})
        - Validating ONNX Model output "last_hidden_state":
                -[\u2713] (2, 8, 768) matches (2, 8, 768)
                -[\u2713] all values close (atol: 1e-05)
All good, model saved at: onnx/model.onnx`,highlighted:`Validating ONNX model...
        -[\u2713] ONNX model output names match reference model ({<span class="hljs-string">&#x27;last_hidden_state&#x27;</span>})
        - Validating ONNX Model output <span class="hljs-string">&quot;last_hidden_state&quot;</span>:
                -[\u2713] (2, 8, 768) matches (2, 8, 768)
                -[\u2713] all values close (atol: 1e-05)
All good, model saved at: onnx/model.onnx`}}),Xt=new S({props:{code:`from transformers import AutoTokenizer
from onnxruntime import InferenceSession

tokenizer = AutoTokenizer.from_pretrained("distilbert-base-uncased")
session = InferenceSession("onnx/model.onnx")
# ONNX Runtime expects NumPy arrays as input
inputs = tokenizer("Using DistilBERT with ONNX Runtime!", return_tensors="np")
outputs = session.run(output_names=["last_hidden_state"], input_feed=dict(inputs))`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> AutoTokenizer
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> onnxruntime <span class="hljs-keyword">import</span> InferenceSession

<span class="hljs-meta">&gt;&gt;&gt; </span>tokenizer = AutoTokenizer.from_pretrained(<span class="hljs-string">&quot;distilbert-base-uncased&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>session = InferenceSession(<span class="hljs-string">&quot;onnx/model.onnx&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># ONNX Runtime expects NumPy arrays as input</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>inputs = tokenizer(<span class="hljs-string">&quot;Using DistilBERT with ONNX Runtime!&quot;</span>, return_tensors=<span class="hljs-string">&quot;np&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>outputs = session.run(output_names=[<span class="hljs-string">&quot;last_hidden_state&quot;</span>], input_feed=<span class="hljs-built_in">dict</span>(inputs))`}}),Rt=new S({props:{code:`from transformers.models.distilbert import DistilBertConfig, DistilBertOnnxConfig

config = DistilBertConfig()
onnx_config = DistilBertOnnxConfig(config)
print(list(onnx_config.outputs.keys()))`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers.models.distilbert <span class="hljs-keyword">import</span> DistilBertConfig, DistilBertOnnxConfig

<span class="hljs-meta">&gt;&gt;&gt; </span>config = DistilBertConfig()
<span class="hljs-meta">&gt;&gt;&gt; </span>onnx_config = DistilBertOnnxConfig(config)
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(<span class="hljs-built_in">list</span>(onnx_config.outputs.keys()))
[<span class="hljs-string">&quot;last_hidden_state&quot;</span>]`}}),Qt=new S({props:{code:"python -m transformers.onnx --model=keras-io/transformers-qa onnx/",highlighted:"python -m transformers.onnx --model=keras-io/transformers-qa onnx/"}}),We=new NE({props:{pytorch:!0,tensorflow:!0,jax:!1,$$slots:{tensorflow:[TE],pytorch:[xE]},$$scope:{ctx:L}}}),Ht=new M({}),io=new S({props:{code:`from transformers.onnx.features import FeaturesManager

distilbert_features = list(FeaturesManager.get_supported_features_for_model_type("distilbert").keys())
print(distilbert_features)`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers.onnx.features <span class="hljs-keyword">import</span> FeaturesManager

<span class="hljs-meta">&gt;&gt;&gt; </span>distilbert_features = <span class="hljs-built_in">list</span>(FeaturesManager.get_supported_features_for_model_type(<span class="hljs-string">&quot;distilbert&quot;</span>).keys())
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(distilbert_features)
[<span class="hljs-string">&quot;default&quot;</span>, <span class="hljs-string">&quot;masked-lm&quot;</span>, <span class="hljs-string">&quot;causal-lm&quot;</span>, <span class="hljs-string">&quot;sequence-classification&quot;</span>, <span class="hljs-string">&quot;token-classification&quot;</span>, <span class="hljs-string">&quot;question-answering&quot;</span>]`}}),ao=new S({props:{code:`python -m transformers.onnx --model=distilbert-base-uncased-finetuned-sst-2-english \\
                            --feature=sequence-classification onnx/`,highlighted:`python -m transformers.onnx --model=distilbert-base-uncased-finetuned-sst-2-english \\
                            --feature=sequence-classification onnx/`}}),no=new S({props:{code:`Validating ONNX model...
        -[\u2713] ONNX model output names match reference model ({'logits'})
        - Validating ONNX Model output "logits":
                -[\u2713] (2, 2) matches (2, 2)
                -[\u2713] all values close (atol: 1e-05)
All good, model saved at: onnx/model.onnx`,highlighted:`Validating ONNX model...
        -[\u2713] ONNX model output names match reference model ({<span class="hljs-string">&#x27;logits&#x27;</span>})
        - Validating ONNX Model output <span class="hljs-string">&quot;logits&quot;</span>:
                -[\u2713] (2, 2) matches (2, 2)
                -[\u2713] all values close (atol: 1e-05)
All good, model saved at: onnx/model.onnx`}}),Ye=new ia({props:{$$slots:{default:[AE]},$$scope:{ctx:L}}}),lo=new M({}),so=new M({}),tt=new ia({props:{$$slots:{default:[qE]},$$scope:{ctx:L}}}),ro=new S({props:{code:`from typing import Mapping, OrderedDict
from transformers.onnx import OnnxConfig


class DistilBertOnnxConfig(OnnxConfig):
    @property
    def inputs(self) -> Mapping[str, Mapping[int, str]]:
        return OrderedDict(
            [
                ("input_ids", {0: "batch", 1: "sequence"}),
                ("attention_mask", {0: "batch", 1: "sequence"}),
            ]
        )`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> Mapping, OrderedDict
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers.onnx <span class="hljs-keyword">import</span> OnnxConfig


<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">class</span> <span class="hljs-title class_">DistilBertOnnxConfig</span>(<span class="hljs-title class_ inherited__">OnnxConfig</span>):
<span class="hljs-meta">... </span>    @<span class="hljs-built_in">property</span>
<span class="hljs-meta">... </span>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">inputs</span>(<span class="hljs-params">self</span>) -&gt; Mapping[<span class="hljs-built_in">str</span>, Mapping[<span class="hljs-built_in">int</span>, <span class="hljs-built_in">str</span>]]:
<span class="hljs-meta">... </span>        <span class="hljs-keyword">return</span> OrderedDict(
<span class="hljs-meta">... </span>            [
<span class="hljs-meta">... </span>                (<span class="hljs-string">&quot;input_ids&quot;</span>, {<span class="hljs-number">0</span>: <span class="hljs-string">&quot;batch&quot;</span>, <span class="hljs-number">1</span>: <span class="hljs-string">&quot;sequence&quot;</span>}),
<span class="hljs-meta">... </span>                (<span class="hljs-string">&quot;attention_mask&quot;</span>, {<span class="hljs-number">0</span>: <span class="hljs-string">&quot;batch&quot;</span>, <span class="hljs-number">1</span>: <span class="hljs-string">&quot;sequence&quot;</span>}),
<span class="hljs-meta">... </span>            ]
<span class="hljs-meta">... </span>        )`}}),it=new ia({props:{$$slots:{default:[PE]},$$scope:{ctx:L}}}),po=new S({props:{code:`from transformers import AutoConfig

config = AutoConfig.from_pretrained("distilbert-base-uncased")
onnx_config = DistilBertOnnxConfig(config)`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> AutoConfig

<span class="hljs-meta">&gt;&gt;&gt; </span>config = AutoConfig.from_pretrained(<span class="hljs-string">&quot;distilbert-base-uncased&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>onnx_config = DistilBertOnnxConfig(config)`}}),co=new S({props:{code:"print(onnx_config.default_onnx_opset)",highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(onnx_config.default_onnx_opset)
<span class="hljs-number">11</span>`}}),uo=new S({props:{code:"print(onnx_config.outputs)",highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(onnx_config.outputs)
OrderedDict([(<span class="hljs-string">&quot;last_hidden_state&quot;</span>, {<span class="hljs-number">0</span>: <span class="hljs-string">&quot;batch&quot;</span>, <span class="hljs-number">1</span>: <span class="hljs-string">&quot;sequence&quot;</span>})])`}}),fo=new S({props:{code:`from transformers import AutoConfig

config = AutoConfig.from_pretrained("distilbert-base-uncased")
onnx_config_for_seq_clf = DistilBertOnnxConfig(config, task="sequence-classification")
print(onnx_config_for_seq_clf.outputs)`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> AutoConfig

<span class="hljs-meta">&gt;&gt;&gt; </span>config = AutoConfig.from_pretrained(<span class="hljs-string">&quot;distilbert-base-uncased&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>onnx_config_for_seq_clf = DistilBertOnnxConfig(config, task=<span class="hljs-string">&quot;sequence-classification&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(onnx_config_for_seq_clf.outputs)
OrderedDict([(<span class="hljs-string">&#x27;logits&#x27;</span>, {<span class="hljs-number">0</span>: <span class="hljs-string">&#x27;batch&#x27;</span>})])`}}),at=new ia({props:{$$slots:{default:[yE]},$$scope:{ctx:L}}}),mo=new M({}),ho=new S({props:{code:`from pathlib import Path
from transformers.onnx import export
from transformers import AutoTokenizer, AutoModel

onnx_path = Path("model.onnx")
model_ckpt = "distilbert-base-uncased"
base_model = AutoModel.from_pretrained(model_ckpt)
tokenizer = AutoTokenizer.from_pretrained(model_ckpt)

onnx_inputs, onnx_outputs = export(tokenizer, base_model, onnx_config, onnx_config.default_onnx_opset, onnx_path)`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> pathlib <span class="hljs-keyword">import</span> Path
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers.onnx <span class="hljs-keyword">import</span> export
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> AutoTokenizer, AutoModel

<span class="hljs-meta">&gt;&gt;&gt; </span>onnx_path = Path(<span class="hljs-string">&quot;model.onnx&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>model_ckpt = <span class="hljs-string">&quot;distilbert-base-uncased&quot;</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>base_model = AutoModel.from_pretrained(model_ckpt)
<span class="hljs-meta">&gt;&gt;&gt; </span>tokenizer = AutoTokenizer.from_pretrained(model_ckpt)

<span class="hljs-meta">&gt;&gt;&gt; </span>onnx_inputs, onnx_outputs = export(tokenizer, base_model, onnx_config, onnx_config.default_onnx_opset, onnx_path)`}}),vo=new S({props:{code:`import onnx

onnx_model = onnx.load("model.onnx")
onnx.checker.check_model(onnx_model)`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> onnx

<span class="hljs-meta">&gt;&gt;&gt; </span>onnx_model = onnx.load(<span class="hljs-string">&quot;model.onnx&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>onnx.checker.check_model(onnx_model)`}}),lt=new ia({props:{$$slots:{default:[CE]},$$scope:{ctx:L}}}),go=new M({}),_o=new S({props:{code:`from transformers.onnx import validate_model_outputs

validate_model_outputs(
    onnx_config, tokenizer, base_model, onnx_path, onnx_outputs, onnx_config.atol_for_validation
)`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers.onnx <span class="hljs-keyword">import</span> validate_model_outputs

<span class="hljs-meta">&gt;&gt;&gt; </span>validate_model_outputs(
<span class="hljs-meta">... </span>    onnx_config, tokenizer, base_model, onnx_path, onnx_outputs, onnx_config.atol_for_validation
<span class="hljs-meta">... </span>)`}}),zo=new M({}),$o=new M({}),ut=new ia({props:{$$slots:{default:[DE]},$$scope:{ctx:L}}}),ko=new M({}),No=new M({}),Oo=new M({}),xo=new M({}),jo=new S({props:{code:`







`,highlighted:`<span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> BertModel, BertTokenizer, BertConfig
<span class="hljs-keyword">import</span> torch

enc = BertTokenizer.from_pretrained(<span class="hljs-string">&quot;bert-base-uncased&quot;</span>)

<span class="hljs-comment"># Tokenizing input text</span>
text = <span class="hljs-string">&quot;[CLS] Who was Jim Henson ? [SEP] Jim Henson was a puppeteer [SEP]&quot;</span>
tokenized_text = enc.tokenize(text)

<span class="hljs-comment"># Masking one of the input tokens</span>
masked_index = <span class="hljs-number">8</span>
tokenized_text[masked_index] = <span class="hljs-string">&quot;[MASK]&quot;</span>
indexed_tokens = enc.convert_tokens_to_ids(tokenized_text)
segments_ids = [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>]

<span class="hljs-comment"># Creating a dummy input</span>
tokens_tensor = torch.tensor([indexed_tokens])
segments_tensors = torch.tensor([segments_ids])
dummy_input = [tokens_tensor, segments_tensors]

<span class="hljs-comment"># Initializing the model with the torchscript flag</span>
<span class="hljs-comment"># Flag set to True even though it is not necessary as this model does not have an LM Head.</span>
config = BertConfig(
    vocab_size_or_config_json_file=<span class="hljs-number">32000</span>,
    hidden_size=<span class="hljs-number">768</span>,
    num_hidden_layers=<span class="hljs-number">12</span>,
    num_attention_heads=<span class="hljs-number">12</span>,
    intermediate_size=<span class="hljs-number">3072</span>,
    torchscript=<span class="hljs-literal">True</span>,
)

<span class="hljs-comment"># Instantiating the model</span>
model = BertModel(config)

<span class="hljs-comment"># The model needs to be in evaluation mode</span>
model.<span class="hljs-built_in">eval</span>()

<span class="hljs-comment"># If you are instantiating the model with *from_pretrained* you can also easily set the TorchScript flag</span>
model = BertModel.from_pretrained(<span class="hljs-string">&quot;bert-base-uncased&quot;</span>, torchscript=<span class="hljs-literal">True</span>)

<span class="hljs-comment"># Creating the trace</span>
traced_model = torch.jit.trace(model, [tokens_tensor, segments_tensors])
torch.jit.save(traced_model, <span class="hljs-string">&quot;traced_bert.pt&quot;</span>)`}}),To=new M({}),Ao=new S({props:{code:"",highlighted:`loaded_model = torch.jit.load(<span class="hljs-string">&quot;traced_bert.pt&quot;</span>)
loaded_model.<span class="hljs-built_in">eval</span>()

all_encoder_layers, pooled_output = loaded_model(*dummy_input)`}}),qo=new M({}),Po=new S({props:{code:"traced_model(tokens_tensor, segments_tensors)",highlighted:"traced_model(tokens_tensor, segments_tensors)"}}),Lo=new M({}),Qo=new M({}),Wo=new M({}),Ko=new S({props:{code:`from transformers import BertModel, BertTokenizer, BertConfig
import torch
import torch.neuron`,highlighted:`<span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> BertModel, BertTokenizer, BertConfig
<span class="hljs-keyword">import</span> torch
<span class="hljs-keyword">import</span> torch.neuron`}}),Vo=new S({props:{code:"torch.jit.trace(model, [tokens_tensor, segments_tensors])",highlighted:"torch.jit.trace(model, [tokens_tensor, segments_tensors])"}}),Jo=new S({props:{code:"torch.neuron.trace(model, [token_tensor, segments_tensors])",highlighted:"torch.neuron.trace(model, [token_tensor, segments_tensors])"}}),{c(){f=i("meta"),N=c(),m=i("h1"),k=i("a"),x=i("span"),_(O.$$.fragment),y=c(),P=i("span"),A=l("Esporta modelli \u{1F917} Transformers"),j=c(),C=i("p"),q=l(`Se devi implementare \u{1F917} modelli Transformers in ambienti di produzione, noi
consigliamo di esportarli in un formato serializzato che pu\xF2 essere caricato ed eseguito
su runtime e hardware specializzati. In questa guida ti mostreremo come farlo
esporta \u{1F917} Modelli Transformers in due formati ampiamente utilizzati: ONNX e TorchScript.`),D=c(),g=i("p"),T=l(`Una volta esportato, un modello pu\xF2 essere ottimizato per l\u2019inferenza tramite tecniche come
la quantizzazione e soppressione. Se sei interessato a ottimizzare i tuoi modelli per l\u2019esecuzione
con la massima efficienza, dai un\u2019occhiata a `),B=i("a"),W=l(`\u{1F917} Optimum
library`),ge=l("."),Me=c(),G=i("h2"),Q=i("a"),_e=i("span"),_(ae.$$.fragment),ze=c(),I=i("span"),ti=l("ONNX"),Pt=c(),K=i("p"),oi=l("Il progetto "),ne=i("a"),ii=l("ONNX (Open Neural Network eXchange)"),ai=l(` Il progetto onnx \xE8 un open
standard che definisce un insieme comune di operatori e un formato di file comune a
rappresentano modelli di deep learning in un\u2019ampia variet\xE0 di framework, tra cui
PyTorch e TensorFlow. Quando un modello viene esportato nel formato ONNX, questi
operatori sono usati per costruire un grafico computazionale (often called an
`),aa=i("em"),cc=l("intermediate representation"),dc=l(`) che rappresenta il flusso di dati attraverso la
rete neurale.`),rs=c(),ni=i("p"),uc=l(`Esponendo un grafico con operatori e tipi di dati standardizzati, ONNX rende
pi\xF9 facile passare da un framework all\u2019altro. Ad esempio, un modello allenato in PyTorch pu\xF2
essere esportato in formato ONNX e quindi importato in TensorFlow (e viceversa).`),ps=c(),Xe=i("p"),fc=l("\u{1F917} Transformers fornisce un pacchetto "),na=i("code"),mc=l("transformers.onnx"),hc=l(` che ti consente di
convertire i checkpoint del modello in un grafico ONNX sfruttando gli oggetti di configurazione.
Questi oggetti di configurazione sono gi\xE0 pronti per una serie di architetture di modelli,
e sono progettati per essere facilmente estensibili ad altre architetture.`),cs=c(),li=i("p"),vc=l("Le configurazioni pronte includono le seguenti architetture:"),ds=c(),h=i("ul"),la=i("li"),gc=l("ALBERT"),_c=c(),sa=i("li"),zc=l("BART"),Ec=c(),ra=i("li"),$c=l("BEiT"),bc=c(),pa=i("li"),wc=l("BERT"),kc=c(),ca=i("li"),Nc=l("BigBird"),Oc=c(),da=i("li"),xc=l("BigBird-Pegasus"),jc=c(),ua=i("li"),Tc=l("Blenderbot"),Ac=c(),fa=i("li"),qc=l("BlenderbotSmall"),Pc=c(),ma=i("li"),yc=l("CamemBERT"),Cc=c(),ha=i("li"),Dc=l("ConvBERT"),Sc=c(),va=i("li"),Ic=l("Data2VecText"),Lc=c(),ga=i("li"),Bc=l("Data2VecVision"),Mc=c(),_a=i("li"),Xc=l("DeiT"),Rc=c(),za=i("li"),Fc=l("DistilBERT"),Qc=c(),Ea=i("li"),Hc=l("ELECTRA"),Uc=c(),$a=i("li"),Wc=l("FlauBERT"),Gc=c(),ba=i("li"),Kc=l("GPT Neo"),Vc=c(),wa=i("li"),Jc=l("GPT-J"),Yc=c(),ka=i("li"),Zc=l("I-BERT"),ed=c(),Na=i("li"),td=l("LayoutLM"),od=c(),Oa=i("li"),id=l("M2M100"),ad=c(),xa=i("li"),nd=l("Marian"),ld=c(),ja=i("li"),sd=l("mBART"),rd=c(),Ta=i("li"),pd=l("MobileBERT"),cd=c(),Aa=i("li"),dd=l("OpenAI GPT-2"),ud=c(),qa=i("li"),fd=l("Perceiver"),md=c(),Pa=i("li"),hd=l("PLBart"),vd=c(),ya=i("li"),gd=l("RoBERTa"),_d=c(),Ca=i("li"),zd=l("RoFormer"),Ed=c(),Da=i("li"),$d=l("SqueezeBERT"),bd=c(),Sa=i("li"),wd=l("T5"),kd=c(),Ia=i("li"),Nd=l("ViT"),Od=c(),La=i("li"),xd=l("XLM"),jd=c(),Ba=i("li"),Td=l("XLM-RoBERTa"),Ad=c(),Ma=i("li"),qd=l("XLM-RoBERTa-XL"),us=c(),si=i("p"),Pd=l("Nelle prossime due sezioni, ti mostreremo come:"),fs=c(),Re=i("ul"),yt=i("li"),yd=l("Esporta un modello supportato usando il pacchetto "),Xa=i("code"),Cd=l("transformers.onnx"),Dd=l("."),Sd=c(),Ra=i("li"),Id=l("Esporta un modello personalizzato per un\u2019architettura non supportata."),ms=c(),Ee=i("h3"),Fe=i("a"),Fa=i("span"),_(Ct.$$.fragment),Ld=c(),Qa=i("span"),Bd=l("Esportazione di un modello in ONNX"),hs=c(),ri=i("p"),Md=l(`Per esportare un modello \u{1F917} Transformers in ONNX, dovrai prima installarne alcune
dipendenze extra:`),vs=c(),_(Dt.$$.fragment),gs=c(),Qe=i("p"),Xd=l("Il pacchetto "),Ha=i("code"),Rd=l("transformers.onnx"),Fd=l(" pu\xF2 essere usato come modulo Python:"),_s=c(),_(St.$$.fragment),zs=c(),pi=i("p"),Qd=l("L\u2019esportazione di un checkpoint utilizzando una configurazione gi\xE0 pronta pu\xF2 essere eseguita come segue:"),Es=c(),_(It.$$.fragment),$s=c(),ci=i("p"),Hd=l("che dovrebbe mostrare i seguenti log:"),bs=c(),_(Lt.$$.fragment),ws=c(),le=i("p"),Ud=l("Questo esporta un grafico ONNX del checkpoint definito dall\u2019argomento "),Ua=i("code"),Wd=l("--model"),Gd=l(`.
In questo esempio \xE8 `),Wa=i("code"),Kd=l("distilbert-base-uncased"),Vd=l(`, ma pu\xF2 essere qualsiasi checkpoint
Hugging Face Hub o uno memorizzato localmente.`),ks=c(),J=i("p"),Jd=l("Il file risultante "),Ga=i("code"),Yd=l("model.onnx"),Zd=l(" pu\xF2 quindi essere eseguito su uno dei "),Bt=i("a"),eu=l(`tanti
acceleratori`),tu=l(` che supportano il
lo standard ONNX. Ad esempio, possiamo caricare ed eseguire il modello con `),Mt=i("a"),ou=l(`ONNX
Runtime`),iu=l(" come segue:"),Ns=c(),_(Xt.$$.fragment),Os=c(),He=i("p"),au=l("I nomi di output richiesti (cio\xE8 "),Ka=i("code"),nu=l('["last_hidden_state"]'),lu=l(`) possono essere ottenuti
dando un\u2019occhiata alla configurazione ONNX di ogni modello. Ad esempio, per
DistilBERT abbiamo:`),xs=c(),_(Rt.$$.fragment),js=c(),Ue=i("p"),su=l(`Il processo \xE8 identico per i checkpoint TensorFlow sull\u2019hub. Ad esempio, noi
possiamo esportare un checkpoint TensorFlow puro da `),Ft=i("a"),ru=l(`Keras
organizzazione`),pu=l(" come segue:"),Ts=c(),_(Qt.$$.fragment),As=c(),di=i("p"),cu=l(`Per esportare un modello memorizzato localmente, devi disporre dei pesi del modello
e file tokenizer memorizzati in una directory. Ad esempio, possiamo caricare e salvare un
checkpoint come segue:`),qs=c(),_(We.$$.fragment),Ps=c(),$e=i("h3"),Ge=i("a"),Va=i("span"),_(Ht.$$.fragment),du=c(),Ja=i("span"),uu=l("Selezione delle caratteristiche per diverse topologie di modello"),ys=c(),Ke=i("p"),fu=l("Ogni configurazione gi\xE0 pronta viene fornita con una serie di "),Ya=i("em"),mu=l("caratteristiche"),hu=l(` che ti consentono di
esportare modelli per diversi tipi di topologie o attivit\xE0. Come mostrato nella tabella
di seguito, ogni caratteristica \xE8 associata a una diversa Auto Class:`),Cs=c(),Ve=i("table"),Za=i("thead"),Ut=i("tr"),en=i("th"),vu=l("Caratteristica"),gu=c(),tn=i("th"),_u=l("Auto Class"),zu=c(),X=i("tbody"),Wt=i("tr"),Gt=i("td"),on=i("code"),Eu=l("causal-lm"),$u=l(", "),an=i("code"),bu=l("causal-lm-with-past"),wu=c(),nn=i("td"),ln=i("code"),ku=l("AutoModelForCausalLM"),Nu=c(),Kt=i("tr"),Vt=i("td"),sn=i("code"),Ou=l("default"),xu=l(", "),rn=i("code"),ju=l("default-with-past"),Tu=c(),pn=i("td"),cn=i("code"),Au=l("AutoModel"),qu=c(),Jt=i("tr"),dn=i("td"),un=i("code"),Pu=l("masked-lm"),yu=c(),fn=i("td"),mn=i("code"),Cu=l("AutoModelForMaskedLM"),Du=c(),Yt=i("tr"),hn=i("td"),vn=i("code"),Su=l("question-answering"),Iu=c(),gn=i("td"),_n=i("code"),Lu=l("AutoModelForQuestionAnswering"),Bu=c(),Zt=i("tr"),eo=i("td"),zn=i("code"),Mu=l("seq2seq-lm"),Xu=l(", "),En=i("code"),Ru=l("seq2seq-lm-with-past"),Fu=c(),$n=i("td"),bn=i("code"),Qu=l("AutoModelForSeq2SeqLM"),Hu=c(),to=i("tr"),wn=i("td"),kn=i("code"),Uu=l("sequence-classification"),Wu=c(),Nn=i("td"),On=i("code"),Gu=l("AutoModelForSequenceClassification"),Ku=c(),oo=i("tr"),xn=i("td"),jn=i("code"),Vu=l("token-classification"),Ju=c(),Tn=i("td"),An=i("code"),Yu=l("AutoModelForTokenClassification"),Ds=c(),Je=i("p"),Zu=l(`Per ciascuna configurazione, puoi trovare l\u2019elenco delle funzionalit\xE0 supportate tramite il
`),qn=i("code"),ef=l("FeaturesManager"),tf=l(". Ad esempio, per DistilBERT abbiamo:"),Ss=c(),_(io.$$.fragment),Is=c(),se=i("p"),of=l("Puoi quindi passare una di queste funzionalit\xE0 all\u2019argomento "),Pn=i("code"),af=l("--feature"),nf=l(` nel
pacchetto `),yn=i("code"),lf=l("transformers.onnx"),sf=l(`. Ad esempio, per esportare un modello di classificazione del testo
possiamo scegliere un modello ottimizzato dall\u2019Hub ed eseguire:`),Ls=c(),_(ao.$$.fragment),Bs=c(),ui=i("p"),rf=l("che visualizzer\xE0 i seguenti registri:"),Ms=c(),_(no.$$.fragment),Xs=c(),Y=i("p"),pf=l(`Puoi notare che in questo caso, i nomi di output del modello ottimizzato sono
`),Cn=i("code"),cf=l("logits"),df=l(" invece di "),Dn=i("code"),uf=l("last_hidden_state"),ff=l(` che abbiamo visto con il
checkpoint `),Sn=i("code"),mf=l("distilbert-base-uncased"),hf=l(` precedente. Questo \xE8 previsto dal
modello ottimizato visto che ha una testa di e.`),Rs=c(),_(Ye.$$.fragment),Fs=c(),be=i("h3"),Ze=i("a"),In=i("span"),_(lo.$$.fragment),vf=c(),Ln=i("span"),gf=l("Esportazione di un modello per un'architettura non supportata"),Qs=c(),fi=i("p"),_f=l(`Se desideri esportare un modello la cui architettura non \xE8 nativamente supportata dalla
libreria, ci sono tre passaggi principali da seguire:`),Hs=c(),re=i("ol"),Bn=i("li"),zf=l("Implementare una configurazione ONNX personalizzata."),Ef=c(),Mn=i("li"),$f=l("Esportare il modello in ONNX."),bf=c(),Xn=i("li"),wf=l("Convalidare gli output di PyTorch e dei modelli esportati."),Us=c(),mi=i("p"),kf=l(`In questa sezione, vedremo come DistilBERT \xE8 stato implementato per mostrare cosa \xE8
coinvolto in ogni passaggio.`),Ws=c(),we=i("h4"),et=i("a"),Rn=i("span"),_(so.$$.fragment),Nf=c(),Fn=i("span"),Of=l("Implementazione di una configurazione ONNX personalizzata"),Gs=c(),hi=i("p"),xf=l(`Iniziamo con l\u2019oggetto di configurazione ONNX. Forniamo tre classi
astratte da cui ereditare, a seconda del tipo di archittettura
del modello che desideri esportare:`),Ks=c(),pe=i("ul"),vi=i("li"),jf=l("I modelli basati su encoder ereditano da "),Qn=i("code"),Tf=l("OnnxConfig"),Af=c(),gi=i("li"),qf=l("I modelli basati su decoder ereditano da "),Hn=i("code"),Pf=l("OnnxConfigWithPast"),yf=c(),_i=i("li"),Cf=l("I modelli encoder-decoder ereditano da"),Un=i("code"),Df=l("OnnxSeq2SeqConfigWithPast"),Vs=c(),_(tt.$$.fragment),Js=c(),ot=i("p"),Sf=l(`Poich\xE9 DistilBERT \xE8 un modello basato su encoder, la sua configurazione eredita da
`),Wn=i("code"),If=l("OnnxConfig"),Lf=l(":"),Ys=c(),_(ro.$$.fragment),Zs=c(),H=i("p"),Bf=l("Ogni oggetto di configurazione deve implementare la propriet\xE0 "),Gn=i("code"),Mf=l("inputs"),Xf=l(` e restituire una
mappatura, dove ogni chiave corrisponde a un input previsto e ogni valore
indica l\u2019asse di quell\u2019input. Per DistilBERT, possiamo vedere che sono richiesti
due input: `),Kn=i("code"),Rf=l("input_ids"),Ff=l(" e "),Vn=i("code"),Qf=l("attention_mask"),Hf=l(`. Questi inputs hanno la stessa forma di
`),Jn=i("code"),Uf=l("(batch_size, sequence_length)"),Wf=l(` per questo motivo vediamo gli stessi assi usati nella
configurazione.`),er=c(),_(it.$$.fragment),tr=c(),zi=i("p"),Gf=l(`Dopo aver implementato una configurazione ONNX, \xE8 possibile istanziarla
fornendo alla configurazione del modello base come segue:`),or=c(),_(po.$$.fragment),ir=c(),Ei=i("p"),Kf=l(`L\u2019oggetto risultante ha diverse propriet\xE0 utili. Ad esempio \xE8 possibile visualizzare il
Set operatore ONNX che verr\xE0 utilizzato durante l\u2019esportazione:`),ar=c(),_(co.$$.fragment),nr=c(),$i=i("p"),Vf=l("\xC8 inoltre possibile visualizzare gli output associati al modello come segue:"),lr=c(),_(uo.$$.fragment),sr=c(),Z=i("p"),Jf=l(`Puoi notare che la propriet\xE0 degli output segue la stessa struttura degli input; esso
restituisce un `),Yn=i("code"),Yf=l("OrderedDict"),Zf=l(` di output con nome e le loro forme. La struttura di output
\xE8 legato alla scelta della funzione con cui viene inizializzata la configurazione.
Per impostazione predefinita, la configurazione ONNX viene inizializzata con la funzione \u2018predefinita\u2019
che corrisponde all\u2019esportazione di un modello caricato con la classe `),Zn=i("code"),em=l("AutoModel"),tm=l(`. Se tu
desideri esportare una topologia di modello diversa, \xE8 sufficiente fornire una funzionalit\xE0 diversa a
l\u2019argomento `),el=i("code"),om=l("task"),im=l(` quando inizializzi la configurazione ONNX. Ad esempio, se
volevamo esportare DistilBERT con una testa di classificazione per sequenze, potremmo
usare:`),rr=c(),_(fo.$$.fragment),pr=c(),_(at.$$.fragment),cr=c(),ke=i("h4"),nt=i("a"),tl=i("span"),_(mo.$$.fragment),am=c(),ol=i("span"),nm=l("Esportazione del modello"),dr=c(),ce=i("p"),lm=l(`Una volta implementata la configurazione ONNX, il passaggio successivo consiste nell\u2019esportare il
modello. Qui possiamo usare la funzione `),il=i("code"),sm=l("export()"),rm=l(` fornita dal
pacchetto `),al=i("code"),pm=l("transformers.onnx"),cm=l(`. Questa funzione prevede la configurazione ONNX, insieme
con il modello base e il tokenizer e il percorso per salvare il file esportato:`),ur=c(),_(ho.$$.fragment),fr=c(),R=i("p"),dm=l("Gli "),nl=i("code"),um=l("onnx_inputs"),fm=l(" e "),ll=i("code"),mm=l("onnx_outputs"),hm=l(" restituiti dalla funzione "),sl=i("code"),vm=l("export()"),gm=l(` sono
liste di chiavi definite nelle propriet\xE0 di `),rl=i("code"),_m=l("input"),zm=l(" e "),pl=i("code"),Em=l("output"),$m=l(` della
configurazione. Una volta esportato il modello, puoi verificare che il modello sia ben
formato come segue:`),mr=c(),_(vo.$$.fragment),hr=c(),_(lt.$$.fragment),vr=c(),Ne=i("h4"),st=i("a"),cl=i("span"),_(go.$$.fragment),bm=c(),dl=i("span"),wm=l("Convalida degli output del modello"),gr=c(),de=i("p"),km=l(`Il passaggio finale consiste nel convalidare gli output dal modello di base e quello esportato
corrispondere entro una soglia di tolleranza assoluta. Qui possiamo usare la
Funzione `),ul=i("code"),Nm=l("validate_model_outputs()"),Om=l(" fornita dal pacchetto "),fl=i("code"),xm=l("transformers.onnx"),jm=l(`
come segue:`),_r=c(),_(_o.$$.fragment),zr=c(),rt=i("p"),Tm=l("Questa funzione usa il metodo "),ml=i("code"),Am=l("OnnxConfig.generate_dummy_inputs()"),qm=l(` per generare
input per il modello di base e quello esportato e la tolleranza assoluta pu\xF2 essere
definita nella configurazione. Generalmente troviamo una corrispondenza numerica nell\u2019intervallo da 1e-6
a 1e-4, anche se \xE8 probabile che qualsiasi cosa inferiore a 1e-3 vada bene.`),Er=c(),Oe=i("h3"),pt=i("a"),hl=i("span"),_(zo.$$.fragment),Pm=c(),vl=i("span"),ym=l("Contribuire con una nuova configurazione a \u{1F917} Transformers"),$r=c(),bi=i("p"),Cm=l(`Stiamo cercando di espandere l\u2019insieme di configurazioni gi\xE0 pronte e di accettare
contributi della community! Se vuoi contribuire con la tua aggiunta
nella libreria, dovrai:`),br=c(),ue=i("ul"),wi=i("li"),Dm=l("Implementare la configurazione ONNX nella corrispondente "),gl=i("code"),Sm=l("configuration file _<model_name>.py"),Im=c(),ki=i("li"),Lm=l("Includere l\u2019architettura del modello e le funzioni corrispondenti in "),_l=i("code"),Bm=l("FeatureManager"),Mm=c(),Ni=i("li"),Xm=l("Aggiungere la tua architettura del modello ai test in "),zl=i("code"),Rm=l("test_onnx_v2.py"),wr=c(),ct=i("p"),Fm=l(`Scopri come stato contribuito la configurazione per [IBERT]
(`),Eo=i("a"),Qm=l("https://github.com/huggingface/transformers/pull/14868/files"),Hm=l(`) per
avere un\u2019idea di cosa \xE8 coinvolto.`),kr=c(),xe=i("h2"),dt=i("a"),El=i("span"),_($o.$$.fragment),Um=c(),$l=i("span"),Wm=l("TorchScript"),Nr=c(),_(ut.$$.fragment),Or=c(),ft=i("p"),Gm=l(`Secondo la documentazione di Pytorch: \u201CTorchScript \xE8 un modo per creare modelli serializzabili e ottimizzabili da codice
Pytorch\u201D. I due moduli di Pytorch `),bo=i("a"),Km=l("JIT e TRACE"),Vm=l(` consentono allo sviluppatore di esportare
il loro modello da riutilizzare in altri programmi, come i programmi C++ orientati all\u2019efficienza.`),xr=c(),Oi=i("p"),Jm=l(`Abbiamo fornito un\u2019interfaccia che consente l\u2019esportazione di modelli \u{1F917} Transformers in TorchScript in modo che possano essere riutilizzati
in un ambiente diverso rispetto a un programma Python basato su Pytorch. Qui spieghiamo come esportare e utilizzare i nostri modelli utilizzando
TorchScript.`),jr=c(),xi=i("p"),Ym=l("Esportare un modello richiede due cose:"),Tr=c(),mt=i("ul"),bl=i("li"),Zm=l("Un passaggio in avanti con input fittizzi."),eh=c(),wo=i("li"),th=l("Istanziazione del modello con flag "),wl=i("code"),oh=l("torchscript"),ih=l("."),Ar=c(),ji=i("p"),ah=l("Queste necessit\xE0 implicano diverse cose a cui gli sviluppatori dovrebbero prestare attenzione. Questi dettagli mostrati sotto."),qr=c(),je=i("h3"),ht=i("a"),kl=i("span"),_(ko.$$.fragment),nh=c(),Nl=i("span"),lh=l("Flag TorchScript e pesi legati"),Pr=c(),Ti=i("p"),sh=l(`Questo flag \xE8 necessario perch\xE9 la maggior parte dei modelli linguistici in questo repository hanno pesi legati tra il loro
strato \u201CEmbedding\u201D e lo strato \u201CDecoding\u201D. TorchScript non consente l\u2019esportazione di modelli che hanno pesi
legati, quindi \xE8 necessario prima slegare e clonare i pesi.`),yr=c(),ee=i("p"),rh=l("Ci\xF2 implica che i modelli istanziati con il flag "),Ol=i("code"),ph=l("torchscript"),ch=l(" hanno il loro strato "),xl=i("code"),dh=l("Embedding"),uh=l(" e strato "),jl=i("code"),fh=l("Decoding"),mh=l(`
separato, il che significa che non dovrebbero essere addestrati in futuro. L\u2019allenamento de-sincronizza i due
strati, portando a risultati inaspettati.`),Cr=c(),vt=i("p"),hh=l(`Questo non \xE8 il caso per i modelli che non hanno una testa del modello linguistico, poich\xE9 quelli non hanno pesi legati. Questi modelli
pu\xF2 essere esportato in sicurezza senza il flag `),Tl=i("code"),vh=l("torchscript"),gh=l("."),Dr=c(),Te=i("h3"),gt=i("a"),Al=i("span"),_(No.$$.fragment),_h=c(),ql=i("span"),zh=l("Input fittizi e standard lengths"),Sr=c(),Ai=i("p"),Eh=l(`Gli input fittizzi sono usati per fare un modello passaggio in avanti . Mentre i valori degli input si propagano attraverso i strati,
Pytorch tiene traccia delle diverse operazioni eseguite su ciascun tensore. Queste operazioni registrate vengono quindi utilizzate per
creare la \u201Ctraccia\u201D del modello.`),Ir=c(),qi=i("p"),$h=l(`La traccia viene creata relativamente alle dimensioni degli input. \xC8 quindi vincolato dalle dimensioni dell\u2019input
fittizio e non funzioner\xE0 per altre lunghezze di sequenza o dimensioni batch. Quando si prover\xE0 con una dimensione diversa, ci sar\xE0 errore
come:`),Lr=c(),Pi=i("p"),Pl=i("code"),bh=l("La dimensione espansa del tensore (3) deve corrispondere alla dimensione esistente (7) nella dimensione non singleton 2"),Br=c(),yi=i("p"),wh=l(`will be raised. Si consiglia pertanto di tracciare il modello con una dimensione di input fittizia grande almeno quanto il pi\xF9 grande
input che verr\xE0 fornito al modello durante l\u2019inferenza. \xC8 possibile eseguire il padding per riempire i valori mancanti. Il modello
sar\xE0 tracciato con una grande dimensione di input, tuttavia, anche le dimensioni della diverse matrici saranno grandi,
risultando in pi\xF9 calcoli.`),Mr=c(),Ci=i("p"),kh=l(`Si raccomanda di prestare attenzione al numero totale di operazioni eseguite su ciascun input e di seguire da vicino le prestazioni
durante l\u2019esportazione di modelli di sequenza-lunghezza variabili.`),Xr=c(),Ae=i("h3"),_t=i("a"),yl=i("span"),_(Oo.$$.fragment),Nh=c(),Cl=i("span"),Oh=l("Usare TorchSscript in Python"),Rr=c(),Di=i("p"),xh=l("Di seguito \xE8 riportato un esempio, che mostra come salvare, caricare modelli e come utilizzare la traccia per l\u2019inferenza."),Fr=c(),qe=i("h4"),zt=i("a"),Dl=i("span"),_(xo.$$.fragment),jh=c(),Sl=i("span"),Th=l("Salvare un modello"),Qr=c(),V=i("p"),Ah=l("Questo frammento di codice mostra come usare TorchScript per esportare un "),Il=i("code"),qh=l("BertModel"),Ph=l(". Qui il "),Ll=i("code"),yh=l("BertModel"),Ch=l(` \xE8 istanziato secondo
una classe `),Bl=i("code"),Dh=l("BertConfig"),Sh=l(" e quindi salvato su disco con il nome del file "),Ml=i("code"),Ih=l("traced_bert.pt"),Hr=c(),_(jo.$$.fragment),Ur=c(),Pe=i("h4"),Et=i("a"),Xl=i("span"),_(To.$$.fragment),Lh=c(),Rl=i("span"),Bh=l("Caricare un modello"),Wr=c(),te=i("p"),Mh=l("Questo frammento di codice mostra come caricare il "),Fl=i("code"),Xh=l("BertModel"),Rh=l(" che era stato precedentemente salvato su disco con il nome "),Ql=i("code"),Fh=l("traced_bert.pt"),Qh=l(`.
Stiamo riutilizzando il `),Hl=i("code"),Hh=l("dummy_input"),Uh=l(" precedentemente inizializzato."),Gr=c(),_(Ao.$$.fragment),Kr=c(),ye=i("h4"),$t=i("a"),Ul=i("span"),_(qo.$$.fragment),Wh=c(),Wl=i("span"),Gh=l("Utilizzare un modello tracciato per l'inferenza"),Vr=c(),bt=i("p"),Kh=l("Usare il modello tracciato per l\u2019inferenza \xE8 semplice come usare il suo metodo dunder "),Gl=i("code"),Vh=l("__call__"),Jh=l(":"),Jr=c(),_(Po.$$.fragment),Yr=c(),Si=i("p"),Yh=l("###Implementare modelli HuggingFace TorchScript su AWS utilizzando Neuron SDK"),Zr=c(),fe=i("p"),Zh=l("AWS ha introdotto "),yo=i("a"),ev=l("Amazon EC2 Inf1"),tv=l(`
famiglia di istanze per l\u2019inferenza di machine learning a basso costo e ad alte prestazioni nel cloud.
Le istanze Inf1 sono alimentate dal chip AWS Inferentia, un acceleratore hardware personalizzato,
specializzato in carichi di lavoro di inferenza di deep learning.
`),Co=i("a"),ov=l("AWS Neuron"),iv=l(`
\xE8 l\u2019SDK per Inferentia che supporta il tracciamento e l\u2019ottimizzazione dei modelli transformers per
distribuzione su Inf1. L\u2019SDK Neuron fornisce:`),ep=c(),me=i("ol"),Kl=i("li"),av=l("API di facile utilizzo con una riga di modifica del codice per tracciare e ottimizzare un modello TorchScript per l\u2019inferenza nel cloud."),nv=c(),Ii=i("li"),lv=l("Ottimizzazioni delle prestazioni pronte all\u2019uso per "),Do=i("a"),sv=l("miglioramento dei costi-prestazioni"),rv=c(),Ce=i("li"),pv=l("Supporto per i modelli di trasformatori HuggingFace costruiti con "),So=i("a"),cv=l("PyTorch"),dv=l(`
o `),Io=i("a"),uv=l("TensorFlow"),fv=l("."),tp=c(),De=i("h4"),wt=i("a"),Vl=i("span"),_(Lo.$$.fragment),mv=c(),Jl=i("span"),hv=l("Implicazioni"),op=c(),F=i("p"),vv=l("Modelli Transformers basati su architettura "),Bo=i("a"),gv=l("BERT (Bidirectional Encoder Representations from Transformers)"),_v=l(`,
o sue varianti come `),Mo=i("a"),zv=l("distilBERT"),Ev=l(`
e `),Xo=i("a"),$v=l("roBERTa"),bv=l(`
funzioneranno meglio su Inf1 per attivit\xE0 non generative come la question answering estrattive,
Classificazione della sequenza, Classificazione dei token. In alternativa, generazione di testo
le attivit\xE0 possono essere adattate per essere eseguite su Inf1, secondo questo `),Ro=i("a"),wv=l("tutorial AWS Neuron MarianMT"),kv=l(`.
Ulteriori informazioni sui modelli che possono essere convertiti fuori dagli schemi su Inferentia possono essere
trovati nella `),Fo=i("a"),Nv=l("sezione Model Architecture Fit della documentazione Neuron"),Ov=l("."),ip=c(),Se=i("h4"),kt=i("a"),Yl=i("span"),_(Qo.$$.fragment),xv=c(),Zl=i("span"),jv=l("Dipendenze"),ap=c(),Li=i("p"),Tv=l("L\u2019utilizzo di AWS Neuron per convertire i modelli richiede le seguenti dipendenze e l\u2019ambiente:"),np=c(),Bi=i("ul"),Ie=i("li"),Av=l("A "),Ho=i("a"),qv=l("Neuron SDK environment"),Pv=l(`,
which comes pre-configured on `),Uo=i("a"),yv=l("AWS Deep Learning AMI"),Cv=l("."),lp=c(),Le=i("h4"),Nt=i("a"),es=i("span"),_(Wo.$$.fragment),Dv=c(),ts=i("span"),Sv=l("Convertire un modello per AWS Neuron"),sp=c(),he=i("p"),Iv=l("Usando lo stesso script come in "),Go=i("a"),Lv=l("Usando TorchScipt in Python"),Bv=l(`
per tracciare un \u201CBertModel\u201D, importi l\u2019estensione del framework `),os=i("code"),Mv=l("torch.neuron"),Xv=l(` per accedere
i componenti di Neuron SDK tramite un\u2019API Python.`),rp=c(),_(Ko.$$.fragment),pp=c(),Mi=i("p"),Rv=l("E modificare solo la riga di codice di traccia"),cp=c(),Xi=i("p"),Fv=l("Da:"),dp=c(),_(Vo.$$.fragment),up=c(),Ri=i("p"),Qv=l("A:"),fp=c(),_(Jo.$$.fragment),mp=c(),Fi=i("p"),Hv=l("Questa modifica consente a Neuron SDK di tracciare il modello e ottimizzarlo per l\u2019esecuzione nelle istanze Inf1."),hp=c(),Ot=i("p"),Uv=l(`Per ulteriori informazioni sulle funzionalit\xE0, gli strumenti, i tutorial di esempi e gli ultimi aggiornamenti di AWS Neuron SDK,
consultare la `),Yo=i("a"),Wv=l("documentazione AWS NeuronSDK"),Gv=l("."),this.h()},l(e){const r=wE('[data-svelte="svelte-1phssyn"]',document.head);f=a(r,"META",{name:!0,content:!0}),r.forEach(o),N=d(e),m=a(e,"H1",{class:!0});var Zo=n(m);k=a(Zo,"A",{id:!0,class:!0,href:!0});var is=n(k);x=a(is,"SPAN",{});var as=n(x);z(O.$$.fragment,as),as.forEach(o),is.forEach(o),y=d(Zo),P=a(Zo,"SPAN",{});var ns=n(P);A=s(ns,"Esporta modelli \u{1F917} Transformers"),ns.forEach(o),Zo.forEach(o),j=d(e),C=a(e,"P",{});var ls=n(C);q=s(ls,`Se devi implementare \u{1F917} modelli Transformers in ambienti di produzione, noi
consigliamo di esportarli in un formato serializzato che pu\xF2 essere caricato ed eseguito
su runtime e hardware specializzati. In questa guida ti mostreremo come farlo
esporta \u{1F917} Modelli Transformers in due formati ampiamente utilizzati: ONNX e TorchScript.`),ls.forEach(o),D=d(e),g=a(e,"P",{});var ei=n(g);T=s(ei,`Una volta esportato, un modello pu\xF2 essere ottimizato per l\u2019inferenza tramite tecniche come
la quantizzazione e soppressione. Se sei interessato a ottimizzare i tuoi modelli per l\u2019esecuzione
con la massima efficienza, dai un\u2019occhiata a `),B=a(ei,"A",{href:!0,rel:!0});var ss=n(B);W=s(ss,`\u{1F917} Optimum
library`),ss.forEach(o),ge=s(ei,"."),ei.forEach(o),Me=d(e),G=a(e,"H2",{class:!0});var gp=n(G);Q=a(gp,"A",{id:!0,class:!0,href:!0});var og=n(Q);_e=a(og,"SPAN",{});var ig=n(_e);z(ae.$$.fragment,ig),ig.forEach(o),og.forEach(o),ze=d(gp),I=a(gp,"SPAN",{});var ag=n(I);ti=s(ag,"ONNX"),ag.forEach(o),gp.forEach(o),Pt=d(e),K=a(e,"P",{});var Qi=n(K);oi=s(Qi,"Il progetto "),ne=a(Qi,"A",{href:!0,rel:!0});var ng=n(ne);ii=s(ng,"ONNX (Open Neural Network eXchange)"),ng.forEach(o),ai=s(Qi,` Il progetto onnx \xE8 un open
standard che definisce un insieme comune di operatori e un formato di file comune a
rappresentano modelli di deep learning in un\u2019ampia variet\xE0 di framework, tra cui
PyTorch e TensorFlow. Quando un modello viene esportato nel formato ONNX, questi
operatori sono usati per costruire un grafico computazionale (often called an
`),aa=a(Qi,"EM",{});var lg=n(aa);cc=s(lg,"intermediate representation"),lg.forEach(o),dc=s(Qi,`) che rappresenta il flusso di dati attraverso la
rete neurale.`),Qi.forEach(o),rs=d(e),ni=a(e,"P",{});var sg=n(ni);uc=s(sg,`Esponendo un grafico con operatori e tipi di dati standardizzati, ONNX rende
pi\xF9 facile passare da un framework all\u2019altro. Ad esempio, un modello allenato in PyTorch pu\xF2
essere esportato in formato ONNX e quindi importato in TensorFlow (e viceversa).`),sg.forEach(o),ps=d(e),Xe=a(e,"P",{});var _p=n(Xe);fc=s(_p,"\u{1F917} Transformers fornisce un pacchetto "),na=a(_p,"CODE",{});var rg=n(na);mc=s(rg,"transformers.onnx"),rg.forEach(o),hc=s(_p,` che ti consente di
convertire i checkpoint del modello in un grafico ONNX sfruttando gli oggetti di configurazione.
Questi oggetti di configurazione sono gi\xE0 pronti per una serie di architetture di modelli,
e sono progettati per essere facilmente estensibili ad altre architetture.`),_p.forEach(o),cs=d(e),li=a(e,"P",{});var pg=n(li);vc=s(pg,"Le configurazioni pronte includono le seguenti architetture:"),pg.forEach(o),ds=d(e),h=a(e,"UL",{});var v=n(h);la=a(v,"LI",{});var cg=n(la);gc=s(cg,"ALBERT"),cg.forEach(o),_c=d(v),sa=a(v,"LI",{});var dg=n(sa);zc=s(dg,"BART"),dg.forEach(o),Ec=d(v),ra=a(v,"LI",{});var ug=n(ra);$c=s(ug,"BEiT"),ug.forEach(o),bc=d(v),pa=a(v,"LI",{});var fg=n(pa);wc=s(fg,"BERT"),fg.forEach(o),kc=d(v),ca=a(v,"LI",{});var mg=n(ca);Nc=s(mg,"BigBird"),mg.forEach(o),Oc=d(v),da=a(v,"LI",{});var hg=n(da);xc=s(hg,"BigBird-Pegasus"),hg.forEach(o),jc=d(v),ua=a(v,"LI",{});var vg=n(ua);Tc=s(vg,"Blenderbot"),vg.forEach(o),Ac=d(v),fa=a(v,"LI",{});var gg=n(fa);qc=s(gg,"BlenderbotSmall"),gg.forEach(o),Pc=d(v),ma=a(v,"LI",{});var _g=n(ma);yc=s(_g,"CamemBERT"),_g.forEach(o),Cc=d(v),ha=a(v,"LI",{});var zg=n(ha);Dc=s(zg,"ConvBERT"),zg.forEach(o),Sc=d(v),va=a(v,"LI",{});var Eg=n(va);Ic=s(Eg,"Data2VecText"),Eg.forEach(o),Lc=d(v),ga=a(v,"LI",{});var $g=n(ga);Bc=s($g,"Data2VecVision"),$g.forEach(o),Mc=d(v),_a=a(v,"LI",{});var bg=n(_a);Xc=s(bg,"DeiT"),bg.forEach(o),Rc=d(v),za=a(v,"LI",{});var wg=n(za);Fc=s(wg,"DistilBERT"),wg.forEach(o),Qc=d(v),Ea=a(v,"LI",{});var kg=n(Ea);Hc=s(kg,"ELECTRA"),kg.forEach(o),Uc=d(v),$a=a(v,"LI",{});var Ng=n($a);Wc=s(Ng,"FlauBERT"),Ng.forEach(o),Gc=d(v),ba=a(v,"LI",{});var Og=n(ba);Kc=s(Og,"GPT Neo"),Og.forEach(o),Vc=d(v),wa=a(v,"LI",{});var xg=n(wa);Jc=s(xg,"GPT-J"),xg.forEach(o),Yc=d(v),ka=a(v,"LI",{});var jg=n(ka);Zc=s(jg,"I-BERT"),jg.forEach(o),ed=d(v),Na=a(v,"LI",{});var Tg=n(Na);td=s(Tg,"LayoutLM"),Tg.forEach(o),od=d(v),Oa=a(v,"LI",{});var Ag=n(Oa);id=s(Ag,"M2M100"),Ag.forEach(o),ad=d(v),xa=a(v,"LI",{});var qg=n(xa);nd=s(qg,"Marian"),qg.forEach(o),ld=d(v),ja=a(v,"LI",{});var Pg=n(ja);sd=s(Pg,"mBART"),Pg.forEach(o),rd=d(v),Ta=a(v,"LI",{});var yg=n(Ta);pd=s(yg,"MobileBERT"),yg.forEach(o),cd=d(v),Aa=a(v,"LI",{});var Cg=n(Aa);dd=s(Cg,"OpenAI GPT-2"),Cg.forEach(o),ud=d(v),qa=a(v,"LI",{});var Dg=n(qa);fd=s(Dg,"Perceiver"),Dg.forEach(o),md=d(v),Pa=a(v,"LI",{});var Sg=n(Pa);hd=s(Sg,"PLBart"),Sg.forEach(o),vd=d(v),ya=a(v,"LI",{});var Ig=n(ya);gd=s(Ig,"RoBERTa"),Ig.forEach(o),_d=d(v),Ca=a(v,"LI",{});var Lg=n(Ca);zd=s(Lg,"RoFormer"),Lg.forEach(o),Ed=d(v),Da=a(v,"LI",{});var Bg=n(Da);$d=s(Bg,"SqueezeBERT"),Bg.forEach(o),bd=d(v),Sa=a(v,"LI",{});var Mg=n(Sa);wd=s(Mg,"T5"),Mg.forEach(o),kd=d(v),Ia=a(v,"LI",{});var Xg=n(Ia);Nd=s(Xg,"ViT"),Xg.forEach(o),Od=d(v),La=a(v,"LI",{});var Rg=n(La);xd=s(Rg,"XLM"),Rg.forEach(o),jd=d(v),Ba=a(v,"LI",{});var Fg=n(Ba);Td=s(Fg,"XLM-RoBERTa"),Fg.forEach(o),Ad=d(v),Ma=a(v,"LI",{});var Qg=n(Ma);qd=s(Qg,"XLM-RoBERTa-XL"),Qg.forEach(o),v.forEach(o),us=d(e),si=a(e,"P",{});var Hg=n(si);Pd=s(Hg,"Nelle prossime due sezioni, ti mostreremo come:"),Hg.forEach(o),fs=d(e),Re=a(e,"UL",{});var zp=n(Re);yt=a(zp,"LI",{});var Ep=n(yt);yd=s(Ep,"Esporta un modello supportato usando il pacchetto "),Xa=a(Ep,"CODE",{});var Ug=n(Xa);Cd=s(Ug,"transformers.onnx"),Ug.forEach(o),Dd=s(Ep,"."),Ep.forEach(o),Sd=d(zp),Ra=a(zp,"LI",{});var Wg=n(Ra);Id=s(Wg,"Esporta un modello personalizzato per un\u2019architettura non supportata."),Wg.forEach(o),zp.forEach(o),ms=d(e),Ee=a(e,"H3",{class:!0});var $p=n(Ee);Fe=a($p,"A",{id:!0,class:!0,href:!0});var Gg=n(Fe);Fa=a(Gg,"SPAN",{});var Kg=n(Fa);z(Ct.$$.fragment,Kg),Kg.forEach(o),Gg.forEach(o),Ld=d($p),Qa=a($p,"SPAN",{});var Vg=n(Qa);Bd=s(Vg,"Esportazione di un modello in ONNX"),Vg.forEach(o),$p.forEach(o),hs=d(e),ri=a(e,"P",{});var Jg=n(ri);Md=s(Jg,`Per esportare un modello \u{1F917} Transformers in ONNX, dovrai prima installarne alcune
dipendenze extra:`),Jg.forEach(o),vs=d(e),z(Dt.$$.fragment,e),gs=d(e),Qe=a(e,"P",{});var bp=n(Qe);Xd=s(bp,"Il pacchetto "),Ha=a(bp,"CODE",{});var Yg=n(Ha);Rd=s(Yg,"transformers.onnx"),Yg.forEach(o),Fd=s(bp," pu\xF2 essere usato come modulo Python:"),bp.forEach(o),_s=d(e),z(St.$$.fragment,e),zs=d(e),pi=a(e,"P",{});var Zg=n(pi);Qd=s(Zg,"L\u2019esportazione di un checkpoint utilizzando una configurazione gi\xE0 pronta pu\xF2 essere eseguita come segue:"),Zg.forEach(o),Es=d(e),z(It.$$.fragment,e),$s=d(e),ci=a(e,"P",{});var e_=n(ci);Hd=s(e_,"che dovrebbe mostrare i seguenti log:"),e_.forEach(o),bs=d(e),z(Lt.$$.fragment,e),ws=d(e),le=a(e,"P",{});var Hi=n(le);Ud=s(Hi,"Questo esporta un grafico ONNX del checkpoint definito dall\u2019argomento "),Ua=a(Hi,"CODE",{});var t_=n(Ua);Wd=s(t_,"--model"),t_.forEach(o),Gd=s(Hi,`.
In questo esempio \xE8 `),Wa=a(Hi,"CODE",{});var o_=n(Wa);Kd=s(o_,"distilbert-base-uncased"),o_.forEach(o),Vd=s(Hi,`, ma pu\xF2 essere qualsiasi checkpoint
Hugging Face Hub o uno memorizzato localmente.`),Hi.forEach(o),ks=d(e),J=a(e,"P",{});var xt=n(J);Jd=s(xt,"Il file risultante "),Ga=a(xt,"CODE",{});var i_=n(Ga);Yd=s(i_,"model.onnx"),i_.forEach(o),Zd=s(xt," pu\xF2 quindi essere eseguito su uno dei "),Bt=a(xt,"A",{href:!0,rel:!0});var a_=n(Bt);eu=s(a_,`tanti
acceleratori`),a_.forEach(o),tu=s(xt,` che supportano il
lo standard ONNX. Ad esempio, possiamo caricare ed eseguire il modello con `),Mt=a(xt,"A",{href:!0,rel:!0});var n_=n(Mt);ou=s(n_,`ONNX
Runtime`),n_.forEach(o),iu=s(xt," come segue:"),xt.forEach(o),Ns=d(e),z(Xt.$$.fragment,e),Os=d(e),He=a(e,"P",{});var wp=n(He);au=s(wp,"I nomi di output richiesti (cio\xE8 "),Ka=a(wp,"CODE",{});var l_=n(Ka);nu=s(l_,'["last_hidden_state"]'),l_.forEach(o),lu=s(wp,`) possono essere ottenuti
dando un\u2019occhiata alla configurazione ONNX di ogni modello. Ad esempio, per
DistilBERT abbiamo:`),wp.forEach(o),xs=d(e),z(Rt.$$.fragment,e),js=d(e),Ue=a(e,"P",{});var kp=n(Ue);su=s(kp,`Il processo \xE8 identico per i checkpoint TensorFlow sull\u2019hub. Ad esempio, noi
possiamo esportare un checkpoint TensorFlow puro da `),Ft=a(kp,"A",{href:!0,rel:!0});var s_=n(Ft);ru=s(s_,`Keras
organizzazione`),s_.forEach(o),pu=s(kp," come segue:"),kp.forEach(o),Ts=d(e),z(Qt.$$.fragment,e),As=d(e),di=a(e,"P",{});var r_=n(di);cu=s(r_,`Per esportare un modello memorizzato localmente, devi disporre dei pesi del modello
e file tokenizer memorizzati in una directory. Ad esempio, possiamo caricare e salvare un
checkpoint come segue:`),r_.forEach(o),qs=d(e),z(We.$$.fragment,e),Ps=d(e),$e=a(e,"H3",{class:!0});var Np=n($e);Ge=a(Np,"A",{id:!0,class:!0,href:!0});var p_=n(Ge);Va=a(p_,"SPAN",{});var c_=n(Va);z(Ht.$$.fragment,c_),c_.forEach(o),p_.forEach(o),du=d(Np),Ja=a(Np,"SPAN",{});var d_=n(Ja);uu=s(d_,"Selezione delle caratteristiche per diverse topologie di modello"),d_.forEach(o),Np.forEach(o),ys=d(e),Ke=a(e,"P",{});var Op=n(Ke);fu=s(Op,"Ogni configurazione gi\xE0 pronta viene fornita con una serie di "),Ya=a(Op,"EM",{});var u_=n(Ya);mu=s(u_,"caratteristiche"),u_.forEach(o),hu=s(Op,` che ti consentono di
esportare modelli per diversi tipi di topologie o attivit\xE0. Come mostrato nella tabella
di seguito, ogni caratteristica \xE8 associata a una diversa Auto Class:`),Op.forEach(o),Cs=d(e),Ve=a(e,"TABLE",{});var xp=n(Ve);Za=a(xp,"THEAD",{});var f_=n(Za);Ut=a(f_,"TR",{});var jp=n(Ut);en=a(jp,"TH",{});var m_=n(en);vu=s(m_,"Caratteristica"),m_.forEach(o),gu=d(jp),tn=a(jp,"TH",{});var h_=n(tn);_u=s(h_,"Auto Class"),h_.forEach(o),jp.forEach(o),f_.forEach(o),zu=d(xp),X=a(xp,"TBODY",{});var U=n(X);Wt=a(U,"TR",{});var Tp=n(Wt);Gt=a(Tp,"TD",{});var Ap=n(Gt);on=a(Ap,"CODE",{});var v_=n(on);Eu=s(v_,"causal-lm"),v_.forEach(o),$u=s(Ap,", "),an=a(Ap,"CODE",{});var g_=n(an);bu=s(g_,"causal-lm-with-past"),g_.forEach(o),Ap.forEach(o),wu=d(Tp),nn=a(Tp,"TD",{});var __=n(nn);ln=a(__,"CODE",{});var z_=n(ln);ku=s(z_,"AutoModelForCausalLM"),z_.forEach(o),__.forEach(o),Tp.forEach(o),Nu=d(U),Kt=a(U,"TR",{});var qp=n(Kt);Vt=a(qp,"TD",{});var Pp=n(Vt);sn=a(Pp,"CODE",{});var E_=n(sn);Ou=s(E_,"default"),E_.forEach(o),xu=s(Pp,", "),rn=a(Pp,"CODE",{});var $_=n(rn);ju=s($_,"default-with-past"),$_.forEach(o),Pp.forEach(o),Tu=d(qp),pn=a(qp,"TD",{});var b_=n(pn);cn=a(b_,"CODE",{});var w_=n(cn);Au=s(w_,"AutoModel"),w_.forEach(o),b_.forEach(o),qp.forEach(o),qu=d(U),Jt=a(U,"TR",{});var yp=n(Jt);dn=a(yp,"TD",{});var k_=n(dn);un=a(k_,"CODE",{});var N_=n(un);Pu=s(N_,"masked-lm"),N_.forEach(o),k_.forEach(o),yu=d(yp),fn=a(yp,"TD",{});var O_=n(fn);mn=a(O_,"CODE",{});var x_=n(mn);Cu=s(x_,"AutoModelForMaskedLM"),x_.forEach(o),O_.forEach(o),yp.forEach(o),Du=d(U),Yt=a(U,"TR",{});var Cp=n(Yt);hn=a(Cp,"TD",{});var j_=n(hn);vn=a(j_,"CODE",{});var T_=n(vn);Su=s(T_,"question-answering"),T_.forEach(o),j_.forEach(o),Iu=d(Cp),gn=a(Cp,"TD",{});var A_=n(gn);_n=a(A_,"CODE",{});var q_=n(_n);Lu=s(q_,"AutoModelForQuestionAnswering"),q_.forEach(o),A_.forEach(o),Cp.forEach(o),Bu=d(U),Zt=a(U,"TR",{});var Dp=n(Zt);eo=a(Dp,"TD",{});var Sp=n(eo);zn=a(Sp,"CODE",{});var P_=n(zn);Mu=s(P_,"seq2seq-lm"),P_.forEach(o),Xu=s(Sp,", "),En=a(Sp,"CODE",{});var y_=n(En);Ru=s(y_,"seq2seq-lm-with-past"),y_.forEach(o),Sp.forEach(o),Fu=d(Dp),$n=a(Dp,"TD",{});var C_=n($n);bn=a(C_,"CODE",{});var D_=n(bn);Qu=s(D_,"AutoModelForSeq2SeqLM"),D_.forEach(o),C_.forEach(o),Dp.forEach(o),Hu=d(U),to=a(U,"TR",{});var Ip=n(to);wn=a(Ip,"TD",{});var S_=n(wn);kn=a(S_,"CODE",{});var I_=n(kn);Uu=s(I_,"sequence-classification"),I_.forEach(o),S_.forEach(o),Wu=d(Ip),Nn=a(Ip,"TD",{});var L_=n(Nn);On=a(L_,"CODE",{});var B_=n(On);Gu=s(B_,"AutoModelForSequenceClassification"),B_.forEach(o),L_.forEach(o),Ip.forEach(o),Ku=d(U),oo=a(U,"TR",{});var Lp=n(oo);xn=a(Lp,"TD",{});var M_=n(xn);jn=a(M_,"CODE",{});var X_=n(jn);Vu=s(X_,"token-classification"),X_.forEach(o),M_.forEach(o),Ju=d(Lp),Tn=a(Lp,"TD",{});var R_=n(Tn);An=a(R_,"CODE",{});var F_=n(An);Yu=s(F_,"AutoModelForTokenClassification"),F_.forEach(o),R_.forEach(o),Lp.forEach(o),U.forEach(o),xp.forEach(o),Ds=d(e),Je=a(e,"P",{});var Bp=n(Je);Zu=s(Bp,`Per ciascuna configurazione, puoi trovare l\u2019elenco delle funzionalit\xE0 supportate tramite il
`),qn=a(Bp,"CODE",{});var Q_=n(qn);ef=s(Q_,"FeaturesManager"),Q_.forEach(o),tf=s(Bp,". Ad esempio, per DistilBERT abbiamo:"),Bp.forEach(o),Ss=d(e),z(io.$$.fragment,e),Is=d(e),se=a(e,"P",{});var Ui=n(se);of=s(Ui,"Puoi quindi passare una di queste funzionalit\xE0 all\u2019argomento "),Pn=a(Ui,"CODE",{});var H_=n(Pn);af=s(H_,"--feature"),H_.forEach(o),nf=s(Ui,` nel
pacchetto `),yn=a(Ui,"CODE",{});var U_=n(yn);lf=s(U_,"transformers.onnx"),U_.forEach(o),sf=s(Ui,`. Ad esempio, per esportare un modello di classificazione del testo
possiamo scegliere un modello ottimizzato dall\u2019Hub ed eseguire:`),Ui.forEach(o),Ls=d(e),z(ao.$$.fragment,e),Bs=d(e),ui=a(e,"P",{});var W_=n(ui);rf=s(W_,"che visualizzer\xE0 i seguenti registri:"),W_.forEach(o),Ms=d(e),z(no.$$.fragment,e),Xs=d(e),Y=a(e,"P",{});var jt=n(Y);pf=s(jt,`Puoi notare che in questo caso, i nomi di output del modello ottimizzato sono
`),Cn=a(jt,"CODE",{});var G_=n(Cn);cf=s(G_,"logits"),G_.forEach(o),df=s(jt," invece di "),Dn=a(jt,"CODE",{});var K_=n(Dn);uf=s(K_,"last_hidden_state"),K_.forEach(o),ff=s(jt,` che abbiamo visto con il
checkpoint `),Sn=a(jt,"CODE",{});var V_=n(Sn);mf=s(V_,"distilbert-base-uncased"),V_.forEach(o),hf=s(jt,` precedente. Questo \xE8 previsto dal
modello ottimizato visto che ha una testa di e.`),jt.forEach(o),Rs=d(e),z(Ye.$$.fragment,e),Fs=d(e),be=a(e,"H3",{class:!0});var Mp=n(be);Ze=a(Mp,"A",{id:!0,class:!0,href:!0});var J_=n(Ze);In=a(J_,"SPAN",{});var Y_=n(In);z(lo.$$.fragment,Y_),Y_.forEach(o),J_.forEach(o),vf=d(Mp),Ln=a(Mp,"SPAN",{});var Z_=n(Ln);gf=s(Z_,"Esportazione di un modello per un'architettura non supportata"),Z_.forEach(o),Mp.forEach(o),Qs=d(e),fi=a(e,"P",{});var ez=n(fi);_f=s(ez,`Se desideri esportare un modello la cui architettura non \xE8 nativamente supportata dalla
libreria, ci sono tre passaggi principali da seguire:`),ez.forEach(o),Hs=d(e),re=a(e,"OL",{});var Wi=n(re);Bn=a(Wi,"LI",{});var tz=n(Bn);zf=s(tz,"Implementare una configurazione ONNX personalizzata."),tz.forEach(o),Ef=d(Wi),Mn=a(Wi,"LI",{});var oz=n(Mn);$f=s(oz,"Esportare il modello in ONNX."),oz.forEach(o),bf=d(Wi),Xn=a(Wi,"LI",{});var iz=n(Xn);wf=s(iz,"Convalidare gli output di PyTorch e dei modelli esportati."),iz.forEach(o),Wi.forEach(o),Us=d(e),mi=a(e,"P",{});var az=n(mi);kf=s(az,`In questa sezione, vedremo come DistilBERT \xE8 stato implementato per mostrare cosa \xE8
coinvolto in ogni passaggio.`),az.forEach(o),Ws=d(e),we=a(e,"H4",{class:!0});var Xp=n(we);et=a(Xp,"A",{id:!0,class:!0,href:!0});var nz=n(et);Rn=a(nz,"SPAN",{});var lz=n(Rn);z(so.$$.fragment,lz),lz.forEach(o),nz.forEach(o),Nf=d(Xp),Fn=a(Xp,"SPAN",{});var sz=n(Fn);Of=s(sz,"Implementazione di una configurazione ONNX personalizzata"),sz.forEach(o),Xp.forEach(o),Gs=d(e),hi=a(e,"P",{});var rz=n(hi);xf=s(rz,`Iniziamo con l\u2019oggetto di configurazione ONNX. Forniamo tre classi
astratte da cui ereditare, a seconda del tipo di archittettura
del modello che desideri esportare:`),rz.forEach(o),Ks=d(e),pe=a(e,"UL",{});var Gi=n(pe);vi=a(Gi,"LI",{});var Kv=n(vi);jf=s(Kv,"I modelli basati su encoder ereditano da "),Qn=a(Kv,"CODE",{});var pz=n(Qn);Tf=s(pz,"OnnxConfig"),pz.forEach(o),Kv.forEach(o),Af=d(Gi),gi=a(Gi,"LI",{});var Vv=n(gi);qf=s(Vv,"I modelli basati su decoder ereditano da "),Hn=a(Vv,"CODE",{});var cz=n(Hn);Pf=s(cz,"OnnxConfigWithPast"),cz.forEach(o),Vv.forEach(o),yf=d(Gi),_i=a(Gi,"LI",{});var Jv=n(_i);Cf=s(Jv,"I modelli encoder-decoder ereditano da"),Un=a(Jv,"CODE",{});var dz=n(Un);Df=s(dz,"OnnxSeq2SeqConfigWithPast"),dz.forEach(o),Jv.forEach(o),Gi.forEach(o),Vs=d(e),z(tt.$$.fragment,e),Js=d(e),ot=a(e,"P",{});var Rp=n(ot);Sf=s(Rp,`Poich\xE9 DistilBERT \xE8 un modello basato su encoder, la sua configurazione eredita da
`),Wn=a(Rp,"CODE",{});var uz=n(Wn);If=s(uz,"OnnxConfig"),uz.forEach(o),Lf=s(Rp,":"),Rp.forEach(o),Ys=d(e),z(ro.$$.fragment,e),Zs=d(e),H=a(e,"P",{});var ve=n(H);Bf=s(ve,"Ogni oggetto di configurazione deve implementare la propriet\xE0 "),Gn=a(ve,"CODE",{});var fz=n(Gn);Mf=s(fz,"inputs"),fz.forEach(o),Xf=s(ve,` e restituire una
mappatura, dove ogni chiave corrisponde a un input previsto e ogni valore
indica l\u2019asse di quell\u2019input. Per DistilBERT, possiamo vedere che sono richiesti
due input: `),Kn=a(ve,"CODE",{});var mz=n(Kn);Rf=s(mz,"input_ids"),mz.forEach(o),Ff=s(ve," e "),Vn=a(ve,"CODE",{});var hz=n(Vn);Qf=s(hz,"attention_mask"),hz.forEach(o),Hf=s(ve,`. Questi inputs hanno la stessa forma di
`),Jn=a(ve,"CODE",{});var vz=n(Jn);Uf=s(vz,"(batch_size, sequence_length)"),vz.forEach(o),Wf=s(ve,` per questo motivo vediamo gli stessi assi usati nella
configurazione.`),ve.forEach(o),er=d(e),z(it.$$.fragment,e),tr=d(e),zi=a(e,"P",{});var gz=n(zi);Gf=s(gz,`Dopo aver implementato una configurazione ONNX, \xE8 possibile istanziarla
fornendo alla configurazione del modello base come segue:`),gz.forEach(o),or=d(e),z(po.$$.fragment,e),ir=d(e),Ei=a(e,"P",{});var _z=n(Ei);Kf=s(_z,`L\u2019oggetto risultante ha diverse propriet\xE0 utili. Ad esempio \xE8 possibile visualizzare il
Set operatore ONNX che verr\xE0 utilizzato durante l\u2019esportazione:`),_z.forEach(o),ar=d(e),z(co.$$.fragment,e),nr=d(e),$i=a(e,"P",{});var zz=n($i);Vf=s(zz,"\xC8 inoltre possibile visualizzare gli output associati al modello come segue:"),zz.forEach(o),lr=d(e),z(uo.$$.fragment,e),sr=d(e),Z=a(e,"P",{});var Tt=n(Z);Jf=s(Tt,`Puoi notare che la propriet\xE0 degli output segue la stessa struttura degli input; esso
restituisce un `),Yn=a(Tt,"CODE",{});var Ez=n(Yn);Yf=s(Ez,"OrderedDict"),Ez.forEach(o),Zf=s(Tt,` di output con nome e le loro forme. La struttura di output
\xE8 legato alla scelta della funzione con cui viene inizializzata la configurazione.
Per impostazione predefinita, la configurazione ONNX viene inizializzata con la funzione \u2018predefinita\u2019
che corrisponde all\u2019esportazione di un modello caricato con la classe `),Zn=a(Tt,"CODE",{});var $z=n(Zn);em=s($z,"AutoModel"),$z.forEach(o),tm=s(Tt,`. Se tu
desideri esportare una topologia di modello diversa, \xE8 sufficiente fornire una funzionalit\xE0 diversa a
l\u2019argomento `),el=a(Tt,"CODE",{});var bz=n(el);om=s(bz,"task"),bz.forEach(o),im=s(Tt,` quando inizializzi la configurazione ONNX. Ad esempio, se
volevamo esportare DistilBERT con una testa di classificazione per sequenze, potremmo
usare:`),Tt.forEach(o),rr=d(e),z(fo.$$.fragment,e),pr=d(e),z(at.$$.fragment,e),cr=d(e),ke=a(e,"H4",{class:!0});var Fp=n(ke);nt=a(Fp,"A",{id:!0,class:!0,href:!0});var wz=n(nt);tl=a(wz,"SPAN",{});var kz=n(tl);z(mo.$$.fragment,kz),kz.forEach(o),wz.forEach(o),am=d(Fp),ol=a(Fp,"SPAN",{});var Nz=n(ol);nm=s(Nz,"Esportazione del modello"),Nz.forEach(o),Fp.forEach(o),dr=d(e),ce=a(e,"P",{});var Ki=n(ce);lm=s(Ki,`Una volta implementata la configurazione ONNX, il passaggio successivo consiste nell\u2019esportare il
modello. Qui possiamo usare la funzione `),il=a(Ki,"CODE",{});var Oz=n(il);sm=s(Oz,"export()"),Oz.forEach(o),rm=s(Ki,` fornita dal
pacchetto `),al=a(Ki,"CODE",{});var xz=n(al);pm=s(xz,"transformers.onnx"),xz.forEach(o),cm=s(Ki,`. Questa funzione prevede la configurazione ONNX, insieme
con il modello base e il tokenizer e il percorso per salvare il file esportato:`),Ki.forEach(o),ur=d(e),z(ho.$$.fragment,e),fr=d(e),R=a(e,"P",{});var oe=n(R);dm=s(oe,"Gli "),nl=a(oe,"CODE",{});var jz=n(nl);um=s(jz,"onnx_inputs"),jz.forEach(o),fm=s(oe," e "),ll=a(oe,"CODE",{});var Tz=n(ll);mm=s(Tz,"onnx_outputs"),Tz.forEach(o),hm=s(oe," restituiti dalla funzione "),sl=a(oe,"CODE",{});var Az=n(sl);vm=s(Az,"export()"),Az.forEach(o),gm=s(oe,` sono
liste di chiavi definite nelle propriet\xE0 di `),rl=a(oe,"CODE",{});var qz=n(rl);_m=s(qz,"input"),qz.forEach(o),zm=s(oe," e "),pl=a(oe,"CODE",{});var Pz=n(pl);Em=s(Pz,"output"),Pz.forEach(o),$m=s(oe,` della
configurazione. Una volta esportato il modello, puoi verificare che il modello sia ben
formato come segue:`),oe.forEach(o),mr=d(e),z(vo.$$.fragment,e),hr=d(e),z(lt.$$.fragment,e),vr=d(e),Ne=a(e,"H4",{class:!0});var Qp=n(Ne);st=a(Qp,"A",{id:!0,class:!0,href:!0});var yz=n(st);cl=a(yz,"SPAN",{});var Cz=n(cl);z(go.$$.fragment,Cz),Cz.forEach(o),yz.forEach(o),bm=d(Qp),dl=a(Qp,"SPAN",{});var Dz=n(dl);wm=s(Dz,"Convalida degli output del modello"),Dz.forEach(o),Qp.forEach(o),gr=d(e),de=a(e,"P",{});var Vi=n(de);km=s(Vi,`Il passaggio finale consiste nel convalidare gli output dal modello di base e quello esportato
corrispondere entro una soglia di tolleranza assoluta. Qui possiamo usare la
Funzione `),ul=a(Vi,"CODE",{});var Sz=n(ul);Nm=s(Sz,"validate_model_outputs()"),Sz.forEach(o),Om=s(Vi," fornita dal pacchetto "),fl=a(Vi,"CODE",{});var Iz=n(fl);xm=s(Iz,"transformers.onnx"),Iz.forEach(o),jm=s(Vi,`
come segue:`),Vi.forEach(o),_r=d(e),z(_o.$$.fragment,e),zr=d(e),rt=a(e,"P",{});var Hp=n(rt);Tm=s(Hp,"Questa funzione usa il metodo "),ml=a(Hp,"CODE",{});var Lz=n(ml);Am=s(Lz,"OnnxConfig.generate_dummy_inputs()"),Lz.forEach(o),qm=s(Hp,` per generare
input per il modello di base e quello esportato e la tolleranza assoluta pu\xF2 essere
definita nella configurazione. Generalmente troviamo una corrispondenza numerica nell\u2019intervallo da 1e-6
a 1e-4, anche se \xE8 probabile che qualsiasi cosa inferiore a 1e-3 vada bene.`),Hp.forEach(o),Er=d(e),Oe=a(e,"H3",{class:!0});var Up=n(Oe);pt=a(Up,"A",{id:!0,class:!0,href:!0});var Bz=n(pt);hl=a(Bz,"SPAN",{});var Mz=n(hl);z(zo.$$.fragment,Mz),Mz.forEach(o),Bz.forEach(o),Pm=d(Up),vl=a(Up,"SPAN",{});var Xz=n(vl);ym=s(Xz,"Contribuire con una nuova configurazione a \u{1F917} Transformers"),Xz.forEach(o),Up.forEach(o),$r=d(e),bi=a(e,"P",{});var Rz=n(bi);Cm=s(Rz,`Stiamo cercando di espandere l\u2019insieme di configurazioni gi\xE0 pronte e di accettare
contributi della community! Se vuoi contribuire con la tua aggiunta
nella libreria, dovrai:`),Rz.forEach(o),br=d(e),ue=a(e,"UL",{});var Ji=n(ue);wi=a(Ji,"LI",{});var Yv=n(wi);Dm=s(Yv,"Implementare la configurazione ONNX nella corrispondente "),gl=a(Yv,"CODE",{});var Fz=n(gl);Sm=s(Fz,"configuration file _<model_name>.py"),Fz.forEach(o),Yv.forEach(o),Im=d(Ji),ki=a(Ji,"LI",{});var Zv=n(ki);Lm=s(Zv,"Includere l\u2019architettura del modello e le funzioni corrispondenti in "),_l=a(Zv,"CODE",{});var Qz=n(_l);Bm=s(Qz,"FeatureManager"),Qz.forEach(o),Zv.forEach(o),Mm=d(Ji),Ni=a(Ji,"LI",{});var eg=n(Ni);Xm=s(eg,"Aggiungere la tua architettura del modello ai test in "),zl=a(eg,"CODE",{});var Hz=n(zl);Rm=s(Hz,"test_onnx_v2.py"),Hz.forEach(o),eg.forEach(o),Ji.forEach(o),wr=d(e),ct=a(e,"P",{});var Wp=n(ct);Fm=s(Wp,`Scopri come stato contribuito la configurazione per [IBERT]
(`),Eo=a(Wp,"A",{href:!0,rel:!0});var Uz=n(Eo);Qm=s(Uz,"https://github.com/huggingface/transformers/pull/14868/files"),Uz.forEach(o),Hm=s(Wp,`) per
avere un\u2019idea di cosa \xE8 coinvolto.`),Wp.forEach(o),kr=d(e),xe=a(e,"H2",{class:!0});var Gp=n(xe);dt=a(Gp,"A",{id:!0,class:!0,href:!0});var Wz=n(dt);El=a(Wz,"SPAN",{});var Gz=n(El);z($o.$$.fragment,Gz),Gz.forEach(o),Wz.forEach(o),Um=d(Gp),$l=a(Gp,"SPAN",{});var Kz=n($l);Wm=s(Kz,"TorchScript"),Kz.forEach(o),Gp.forEach(o),Nr=d(e),z(ut.$$.fragment,e),Or=d(e),ft=a(e,"P",{});var Kp=n(ft);Gm=s(Kp,`Secondo la documentazione di Pytorch: \u201CTorchScript \xE8 un modo per creare modelli serializzabili e ottimizzabili da codice
Pytorch\u201D. I due moduli di Pytorch `),bo=a(Kp,"A",{href:!0,rel:!0});var Vz=n(bo);Km=s(Vz,"JIT e TRACE"),Vz.forEach(o),Vm=s(Kp,` consentono allo sviluppatore di esportare
il loro modello da riutilizzare in altri programmi, come i programmi C++ orientati all\u2019efficienza.`),Kp.forEach(o),xr=d(e),Oi=a(e,"P",{});var Jz=n(Oi);Jm=s(Jz,`Abbiamo fornito un\u2019interfaccia che consente l\u2019esportazione di modelli \u{1F917} Transformers in TorchScript in modo che possano essere riutilizzati
in un ambiente diverso rispetto a un programma Python basato su Pytorch. Qui spieghiamo come esportare e utilizzare i nostri modelli utilizzando
TorchScript.`),Jz.forEach(o),jr=d(e),xi=a(e,"P",{});var Yz=n(xi);Ym=s(Yz,"Esportare un modello richiede due cose:"),Yz.forEach(o),Tr=d(e),mt=a(e,"UL",{});var Vp=n(mt);bl=a(Vp,"LI",{});var Zz=n(bl);Zm=s(Zz,"Un passaggio in avanti con input fittizzi."),Zz.forEach(o),eh=d(Vp),wo=a(Vp,"LI",{});var Jp=n(wo);th=s(Jp,"Istanziazione del modello con flag "),wl=a(Jp,"CODE",{});var e1=n(wl);oh=s(e1,"torchscript"),e1.forEach(o),ih=s(Jp,"."),Jp.forEach(o),Vp.forEach(o),Ar=d(e),ji=a(e,"P",{});var t1=n(ji);ah=s(t1,"Queste necessit\xE0 implicano diverse cose a cui gli sviluppatori dovrebbero prestare attenzione. Questi dettagli mostrati sotto."),t1.forEach(o),qr=d(e),je=a(e,"H3",{class:!0});var Yp=n(je);ht=a(Yp,"A",{id:!0,class:!0,href:!0});var o1=n(ht);kl=a(o1,"SPAN",{});var i1=n(kl);z(ko.$$.fragment,i1),i1.forEach(o),o1.forEach(o),nh=d(Yp),Nl=a(Yp,"SPAN",{});var a1=n(Nl);lh=s(a1,"Flag TorchScript e pesi legati"),a1.forEach(o),Yp.forEach(o),Pr=d(e),Ti=a(e,"P",{});var n1=n(Ti);sh=s(n1,`Questo flag \xE8 necessario perch\xE9 la maggior parte dei modelli linguistici in questo repository hanno pesi legati tra il loro
strato \u201CEmbedding\u201D e lo strato \u201CDecoding\u201D. TorchScript non consente l\u2019esportazione di modelli che hanno pesi
legati, quindi \xE8 necessario prima slegare e clonare i pesi.`),n1.forEach(o),yr=d(e),ee=a(e,"P",{});var At=n(ee);rh=s(At,"Ci\xF2 implica che i modelli istanziati con il flag "),Ol=a(At,"CODE",{});var l1=n(Ol);ph=s(l1,"torchscript"),l1.forEach(o),ch=s(At," hanno il loro strato "),xl=a(At,"CODE",{});var s1=n(xl);dh=s(s1,"Embedding"),s1.forEach(o),uh=s(At," e strato "),jl=a(At,"CODE",{});var r1=n(jl);fh=s(r1,"Decoding"),r1.forEach(o),mh=s(At,`
separato, il che significa che non dovrebbero essere addestrati in futuro. L\u2019allenamento de-sincronizza i due
strati, portando a risultati inaspettati.`),At.forEach(o),Cr=d(e),vt=a(e,"P",{});var Zp=n(vt);hh=s(Zp,`Questo non \xE8 il caso per i modelli che non hanno una testa del modello linguistico, poich\xE9 quelli non hanno pesi legati. Questi modelli
pu\xF2 essere esportato in sicurezza senza il flag `),Tl=a(Zp,"CODE",{});var p1=n(Tl);vh=s(p1,"torchscript"),p1.forEach(o),gh=s(Zp,"."),Zp.forEach(o),Dr=d(e),Te=a(e,"H3",{class:!0});var ec=n(Te);gt=a(ec,"A",{id:!0,class:!0,href:!0});var c1=n(gt);Al=a(c1,"SPAN",{});var d1=n(Al);z(No.$$.fragment,d1),d1.forEach(o),c1.forEach(o),_h=d(ec),ql=a(ec,"SPAN",{});var u1=n(ql);zh=s(u1,"Input fittizi e standard lengths"),u1.forEach(o),ec.forEach(o),Sr=d(e),Ai=a(e,"P",{});var f1=n(Ai);Eh=s(f1,`Gli input fittizzi sono usati per fare un modello passaggio in avanti . Mentre i valori degli input si propagano attraverso i strati,
Pytorch tiene traccia delle diverse operazioni eseguite su ciascun tensore. Queste operazioni registrate vengono quindi utilizzate per
creare la \u201Ctraccia\u201D del modello.`),f1.forEach(o),Ir=d(e),qi=a(e,"P",{});var m1=n(qi);$h=s(m1,`La traccia viene creata relativamente alle dimensioni degli input. \xC8 quindi vincolato dalle dimensioni dell\u2019input
fittizio e non funzioner\xE0 per altre lunghezze di sequenza o dimensioni batch. Quando si prover\xE0 con una dimensione diversa, ci sar\xE0 errore
come:`),m1.forEach(o),Lr=d(e),Pi=a(e,"P",{});var h1=n(Pi);Pl=a(h1,"CODE",{});var v1=n(Pl);bh=s(v1,"La dimensione espansa del tensore (3) deve corrispondere alla dimensione esistente (7) nella dimensione non singleton 2"),v1.forEach(o),h1.forEach(o),Br=d(e),yi=a(e,"P",{});var g1=n(yi);wh=s(g1,`will be raised. Si consiglia pertanto di tracciare il modello con una dimensione di input fittizia grande almeno quanto il pi\xF9 grande
input che verr\xE0 fornito al modello durante l\u2019inferenza. \xC8 possibile eseguire il padding per riempire i valori mancanti. Il modello
sar\xE0 tracciato con una grande dimensione di input, tuttavia, anche le dimensioni della diverse matrici saranno grandi,
risultando in pi\xF9 calcoli.`),g1.forEach(o),Mr=d(e),Ci=a(e,"P",{});var _1=n(Ci);kh=s(_1,`Si raccomanda di prestare attenzione al numero totale di operazioni eseguite su ciascun input e di seguire da vicino le prestazioni
durante l\u2019esportazione di modelli di sequenza-lunghezza variabili.`),_1.forEach(o),Xr=d(e),Ae=a(e,"H3",{class:!0});var tc=n(Ae);_t=a(tc,"A",{id:!0,class:!0,href:!0});var z1=n(_t);yl=a(z1,"SPAN",{});var E1=n(yl);z(Oo.$$.fragment,E1),E1.forEach(o),z1.forEach(o),Nh=d(tc),Cl=a(tc,"SPAN",{});var $1=n(Cl);Oh=s($1,"Usare TorchSscript in Python"),$1.forEach(o),tc.forEach(o),Rr=d(e),Di=a(e,"P",{});var b1=n(Di);xh=s(b1,"Di seguito \xE8 riportato un esempio, che mostra come salvare, caricare modelli e come utilizzare la traccia per l\u2019inferenza."),b1.forEach(o),Fr=d(e),qe=a(e,"H4",{class:!0});var oc=n(qe);zt=a(oc,"A",{id:!0,class:!0,href:!0});var w1=n(zt);Dl=a(w1,"SPAN",{});var k1=n(Dl);z(xo.$$.fragment,k1),k1.forEach(o),w1.forEach(o),jh=d(oc),Sl=a(oc,"SPAN",{});var N1=n(Sl);Th=s(N1,"Salvare un modello"),N1.forEach(o),oc.forEach(o),Qr=d(e),V=a(e,"P",{});var Be=n(V);Ah=s(Be,"Questo frammento di codice mostra come usare TorchScript per esportare un "),Il=a(Be,"CODE",{});var O1=n(Il);qh=s(O1,"BertModel"),O1.forEach(o),Ph=s(Be,". Qui il "),Ll=a(Be,"CODE",{});var x1=n(Ll);yh=s(x1,"BertModel"),x1.forEach(o),Ch=s(Be,` \xE8 istanziato secondo
una classe `),Bl=a(Be,"CODE",{});var j1=n(Bl);Dh=s(j1,"BertConfig"),j1.forEach(o),Sh=s(Be," e quindi salvato su disco con il nome del file "),Ml=a(Be,"CODE",{});var T1=n(Ml);Ih=s(T1,"traced_bert.pt"),T1.forEach(o),Be.forEach(o),Hr=d(e),z(jo.$$.fragment,e),Ur=d(e),Pe=a(e,"H4",{class:!0});var ic=n(Pe);Et=a(ic,"A",{id:!0,class:!0,href:!0});var A1=n(Et);Xl=a(A1,"SPAN",{});var q1=n(Xl);z(To.$$.fragment,q1),q1.forEach(o),A1.forEach(o),Lh=d(ic),Rl=a(ic,"SPAN",{});var P1=n(Rl);Bh=s(P1,"Caricare un modello"),P1.forEach(o),ic.forEach(o),Wr=d(e),te=a(e,"P",{});var qt=n(te);Mh=s(qt,"Questo frammento di codice mostra come caricare il "),Fl=a(qt,"CODE",{});var y1=n(Fl);Xh=s(y1,"BertModel"),y1.forEach(o),Rh=s(qt," che era stato precedentemente salvato su disco con il nome "),Ql=a(qt,"CODE",{});var C1=n(Ql);Fh=s(C1,"traced_bert.pt"),C1.forEach(o),Qh=s(qt,`.
Stiamo riutilizzando il `),Hl=a(qt,"CODE",{});var D1=n(Hl);Hh=s(D1,"dummy_input"),D1.forEach(o),Uh=s(qt," precedentemente inizializzato."),qt.forEach(o),Gr=d(e),z(Ao.$$.fragment,e),Kr=d(e),ye=a(e,"H4",{class:!0});var ac=n(ye);$t=a(ac,"A",{id:!0,class:!0,href:!0});var S1=n($t);Ul=a(S1,"SPAN",{});var I1=n(Ul);z(qo.$$.fragment,I1),I1.forEach(o),S1.forEach(o),Wh=d(ac),Wl=a(ac,"SPAN",{});var L1=n(Wl);Gh=s(L1,"Utilizzare un modello tracciato per l'inferenza"),L1.forEach(o),ac.forEach(o),Vr=d(e),bt=a(e,"P",{});var nc=n(bt);Kh=s(nc,"Usare il modello tracciato per l\u2019inferenza \xE8 semplice come usare il suo metodo dunder "),Gl=a(nc,"CODE",{});var B1=n(Gl);Vh=s(B1,"__call__"),B1.forEach(o),Jh=s(nc,":"),nc.forEach(o),Jr=d(e),z(Po.$$.fragment,e),Yr=d(e),Si=a(e,"P",{});var M1=n(Si);Yh=s(M1,"###Implementare modelli HuggingFace TorchScript su AWS utilizzando Neuron SDK"),M1.forEach(o),Zr=d(e),fe=a(e,"P",{});var Yi=n(fe);Zh=s(Yi,"AWS ha introdotto "),yo=a(Yi,"A",{href:!0,rel:!0});var X1=n(yo);ev=s(X1,"Amazon EC2 Inf1"),X1.forEach(o),tv=s(Yi,`
famiglia di istanze per l\u2019inferenza di machine learning a basso costo e ad alte prestazioni nel cloud.
Le istanze Inf1 sono alimentate dal chip AWS Inferentia, un acceleratore hardware personalizzato,
specializzato in carichi di lavoro di inferenza di deep learning.
`),Co=a(Yi,"A",{href:!0,rel:!0});var R1=n(Co);ov=s(R1,"AWS Neuron"),R1.forEach(o),iv=s(Yi,`
\xE8 l\u2019SDK per Inferentia che supporta il tracciamento e l\u2019ottimizzazione dei modelli transformers per
distribuzione su Inf1. L\u2019SDK Neuron fornisce:`),Yi.forEach(o),ep=d(e),me=a(e,"OL",{});var Zi=n(me);Kl=a(Zi,"LI",{});var F1=n(Kl);av=s(F1,"API di facile utilizzo con una riga di modifica del codice per tracciare e ottimizzare un modello TorchScript per l\u2019inferenza nel cloud."),F1.forEach(o),nv=d(Zi),Ii=a(Zi,"LI",{});var tg=n(Ii);lv=s(tg,"Ottimizzazioni delle prestazioni pronte all\u2019uso per "),Do=a(tg,"A",{href:!0,rel:!0});var Q1=n(Do);sv=s(Q1,"miglioramento dei costi-prestazioni"),Q1.forEach(o),tg.forEach(o),rv=d(Zi),Ce=a(Zi,"LI",{});var ea=n(Ce);pv=s(ea,"Supporto per i modelli di trasformatori HuggingFace costruiti con "),So=a(ea,"A",{href:!0,rel:!0});var H1=n(So);cv=s(H1,"PyTorch"),H1.forEach(o),dv=s(ea,`
o `),Io=a(ea,"A",{href:!0,rel:!0});var U1=n(Io);uv=s(U1,"TensorFlow"),U1.forEach(o),fv=s(ea,"."),ea.forEach(o),Zi.forEach(o),tp=d(e),De=a(e,"H4",{class:!0});var lc=n(De);wt=a(lc,"A",{id:!0,class:!0,href:!0});var W1=n(wt);Vl=a(W1,"SPAN",{});var G1=n(Vl);z(Lo.$$.fragment,G1),G1.forEach(o),W1.forEach(o),mv=d(lc),Jl=a(lc,"SPAN",{});var K1=n(Jl);hv=s(K1,"Implicazioni"),K1.forEach(o),lc.forEach(o),op=d(e),F=a(e,"P",{});var ie=n(F);vv=s(ie,"Modelli Transformers basati su architettura "),Bo=a(ie,"A",{href:!0,rel:!0});var V1=n(Bo);gv=s(V1,"BERT (Bidirectional Encoder Representations from Transformers)"),V1.forEach(o),_v=s(ie,`,
o sue varianti come `),Mo=a(ie,"A",{href:!0,rel:!0});var J1=n(Mo);zv=s(J1,"distilBERT"),J1.forEach(o),Ev=s(ie,`
e `),Xo=a(ie,"A",{href:!0,rel:!0});var Y1=n(Xo);$v=s(Y1,"roBERTa"),Y1.forEach(o),bv=s(ie,`
funzioneranno meglio su Inf1 per attivit\xE0 non generative come la question answering estrattive,
Classificazione della sequenza, Classificazione dei token. In alternativa, generazione di testo
le attivit\xE0 possono essere adattate per essere eseguite su Inf1, secondo questo `),Ro=a(ie,"A",{href:!0,rel:!0});var Z1=n(Ro);wv=s(Z1,"tutorial AWS Neuron MarianMT"),Z1.forEach(o),kv=s(ie,`.
Ulteriori informazioni sui modelli che possono essere convertiti fuori dagli schemi su Inferentia possono essere
trovati nella `),Fo=a(ie,"A",{href:!0,rel:!0});var eE=n(Fo);Nv=s(eE,"sezione Model Architecture Fit della documentazione Neuron"),eE.forEach(o),Ov=s(ie,"."),ie.forEach(o),ip=d(e),Se=a(e,"H4",{class:!0});var sc=n(Se);kt=a(sc,"A",{id:!0,class:!0,href:!0});var tE=n(kt);Yl=a(tE,"SPAN",{});var oE=n(Yl);z(Qo.$$.fragment,oE),oE.forEach(o),tE.forEach(o),xv=d(sc),Zl=a(sc,"SPAN",{});var iE=n(Zl);jv=s(iE,"Dipendenze"),iE.forEach(o),sc.forEach(o),ap=d(e),Li=a(e,"P",{});var aE=n(Li);Tv=s(aE,"L\u2019utilizzo di AWS Neuron per convertire i modelli richiede le seguenti dipendenze e l\u2019ambiente:"),aE.forEach(o),np=d(e),Bi=a(e,"UL",{});var nE=n(Bi);Ie=a(nE,"LI",{});var ta=n(Ie);Av=s(ta,"A "),Ho=a(ta,"A",{href:!0,rel:!0});var lE=n(Ho);qv=s(lE,"Neuron SDK environment"),lE.forEach(o),Pv=s(ta,`,
which comes pre-configured on `),Uo=a(ta,"A",{href:!0,rel:!0});var sE=n(Uo);yv=s(sE,"AWS Deep Learning AMI"),sE.forEach(o),Cv=s(ta,"."),ta.forEach(o),nE.forEach(o),lp=d(e),Le=a(e,"H4",{class:!0});var rc=n(Le);Nt=a(rc,"A",{id:!0,class:!0,href:!0});var rE=n(Nt);es=a(rE,"SPAN",{});var pE=n(es);z(Wo.$$.fragment,pE),pE.forEach(o),rE.forEach(o),Dv=d(rc),ts=a(rc,"SPAN",{});var cE=n(ts);Sv=s(cE,"Convertire un modello per AWS Neuron"),cE.forEach(o),rc.forEach(o),sp=d(e),he=a(e,"P",{});var oa=n(he);Iv=s(oa,"Usando lo stesso script come in "),Go=a(oa,"A",{href:!0,rel:!0});var dE=n(Go);Lv=s(dE,"Usando TorchScipt in Python"),dE.forEach(o),Bv=s(oa,`
per tracciare un \u201CBertModel\u201D, importi l\u2019estensione del framework `),os=a(oa,"CODE",{});var uE=n(os);Mv=s(uE,"torch.neuron"),uE.forEach(o),Xv=s(oa,` per accedere
i componenti di Neuron SDK tramite un\u2019API Python.`),oa.forEach(o),rp=d(e),z(Ko.$$.fragment,e),pp=d(e),Mi=a(e,"P",{});var fE=n(Mi);Rv=s(fE,"E modificare solo la riga di codice di traccia"),fE.forEach(o),cp=d(e),Xi=a(e,"P",{});var mE=n(Xi);Fv=s(mE,"Da:"),mE.forEach(o),dp=d(e),z(Vo.$$.fragment,e),up=d(e),Ri=a(e,"P",{});var hE=n(Ri);Qv=s(hE,"A:"),hE.forEach(o),fp=d(e),z(Jo.$$.fragment,e),mp=d(e),Fi=a(e,"P",{});var vE=n(Fi);Hv=s(vE,"Questa modifica consente a Neuron SDK di tracciare il modello e ottimizzarlo per l\u2019esecuzione nelle istanze Inf1."),vE.forEach(o),hp=d(e),Ot=a(e,"P",{});var pc=n(Ot);Uv=s(pc,`Per ulteriori informazioni sulle funzionalit\xE0, gli strumenti, i tutorial di esempi e gli ultimi aggiornamenti di AWS Neuron SDK,
consultare la `),Yo=a(pc,"A",{href:!0,rel:!0});var gE=n(Yo);Wv=s(gE,"documentazione AWS NeuronSDK"),gE.forEach(o),Gv=s(pc,"."),pc.forEach(o),this.h()},h(){u(f,"name","hf:doc:metadata"),u(f,"content",JSON.stringify(IE)),u(k,"id","esporta-modelli-transformers"),u(k,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),u(k,"href","#esporta-modelli-transformers"),u(m,"class","relative group"),u(B,"href","https://github.com/huggingface/optimum"),u(B,"rel","nofollow"),u(Q,"id","onnx"),u(Q,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),u(Q,"href","#onnx"),u(G,"class","relative group"),u(ne,"href","http://onnx.ai"),u(ne,"rel","nofollow"),u(Fe,"id","esportazione-di-un-modello-in-onnx"),u(Fe,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),u(Fe,"href","#esportazione-di-un-modello-in-onnx"),u(Ee,"class","relative group"),u(Bt,"href","https://onnx.ai/supported-tools.html#deployModel"),u(Bt,"rel","nofollow"),u(Mt,"href","https://onnxruntime.ai/"),u(Mt,"rel","nofollow"),u(Ft,"href","https://huggingface.co/keras-io"),u(Ft,"rel","nofollow"),u(Ge,"id","selezione-delle-caratteristiche-per-diverse-topologie-di-modello"),u(Ge,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),u(Ge,"href","#selezione-delle-caratteristiche-per-diverse-topologie-di-modello"),u($e,"class","relative group"),u(Ze,"id","esportazione-di-un-modello-per-unarchitettura-non-supportata"),u(Ze,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),u(Ze,"href","#esportazione-di-un-modello-per-unarchitettura-non-supportata"),u(be,"class","relative group"),u(et,"id","implementazione-di-una-configurazione-onnx-personalizzata"),u(et,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),u(et,"href","#implementazione-di-una-configurazione-onnx-personalizzata"),u(we,"class","relative group"),u(nt,"id","esportazione-del-modello"),u(nt,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),u(nt,"href","#esportazione-del-modello"),u(ke,"class","relative group"),u(st,"id","convalida-degli-output-del-modello"),u(st,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),u(st,"href","#convalida-degli-output-del-modello"),u(Ne,"class","relative group"),u(pt,"id","contribuire-con-una-nuova-configurazione-a-transformers"),u(pt,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),u(pt,"href","#contribuire-con-una-nuova-configurazione-a-transformers"),u(Oe,"class","relative group"),u(Eo,"href","https://github.com/huggingface/transformers/pull/14868/files"),u(Eo,"rel","nofollow"),u(dt,"id","torchscript"),u(dt,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),u(dt,"href","#torchscript"),u(xe,"class","relative group"),u(bo,"href","https://pytorch.org/docs/stable/jit.html"),u(bo,"rel","nofollow"),u(ht,"id","flag-torchscript-e-pesi-legati"),u(ht,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),u(ht,"href","#flag-torchscript-e-pesi-legati"),u(je,"class","relative group"),u(gt,"id","input-fittizi-e-standard-lengths"),u(gt,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),u(gt,"href","#input-fittizi-e-standard-lengths"),u(Te,"class","relative group"),u(_t,"id","usare-torchsscript-in-python"),u(_t,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),u(_t,"href","#usare-torchsscript-in-python"),u(Ae,"class","relative group"),u(zt,"id","salvare-un-modello"),u(zt,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),u(zt,"href","#salvare-un-modello"),u(qe,"class","relative group"),u(Et,"id","caricare-un-modello"),u(Et,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),u(Et,"href","#caricare-un-modello"),u(Pe,"class","relative group"),u($t,"id","utilizzare-un-modello-tracciato-per-linferenza"),u($t,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),u($t,"href","#utilizzare-un-modello-tracciato-per-linferenza"),u(ye,"class","relative group"),u(yo,"href","https://aws.amazon.com/ec2/instance-types/inf1/"),u(yo,"rel","nofollow"),u(Co,"href","https://awsdocs-neuron.readthedocs-hosted.com/en/latest/#"),u(Co,"rel","nofollow"),u(Do,"href","https://awsdocs-neuron.readthedocs-hosted.com/en/latest/neuron-guide/benchmark/%3E"),u(Do,"rel","nofollow"),u(So,"href","https://awsdocs-neuron.readthedocs-hosted.com/en/latest/src/examples/pytorch/bert_tutorial/tutorial_pretrained_bert.html"),u(So,"rel","nofollow"),u(Io,"href","https://awsdocs-neuron.readthedocs-hosted.com/en/latest/src/examples/tensorflow/huggingface_bert/huggingface_bert.html"),u(Io,"rel","nofollow"),u(wt,"id","implicazioni"),u(wt,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),u(wt,"href","#implicazioni"),u(De,"class","relative group"),u(Bo,"href","https://huggingface.co/docs/transformers/main/model_doc/bert"),u(Bo,"rel","nofollow"),u(Mo,"href","https://huggingface.co/docs/transformers/main/model_doc/distilbert"),u(Mo,"rel","nofollow"),u(Xo,"href","https://huggingface.co/docs/transformers/main/model_doc/roberta"),u(Xo,"rel","nofollow"),u(Ro,"href","https://awsdocs-neuron.readthedocs-hosted.com/en/latest/src/examples/pytorch/transformers-marianmt.html"),u(Ro,"rel","nofollow"),u(Fo,"href","https://awsdocs-neuron.readthedocs-hosted.com/en/latest/neuron-guide/models/models-inferentia.html#models-inferentia"),u(Fo,"rel","nofollow"),u(kt,"id","dipendenze"),u(kt,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),u(kt,"href","#dipendenze"),u(Se,"class","relative group"),u(Ho,"href","https://awsdocs-neuron.readthedocs-hosted.com/en/latest/neuron-guide/neuron-frameworks/pytorch-neuron/index.html#installation-guide"),u(Ho,"rel","nofollow"),u(Uo,"href","https://docs.aws.amazon.com/dlami/latest/devguide/tutorial-inferentia-launching.html"),u(Uo,"rel","nofollow"),u(Nt,"id","convertire-un-modello-per-aws-neuron"),u(Nt,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),u(Nt,"href","#convertire-un-modello-per-aws-neuron"),u(Le,"class","relative group"),u(Go,"href","https://huggingface.co/docs/transformers/main/en/serialization#using-torchscript-in-python"),u(Go,"rel","nofollow"),u(Yo,"href","https://awsdocs-neuron.readthedocs-hosted.com/en/latest/index.html"),u(Yo,"rel","nofollow")},m(e,r){t(document.head,f),p(e,N,r),p(e,m,r),t(m,k),t(k,x),E(O,x,null),t(m,y),t(m,P),t(P,A),p(e,j,r),p(e,C,r),t(C,q),p(e,D,r),p(e,g,r),t(g,T),t(g,B),t(B,W),t(g,ge),p(e,Me,r),p(e,G,r),t(G,Q),t(Q,_e),E(ae,_e,null),t(G,ze),t(G,I),t(I,ti),p(e,Pt,r),p(e,K,r),t(K,oi),t(K,ne),t(ne,ii),t(K,ai),t(K,aa),t(aa,cc),t(K,dc),p(e,rs,r),p(e,ni,r),t(ni,uc),p(e,ps,r),p(e,Xe,r),t(Xe,fc),t(Xe,na),t(na,mc),t(Xe,hc),p(e,cs,r),p(e,li,r),t(li,vc),p(e,ds,r),p(e,h,r),t(h,la),t(la,gc),t(h,_c),t(h,sa),t(sa,zc),t(h,Ec),t(h,ra),t(ra,$c),t(h,bc),t(h,pa),t(pa,wc),t(h,kc),t(h,ca),t(ca,Nc),t(h,Oc),t(h,da),t(da,xc),t(h,jc),t(h,ua),t(ua,Tc),t(h,Ac),t(h,fa),t(fa,qc),t(h,Pc),t(h,ma),t(ma,yc),t(h,Cc),t(h,ha),t(ha,Dc),t(h,Sc),t(h,va),t(va,Ic),t(h,Lc),t(h,ga),t(ga,Bc),t(h,Mc),t(h,_a),t(_a,Xc),t(h,Rc),t(h,za),t(za,Fc),t(h,Qc),t(h,Ea),t(Ea,Hc),t(h,Uc),t(h,$a),t($a,Wc),t(h,Gc),t(h,ba),t(ba,Kc),t(h,Vc),t(h,wa),t(wa,Jc),t(h,Yc),t(h,ka),t(ka,Zc),t(h,ed),t(h,Na),t(Na,td),t(h,od),t(h,Oa),t(Oa,id),t(h,ad),t(h,xa),t(xa,nd),t(h,ld),t(h,ja),t(ja,sd),t(h,rd),t(h,Ta),t(Ta,pd),t(h,cd),t(h,Aa),t(Aa,dd),t(h,ud),t(h,qa),t(qa,fd),t(h,md),t(h,Pa),t(Pa,hd),t(h,vd),t(h,ya),t(ya,gd),t(h,_d),t(h,Ca),t(Ca,zd),t(h,Ed),t(h,Da),t(Da,$d),t(h,bd),t(h,Sa),t(Sa,wd),t(h,kd),t(h,Ia),t(Ia,Nd),t(h,Od),t(h,La),t(La,xd),t(h,jd),t(h,Ba),t(Ba,Td),t(h,Ad),t(h,Ma),t(Ma,qd),p(e,us,r),p(e,si,r),t(si,Pd),p(e,fs,r),p(e,Re,r),t(Re,yt),t(yt,yd),t(yt,Xa),t(Xa,Cd),t(yt,Dd),t(Re,Sd),t(Re,Ra),t(Ra,Id),p(e,ms,r),p(e,Ee,r),t(Ee,Fe),t(Fe,Fa),E(Ct,Fa,null),t(Ee,Ld),t(Ee,Qa),t(Qa,Bd),p(e,hs,r),p(e,ri,r),t(ri,Md),p(e,vs,r),E(Dt,e,r),p(e,gs,r),p(e,Qe,r),t(Qe,Xd),t(Qe,Ha),t(Ha,Rd),t(Qe,Fd),p(e,_s,r),E(St,e,r),p(e,zs,r),p(e,pi,r),t(pi,Qd),p(e,Es,r),E(It,e,r),p(e,$s,r),p(e,ci,r),t(ci,Hd),p(e,bs,r),E(Lt,e,r),p(e,ws,r),p(e,le,r),t(le,Ud),t(le,Ua),t(Ua,Wd),t(le,Gd),t(le,Wa),t(Wa,Kd),t(le,Vd),p(e,ks,r),p(e,J,r),t(J,Jd),t(J,Ga),t(Ga,Yd),t(J,Zd),t(J,Bt),t(Bt,eu),t(J,tu),t(J,Mt),t(Mt,ou),t(J,iu),p(e,Ns,r),E(Xt,e,r),p(e,Os,r),p(e,He,r),t(He,au),t(He,Ka),t(Ka,nu),t(He,lu),p(e,xs,r),E(Rt,e,r),p(e,js,r),p(e,Ue,r),t(Ue,su),t(Ue,Ft),t(Ft,ru),t(Ue,pu),p(e,Ts,r),E(Qt,e,r),p(e,As,r),p(e,di,r),t(di,cu),p(e,qs,r),E(We,e,r),p(e,Ps,r),p(e,$e,r),t($e,Ge),t(Ge,Va),E(Ht,Va,null),t($e,du),t($e,Ja),t(Ja,uu),p(e,ys,r),p(e,Ke,r),t(Ke,fu),t(Ke,Ya),t(Ya,mu),t(Ke,hu),p(e,Cs,r),p(e,Ve,r),t(Ve,Za),t(Za,Ut),t(Ut,en),t(en,vu),t(Ut,gu),t(Ut,tn),t(tn,_u),t(Ve,zu),t(Ve,X),t(X,Wt),t(Wt,Gt),t(Gt,on),t(on,Eu),t(Gt,$u),t(Gt,an),t(an,bu),t(Wt,wu),t(Wt,nn),t(nn,ln),t(ln,ku),t(X,Nu),t(X,Kt),t(Kt,Vt),t(Vt,sn),t(sn,Ou),t(Vt,xu),t(Vt,rn),t(rn,ju),t(Kt,Tu),t(Kt,pn),t(pn,cn),t(cn,Au),t(X,qu),t(X,Jt),t(Jt,dn),t(dn,un),t(un,Pu),t(Jt,yu),t(Jt,fn),t(fn,mn),t(mn,Cu),t(X,Du),t(X,Yt),t(Yt,hn),t(hn,vn),t(vn,Su),t(Yt,Iu),t(Yt,gn),t(gn,_n),t(_n,Lu),t(X,Bu),t(X,Zt),t(Zt,eo),t(eo,zn),t(zn,Mu),t(eo,Xu),t(eo,En),t(En,Ru),t(Zt,Fu),t(Zt,$n),t($n,bn),t(bn,Qu),t(X,Hu),t(X,to),t(to,wn),t(wn,kn),t(kn,Uu),t(to,Wu),t(to,Nn),t(Nn,On),t(On,Gu),t(X,Ku),t(X,oo),t(oo,xn),t(xn,jn),t(jn,Vu),t(oo,Ju),t(oo,Tn),t(Tn,An),t(An,Yu),p(e,Ds,r),p(e,Je,r),t(Je,Zu),t(Je,qn),t(qn,ef),t(Je,tf),p(e,Ss,r),E(io,e,r),p(e,Is,r),p(e,se,r),t(se,of),t(se,Pn),t(Pn,af),t(se,nf),t(se,yn),t(yn,lf),t(se,sf),p(e,Ls,r),E(ao,e,r),p(e,Bs,r),p(e,ui,r),t(ui,rf),p(e,Ms,r),E(no,e,r),p(e,Xs,r),p(e,Y,r),t(Y,pf),t(Y,Cn),t(Cn,cf),t(Y,df),t(Y,Dn),t(Dn,uf),t(Y,ff),t(Y,Sn),t(Sn,mf),t(Y,hf),p(e,Rs,r),E(Ye,e,r),p(e,Fs,r),p(e,be,r),t(be,Ze),t(Ze,In),E(lo,In,null),t(be,vf),t(be,Ln),t(Ln,gf),p(e,Qs,r),p(e,fi,r),t(fi,_f),p(e,Hs,r),p(e,re,r),t(re,Bn),t(Bn,zf),t(re,Ef),t(re,Mn),t(Mn,$f),t(re,bf),t(re,Xn),t(Xn,wf),p(e,Us,r),p(e,mi,r),t(mi,kf),p(e,Ws,r),p(e,we,r),t(we,et),t(et,Rn),E(so,Rn,null),t(we,Nf),t(we,Fn),t(Fn,Of),p(e,Gs,r),p(e,hi,r),t(hi,xf),p(e,Ks,r),p(e,pe,r),t(pe,vi),t(vi,jf),t(vi,Qn),t(Qn,Tf),t(pe,Af),t(pe,gi),t(gi,qf),t(gi,Hn),t(Hn,Pf),t(pe,yf),t(pe,_i),t(_i,Cf),t(_i,Un),t(Un,Df),p(e,Vs,r),E(tt,e,r),p(e,Js,r),p(e,ot,r),t(ot,Sf),t(ot,Wn),t(Wn,If),t(ot,Lf),p(e,Ys,r),E(ro,e,r),p(e,Zs,r),p(e,H,r),t(H,Bf),t(H,Gn),t(Gn,Mf),t(H,Xf),t(H,Kn),t(Kn,Rf),t(H,Ff),t(H,Vn),t(Vn,Qf),t(H,Hf),t(H,Jn),t(Jn,Uf),t(H,Wf),p(e,er,r),E(it,e,r),p(e,tr,r),p(e,zi,r),t(zi,Gf),p(e,or,r),E(po,e,r),p(e,ir,r),p(e,Ei,r),t(Ei,Kf),p(e,ar,r),E(co,e,r),p(e,nr,r),p(e,$i,r),t($i,Vf),p(e,lr,r),E(uo,e,r),p(e,sr,r),p(e,Z,r),t(Z,Jf),t(Z,Yn),t(Yn,Yf),t(Z,Zf),t(Z,Zn),t(Zn,em),t(Z,tm),t(Z,el),t(el,om),t(Z,im),p(e,rr,r),E(fo,e,r),p(e,pr,r),E(at,e,r),p(e,cr,r),p(e,ke,r),t(ke,nt),t(nt,tl),E(mo,tl,null),t(ke,am),t(ke,ol),t(ol,nm),p(e,dr,r),p(e,ce,r),t(ce,lm),t(ce,il),t(il,sm),t(ce,rm),t(ce,al),t(al,pm),t(ce,cm),p(e,ur,r),E(ho,e,r),p(e,fr,r),p(e,R,r),t(R,dm),t(R,nl),t(nl,um),t(R,fm),t(R,ll),t(ll,mm),t(R,hm),t(R,sl),t(sl,vm),t(R,gm),t(R,rl),t(rl,_m),t(R,zm),t(R,pl),t(pl,Em),t(R,$m),p(e,mr,r),E(vo,e,r),p(e,hr,r),E(lt,e,r),p(e,vr,r),p(e,Ne,r),t(Ne,st),t(st,cl),E(go,cl,null),t(Ne,bm),t(Ne,dl),t(dl,wm),p(e,gr,r),p(e,de,r),t(de,km),t(de,ul),t(ul,Nm),t(de,Om),t(de,fl),t(fl,xm),t(de,jm),p(e,_r,r),E(_o,e,r),p(e,zr,r),p(e,rt,r),t(rt,Tm),t(rt,ml),t(ml,Am),t(rt,qm),p(e,Er,r),p(e,Oe,r),t(Oe,pt),t(pt,hl),E(zo,hl,null),t(Oe,Pm),t(Oe,vl),t(vl,ym),p(e,$r,r),p(e,bi,r),t(bi,Cm),p(e,br,r),p(e,ue,r),t(ue,wi),t(wi,Dm),t(wi,gl),t(gl,Sm),t(ue,Im),t(ue,ki),t(ki,Lm),t(ki,_l),t(_l,Bm),t(ue,Mm),t(ue,Ni),t(Ni,Xm),t(Ni,zl),t(zl,Rm),p(e,wr,r),p(e,ct,r),t(ct,Fm),t(ct,Eo),t(Eo,Qm),t(ct,Hm),p(e,kr,r),p(e,xe,r),t(xe,dt),t(dt,El),E($o,El,null),t(xe,Um),t(xe,$l),t($l,Wm),p(e,Nr,r),E(ut,e,r),p(e,Or,r),p(e,ft,r),t(ft,Gm),t(ft,bo),t(bo,Km),t(ft,Vm),p(e,xr,r),p(e,Oi,r),t(Oi,Jm),p(e,jr,r),p(e,xi,r),t(xi,Ym),p(e,Tr,r),p(e,mt,r),t(mt,bl),t(bl,Zm),t(mt,eh),t(mt,wo),t(wo,th),t(wo,wl),t(wl,oh),t(wo,ih),p(e,Ar,r),p(e,ji,r),t(ji,ah),p(e,qr,r),p(e,je,r),t(je,ht),t(ht,kl),E(ko,kl,null),t(je,nh),t(je,Nl),t(Nl,lh),p(e,Pr,r),p(e,Ti,r),t(Ti,sh),p(e,yr,r),p(e,ee,r),t(ee,rh),t(ee,Ol),t(Ol,ph),t(ee,ch),t(ee,xl),t(xl,dh),t(ee,uh),t(ee,jl),t(jl,fh),t(ee,mh),p(e,Cr,r),p(e,vt,r),t(vt,hh),t(vt,Tl),t(Tl,vh),t(vt,gh),p(e,Dr,r),p(e,Te,r),t(Te,gt),t(gt,Al),E(No,Al,null),t(Te,_h),t(Te,ql),t(ql,zh),p(e,Sr,r),p(e,Ai,r),t(Ai,Eh),p(e,Ir,r),p(e,qi,r),t(qi,$h),p(e,Lr,r),p(e,Pi,r),t(Pi,Pl),t(Pl,bh),p(e,Br,r),p(e,yi,r),t(yi,wh),p(e,Mr,r),p(e,Ci,r),t(Ci,kh),p(e,Xr,r),p(e,Ae,r),t(Ae,_t),t(_t,yl),E(Oo,yl,null),t(Ae,Nh),t(Ae,Cl),t(Cl,Oh),p(e,Rr,r),p(e,Di,r),t(Di,xh),p(e,Fr,r),p(e,qe,r),t(qe,zt),t(zt,Dl),E(xo,Dl,null),t(qe,jh),t(qe,Sl),t(Sl,Th),p(e,Qr,r),p(e,V,r),t(V,Ah),t(V,Il),t(Il,qh),t(V,Ph),t(V,Ll),t(Ll,yh),t(V,Ch),t(V,Bl),t(Bl,Dh),t(V,Sh),t(V,Ml),t(Ml,Ih),p(e,Hr,r),E(jo,e,r),p(e,Ur,r),p(e,Pe,r),t(Pe,Et),t(Et,Xl),E(To,Xl,null),t(Pe,Lh),t(Pe,Rl),t(Rl,Bh),p(e,Wr,r),p(e,te,r),t(te,Mh),t(te,Fl),t(Fl,Xh),t(te,Rh),t(te,Ql),t(Ql,Fh),t(te,Qh),t(te,Hl),t(Hl,Hh),t(te,Uh),p(e,Gr,r),E(Ao,e,r),p(e,Kr,r),p(e,ye,r),t(ye,$t),t($t,Ul),E(qo,Ul,null),t(ye,Wh),t(ye,Wl),t(Wl,Gh),p(e,Vr,r),p(e,bt,r),t(bt,Kh),t(bt,Gl),t(Gl,Vh),t(bt,Jh),p(e,Jr,r),E(Po,e,r),p(e,Yr,r),p(e,Si,r),t(Si,Yh),p(e,Zr,r),p(e,fe,r),t(fe,Zh),t(fe,yo),t(yo,ev),t(fe,tv),t(fe,Co),t(Co,ov),t(fe,iv),p(e,ep,r),p(e,me,r),t(me,Kl),t(Kl,av),t(me,nv),t(me,Ii),t(Ii,lv),t(Ii,Do),t(Do,sv),t(me,rv),t(me,Ce),t(Ce,pv),t(Ce,So),t(So,cv),t(Ce,dv),t(Ce,Io),t(Io,uv),t(Ce,fv),p(e,tp,r),p(e,De,r),t(De,wt),t(wt,Vl),E(Lo,Vl,null),t(De,mv),t(De,Jl),t(Jl,hv),p(e,op,r),p(e,F,r),t(F,vv),t(F,Bo),t(Bo,gv),t(F,_v),t(F,Mo),t(Mo,zv),t(F,Ev),t(F,Xo),t(Xo,$v),t(F,bv),t(F,Ro),t(Ro,wv),t(F,kv),t(F,Fo),t(Fo,Nv),t(F,Ov),p(e,ip,r),p(e,Se,r),t(Se,kt),t(kt,Yl),E(Qo,Yl,null),t(Se,xv),t(Se,Zl),t(Zl,jv),p(e,ap,r),p(e,Li,r),t(Li,Tv),p(e,np,r),p(e,Bi,r),t(Bi,Ie),t(Ie,Av),t(Ie,Ho),t(Ho,qv),t(Ie,Pv),t(Ie,Uo),t(Uo,yv),t(Ie,Cv),p(e,lp,r),p(e,Le,r),t(Le,Nt),t(Nt,es),E(Wo,es,null),t(Le,Dv),t(Le,ts),t(ts,Sv),p(e,sp,r),p(e,he,r),t(he,Iv),t(he,Go),t(Go,Lv),t(he,Bv),t(he,os),t(os,Mv),t(he,Xv),p(e,rp,r),E(Ko,e,r),p(e,pp,r),p(e,Mi,r),t(Mi,Rv),p(e,cp,r),p(e,Xi,r),t(Xi,Fv),p(e,dp,r),E(Vo,e,r),p(e,up,r),p(e,Ri,r),t(Ri,Qv),p(e,fp,r),E(Jo,e,r),p(e,mp,r),p(e,Fi,r),t(Fi,Hv),p(e,hp,r),p(e,Ot,r),t(Ot,Uv),t(Ot,Yo),t(Yo,Wv),t(Ot,Gv),vp=!0},p(e,[r]){const Zo={};r&2&&(Zo.$$scope={dirty:r,ctx:e}),We.$set(Zo);const is={};r&2&&(is.$$scope={dirty:r,ctx:e}),Ye.$set(is);const as={};r&2&&(as.$$scope={dirty:r,ctx:e}),tt.$set(as);const ns={};r&2&&(ns.$$scope={dirty:r,ctx:e}),it.$set(ns);const ls={};r&2&&(ls.$$scope={dirty:r,ctx:e}),at.$set(ls);const ei={};r&2&&(ei.$$scope={dirty:r,ctx:e}),lt.$set(ei);const ss={};r&2&&(ss.$$scope={dirty:r,ctx:e}),ut.$set(ss)},i(e){vp||($(O.$$.fragment,e),$(ae.$$.fragment,e),$(Ct.$$.fragment,e),$(Dt.$$.fragment,e),$(St.$$.fragment,e),$(It.$$.fragment,e),$(Lt.$$.fragment,e),$(Xt.$$.fragment,e),$(Rt.$$.fragment,e),$(Qt.$$.fragment,e),$(We.$$.fragment,e),$(Ht.$$.fragment,e),$(io.$$.fragment,e),$(ao.$$.fragment,e),$(no.$$.fragment,e),$(Ye.$$.fragment,e),$(lo.$$.fragment,e),$(so.$$.fragment,e),$(tt.$$.fragment,e),$(ro.$$.fragment,e),$(it.$$.fragment,e),$(po.$$.fragment,e),$(co.$$.fragment,e),$(uo.$$.fragment,e),$(fo.$$.fragment,e),$(at.$$.fragment,e),$(mo.$$.fragment,e),$(ho.$$.fragment,e),$(vo.$$.fragment,e),$(lt.$$.fragment,e),$(go.$$.fragment,e),$(_o.$$.fragment,e),$(zo.$$.fragment,e),$($o.$$.fragment,e),$(ut.$$.fragment,e),$(ko.$$.fragment,e),$(No.$$.fragment,e),$(Oo.$$.fragment,e),$(xo.$$.fragment,e),$(jo.$$.fragment,e),$(To.$$.fragment,e),$(Ao.$$.fragment,e),$(qo.$$.fragment,e),$(Po.$$.fragment,e),$(Lo.$$.fragment,e),$(Qo.$$.fragment,e),$(Wo.$$.fragment,e),$(Ko.$$.fragment,e),$(Vo.$$.fragment,e),$(Jo.$$.fragment,e),vp=!0)},o(e){b(O.$$.fragment,e),b(ae.$$.fragment,e),b(Ct.$$.fragment,e),b(Dt.$$.fragment,e),b(St.$$.fragment,e),b(It.$$.fragment,e),b(Lt.$$.fragment,e),b(Xt.$$.fragment,e),b(Rt.$$.fragment,e),b(Qt.$$.fragment,e),b(We.$$.fragment,e),b(Ht.$$.fragment,e),b(io.$$.fragment,e),b(ao.$$.fragment,e),b(no.$$.fragment,e),b(Ye.$$.fragment,e),b(lo.$$.fragment,e),b(so.$$.fragment,e),b(tt.$$.fragment,e),b(ro.$$.fragment,e),b(it.$$.fragment,e),b(po.$$.fragment,e),b(co.$$.fragment,e),b(uo.$$.fragment,e),b(fo.$$.fragment,e),b(at.$$.fragment,e),b(mo.$$.fragment,e),b(ho.$$.fragment,e),b(vo.$$.fragment,e),b(lt.$$.fragment,e),b(go.$$.fragment,e),b(_o.$$.fragment,e),b(zo.$$.fragment,e),b($o.$$.fragment,e),b(ut.$$.fragment,e),b(ko.$$.fragment,e),b(No.$$.fragment,e),b(Oo.$$.fragment,e),b(xo.$$.fragment,e),b(jo.$$.fragment,e),b(To.$$.fragment,e),b(Ao.$$.fragment,e),b(qo.$$.fragment,e),b(Po.$$.fragment,e),b(Lo.$$.fragment,e),b(Qo.$$.fragment,e),b(Wo.$$.fragment,e),b(Ko.$$.fragment,e),b(Vo.$$.fragment,e),b(Jo.$$.fragment,e),vp=!1},d(e){o(f),e&&o(N),e&&o(m),w(O),e&&o(j),e&&o(C),e&&o(D),e&&o(g),e&&o(Me),e&&o(G),w(ae),e&&o(Pt),e&&o(K),e&&o(rs),e&&o(ni),e&&o(ps),e&&o(Xe),e&&o(cs),e&&o(li),e&&o(ds),e&&o(h),e&&o(us),e&&o(si),e&&o(fs),e&&o(Re),e&&o(ms),e&&o(Ee),w(Ct),e&&o(hs),e&&o(ri),e&&o(vs),w(Dt,e),e&&o(gs),e&&o(Qe),e&&o(_s),w(St,e),e&&o(zs),e&&o(pi),e&&o(Es),w(It,e),e&&o($s),e&&o(ci),e&&o(bs),w(Lt,e),e&&o(ws),e&&o(le),e&&o(ks),e&&o(J),e&&o(Ns),w(Xt,e),e&&o(Os),e&&o(He),e&&o(xs),w(Rt,e),e&&o(js),e&&o(Ue),e&&o(Ts),w(Qt,e),e&&o(As),e&&o(di),e&&o(qs),w(We,e),e&&o(Ps),e&&o($e),w(Ht),e&&o(ys),e&&o(Ke),e&&o(Cs),e&&o(Ve),e&&o(Ds),e&&o(Je),e&&o(Ss),w(io,e),e&&o(Is),e&&o(se),e&&o(Ls),w(ao,e),e&&o(Bs),e&&o(ui),e&&o(Ms),w(no,e),e&&o(Xs),e&&o(Y),e&&o(Rs),w(Ye,e),e&&o(Fs),e&&o(be),w(lo),e&&o(Qs),e&&o(fi),e&&o(Hs),e&&o(re),e&&o(Us),e&&o(mi),e&&o(Ws),e&&o(we),w(so),e&&o(Gs),e&&o(hi),e&&o(Ks),e&&o(pe),e&&o(Vs),w(tt,e),e&&o(Js),e&&o(ot),e&&o(Ys),w(ro,e),e&&o(Zs),e&&o(H),e&&o(er),w(it,e),e&&o(tr),e&&o(zi),e&&o(or),w(po,e),e&&o(ir),e&&o(Ei),e&&o(ar),w(co,e),e&&o(nr),e&&o($i),e&&o(lr),w(uo,e),e&&o(sr),e&&o(Z),e&&o(rr),w(fo,e),e&&o(pr),w(at,e),e&&o(cr),e&&o(ke),w(mo),e&&o(dr),e&&o(ce),e&&o(ur),w(ho,e),e&&o(fr),e&&o(R),e&&o(mr),w(vo,e),e&&o(hr),w(lt,e),e&&o(vr),e&&o(Ne),w(go),e&&o(gr),e&&o(de),e&&o(_r),w(_o,e),e&&o(zr),e&&o(rt),e&&o(Er),e&&o(Oe),w(zo),e&&o($r),e&&o(bi),e&&o(br),e&&o(ue),e&&o(wr),e&&o(ct),e&&o(kr),e&&o(xe),w($o),e&&o(Nr),w(ut,e),e&&o(Or),e&&o(ft),e&&o(xr),e&&o(Oi),e&&o(jr),e&&o(xi),e&&o(Tr),e&&o(mt),e&&o(Ar),e&&o(ji),e&&o(qr),e&&o(je),w(ko),e&&o(Pr),e&&o(Ti),e&&o(yr),e&&o(ee),e&&o(Cr),e&&o(vt),e&&o(Dr),e&&o(Te),w(No),e&&o(Sr),e&&o(Ai),e&&o(Ir),e&&o(qi),e&&o(Lr),e&&o(Pi),e&&o(Br),e&&o(yi),e&&o(Mr),e&&o(Ci),e&&o(Xr),e&&o(Ae),w(Oo),e&&o(Rr),e&&o(Di),e&&o(Fr),e&&o(qe),w(xo),e&&o(Qr),e&&o(V),e&&o(Hr),w(jo,e),e&&o(Ur),e&&o(Pe),w(To),e&&o(Wr),e&&o(te),e&&o(Gr),w(Ao,e),e&&o(Kr),e&&o(ye),w(qo),e&&o(Vr),e&&o(bt),e&&o(Jr),w(Po,e),e&&o(Yr),e&&o(Si),e&&o(Zr),e&&o(fe),e&&o(ep),e&&o(me),e&&o(tp),e&&o(De),w(Lo),e&&o(op),e&&o(F),e&&o(ip),e&&o(Se),w(Qo),e&&o(ap),e&&o(Li),e&&o(np),e&&o(Bi),e&&o(lp),e&&o(Le),w(Wo),e&&o(sp),e&&o(he),e&&o(rp),w(Ko,e),e&&o(pp),e&&o(Mi),e&&o(cp),e&&o(Xi),e&&o(dp),w(Vo,e),e&&o(up),e&&o(Ri),e&&o(fp),w(Jo,e),e&&o(mp),e&&o(Fi),e&&o(hp),e&&o(Ot)}}}const IE={local:"esporta-modelli-transformers",sections:[{local:"onnx",sections:[{local:"esportazione-di-un-modello-in-onnx",title:"Esportazione di un modello in ONNX"},{local:"selezione-delle-caratteristiche-per-diverse-topologie-di-modello",title:"Selezione delle caratteristiche per diverse topologie di modello"},{local:"esportazione-di-un-modello-per-unarchitettura-non-supportata",sections:[{local:"implementazione-di-una-configurazione-onnx-personalizzata",title:"Implementazione di una configurazione ONNX personalizzata"},{local:"esportazione-del-modello",title:"Esportazione del modello"},{local:"convalida-degli-output-del-modello",title:"Convalida degli output del modello"}],title:"Esportazione di un modello per un'architettura non supportata"},{local:"contribuire-con-una-nuova-configurazione-a-transformers",title:"Contribuire con una nuova configurazione a \u{1F917} Transformers"}],title:"ONNX"},{local:"torchscript",sections:[{local:"flag-torchscript-e-pesi-legati",title:"Flag TorchScript e pesi legati"},{local:"input-fittizi-e-standard-lengths",title:"Input fittizi e standard lengths"},{local:"usare-torchsscript-in-python",sections:[{local:"salvare-un-modello",title:"Salvare un modello"},{local:"caricare-un-modello",title:"Caricare un modello"},{local:"utilizzare-un-modello-tracciato-per-linferenza",title:"Utilizzare un modello tracciato per l'inferenza"},{local:"implicazioni",title:"Implicazioni"},{local:"dipendenze",title:"Dipendenze"},{local:"convertire-un-modello-per-aws-neuron",title:"Convertire un modello per AWS Neuron"}],title:"Usare TorchSscript in Python"}],title:"TorchScript"}],title:"Esporta modelli \u{1F917} Transformers "};function LE(L){return kE(()=>{new URLSearchParams(window.location.search).get("fw")}),[]}class FE extends EE{constructor(f){super();$E(this,f,LE,SE,bE,{})}}export{FE as default,IE as metadata};
