import{S as so,i as ao,s as oo,e as r,k as c,w as $,t as o,M as no,c as l,d as t,m as u,x as y,a as i,h as n,b as w,G as s,g as h,y as _,q as v,o as b,B as k,v as ro}from"../../chunks/vendor-hf-doc-builder.js";import{T as ss}from"../../chunks/Tip-hf-doc-builder.js";import{Y as as}from"../../chunks/Youtube-hf-doc-builder.js";import{I as os}from"../../chunks/IconCopyLink-hf-doc-builder.js";import{C as I}from"../../chunks/CodeBlock-hf-doc-builder.js";import{D as lo}from"../../chunks/DocNotebookDropdown-hf-doc-builder.js";import{F as io}from"../../chunks/FrameworkSwitchCourse-hf-doc-builder.js";function ho(S){let p,j,f,T,g;return{c(){p=r("p"),j=o("Note that \u{1F917} Transformers models have a special ability that most Keras models don\u2019t - they can automatically use an appropriate loss which they compute internally. They will use this loss by default if you don\u2019t set a loss argument in "),f=r("code"),T=o("compile()"),g=o(". Note that to use the internal loss you\u2019ll need to pass your labels as part of the input, not as a separate label, which is the normal way to use labels with Keras models. You\u2019ll see examples of this in Part 2 of the course, where defining the correct loss function can be tricky. For sequence classification, however, a standard Keras loss function works fine, so that\u2019s what we\u2019ll use here.")},l(m){p=l(m,"P",{});var E=i(p);j=n(E,"Note that \u{1F917} Transformers models have a special ability that most Keras models don\u2019t - they can automatically use an appropriate loss which they compute internally. They will use this loss by default if you don\u2019t set a loss argument in "),f=l(E,"CODE",{});var q=i(f);T=n(q,"compile()"),q.forEach(t),g=n(E,". Note that to use the internal loss you\u2019ll need to pass your labels as part of the input, not as a separate label, which is the normal way to use labels with Keras models. You\u2019ll see examples of this in Part 2 of the course, where defining the correct loss function can be tricky. For sequence classification, however, a standard Keras loss function works fine, so that\u2019s what we\u2019ll use here."),E.forEach(t)},m(m,E){h(m,p,E),s(p,j),s(p,f),s(f,T),s(p,g)},d(m){m&&t(p)}}}function po(S){let p,j,f,T,g,m,E,q;return{c(){p=r("p"),j=o("Note a very common pitfall here \u2014 you "),f=r("em"),T=o("can"),g=o(" just pass the name of the loss as a string to Keras, but by default Keras will assume that you have already applied a softmax to your outputs. Many models, however, output the values right before the softmax is applied, which are also known as the "),m=r("em"),E=o("logits"),q=o(". We need to tell the loss function that that\u2019s what our model does, and the only way to do that is to call it directly, rather than by name with a string.")},l(P){p=l(P,"P",{});var d=i(p);j=n(d,"Note a very common pitfall here \u2014 you "),f=l(d,"EM",{});var x=i(f);T=n(x,"can"),x.forEach(t),g=n(d," just pass the name of the loss as a string to Keras, but by default Keras will assume that you have already applied a softmax to your outputs. Many models, however, output the values right before the softmax is applied, which are also known as the "),m=l(d,"EM",{});var C=i(m);E=n(C,"logits"),C.forEach(t),q=n(d,". We need to tell the loss function that that\u2019s what our model does, and the only way to do that is to call it directly, rather than by name with a string."),d.forEach(t)},m(P,d){h(P,p,d),s(p,j),s(p,f),s(f,T),s(p,g),s(p,m),s(m,E),s(p,q)},d(P){P&&t(p)}}}function co(S){let p,j,f,T,g,m,E,q;return{c(){p=r("p"),j=o("The \u{1F917} Transformers library also has a "),f=r("code"),T=o("create_optimizer()"),g=o(" function that will create an "),m=r("code"),E=o("AdamW"),q=o(" optimizer with learning rate decay. This is a convenient shortcut that you\u2019ll see in detail in future sections of the course.")},l(P){p=l(P,"P",{});var d=i(p);j=n(d,"The \u{1F917} Transformers library also has a "),f=l(d,"CODE",{});var x=i(f);T=n(x,"create_optimizer()"),x.forEach(t),g=n(d," function that will create an "),m=l(d,"CODE",{});var C=i(m);E=n(C,"AdamW"),C.forEach(t),q=n(d," optimizer with learning rate decay. This is a convenient shortcut that you\u2019ll see in detail in future sections of the course."),d.forEach(t)},m(P,d){h(P,p,d),s(p,j),s(p,f),s(f,T),s(p,g),s(p,m),s(m,E),s(p,q)},d(P){P&&t(p)}}}function uo(S){let p,j,f,T,g,m,E,q,P,d;return{c(){p=r("p"),j=o("\u{1F4A1} If you want to automatically upload your model to the Hub during training, you can pass along a "),f=r("code"),T=o("PushToHubCallback"),g=o(" in the "),m=r("code"),E=o("model.fit()"),q=o(" method. We will learn more about this in "),P=r("a"),d=o("Chapter 4"),this.h()},l(x){p=l(x,"P",{});var C=i(p);j=n(C,"\u{1F4A1} If you want to automatically upload your model to the Hub during training, you can pass along a "),f=l(C,"CODE",{});var K=i(f);T=n(K,"PushToHubCallback"),K.forEach(t),g=n(C," in the "),m=l(C,"CODE",{});var ne=i(m);E=n(ne,"model.fit()"),ne.forEach(t),q=n(C," method. We will learn more about this in "),P=l(C,"A",{href:!0});var z=i(P);d=n(z,"Chapter 4"),z.forEach(t),C.forEach(t),this.h()},h(){w(P,"href","/course/chapter4/3")},m(x,C){h(x,p,C),s(p,j),s(p,f),s(f,T),s(p,g),s(p,m),s(m,E),s(p,q),s(p,P),s(P,d)},d(x){x&&t(p)}}}function fo(S){let p,j,f,T,g,m,E,q,P,d,x,C,K,ne,z,ns,Ke,rs,ls,re,is,hs,ct,qe,ps,ut,le,ft,W,L,Me,ie,cs,Oe,us,mt,Pe,fs,dt,he,wt,Ce,ms,gt,pe,$t,M,ds,Ae,ws,gs,Ue,$s,ys,yt,ce,_t,B,_s,xe,vs,bs,vt,O,ks,We,Es,js,Ge,Ts,qs,bt,Y,kt,ue,Et,J,jt,G,V,He,fe,Ps,Re,Cs,Tt,me,qt,Q,As,Le,xs,zs,Pt,A,Ds,Be,Fs,Ns,Ye,Ss,Is,Je,Ks,Ms,Ve,Os,Us,Qe,Ws,Gs,Ct,de,At,X,xt,ze,Hs,zt,we,Dt,De,Rs,Ft,ge,Nt,Z,St,H,ee,Xe,$e,Ls,Ze,Bs,It,ye,Kt,U,Ys,et,Js,Vs,tt,Qs,Xs,Mt,_e,Ot,te,Zs,st,ea,ta,Ut,ve,Wt,be,Gt,D,sa,at,aa,oa,ot,na,ra,nt,la,ia,Ht,ke,Rt,Ee,Lt,F,ha,je,pa,ca,rt,ua,fa,lt,ma,da,Bt,se,wa,Fe,ga,$a,Yt;return f=new io({props:{fw:S[0]}}),q=new os({}),K=new lo({props:{classNames:"absolute z-10 right-0 top-0",options:[{label:"Google Colab",value:"https://colab.research.google.com/github/huggingface/notebooks/blob/master/course/chapter3/section3_tf.ipynb"},{label:"Aws Studio",value:"https://studiolab.sagemaker.aws/import/github/huggingface/notebooks/blob/master/course/chapter3/section3_tf.ipynb"}]}}),le=new I({props:{code:`






`,highlighted:`<span class="hljs-keyword">from</span> datasets <span class="hljs-keyword">import</span> load_dataset
<span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> AutoTokenizer, DataCollatorWithPadding
<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np

raw_datasets = load_dataset(<span class="hljs-string">&quot;glue&quot;</span>, <span class="hljs-string">&quot;mrpc&quot;</span>)
checkpoint = <span class="hljs-string">&quot;bert-base-uncased&quot;</span>
tokenizer = AutoTokenizer.from_pretrained(checkpoint)


<span class="hljs-keyword">def</span> <span class="hljs-title function_">tokenize_function</span>(<span class="hljs-params">example</span>):
    <span class="hljs-keyword">return</span> tokenizer(example[<span class="hljs-string">&quot;sentence1&quot;</span>], example[<span class="hljs-string">&quot;sentence2&quot;</span>], truncation=<span class="hljs-literal">True</span>)


tokenized_datasets = raw_datasets.<span class="hljs-built_in">map</span>(tokenize_function, batched=<span class="hljs-literal">True</span>)

data_collator = DataCollatorWithPadding(tokenizer=tokenizer, return_tensors=<span class="hljs-string">&quot;tf&quot;</span>)

tf_train_dataset = tokenized_datasets[<span class="hljs-string">&quot;train&quot;</span>].to_tf_dataset(
    columns=[<span class="hljs-string">&quot;attention_mask&quot;</span>, <span class="hljs-string">&quot;input_ids&quot;</span>, <span class="hljs-string">&quot;token_type_ids&quot;</span>],
    label_cols=[<span class="hljs-string">&quot;labels&quot;</span>],
    shuffle=<span class="hljs-literal">True</span>,
    collate_fn=data_collator,
    batch_size=<span class="hljs-number">8</span>,
)

tf_validation_dataset = tokenized_datasets[<span class="hljs-string">&quot;validation&quot;</span>].to_tf_dataset(
    columns=[<span class="hljs-string">&quot;attention_mask&quot;</span>, <span class="hljs-string">&quot;input_ids&quot;</span>, <span class="hljs-string">&quot;token_type_ids&quot;</span>],
    label_cols=[<span class="hljs-string">&quot;labels&quot;</span>],
    shuffle=<span class="hljs-literal">False</span>,
    collate_fn=data_collator,
    batch_size=<span class="hljs-number">8</span>,
)`}}),ie=new os({}),he=new as({props:{id:"rnTGBy2ax1c"}}),pe=new as({props:{id:"AUozVp78dhk"}}),ce=new I({props:{code:"",highlighted:`<span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> TFAutoModelForSequenceClassification

model = TFAutoModelForSequenceClassification.from_pretrained(checkpoint, num_labels=<span class="hljs-number">2</span>)`}}),Y=new ss({props:{$$slots:{default:[ho]},$$scope:{ctx:S}}}),ue=new I({props:{code:"",highlighted:`<span class="hljs-keyword">from</span> tensorflow.keras.losses <span class="hljs-keyword">import</span> SparseCategoricalCrossentropy

model.<span class="hljs-built_in">compile</span>(
    optimizer=<span class="hljs-string">&quot;adam&quot;</span>,
    loss=SparseCategoricalCrossentropy(from_logits=<span class="hljs-literal">True</span>),
    metrics=[<span class="hljs-string">&quot;accuracy&quot;</span>],
)
model.fit(
    tf_train_dataset,
    validation_data=tf_validation_dataset,
)`}}),J=new ss({props:{warning:!0,$$slots:{default:[po]},$$scope:{ctx:S}}}),fe=new os({}),me=new as({props:{id:"cpzq6ESSM5c"}}),de=new I({props:{code:`
`,highlighted:`<span class="hljs-keyword">from</span> tensorflow.keras.optimizers.schedules <span class="hljs-keyword">import</span> PolynomialDecay

batch_size = <span class="hljs-number">8</span>
num_epochs = <span class="hljs-number">3</span>
<span class="hljs-comment"># The number of training steps is the number of samples in the dataset, divided by the batch size then multiplied</span>
<span class="hljs-comment"># by the total number of epochs. Note that the tf_train_dataset here is a batched tf.data.Dataset,</span>
<span class="hljs-comment"># not the original Hugging Face Dataset, so its len() is already num_samples // batch_size.</span>
num_train_steps = <span class="hljs-built_in">len</span>(tf_train_dataset) * num_epochs
lr_scheduler = PolynomialDecay(
    initial_learning_rate=<span class="hljs-number">5e-5</span>, end_learning_rate=<span class="hljs-number">0.0</span>, decay_steps=num_train_steps
)
<span class="hljs-keyword">from</span> tensorflow.keras.optimizers <span class="hljs-keyword">import</span> Adam

opt = Adam(learning_rate=lr_scheduler)`}}),X=new ss({props:{$$slots:{default:[co]},$$scope:{ctx:S}}}),we=new I({props:{code:"",highlighted:`<span class="hljs-keyword">import</span> tensorflow <span class="hljs-keyword">as</span> tf

model = TFAutoModelForSequenceClassification.from_pretrained(checkpoint, num_labels=<span class="hljs-number">2</span>)
loss = tf.keras.losses.SparseCategoricalCrossentropy(from_logits=<span class="hljs-literal">True</span>)
model.<span class="hljs-built_in">compile</span>(optimizer=opt, loss=loss, metrics=[<span class="hljs-string">&quot;accuracy&quot;</span>])`}}),ge=new I({props:{code:"model.fit(tf_train_dataset, validation_data=tf_validation_dataset, epochs=3)",highlighted:'model.fit(tf_train_dataset, validation_data=tf_validation_dataset, epochs=<span class="hljs-number">3</span>)'}}),Z=new ss({props:{$$slots:{default:[uo]},$$scope:{ctx:S}}}),$e=new os({}),ye=new as({props:{id:"nx10eh4CoOs"}}),_e=new I({props:{code:'preds = model.predict(tf_validation_dataset)["logits"]',highlighted:'preds = model.predict(tf_validation_dataset)[<span class="hljs-string">&quot;logits&quot;</span>]'}}),ve=new I({props:{code:`class_preds = np.argmax(preds, axis=1)
print(preds.shape, class_preds.shape)`,highlighted:`class_preds = np.argmax(preds, axis=<span class="hljs-number">1</span>)
<span class="hljs-built_in">print</span>(preds.shape, class_preds.shape)`}}),be=new I({props:{code:"(408, 2) (408,)",highlighted:'(<span class="hljs-number">408</span>, <span class="hljs-number">2</span>) (<span class="hljs-number">408</span>,)'}}),ke=new I({props:{code:"",highlighted:`<span class="hljs-keyword">from</span> datasets <span class="hljs-keyword">import</span> load_metric

metric = load_metric(<span class="hljs-string">&quot;glue&quot;</span>, <span class="hljs-string">&quot;mrpc&quot;</span>)
metric.compute(predictions=class_preds, references=raw_datasets[<span class="hljs-string">&quot;validation&quot;</span>][<span class="hljs-string">&quot;label&quot;</span>])`}}),Ee=new I({props:{code:"{'accuracy': 0.8578431372549019, 'f1': 0.8996539792387542}",highlighted:'{<span class="hljs-string">&#x27;accuracy&#x27;</span>: <span class="hljs-number">0.8578431372549019</span>, <span class="hljs-string">&#x27;f1&#x27;</span>: <span class="hljs-number">0.8996539792387542</span>}'}}),{c(){p=r("meta"),j=c(),$(f.$$.fragment),T=c(),g=r("h1"),m=r("a"),E=r("span"),$(q.$$.fragment),P=c(),d=r("span"),x=o("Fine-tuning a model with Keras"),C=c(),$(K.$$.fragment),ne=c(),z=r("p"),ns=o("Once you\u2019ve done all the data preprocessing work in the last section, you have just a few steps left to train the model. Note, however, that the "),Ke=r("code"),rs=o("model.fit()"),ls=o(" command will run very slowly on a CPU. If you don\u2019t have a GPU set up, you can get access to free GPUs or TPUs on "),re=r("a"),is=o("Google Colab"),hs=o("."),ct=c(),qe=r("p"),ps=o("The code examples below assume you have already executed the examples in the previous section. Here is a short summary recapping what you need:"),ut=c(),$(le.$$.fragment),ft=c(),W=r("h3"),L=r("a"),Me=r("span"),$(ie.$$.fragment),cs=c(),Oe=r("span"),us=o("Training"),mt=c(),Pe=r("p"),fs=o("TensorFlow models imported from \u{1F917} Transformers are already Keras models. Here is a short introduction to Keras."),dt=c(),$(he.$$.fragment),wt=c(),Ce=r("p"),ms=o("That means that once we have our data, very little work is required to begin training on it."),gt=c(),$(pe.$$.fragment),$t=c(),M=r("p"),ds=o("As in the "),Ae=r("a"),ws=o("previous chapter"),gs=o(", we will use the "),Ue=r("code"),$s=o("TFAutoModelForSequenceClassification"),ys=o(" class, with two labels:"),yt=c(),$(ce.$$.fragment),_t=c(),B=r("p"),_s=o("You will notice that unlike in "),xe=r("a"),vs=o("Chapter 2"),bs=o(", you get a warning after instantiating this pretrained model. This is because BERT has not been pretrained on classifying pairs of sentences, so the head of the pretrained model has been discarded and a new head suitable for sequence classification has been inserted instead. The warnings indicate that some weights were not used (the ones corresponding to the dropped pretraining head) and that some others were randomly initialized (the ones for the new head). It concludes by encouraging you to train the model, which is exactly what we are going to do now."),vt=c(),O=r("p"),ks=o("To fine-tune the model on our dataset, we just have to "),We=r("code"),Es=o("compile()"),js=o(" our model and then pass our data to the "),Ge=r("code"),Ts=o("fit()"),qs=o(" method. This will start the fine-tuning process (which should take a couple of minutes on a GPU) and report training loss as it goes, plus the validation loss at the end of each epoch."),bt=c(),$(Y.$$.fragment),kt=c(),$(ue.$$.fragment),Et=c(),$(J.$$.fragment),jt=c(),G=r("h3"),V=r("a"),He=r("span"),$(fe.$$.fragment),Ps=c(),Re=r("span"),Cs=o("Improving training performance"),Tt=c(),$(me.$$.fragment),qt=c(),Q=r("p"),As=o(`If you try the above code, it certainly runs, but you\u2019ll find that the loss declines only slowly or sporadically. The primary cause
is the `),Le=r("em"),xs=o("learning rate"),zs=o(`. As with the loss, when we pass Keras the name of an optimizer as a string, Keras initializes
that optimizer with default values for all parameters, including learning rate. From long experience, though, we know
that transformer models benefit from a much lower learning rate than the default for Adam, which is 1e-3, also written
as 10 to the power of -3, or 0.001. 5e-5 (0.00005), which is some twenty times lower, is a much better starting point.`),Pt=c(),A=r("p"),Ds=o(`In addition to lowering the learning rate, we have a second trick up our sleeve: We can slowly reduce the learning rate
over the course of training. In the literature, you will sometimes see this referred to as `),Be=r("em"),Fs=o("decaying"),Ns=o(" or "),Ye=r("em"),Ss=o("annealing"),Is=o(`
the learning rate. In Keras, the best way to do this is to use a `),Je=r("em"),Ks=o("learning rate scheduler"),Ms=o(`. A good one to use is
`),Ve=r("code"),Os=o("PolynomialDecay"),Us=o(` \u2014 despite the name, with default settings it simply linearly decays the learning rate from the initial
value to the final value over the course of training, which is exactly what we want. In order to use a scheduler correctly,
though, we need to tell it how long training is going to be. We compute that as `),Qe=r("code"),Ws=o("num_train_steps"),Gs=o(" below."),Ct=c(),$(de.$$.fragment),At=c(),$(X.$$.fragment),xt=c(),ze=r("p"),Hs=o("Now we have our all-new optimizer, and we can try training with it. First, let\u2019s reload the model, to reset the changes to the weights from the training run we just did, and then we can compile it with the new optimizer:"),zt=c(),$(we.$$.fragment),Dt=c(),De=r("p"),Rs=o("Now, we fit again:"),Ft=c(),$(ge.$$.fragment),Nt=c(),$(Z.$$.fragment),St=c(),H=r("h3"),ee=r("a"),Xe=r("span"),$($e.$$.fragment),Ls=c(),Ze=r("span"),Bs=o("Model predictions"),It=c(),$(ye.$$.fragment),Kt=c(),U=r("p"),Ys=o("Training and watching the loss go down is all very nice, but what if we want to actually get outputs from the trained model, either to compute some metrics, or to use the model in production? To do that, we can just use the "),et=r("code"),Js=o("predict()"),Vs=o(" method. This will return the "),tt=r("em"),Qs=o("logits"),Xs=o(" from the output head of the model, one per class."),Mt=c(),$(_e.$$.fragment),Ot=c(),te=r("p"),Zs=o("We can convert these logits into the model\u2019s class predictions by using "),st=r("code"),ea=o("argmax"),ta=o(" to find the highest logit, which corresponds to the most likely class:"),Ut=c(),$(ve.$$.fragment),Wt=c(),$(be.$$.fragment),Gt=c(),D=r("p"),sa=o("Now, let\u2019s use those "),at=r("code"),aa=o("preds"),oa=o(" to compute some metrics! We can load the metrics associated with the MRPC dataset as easily as we loaded the dataset, this time with the "),ot=r("code"),na=o("load_metric()"),ra=o(" function. The object returned has a "),nt=r("code"),la=o("compute()"),ia=o(" method we can use to do the metric calculation:"),Ht=c(),$(ke.$$.fragment),Rt=c(),$(Ee.$$.fragment),Lt=c(),F=r("p"),ha=o("The exact results you get may vary, as the random initialization of the model head might change the metrics it achieved. Here, we can see our model has an accuracy of 85.78% on the validation set and an F1 score of 89.97. Those are the two metrics used to evaluate results on the MRPC dataset for the GLUE benchmark. The table in the "),je=r("a"),pa=o("BERT paper"),ca=o(" reported an F1 score of 88.9 for the base model. That was the "),rt=r("code"),ua=o("uncased"),fa=o(" model while we are currently using the "),lt=r("code"),ma=o("cased"),da=o(" model, which explains the better result."),Bt=c(),se=r("p"),wa=o("This concludes the introduction to fine-tuning using the Keras API. An example of doing this for most common NLP tasks will be given in "),Fe=r("a"),ga=o("Chapter 7"),$a=o(". If you would like to hone your skills on the Keras API, try to fine-tune a model on the GLUE SST-2 dataset, using the data processing you did in section 2."),this.h()},l(e){const a=no('[data-svelte="svelte-1phssyn"]',document.head);p=l(a,"META",{name:!0,content:!0}),a.forEach(t),j=u(e),y(f.$$.fragment,e),T=u(e),g=l(e,"H1",{class:!0});var Te=i(g);m=l(Te,"A",{id:!0,class:!0,href:!0});var it=i(m);E=l(it,"SPAN",{});var ht=i(E);y(q.$$.fragment,ht),ht.forEach(t),it.forEach(t),P=u(Te),d=l(Te,"SPAN",{});var pt=i(d);x=n(pt,"Fine-tuning a model with Keras"),pt.forEach(t),Te.forEach(t),C=u(e),y(K.$$.fragment,e),ne=u(e),z=l(e,"P",{});var R=i(z);ns=n(R,"Once you\u2019ve done all the data preprocessing work in the last section, you have just a few steps left to train the model. Note, however, that the "),Ke=l(R,"CODE",{});var ya=i(Ke);rs=n(ya,"model.fit()"),ya.forEach(t),ls=n(R," command will run very slowly on a CPU. If you don\u2019t have a GPU set up, you can get access to free GPUs or TPUs on "),re=l(R,"A",{href:!0,rel:!0});var _a=i(re);is=n(_a,"Google Colab"),_a.forEach(t),hs=n(R,"."),R.forEach(t),ct=u(e),qe=l(e,"P",{});var va=i(qe);ps=n(va,"The code examples below assume you have already executed the examples in the previous section. Here is a short summary recapping what you need:"),va.forEach(t),ut=u(e),y(le.$$.fragment,e),ft=u(e),W=l(e,"H3",{class:!0});var Jt=i(W);L=l(Jt,"A",{id:!0,class:!0,href:!0});var ba=i(L);Me=l(ba,"SPAN",{});var ka=i(Me);y(ie.$$.fragment,ka),ka.forEach(t),ba.forEach(t),cs=u(Jt),Oe=l(Jt,"SPAN",{});var Ea=i(Oe);us=n(Ea,"Training"),Ea.forEach(t),Jt.forEach(t),mt=u(e),Pe=l(e,"P",{});var ja=i(Pe);fs=n(ja,"TensorFlow models imported from \u{1F917} Transformers are already Keras models. Here is a short introduction to Keras."),ja.forEach(t),dt=u(e),y(he.$$.fragment,e),wt=u(e),Ce=l(e,"P",{});var Ta=i(Ce);ms=n(Ta,"That means that once we have our data, very little work is required to begin training on it."),Ta.forEach(t),gt=u(e),y(pe.$$.fragment,e),$t=u(e),M=l(e,"P",{});var Ne=i(M);ds=n(Ne,"As in the "),Ae=l(Ne,"A",{href:!0});var qa=i(Ae);ws=n(qa,"previous chapter"),qa.forEach(t),gs=n(Ne,", we will use the "),Ue=l(Ne,"CODE",{});var Pa=i(Ue);$s=n(Pa,"TFAutoModelForSequenceClassification"),Pa.forEach(t),ys=n(Ne," class, with two labels:"),Ne.forEach(t),yt=u(e),y(ce.$$.fragment,e),_t=u(e),B=l(e,"P",{});var Vt=i(B);_s=n(Vt,"You will notice that unlike in "),xe=l(Vt,"A",{href:!0});var Ca=i(xe);vs=n(Ca,"Chapter 2"),Ca.forEach(t),bs=n(Vt,", you get a warning after instantiating this pretrained model. This is because BERT has not been pretrained on classifying pairs of sentences, so the head of the pretrained model has been discarded and a new head suitable for sequence classification has been inserted instead. The warnings indicate that some weights were not used (the ones corresponding to the dropped pretraining head) and that some others were randomly initialized (the ones for the new head). It concludes by encouraging you to train the model, which is exactly what we are going to do now."),Vt.forEach(t),vt=u(e),O=l(e,"P",{});var Se=i(O);ks=n(Se,"To fine-tune the model on our dataset, we just have to "),We=l(Se,"CODE",{});var Aa=i(We);Es=n(Aa,"compile()"),Aa.forEach(t),js=n(Se," our model and then pass our data to the "),Ge=l(Se,"CODE",{});var xa=i(Ge);Ts=n(xa,"fit()"),xa.forEach(t),qs=n(Se," method. This will start the fine-tuning process (which should take a couple of minutes on a GPU) and report training loss as it goes, plus the validation loss at the end of each epoch."),Se.forEach(t),bt=u(e),y(Y.$$.fragment,e),kt=u(e),y(ue.$$.fragment,e),Et=u(e),y(J.$$.fragment,e),jt=u(e),G=l(e,"H3",{class:!0});var Qt=i(G);V=l(Qt,"A",{id:!0,class:!0,href:!0});var za=i(V);He=l(za,"SPAN",{});var Da=i(He);y(fe.$$.fragment,Da),Da.forEach(t),za.forEach(t),Ps=u(Qt),Re=l(Qt,"SPAN",{});var Fa=i(Re);Cs=n(Fa,"Improving training performance"),Fa.forEach(t),Qt.forEach(t),Tt=u(e),y(me.$$.fragment,e),qt=u(e),Q=l(e,"P",{});var Xt=i(Q);As=n(Xt,`If you try the above code, it certainly runs, but you\u2019ll find that the loss declines only slowly or sporadically. The primary cause
is the `),Le=l(Xt,"EM",{});var Na=i(Le);xs=n(Na,"learning rate"),Na.forEach(t),zs=n(Xt,`. As with the loss, when we pass Keras the name of an optimizer as a string, Keras initializes
that optimizer with default values for all parameters, including learning rate. From long experience, though, we know
that transformer models benefit from a much lower learning rate than the default for Adam, which is 1e-3, also written
as 10 to the power of -3, or 0.001. 5e-5 (0.00005), which is some twenty times lower, is a much better starting point.`),Xt.forEach(t),Pt=u(e),A=l(e,"P",{});var N=i(A);Ds=n(N,`In addition to lowering the learning rate, we have a second trick up our sleeve: We can slowly reduce the learning rate
over the course of training. In the literature, you will sometimes see this referred to as `),Be=l(N,"EM",{});var Sa=i(Be);Fs=n(Sa,"decaying"),Sa.forEach(t),Ns=n(N," or "),Ye=l(N,"EM",{});var Ia=i(Ye);Ss=n(Ia,"annealing"),Ia.forEach(t),Is=n(N,`
the learning rate. In Keras, the best way to do this is to use a `),Je=l(N,"EM",{});var Ka=i(Je);Ks=n(Ka,"learning rate scheduler"),Ka.forEach(t),Ms=n(N,`. A good one to use is
`),Ve=l(N,"CODE",{});var Ma=i(Ve);Os=n(Ma,"PolynomialDecay"),Ma.forEach(t),Us=n(N,` \u2014 despite the name, with default settings it simply linearly decays the learning rate from the initial
value to the final value over the course of training, which is exactly what we want. In order to use a scheduler correctly,
though, we need to tell it how long training is going to be. We compute that as `),Qe=l(N,"CODE",{});var Oa=i(Qe);Ws=n(Oa,"num_train_steps"),Oa.forEach(t),Gs=n(N," below."),N.forEach(t),Ct=u(e),y(de.$$.fragment,e),At=u(e),y(X.$$.fragment,e),xt=u(e),ze=l(e,"P",{});var Ua=i(ze);Hs=n(Ua,"Now we have our all-new optimizer, and we can try training with it. First, let\u2019s reload the model, to reset the changes to the weights from the training run we just did, and then we can compile it with the new optimizer:"),Ua.forEach(t),zt=u(e),y(we.$$.fragment,e),Dt=u(e),De=l(e,"P",{});var Wa=i(De);Rs=n(Wa,"Now, we fit again:"),Wa.forEach(t),Ft=u(e),y(ge.$$.fragment,e),Nt=u(e),y(Z.$$.fragment,e),St=u(e),H=l(e,"H3",{class:!0});var Zt=i(H);ee=l(Zt,"A",{id:!0,class:!0,href:!0});var Ga=i(ee);Xe=l(Ga,"SPAN",{});var Ha=i(Xe);y($e.$$.fragment,Ha),Ha.forEach(t),Ga.forEach(t),Ls=u(Zt),Ze=l(Zt,"SPAN",{});var Ra=i(Ze);Bs=n(Ra,"Model predictions"),Ra.forEach(t),Zt.forEach(t),It=u(e),y(ye.$$.fragment,e),Kt=u(e),U=l(e,"P",{});var Ie=i(U);Ys=n(Ie,"Training and watching the loss go down is all very nice, but what if we want to actually get outputs from the trained model, either to compute some metrics, or to use the model in production? To do that, we can just use the "),et=l(Ie,"CODE",{});var La=i(et);Js=n(La,"predict()"),La.forEach(t),Vs=n(Ie," method. This will return the "),tt=l(Ie,"EM",{});var Ba=i(tt);Qs=n(Ba,"logits"),Ba.forEach(t),Xs=n(Ie," from the output head of the model, one per class."),Ie.forEach(t),Mt=u(e),y(_e.$$.fragment,e),Ot=u(e),te=l(e,"P",{});var es=i(te);Zs=n(es,"We can convert these logits into the model\u2019s class predictions by using "),st=l(es,"CODE",{});var Ya=i(st);ea=n(Ya,"argmax"),Ya.forEach(t),ta=n(es," to find the highest logit, which corresponds to the most likely class:"),es.forEach(t),Ut=u(e),y(ve.$$.fragment,e),Wt=u(e),y(be.$$.fragment,e),Gt=u(e),D=l(e,"P",{});var ae=i(D);sa=n(ae,"Now, let\u2019s use those "),at=l(ae,"CODE",{});var Ja=i(at);aa=n(Ja,"preds"),Ja.forEach(t),oa=n(ae," to compute some metrics! We can load the metrics associated with the MRPC dataset as easily as we loaded the dataset, this time with the "),ot=l(ae,"CODE",{});var Va=i(ot);na=n(Va,"load_metric()"),Va.forEach(t),ra=n(ae," function. The object returned has a "),nt=l(ae,"CODE",{});var Qa=i(nt);la=n(Qa,"compute()"),Qa.forEach(t),ia=n(ae," method we can use to do the metric calculation:"),ae.forEach(t),Ht=u(e),y(ke.$$.fragment,e),Rt=u(e),y(Ee.$$.fragment,e),Lt=u(e),F=l(e,"P",{});var oe=i(F);ha=n(oe,"The exact results you get may vary, as the random initialization of the model head might change the metrics it achieved. Here, we can see our model has an accuracy of 85.78% on the validation set and an F1 score of 89.97. Those are the two metrics used to evaluate results on the MRPC dataset for the GLUE benchmark. The table in the "),je=l(oe,"A",{href:!0,rel:!0});var Xa=i(je);pa=n(Xa,"BERT paper"),Xa.forEach(t),ca=n(oe," reported an F1 score of 88.9 for the base model. That was the "),rt=l(oe,"CODE",{});var Za=i(rt);ua=n(Za,"uncased"),Za.forEach(t),fa=n(oe," model while we are currently using the "),lt=l(oe,"CODE",{});var eo=i(lt);ma=n(eo,"cased"),eo.forEach(t),da=n(oe," model, which explains the better result."),oe.forEach(t),Bt=u(e),se=l(e,"P",{});var ts=i(se);wa=n(ts,"This concludes the introduction to fine-tuning using the Keras API. An example of doing this for most common NLP tasks will be given in "),Fe=l(ts,"A",{href:!0});var to=i(Fe);ga=n(to,"Chapter 7"),to.forEach(t),$a=n(ts,". If you would like to hone your skills on the Keras API, try to fine-tune a model on the GLUE SST-2 dataset, using the data processing you did in section 2."),ts.forEach(t),this.h()},h(){w(p,"name","hf:doc:metadata"),w(p,"content",JSON.stringify(mo)),w(m,"id","finetuning-a-model-with-keras"),w(m,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),w(m,"href","#finetuning-a-model-with-keras"),w(g,"class","relative group"),w(re,"href","https://colab.research.google.com/"),w(re,"rel","nofollow"),w(L,"id","training"),w(L,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),w(L,"href","#training"),w(W,"class","relative group"),w(Ae,"href","/course/chapter2"),w(xe,"href","/course/chapter2"),w(V,"id","improving-training-performance"),w(V,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),w(V,"href","#improving-training-performance"),w(G,"class","relative group"),w(ee,"id","model-predictions"),w(ee,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),w(ee,"href","#model-predictions"),w(H,"class","relative group"),w(je,"href","https://arxiv.org/pdf/1810.04805.pdf"),w(je,"rel","nofollow"),w(Fe,"href","/course/chapter7")},m(e,a){s(document.head,p),h(e,j,a),_(f,e,a),h(e,T,a),h(e,g,a),s(g,m),s(m,E),_(q,E,null),s(g,P),s(g,d),s(d,x),h(e,C,a),_(K,e,a),h(e,ne,a),h(e,z,a),s(z,ns),s(z,Ke),s(Ke,rs),s(z,ls),s(z,re),s(re,is),s(z,hs),h(e,ct,a),h(e,qe,a),s(qe,ps),h(e,ut,a),_(le,e,a),h(e,ft,a),h(e,W,a),s(W,L),s(L,Me),_(ie,Me,null),s(W,cs),s(W,Oe),s(Oe,us),h(e,mt,a),h(e,Pe,a),s(Pe,fs),h(e,dt,a),_(he,e,a),h(e,wt,a),h(e,Ce,a),s(Ce,ms),h(e,gt,a),_(pe,e,a),h(e,$t,a),h(e,M,a),s(M,ds),s(M,Ae),s(Ae,ws),s(M,gs),s(M,Ue),s(Ue,$s),s(M,ys),h(e,yt,a),_(ce,e,a),h(e,_t,a),h(e,B,a),s(B,_s),s(B,xe),s(xe,vs),s(B,bs),h(e,vt,a),h(e,O,a),s(O,ks),s(O,We),s(We,Es),s(O,js),s(O,Ge),s(Ge,Ts),s(O,qs),h(e,bt,a),_(Y,e,a),h(e,kt,a),_(ue,e,a),h(e,Et,a),_(J,e,a),h(e,jt,a),h(e,G,a),s(G,V),s(V,He),_(fe,He,null),s(G,Ps),s(G,Re),s(Re,Cs),h(e,Tt,a),_(me,e,a),h(e,qt,a),h(e,Q,a),s(Q,As),s(Q,Le),s(Le,xs),s(Q,zs),h(e,Pt,a),h(e,A,a),s(A,Ds),s(A,Be),s(Be,Fs),s(A,Ns),s(A,Ye),s(Ye,Ss),s(A,Is),s(A,Je),s(Je,Ks),s(A,Ms),s(A,Ve),s(Ve,Os),s(A,Us),s(A,Qe),s(Qe,Ws),s(A,Gs),h(e,Ct,a),_(de,e,a),h(e,At,a),_(X,e,a),h(e,xt,a),h(e,ze,a),s(ze,Hs),h(e,zt,a),_(we,e,a),h(e,Dt,a),h(e,De,a),s(De,Rs),h(e,Ft,a),_(ge,e,a),h(e,Nt,a),_(Z,e,a),h(e,St,a),h(e,H,a),s(H,ee),s(ee,Xe),_($e,Xe,null),s(H,Ls),s(H,Ze),s(Ze,Bs),h(e,It,a),_(ye,e,a),h(e,Kt,a),h(e,U,a),s(U,Ys),s(U,et),s(et,Js),s(U,Vs),s(U,tt),s(tt,Qs),s(U,Xs),h(e,Mt,a),_(_e,e,a),h(e,Ot,a),h(e,te,a),s(te,Zs),s(te,st),s(st,ea),s(te,ta),h(e,Ut,a),_(ve,e,a),h(e,Wt,a),_(be,e,a),h(e,Gt,a),h(e,D,a),s(D,sa),s(D,at),s(at,aa),s(D,oa),s(D,ot),s(ot,na),s(D,ra),s(D,nt),s(nt,la),s(D,ia),h(e,Ht,a),_(ke,e,a),h(e,Rt,a),_(Ee,e,a),h(e,Lt,a),h(e,F,a),s(F,ha),s(F,je),s(je,pa),s(F,ca),s(F,rt),s(rt,ua),s(F,fa),s(F,lt),s(lt,ma),s(F,da),h(e,Bt,a),h(e,se,a),s(se,wa),s(se,Fe),s(Fe,ga),s(se,$a),Yt=!0},p(e,[a]){const Te={};a&1&&(Te.fw=e[0]),f.$set(Te);const it={};a&2&&(it.$$scope={dirty:a,ctx:e}),Y.$set(it);const ht={};a&2&&(ht.$$scope={dirty:a,ctx:e}),J.$set(ht);const pt={};a&2&&(pt.$$scope={dirty:a,ctx:e}),X.$set(pt);const R={};a&2&&(R.$$scope={dirty:a,ctx:e}),Z.$set(R)},i(e){Yt||(v(f.$$.fragment,e),v(q.$$.fragment,e),v(K.$$.fragment,e),v(le.$$.fragment,e),v(ie.$$.fragment,e),v(he.$$.fragment,e),v(pe.$$.fragment,e),v(ce.$$.fragment,e),v(Y.$$.fragment,e),v(ue.$$.fragment,e),v(J.$$.fragment,e),v(fe.$$.fragment,e),v(me.$$.fragment,e),v(de.$$.fragment,e),v(X.$$.fragment,e),v(we.$$.fragment,e),v(ge.$$.fragment,e),v(Z.$$.fragment,e),v($e.$$.fragment,e),v(ye.$$.fragment,e),v(_e.$$.fragment,e),v(ve.$$.fragment,e),v(be.$$.fragment,e),v(ke.$$.fragment,e),v(Ee.$$.fragment,e),Yt=!0)},o(e){b(f.$$.fragment,e),b(q.$$.fragment,e),b(K.$$.fragment,e),b(le.$$.fragment,e),b(ie.$$.fragment,e),b(he.$$.fragment,e),b(pe.$$.fragment,e),b(ce.$$.fragment,e),b(Y.$$.fragment,e),b(ue.$$.fragment,e),b(J.$$.fragment,e),b(fe.$$.fragment,e),b(me.$$.fragment,e),b(de.$$.fragment,e),b(X.$$.fragment,e),b(we.$$.fragment,e),b(ge.$$.fragment,e),b(Z.$$.fragment,e),b($e.$$.fragment,e),b(ye.$$.fragment,e),b(_e.$$.fragment,e),b(ve.$$.fragment,e),b(be.$$.fragment,e),b(ke.$$.fragment,e),b(Ee.$$.fragment,e),Yt=!1},d(e){t(p),e&&t(j),k(f,e),e&&t(T),e&&t(g),k(q),e&&t(C),k(K,e),e&&t(ne),e&&t(z),e&&t(ct),e&&t(qe),e&&t(ut),k(le,e),e&&t(ft),e&&t(W),k(ie),e&&t(mt),e&&t(Pe),e&&t(dt),k(he,e),e&&t(wt),e&&t(Ce),e&&t(gt),k(pe,e),e&&t($t),e&&t(M),e&&t(yt),k(ce,e),e&&t(_t),e&&t(B),e&&t(vt),e&&t(O),e&&t(bt),k(Y,e),e&&t(kt),k(ue,e),e&&t(Et),k(J,e),e&&t(jt),e&&t(G),k(fe),e&&t(Tt),k(me,e),e&&t(qt),e&&t(Q),e&&t(Pt),e&&t(A),e&&t(Ct),k(de,e),e&&t(At),k(X,e),e&&t(xt),e&&t(ze),e&&t(zt),k(we,e),e&&t(Dt),e&&t(De),e&&t(Ft),k(ge,e),e&&t(Nt),k(Z,e),e&&t(St),e&&t(H),k($e),e&&t(It),k(ye,e),e&&t(Kt),e&&t(U),e&&t(Mt),k(_e,e),e&&t(Ot),e&&t(te),e&&t(Ut),k(ve,e),e&&t(Wt),k(be,e),e&&t(Gt),e&&t(D),e&&t(Ht),k(ke,e),e&&t(Rt),k(Ee,e),e&&t(Lt),e&&t(F),e&&t(Bt),e&&t(se)}}}const mo={local:"finetuning-a-model-with-keras",sections:[{local:"training",title:"Training"},{local:"improving-training-performance",title:"Improving training performance"},{local:"model-predictions",title:"Model predictions"}],title:"Fine-tuning a model with Keras"};function wo(S,p,j){let f="pt";return ro(()=>{const T=new URLSearchParams(window.location.search);j(0,f=T.get("fw")||"pt")}),[f]}class Eo extends so{constructor(p){super();ao(this,p,wo,fo,oo,{})}}export{Eo as default,mo as metadata};
