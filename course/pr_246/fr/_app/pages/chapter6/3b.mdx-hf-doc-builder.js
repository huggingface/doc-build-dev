import{S as Am,i as Om,s as Im,e as i,k as d,w as $,t as r,U as zm,M as Fm,c as u,d as t,m as f,x as g,a as p,h as o,V as Nm,b as N,N as Sm,G as s,g as m,y as x,o as h,p as ne,q as _,B as q,v as Um,n as ae}from"../../chunks/vendor-hf-doc-builder.js";import{T as Hr}from"../../chunks/Tip-hf-doc-builder.js";import{Y as Tm}from"../../chunks/Youtube-hf-doc-builder.js";import{I as Qr}from"../../chunks/IconCopyLink-hf-doc-builder.js";import{C as j}from"../../chunks/CodeBlock-hf-doc-builder.js";import{D as Lm}from"../../chunks/DocNotebookDropdown-hf-doc-builder.js";import{F as Gm}from"../../chunks/FrameworkSwitchCourse-hf-doc-builder.js";function Jm(k){let a,c;return a=new Lm({props:{classNames:"absolute z-10 right-0 top-0",options:[{label:"Google Colab",value:"https://colab.research.google.com/github/huggingface/notebooks/blob/master/course/chapter6/section3b_tf.ipynb"},{label:"Aws Studio",value:"https://studiolab.sagemaker.aws/import/github/huggingface/notebooks/blob/master/course/chapter6/section3b_tf.ipynb"}]}}),{c(){$(a.$$.fragment)},l(n){g(a.$$.fragment,n)},m(n,v){x(a,n,v),c=!0},i(n){c||(_(a.$$.fragment,n),c=!0)},o(n){h(a.$$.fragment,n),c=!1},d(n){q(a,n)}}}function Rm(k){let a,c;return a=new Lm({props:{classNames:"absolute z-10 right-0 top-0",options:[{label:"Google Colab",value:"https://colab.research.google.com/github/huggingface/notebooks/blob/master/course/chapter6/section3b_pt.ipynb"},{label:"Aws Studio",value:"https://studiolab.sagemaker.aws/import/github/huggingface/notebooks/blob/master/course/chapter6/section3b_pt.ipynb"}]}}),{c(){$(a.$$.fragment)},l(n){g(a.$$.fragment,n)},m(n,v){x(a,n,v),c=!0},i(n){c||(_(a.$$.fragment,n),c=!0)},o(n){h(a.$$.fragment,n),c=!1},d(n){q(a,n)}}}function Hm(k){let a,c;return a=new Tm({props:{id:"b3u8RzBCX9Y"}}),{c(){$(a.$$.fragment)},l(n){g(a.$$.fragment,n)},m(n,v){x(a,n,v),c=!0},i(n){c||(_(a.$$.fragment,n),c=!0)},o(n){h(a.$$.fragment,n),c=!1},d(n){q(a,n)}}}function Qm(k){let a,c;return a=new Tm({props:{id:"_wxyB3j3mk4"}}),{c(){$(a.$$.fragment)},l(n){g(a.$$.fragment,n)},m(n,v){x(a,n,v),c=!0},i(n){c||(_(a.$$.fragment,n),c=!0)},o(n){h(a.$$.fragment,n),c=!1},d(n){q(a,n)}}}function Km(k){let a,c;return a=new j({props:{code:`
`,highlighted:`<span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> AutoTokenizer, TFAutoModelForQuestionAnswering

model_checkpoint = <span class="hljs-string">&quot;distilbert-base-cased-distilled-squad&quot;</span>
tokenizer = AutoTokenizer.from_pretrained(model_checkpoint)
model = TFAutoModelForQuestionAnswering.from_pretrained(model_checkpoint)

inputs = tokenizer(question, context, return_tensors=<span class="hljs-string">&quot;tf&quot;</span>)
outputs = model(**inputs)`}}),{c(){$(a.$$.fragment)},l(n){g(a.$$.fragment,n)},m(n,v){x(a,n,v),c=!0},i(n){c||(_(a.$$.fragment,n),c=!0)},o(n){h(a.$$.fragment,n),c=!1},d(n){q(a,n)}}}function Vm(k){let a,c;return a=new j({props:{code:`
`,highlighted:`<span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> AutoTokenizer, AutoModelForQuestionAnswering

model_checkpoint = <span class="hljs-string">&quot;distilbert-base-cased-distilled-squad&quot;</span>
tokenizer = AutoTokenizer.from_pretrained(model_checkpoint)
model = AutoModelForQuestionAnswering.from_pretrained(model_checkpoint)

inputs = tokenizer(question, context, return_tensors=<span class="hljs-string">&quot;pt&quot;</span>)
outputs = model(**inputs)`}}),{c(){$(a.$$.fragment)},l(n){g(a.$$.fragment,n)},m(n,v){x(a,n,v),c=!0},i(n){c||(_(a.$$.fragment,n),c=!0)},o(n){h(a.$$.fragment,n),c=!1},d(n){q(a,n)}}}function Wm(k){let a,c;return a=new j({props:{code:"(1, 66) (1, 66)",highlighted:'(<span class="hljs-number">1</span>, <span class="hljs-number">66</span>) (<span class="hljs-number">1</span>, <span class="hljs-number">66</span>)'}}),{c(){$(a.$$.fragment)},l(n){g(a.$$.fragment,n)},m(n,v){x(a,n,v),c=!0},i(n){c||(_(a.$$.fragment,n),c=!0)},o(n){h(a.$$.fragment,n),c=!1},d(n){q(a,n)}}}function Bm(k){let a,c;return a=new j({props:{code:"torch.Size([1, 66]) torch.Size([1, 66])",highlighted:'torch.Size([<span class="hljs-number">1</span>, <span class="hljs-number">66</span>]) torch.Size([<span class="hljs-number">1</span>, <span class="hljs-number">66</span>])'}}),{c(){$(a.$$.fragment)},l(n){g(a.$$.fragment,n)},m(n,v){x(a,n,v),c=!0},i(n){c||(_(a.$$.fragment,n),c=!0)},o(n){h(a.$$.fragment,n),c=!1},d(n){q(a,n)}}}function Ym(k){let a,c;return a=new j({props:{code:`
`,highlighted:`<span class="hljs-keyword">import</span> tensorflow <span class="hljs-keyword">as</span> tf

sequence_ids = inputs.sequence_ids()
<span class="hljs-comment"># Masque tout, sauf les tokens du contexte</span>
mask = [i != <span class="hljs-number">1</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> sequence_ids]
<span class="hljs-comment"># D\xE9masquer le token [CLS]</span>
mask[<span class="hljs-number">0</span>] = <span class="hljs-literal">False</span>
mask = tf.constant(mask)[<span class="hljs-literal">None</span>]

start_logits = tf.where(mask, -<span class="hljs-number">10000</span>, start_logits)
end_logits = tf.where(mask, -<span class="hljs-number">10000</span>, end_logits)`}}),{c(){$(a.$$.fragment)},l(n){g(a.$$.fragment,n)},m(n,v){x(a,n,v),c=!0},i(n){c||(_(a.$$.fragment,n),c=!0)},o(n){h(a.$$.fragment,n),c=!1},d(n){q(a,n)}}}function Xm(k){let a,c;return a=new j({props:{code:`
`,highlighted:`<span class="hljs-keyword">import</span> torch

sequence_ids = inputs.sequence_ids()
<span class="hljs-comment"># Masque tout, sauf les tokens du contexte</span>
mask = [i != <span class="hljs-number">1</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> sequence_ids]
<span class="hljs-comment"># D\xE9masquer le token [CLS]</span>
mask[<span class="hljs-number">0</span>] = <span class="hljs-literal">False</span>
mask = torch.tensor(mask)[<span class="hljs-literal">None</span>]

start_logits[mask] = -<span class="hljs-number">10000</span>
end_logits[mask] = -<span class="hljs-number">10000</span>`}}),{c(){$(a.$$.fragment)},l(n){g(a.$$.fragment,n)},m(n,v){x(a,n,v),c=!0},i(n){c||(_(a.$$.fragment,n),c=!0)},o(n){h(a.$$.fragment,n),c=!1},d(n){q(a,n)}}}function Zm(k){let a,c;return a=new j({props:{code:`start_probabilities = tf.math.softmax(start_logits, axis=-1)[0].numpy()
end_probabilities = tf.math.softmax(end_logits, axis=-1)[0].numpy()`,highlighted:`start_probabilities = tf.math.softmax(start_logits, axis=-<span class="hljs-number">1</span>)[<span class="hljs-number">0</span>].numpy()
end_probabilities = tf.math.softmax(end_logits, axis=-<span class="hljs-number">1</span>)[<span class="hljs-number">0</span>].numpy()`}}),{c(){$(a.$$.fragment)},l(n){g(a.$$.fragment,n)},m(n,v){x(a,n,v),c=!0},i(n){c||(_(a.$$.fragment,n),c=!0)},o(n){h(a.$$.fragment,n),c=!1},d(n){q(a,n)}}}function ec(k){let a,c;return a=new j({props:{code:`start_probabilities = torch.nn.functional.softmax(start_logits, dim=-1)[0]
end_probabilities = torch.nn.functional.softmax(end_logits, dim=-1)[0]`,highlighted:`start_probabilities = torch.nn.functional.softmax(start_logits, dim=-<span class="hljs-number">1</span>)[<span class="hljs-number">0</span>]
end_probabilities = torch.nn.functional.softmax(end_logits, dim=-<span class="hljs-number">1</span>)[<span class="hljs-number">0</span>]`}}),{c(){$(a.$$.fragment)},l(n){g(a.$$.fragment,n)},m(n,v){x(a,n,v),c=!0},i(n){c||(_(a.$$.fragment,n),c=!0)},o(n){h(a.$$.fragment,n),c=!1},d(n){q(a,n)}}}function sc(k){let a,c,n,v,b,w,P,z,S,C,L,D,M,H;return M=new j({props:{code:"scores = np.triu(scores)",highlighted:"scores = np.triu(scores)"}}),{c(){a=i("p"),c=r("Ensuite, nous masquerons les valeurs o\xF9 "),n=i("code"),v=r("start_index > end_index"),b=r(" en les mettant \xE0 "),w=i("code"),P=r("0"),z=r(" (les autres probabilit\xE9s sont toutes des nombres positifs). La fonction "),S=i("code"),C=r("np.triu()"),L=r(" renvoie la partie triangulaire sup\xE9rieure du tenseur 2D pass\xE9 en argument, elle fera donc ce masquage pour nous :"),D=d(),$(M.$$.fragment)},l(E){a=u(E,"P",{});var y=p(a);c=o(y,"Ensuite, nous masquerons les valeurs o\xF9 "),n=u(y,"CODE",{});var B=p(n);v=o(B,"start_index > end_index"),B.forEach(t),b=o(y," en les mettant \xE0 "),w=u(y,"CODE",{});var O=p(w);P=o(O,"0"),O.forEach(t),z=o(y," (les autres probabilit\xE9s sont toutes des nombres positifs). La fonction "),S=u(y,"CODE",{});var Ie=p(S);C=o(Ie,"np.triu()"),Ie.forEach(t),L=o(y," renvoie la partie triangulaire sup\xE9rieure du tenseur 2D pass\xE9 en argument, elle fera donc ce masquage pour nous :"),y.forEach(t),D=f(E),g(M.$$.fragment,E)},m(E,y){m(E,a,y),s(a,c),s(a,n),s(n,v),s(a,b),s(a,w),s(w,P),s(a,z),s(a,S),s(S,C),s(a,L),m(E,D,y),x(M,E,y),H=!0},i(E){H||(_(M.$$.fragment,E),H=!0)},o(E){h(M.$$.fragment,E),H=!1},d(E){E&&t(a),E&&t(D),q(M,E)}}}function tc(k){let a,c,n,v,b,w,P,z,S,C,L,D,M,H;return M=new j({props:{code:"scores = torch.triu(scores)",highlighted:"scores = torch.triu(scores)"}}),{c(){a=i("p"),c=r("Ensuite, nous masquerons les valeurs o\xF9 "),n=i("code"),v=r("start_index > end_index"),b=r(" en les mettant \xE0 "),w=i("code"),P=r("0"),z=r(" (les autres probabilit\xE9s sont toutes des nombres positifs). La fonction "),S=i("code"),C=r("torch.triu()"),L=r(" renvoie la partie triangulaire sup\xE9rieure du tenseur 2D pass\xE9 en argument, elle fera donc ce masquage pour nous :"),D=d(),$(M.$$.fragment)},l(E){a=u(E,"P",{});var y=p(a);c=o(y,"Ensuite, nous masquerons les valeurs o\xF9 "),n=u(y,"CODE",{});var B=p(n);v=o(B,"start_index > end_index"),B.forEach(t),b=o(y," en les mettant \xE0 "),w=u(y,"CODE",{});var O=p(w);P=o(O,"0"),O.forEach(t),z=o(y," (les autres probabilit\xE9s sont toutes des nombres positifs). La fonction "),S=u(y,"CODE",{});var Ie=p(S);C=o(Ie,"torch.triu()"),Ie.forEach(t),L=o(y," renvoie la partie triangulaire sup\xE9rieure du tenseur 2D pass\xE9 en argument, elle fera donc ce masquage pour nous :"),y.forEach(t),D=f(E),g(M.$$.fragment,E)},m(E,y){m(E,a,y),s(a,c),s(a,n),s(n,v),s(a,b),s(a,w),s(w,P),s(a,z),s(a,S),s(S,C),s(a,L),m(E,D,y),x(M,E,y),H=!0},i(E){H||(_(M.$$.fragment,E),H=!0)},o(E){h(M.$$.fragment,E),H=!1},d(E){E&&t(a),E&&t(D),q(M,E)}}}function nc(k){let a,c,n,v,b;return{c(){a=i("p"),c=r("\u270F\uFE0F "),n=i("strong"),v=r("Essayez !"),b=r(" Calculez les indices de d\xE9but et de fin pour les cinq r\xE9ponses les plus probables.")},l(w){a=u(w,"P",{});var P=p(a);c=o(P,"\u270F\uFE0F "),n=u(P,"STRONG",{});var z=p(n);v=o(z,"Essayez !"),z.forEach(t),b=o(P," Calculez les indices de d\xE9but et de fin pour les cinq r\xE9ponses les plus probables."),P.forEach(t)},m(w,P){m(w,a,P),s(a,c),s(a,n),s(n,v),s(a,b)},d(w){w&&t(a)}}}function ac(k){let a,c,n,v,b,w,P,z;return{c(){a=i("p"),c=r("\u270F\uFE0F "),n=i("strong"),v=r("Essayez !"),b=r(" Utilisez les meilleurs scores que vous avez calcul\xE9s pr\xE9c\xE9demment pour afficher les cinq r\xE9ponses les plus probables. Pour v\xE9rifier vos r\xE9sultats, retournez au premier pipeline et passez dans "),w=i("code"),P=r("top_k=5"),z=r(" lorsque vous l\u2019appelez.")},l(S){a=u(S,"P",{});var C=p(a);c=o(C,"\u270F\uFE0F "),n=u(C,"STRONG",{});var L=p(n);v=o(L,"Essayez !"),L.forEach(t),b=o(C," Utilisez les meilleurs scores que vous avez calcul\xE9s pr\xE9c\xE9demment pour afficher les cinq r\xE9ponses les plus probables. Pour v\xE9rifier vos r\xE9sultats, retournez au premier pipeline et passez dans "),w=u(C,"CODE",{});var D=p(w);P=o(D,"top_k=5"),D.forEach(t),z=o(C," lorsque vous l\u2019appelez."),C.forEach(t)},m(S,C){m(S,a,C),s(a,c),s(a,n),s(n,v),s(a,b),s(a,w),s(w,P),s(a,z)},d(S){S&&t(a)}}}function rc(k){let a,c,n,v;return a=new j({props:{code:"",highlighted:`_ = inputs.pop(<span class="hljs-string">&quot;overflow_to_sample_mapping&quot;</span>)
offsets = inputs.pop(<span class="hljs-string">&quot;offset_mapping&quot;</span>)

inputs = inputs.convert_to_tensors(<span class="hljs-string">&quot;tf&quot;</span>)
<span class="hljs-built_in">print</span>(inputs[<span class="hljs-string">&quot;input_ids&quot;</span>].shape)`}}),n=new j({props:{code:"(2, 384)",highlighted:'(<span class="hljs-number">2</span>, <span class="hljs-number">384</span>)'}}),{c(){$(a.$$.fragment),c=d(),$(n.$$.fragment)},l(b){g(a.$$.fragment,b),c=f(b),g(n.$$.fragment,b)},m(b,w){x(a,b,w),m(b,c,w),x(n,b,w),v=!0},i(b){v||(_(a.$$.fragment,b),_(n.$$.fragment,b),v=!0)},o(b){h(a.$$.fragment,b),h(n.$$.fragment,b),v=!1},d(b){q(a,b),b&&t(c),q(n,b)}}}function oc(k){let a,c,n,v;return a=new j({props:{code:"",highlighted:`_ = inputs.pop(<span class="hljs-string">&quot;overflow_to_sample_mapping&quot;</span>)
offsets = inputs.pop(<span class="hljs-string">&quot;offset_mapping&quot;</span>)

inputs = inputs.convert_to_tensors(<span class="hljs-string">&quot;pt&quot;</span>)
<span class="hljs-built_in">print</span>(inputs[<span class="hljs-string">&quot;input_ids&quot;</span>].shape)`}}),n=new j({props:{code:"torch.Size([2, 384])",highlighted:'torch.Size([<span class="hljs-number">2</span>, <span class="hljs-number">384</span>])'}}),{c(){$(a.$$.fragment),c=d(),$(n.$$.fragment)},l(b){g(a.$$.fragment,b),c=f(b),g(n.$$.fragment,b)},m(b,w){x(a,b,w),m(b,c,w),x(n,b,w),v=!0},i(b){v||(_(a.$$.fragment,b),_(n.$$.fragment,b),v=!0)},o(b){h(a.$$.fragment,b),h(n.$$.fragment,b),v=!1},d(b){q(a,b),b&&t(c),q(n,b)}}}function lc(k){let a,c;return a=new j({props:{code:"(2, 384) (2, 384)",highlighted:'(<span class="hljs-number">2</span>, <span class="hljs-number">384</span>) (<span class="hljs-number">2</span>, <span class="hljs-number">384</span>)'}}),{c(){$(a.$$.fragment)},l(n){g(a.$$.fragment,n)},m(n,v){x(a,n,v),c=!0},i(n){c||(_(a.$$.fragment,n),c=!0)},o(n){h(a.$$.fragment,n),c=!1},d(n){q(a,n)}}}function ic(k){let a,c;return a=new j({props:{code:"torch.Size([2, 384]) torch.Size([2, 384])",highlighted:'torch.Size([<span class="hljs-number">2</span>, <span class="hljs-number">384</span>]) torch.Size([<span class="hljs-number">2</span>, <span class="hljs-number">384</span>])'}}),{c(){$(a.$$.fragment)},l(n){g(a.$$.fragment,n)},m(n,v){x(a,n,v),c=!0},i(n){c||(_(a.$$.fragment,n),c=!0)},o(n){h(a.$$.fragment,n),c=!1},d(n){q(a,n)}}}function uc(k){let a,c;return a=new j({props:{code:"",highlighted:`sequence_ids = inputs.sequence_ids()
<span class="hljs-comment"># Masque tout, sauf les tokens du contexte</span>
mask = [i != <span class="hljs-number">1</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> sequence_ids]
<span class="hljs-comment"># D\xE9masquer le jeton [CLS]</span>
mask[<span class="hljs-number">0</span>] = <span class="hljs-literal">False</span>
<span class="hljs-comment"># Masquer tous les tokens [PAD]</span>
mask = tf.math.logical_or(tf.constant(mask)[<span class="hljs-literal">None</span>], inputs[<span class="hljs-string">&quot;attention_mask&quot;</span>] == <span class="hljs-number">0</span>)

start_logits = tf.where(mask, -<span class="hljs-number">10000</span>, start_logits)
end_logits = tf.where(mask, -<span class="hljs-number">10000</span>, end_logits)`}}),{c(){$(a.$$.fragment)},l(n){g(a.$$.fragment,n)},m(n,v){x(a,n,v),c=!0},i(n){c||(_(a.$$.fragment,n),c=!0)},o(n){h(a.$$.fragment,n),c=!1},d(n){q(a,n)}}}function pc(k){let a,c;return a=new j({props:{code:"",highlighted:`sequence_ids = inputs.sequence_ids()
<span class="hljs-comment"># Masque tout, sauf les tokens du contexte</span>
mask = [i != <span class="hljs-number">1</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> sequence_ids]
<span class="hljs-comment"># D\xE9masquer le jeton [CLS]</span>
mask[<span class="hljs-number">0</span>] = <span class="hljs-literal">False</span>
<span class="hljs-comment"># Masquer tous les tokens [PAD]</span>
mask = torch.logical_or(torch.tensor(mask)[<span class="hljs-literal">None</span>], (inputs[<span class="hljs-string">&quot;attention_mask&quot;</span>] == <span class="hljs-number">0</span>))

start_logits[mask] = -<span class="hljs-number">10000</span>
end_logits[mask] = -<span class="hljs-number">10000</span>`}}),{c(){$(a.$$.fragment)},l(n){g(a.$$.fragment,n)},m(n,v){x(a,n,v),c=!0},i(n){c||(_(a.$$.fragment,n),c=!0)},o(n){h(a.$$.fragment,n),c=!1},d(n){q(a,n)}}}function mc(k){let a,c;return a=new j({props:{code:`start_probabilities = tf.math.softmax(start_logits, axis=-1).numpy()
end_probabilities = tf.math.softmax(end_logits, axis=-1).numpy()`,highlighted:`start_probabilities = tf.math.softmax(start_logits, axis=-<span class="hljs-number">1</span>).numpy()
end_probabilities = tf.math.softmax(end_logits, axis=-<span class="hljs-number">1</span>).numpy()`}}),{c(){$(a.$$.fragment)},l(n){g(a.$$.fragment,n)},m(n,v){x(a,n,v),c=!0},i(n){c||(_(a.$$.fragment,n),c=!0)},o(n){h(a.$$.fragment,n),c=!1},d(n){q(a,n)}}}function cc(k){let a,c;return a=new j({props:{code:`start_probabilities = torch.nn.functional.softmax(start_logits, dim=-1)
end_probabilities = torch.nn.functional.softmax(end_logits, dim=-1)`,highlighted:`start_probabilities = torch.nn.functional.softmax(start_logits, dim=-<span class="hljs-number">1</span>)
end_probabilities = torch.nn.functional.softmax(end_logits, dim=-<span class="hljs-number">1</span>)`}}),{c(){$(a.$$.fragment)},l(n){g(a.$$.fragment,n)},m(n,v){x(a,n,v),c=!0},i(n){c||(_(a.$$.fragment,n),c=!0)},o(n){h(a.$$.fragment,n),c=!1},d(n){q(a,n)}}}function dc(k){let a,c;return a=new j({props:{code:`
`,highlighted:`candidates = []
<span class="hljs-keyword">for</span> start_probs, end_probs <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(start_probabilities, end_probabilities):
    scores = start_probs[:, <span class="hljs-literal">None</span>] * end_probs[<span class="hljs-literal">None</span>, :]
    idx = np.triu(scores).argmax().item()

    start_idx = idx // scores.shape[<span class="hljs-number">0</span>]
    end_idx = idx % scores.shape[<span class="hljs-number">0</span>]
    score = scores[start_idx, end_idx].item()
    candidates.append((start_idx, end_idx, score))

<span class="hljs-built_in">print</span>(candidates)`}}),{c(){$(a.$$.fragment)},l(n){g(a.$$.fragment,n)},m(n,v){x(a,n,v),c=!0},i(n){c||(_(a.$$.fragment,n),c=!0)},o(n){h(a.$$.fragment,n),c=!1},d(n){q(a,n)}}}function fc(k){let a,c;return a=new j({props:{code:`
`,highlighted:`candidates = []
<span class="hljs-keyword">for</span> start_probs, end_probs <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(start_probabilities, end_probabilities):
    scores = start_probs[:, <span class="hljs-literal">None</span>] * end_probs[<span class="hljs-literal">None</span>, :]
    idx = torch.triu(scores).argmax().item()

    start_idx = idx // scores.shape[<span class="hljs-number">0</span>]
    end_idx = idx % scores.shape[<span class="hljs-number">0</span>]
    score = scores[start_idx, end_idx].item()
    candidates.append((start_idx, end_idx, score))

<span class="hljs-built_in">print</span>(candidates)`}}),{c(){$(a.$$.fragment)},l(n){g(a.$$.fragment,n)},m(n,v){x(a,n,v),c=!0},i(n){c||(_(a.$$.fragment,n),c=!0)},o(n){h(a.$$.fragment,n),c=!1},d(n){q(a,n)}}}function hc(k){let a,c,n,v,b;return{c(){a=i("p"),c=r("\u270F\uFE0F "),n=i("strong"),v=r("Essayez !"),b=r(" Adaptez le code ci-dessus pour renvoyer les scores et les \xE9tendues des cinq r\xE9ponses les plus probables (au total, pas par morceau).")},l(w){a=u(w,"P",{});var P=p(a);c=o(P,"\u270F\uFE0F "),n=u(P,"STRONG",{});var z=p(n);v=o(z,"Essayez !"),z.forEach(t),b=o(P," Adaptez le code ci-dessus pour renvoyer les scores et les \xE9tendues des cinq r\xE9ponses les plus probables (au total, pas par morceau)."),P.forEach(t)},m(w,P){m(w,a,P),s(a,c),s(a,n),s(n,v),s(a,b)},d(w){w&&t(a)}}}function _c(k){let a,c,n,v,b,w,P,z;return{c(){a=i("p"),c=r("\u270F\uFE0F "),n=i("strong"),v=r("Essayez !"),b=r(" Utilisez les meilleurs scores que vous avez calcul\xE9s auparavant pour montrer les cinq r\xE9ponses les plus probables (pour l\u2019ensemble du contexte, pas pour chaque morceau). Pour v\xE9rifier vos r\xE9sultats, retournez au premier pipeline et sp\xE9cifiez "),w=i("code"),P=r("top_k=5"),z=r(" en argument en l\u2019appelant.")},l(S){a=u(S,"P",{});var C=p(a);c=o(C,"\u270F\uFE0F "),n=u(C,"STRONG",{});var L=p(n);v=o(L,"Essayez !"),L.forEach(t),b=o(C," Utilisez les meilleurs scores que vous avez calcul\xE9s auparavant pour montrer les cinq r\xE9ponses les plus probables (pour l\u2019ensemble du contexte, pas pour chaque morceau). Pour v\xE9rifier vos r\xE9sultats, retournez au premier pipeline et sp\xE9cifiez "),w=u(C,"CODE",{});var D=p(w);P=o(D,"top_k=5"),D.forEach(t),z=o(C," en argument en l\u2019appelant."),C.forEach(t)},m(S,C){m(S,a,C),s(a,c),s(a,n),s(n,v),s(a,b),s(a,w),s(w,P),s(a,z)},d(S){S&&t(a)}}}function vc(k){let a,c,n,v,b,w,P,z,S,C,L,D,M,H,E,y,B,O,Ie,Gt,Kr,Vr,Jt,Wr,Br,fa,re,oe,Zs,Fe,Re,Rt,ns,Yr,et,Xr,Ht,Zr,ha,Pe,eo,st,so,to,Qt,no,ao,_a,as,va,rs,ba,tt,ro,$a,os,ga,ls,xa,nt,oo,qa,Ue,He,Kt,is,lo,Vt,io,ka,I,uo,Wt,po,mo,Bt,co,fo,us,Yt,ho,_o,Xt,vo,bo,at,$o,go,wa,le,ie,rt,ot,xo,ja,Ge,ps,qu,qo,ms,ku,Ea,F,ko,Zt,wo,jo,en,Eo,yo,sn,Po,Co,tn,zo,No,nn,So,To,ya,cs,Pa,ue,pe,lt,A,Lo,an,Do,Mo,rn,Ao,Oo,on,Io,Fo,ln,Uo,Go,un,Jo,Ro,pn,Ho,Qo,Ca,Qe,Ko,mn,Vo,Wo,za,me,ce,it,ut,Bo,Na,de,fe,pt,U,Yo,cn,Xo,Zo,dn,el,sl,fn,tl,nl,hn,al,rl,_n,ol,ll,Sa,R,il,vn,ul,pl,bn,ml,cl,$n,dl,fl,gn,hl,_l,Ta,Dm='<span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mrow><mi mathvariant="normal">s</mi><mi mathvariant="normal">t</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">r</mi><mi mathvariant="normal">t</mi><mi mathvariant="normal">_</mi><mi mathvariant="normal">p</mi><mi mathvariant="normal">r</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">b</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">b</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">l</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">t</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">s</mi></mrow><mo stretchy="false">[</mo><mrow><mi mathvariant="normal">s</mi><mi mathvariant="normal">t</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">r</mi><mi mathvariant="normal">t</mi><mi mathvariant="normal">_</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">n</mi><mi mathvariant="normal">d</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">x</mi></mrow><mo stretchy="false">]</mo><mo>\xD7</mo><mrow><mi mathvariant="normal">e</mi><mi mathvariant="normal">n</mi><mi mathvariant="normal">d</mi><mi mathvariant="normal">_</mi><mi mathvariant="normal">p</mi><mi mathvariant="normal">r</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">b</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">b</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">l</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">t</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">s</mi></mrow><mo stretchy="false">[</mo><mrow><mi mathvariant="normal">e</mi><mi mathvariant="normal">n</mi><mi mathvariant="normal">d</mi><mi mathvariant="normal">_</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">n</mi><mi mathvariant="normal">d</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">x</mi></mrow><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">\\mathrm{start\\_probabilities}[\\mathrm{start\\_index}] \\times \\mathrm{end\\_probabilities}[\\mathrm{end\\_index}]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.06em;vertical-align:-0.31em;"></span><span class="mord"><span class="mord mathrm">start_probabilities</span></span><span class="mopen">[</span><span class="mord"><span class="mord mathrm">start_index</span></span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">\xD7</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.06em;vertical-align:-0.31em;"></span><span class="mord"><span class="mord mathrm">end_probabilities</span></span><span class="mopen">[</span><span class="mord"><span class="mord mathrm">end_index</span></span><span class="mclose">]</span></span></span></span></span>',La,Ce,vl,Da,Mm='<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">s</mi><mi mathvariant="normal">t</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">r</mi><mi mathvariant="normal">t</mi><mi mathvariant="normal">_</mi><mi mathvariant="normal">p</mi><mi mathvariant="normal">r</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">b</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">b</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">l</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">t</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">s</mi></mrow><mo stretchy="false">[</mo><mrow><mi mathvariant="normal">s</mi><mi mathvariant="normal">t</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">r</mi><mi mathvariant="normal">t</mi><mi mathvariant="normal">_</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">n</mi><mi mathvariant="normal">d</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">x</mi></mrow><mo stretchy="false">]</mo><mo>\xD7</mo><mrow><mi mathvariant="normal">e</mi><mi mathvariant="normal">n</mi><mi mathvariant="normal">d</mi><mi mathvariant="normal">_</mi><mi mathvariant="normal">p</mi><mi mathvariant="normal">r</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">b</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">b</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">l</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">t</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">s</mi></mrow><mo stretchy="false">[</mo><mrow><mi mathvariant="normal">e</mi><mi mathvariant="normal">n</mi><mi mathvariant="normal">d</mi><mi mathvariant="normal">_</mi><mi mathvariant="normal">i</mi><mi mathvariant="normal">n</mi><mi mathvariant="normal">d</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">x</mi></mrow><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">\\mathrm{start\\_probabilities}[\\mathrm{start\\_index}] \\times \\mathrm{end\\_probabilities}[\\mathrm{end\\_index}]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.06em;vertical-align:-0.31em;"></span><span class="mord"><span class="mord mathrm">start_probabilities</span></span><span class="mopen">[</span><span class="mord"><span class="mord mathrm">start_index</span></span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">\xD7</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.06em;vertical-align:-0.31em;"></span><span class="mord"><span class="mord mathrm">end_probabilities</span></span><span class="mopen">[</span><span class="mord"><span class="mord mathrm">end_index</span></span><span class="mclose">]</span></span></span></span>',Ma,xn,bl,$l,Aa,mt,gl,Oa,ds,Ia,he,_e,ct,Q,xl,qn,ql,kl,kn,wl,jl,wn,El,yl,jn,Pl,Cl,Fa,fs,Ua,dt,zl,Ga,hs,Ja,Ke,Ra,G,Nl,En,Sl,Tl,yn,Ll,Dl,Pn,Ml,Al,Cn,Ol,Il,zn,Fl,Ul,Ha,_s,Qa,ft,Gl,Ka,vs,Va,bs,Wa,ht,Jl,Ba,Ve,Ya,Je,We,Nn,$s,Rl,Sn,Hl,Xa,ze,Ql,Tn,Kl,Vl,Ln,Wl,Bl,Za,gs,er,xs,sr,Be,Yl,Dn,Xl,Zl,tr,qs,nr,ks,ar,Ye,ei,Mn,si,ti,rr,Y,ni,An,ai,ri,On,oi,li,In,ii,ui,or,ws,lr,js,ir,K,pi,Fn,mi,ci,Un,di,fi,Gn,hi,_i,Jn,vi,bi,ur,_t,$i,pr,Es,mr,ys,cr,Ne,gi,Rn,xi,qi,Hn,ki,wi,dr,Ps,fr,Cs,hr,vt,ji,_r,zs,vr,bt,Ei,br,Ns,$r,$t,yi,gr,T,Pi,Qn,Ci,zi,Kn,Ni,Si,Vn,Ti,Li,Wn,Di,Mi,Bn,Ai,Oi,Yn,Ii,Fi,Xn,Ui,Gi,xr,Ss,qr,V,Ji,Zn,Ri,Hi,ea,Qi,Ki,sa,Vi,Wi,ta,Bi,Yi,kr,ve,be,gt,xt,Xi,wr,Ts,jr,$e,ge,qt,X,Zi,na,eu,su,aa,tu,nu,ra,au,ru,Er,xe,qe,kt,wt,ou,yr,ke,we,jt,Et,lu,Pr,je,Ee,yt,Ls,Cr,Xe,iu,oa,uu,pu,zr,Ze,Nr,Se,mu,la,cu,du,ia,fu,hu,Sr,Ds,Tr,Ms,Lr,Pt,_u,Dr,es,Mr,Te,vu,ua,bu,$u,pa,gu,xu,Ar;n=new Gm({props:{fw:k[0]}}),z=new Qr({});const wu=[Rm,Jm],As=[];function ju(e,l){return e[0]==="pt"?0:1}E=ju(k),y=As[E]=wu[E](k);const Eu=[Qm,Hm],Os=[];function yu(e,l){return e[0]==="pt"?0:1}re=yu(k),oe=Os[re]=Eu[re](k),ns=new Qr({}),as=new j({props:{code:"",highlighted:`<span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> pipeline

question_answerer = pipeline(<span class="hljs-string">&quot;question-answering&quot;</span>)
context = <span class="hljs-string">&quot;&quot;&quot;
\u{1F917} Transformers is backed by the three most popular deep learning libraries
 \u2014 Jax, PyTorch, and TensorFlow \u2014 with a seamless integration between them. 
It&#x27;s straightforward to train your models with one before loading them for inference with the other.
&quot;&quot;&quot;</span>
<span class="hljs-comment"># \u{1F917} Transformers s&#x27;appuie sur les trois biblioth\xE8ques d&#x27;apprentissage profond les plus populaires</span>
<span class="hljs-comment"># (Jax, PyTorch et TensorFlow) avec une int\xE9gration transparente entre elles.</span>
<span class="hljs-comment"># C&#x27;est simple d&#x27;entra\xEEner vos mod\xE8les avec l&#x27;une avant de les charger pour l&#x27;inf\xE9rence avec l&#x27;autre.</span>
question = <span class="hljs-string">&quot;Which deep learning libraries back \u{1F917} Transformers?&quot;</span>
<span class="hljs-comment"># Quelles biblioth\xE8ques d&#x27;apprentissage profond derri\xE8re \u{1F917} Transformers ?</span>
question_answerer(question=question, context=context)`}}),rs=new j({props:{code:`{'score': 0.97773,
 'start': 78,
 'end': 105,
 'answer': 'Jax, PyTorch and TensorFlow'}`,highlighted:`{<span class="hljs-string">&#x27;score&#x27;</span>: <span class="hljs-number">0.97773</span>,
 <span class="hljs-string">&#x27;start&#x27;</span>: <span class="hljs-number">78</span>,
 <span class="hljs-string">&#x27;end&#x27;</span>: <span class="hljs-number">105</span>,
 <span class="hljs-string">&#x27;answer&#x27;</span>: <span class="hljs-string">&#x27;Jax, PyTorch and TensorFlow&#x27;</span>}`}}),os=new j({props:{code:`















`,highlighted:`long_context = <span class="hljs-string">&quot;&quot;&quot;
\u{1F917} Transformers: State of the Art NLP

\u{1F917} Transformers provides thousands of pretrained models to perform tasks on texts such as classification, information extraction,
question answering, summarization, translation, text generation and more in over 100 languages.
Its aim is to make cutting-edge NLP easier to use for everyone.

\u{1F917} Transformers provides APIs to quickly download and use those pretrained models on a given text, fine-tune them on your own datasets and
then share them with the community on our model hub. At the same time, each python module defining an architecture is fully standalone and
can be modified to enable quick research experiments.

Why should I use transformers?

1. Easy-to-use state-of-the-art models:
  - High performance on NLU and NLG tasks.
  - Low barrier to entry for educators and practitioners.
  - Few user-facing abstractions with just three classes to learn.
  - A unified API for using all our pretrained models.
  - Lower compute costs, smaller carbon footprint:

2. Researchers can share trained models instead of always retraining.
  - Practitioners can reduce compute time and production costs.
  - Dozens of architectures with over 10,000 pretrained models, some in more than 100 languages.

3. Choose the right framework for every part of a model&#x27;s lifetime:
  - Train state-of-the-art models in 3 lines of code.
  - Move a single model between TF2.0/PyTorch frameworks at will.
  - Seamlessly pick the right framework for training, evaluation and production.

4. Easily customize a model or an example to your needs:
  - We provide examples for each architecture to reproduce the results published by its original authors.
  - Model internals are exposed as consistently as possible.
  - Model files can be used independently of the library for quick experiments.

\u{1F917} Transformers is backed by the three most popular deep learning libraries \u2014 Jax, PyTorch and TensorFlow \u2014 with a seamless integration
between them. It&#x27;s straightforward to train your models with one before loading them for inference with the other.
&quot;&quot;&quot;</span>

long_context - fr = <span class="hljs-string">&quot;&quot;&quot;
\u{1F917} Transformers : l&#x27;\xE9tat de l&#x27;art du NLP

\u{1F917} Transformers fournit des milliers de mod\xE8les pr\xE9-entra\xEEn\xE9s pour effectuer des t\xE2ches sur des textes telles que la classification, 
l&#x27;extraction d&#x27;informations, la r\xE9ponse \xE0 des questions, le r\xE9sum\xE9 de textes, la traduction, la g\xE9n\xE9ration de texte et plus encore dans plus de 100 langues.
Son objectif est de rendre le traitement automatique des langues de pointe plus facile \xE0 utiliser pour tout le monde.

\u{1F917} Transformers fournit des API permettant de t\xE9l\xE9charger et d&#x27;utiliser rapidement ces mod\xE8les pr\xE9-entra\xEEn\xE9s sur un texte donn\xE9, de les affiner sur vos propres ensembles de donn\xE9es et de les partager avec la communaut\xE9 sur notre site Web.
puis de les partager avec la communaut\xE9 sur notre hub de mod\xE8les. En m\xEAme temps, chaque module python d\xE9finissant une architecture est enti\xE8rement autonome et peut \xEAtre modifi\xE9 pour permettre des exp\xE9riences de recherche rapides.
peut \xEAtre modifi\xE9 pour permettre des exp\xE9riences de recherche rapides.

Pourquoi devrais-je utiliser des transformateurs ?

1. Des mod\xE8les de pointe faciles \xE0 utiliser :
  - Haute performance sur les t\xE2ches NLU et NLG.
  - Faible barri\xE8re \xE0 l&#x27;entr\xE9e pour les \xE9ducateurs et les praticiens.
  - Peu d&#x27;abstractions pour l&#x27;utilisateur avec seulement trois classes \xE0 apprendre.
  - Une API unifi\xE9e pour utiliser tous nos mod\xE8les pr\xE9-entra\xEEn\xE9s.
  - Des co\xFBts de calcul plus faibles, une empreinte carbone r\xE9duite :

2. Les chercheurs peuvent partager les mod\xE8les form\xE9s au lieu de toujours les reformer.
  - Les praticiens peuvent r\xE9duire le temps de calcul et les co\xFBts de production.
  - Des dizaines d&#x27;architectures avec plus de 10 000 mod\xE8les pr\xE9-form\xE9s, certains dans plus de 100 langues.

3. Choisissez le cadre appropri\xE9 pour chaque \xE9tape de la vie d&#x27;un mod\xE8le :
  - Entra\xEEnez des mod\xE8les de pointe en 3 lignes de code.
  - D\xE9placez un seul mod\xE8le entre les frameworks TF2.0/PyTorch \xE0 volont\xE9.
  - Choisissez de mani\xE8re transparente le bon framework pour l&#x27;entra\xEEnement, l&#x27;\xE9valuation et la production.

4. Adaptez facilement un mod\xE8le ou un exemple \xE0 vos besoins :
  - Nous fournissons des exemples pour chaque architecture afin de reproduire les r\xE9sultats publi\xE9s par ses auteurs originaux.
  - Les \xE9l\xE9ments internes des mod\xE8les sont expos\xE9s de mani\xE8re aussi coh\xE9rente que possible.
  - Les fichiers de mod\xE8les peuvent \xEAtre utilis\xE9s ind\xE9pendamment de la biblioth\xE8que pour des exp\xE9riences rapides.

\u{1F917} Transformers s&#x27;appuie sur les trois biblioth\xE8ques d&#x27;apprentissage profond les plus populaires (Jax, PyTorch et TensorFlow) avec une int\xE9gration parfaite
entre elles. Il est simple d&#x27;entra\xEEner vos mod\xE8les avec l&#x27;une avant de les charger pour l&#x27;inf\xE9rence avec l&#x27;autre.
&quot;&quot;&quot;</span>
question_answerer(question=question, context=long_context)`}}),ls=new j({props:{code:`{'score': 0.97149,
 'start': 1892,
 'end': 1919,
 'answer': 'Jax, PyTorch and TensorFlow'}`,highlighted:`{<span class="hljs-string">&#x27;score&#x27;</span>: <span class="hljs-number">0.97149</span>,
 <span class="hljs-string">&#x27;start&#x27;</span>: <span class="hljs-number">1892</span>,
 <span class="hljs-string">&#x27;end&#x27;</span>: <span class="hljs-number">1919</span>,
 <span class="hljs-string">&#x27;answer&#x27;</span>: <span class="hljs-string">&#x27;Jax, PyTorch and TensorFlow&#x27;</span>}`}}),is=new Qr({});const Pu=[Vm,Km],Is=[];function Cu(e,l){return e[0]==="pt"?0:1}le=Cu(k),ie=Is[le]=Pu[le](k),cs=new j({props:{code:`start_logits = outputs.start_logits
end_logits = outputs.end_logits
print(start_logits.shape, end_logits.shape)`,highlighted:`start_logits = outputs.start_logits
end_logits = outputs.end_logits
<span class="hljs-built_in">print</span>(start_logits.shape, end_logits.shape)`}});const zu=[Bm,Wm],Fs=[];function Nu(e,l){return e[0]==="pt"?0:1}ue=Nu(k),pe=Fs[ue]=zu[ue](k);const Su=[Xm,Ym],Us=[];function Tu(e,l){return e[0]==="pt"?0:1}me=Tu(k),ce=Us[me]=Su[me](k);const Lu=[ec,Zm],Gs=[];function Du(e,l){return e[0]==="pt"?0:1}de=Du(k),fe=Gs[de]=Lu[de](k),ds=new j({props:{code:"scores = start_probabilities[:, None] * end_probabilities[None, :]",highlighted:'scores = start_probabilities[:, <span class="hljs-literal">None</span>] * end_probabilities[<span class="hljs-literal">None</span>, :]'}});const Mu=[tc,sc],Js=[];function Au(e,l){return e[0]==="pt"?0:1}he=Au(k),_e=Js[he]=Mu[he](k),fs=new j({props:{code:`max_index = scores.argmax().item()
start_index = max_index // scores.shape[1]
end_index = max_index % scores.shape[1]
print(scores[start_index, end_index])`,highlighted:`max_index = scores.argmax().item()
start_index = max_index // scores.shape[<span class="hljs-number">1</span>]
end_index = max_index % scores.shape[<span class="hljs-number">1</span>]
<span class="hljs-built_in">print</span>(scores[start_index, end_index])`}}),hs=new j({props:{code:"0.97773",highlighted:'<span class="hljs-number">0.97773</span>'}}),Ke=new Hr({props:{$$slots:{default:[nc]},$$scope:{ctx:k}}}),_s=new j({props:{code:"",highlighted:`inputs_with_offsets = tokenizer(question, context, return_offsets_mapping=<span class="hljs-literal">True</span>)
offsets = inputs_with_offsets[<span class="hljs-string">&quot;offset_mapping&quot;</span>]

start_char, _ = offsets[start_index]
_, end_char = offsets[end_index]
answer = context[start_char:end_char]`}}),vs=new j({props:{code:`result = {
    "answer": answer,
    "start": start_char,
    "end": end_char,
    "score": scores[start_index, end_index],
}
print(result)`,highlighted:`result = {
    <span class="hljs-string">&quot;answer&quot;</span>: answer,
    <span class="hljs-string">&quot;start&quot;</span>: start_char,
    <span class="hljs-string">&quot;end&quot;</span>: end_char,
    <span class="hljs-string">&quot;score&quot;</span>: scores[start_index, end_index],
}
<span class="hljs-built_in">print</span>(result)`}}),bs=new j({props:{code:`{'answer': 'Jax, PyTorch and TensorFlow',
 'start': 78,
 'end': 105,
 'score': 0.97773}`,highlighted:`{<span class="hljs-string">&#x27;answer&#x27;</span>: <span class="hljs-string">&#x27;Jax, PyTorch and TensorFlow&#x27;</span>,
 <span class="hljs-string">&#x27;start&#x27;</span>: <span class="hljs-number">78</span>,
 <span class="hljs-string">&#x27;end&#x27;</span>: <span class="hljs-number">105</span>,
 <span class="hljs-string">&#x27;score&#x27;</span>: <span class="hljs-number">0.97773</span>}`}}),Ve=new Hr({props:{$$slots:{default:[ac]},$$scope:{ctx:k}}}),$s=new Qr({}),gs=new j({props:{code:`inputs = tokenizer(question, long_context)
print(len(inputs["input_ids"]))`,highlighted:`inputs = tokenizer(question, long_context)
<span class="hljs-built_in">print</span>(<span class="hljs-built_in">len</span>(inputs[<span class="hljs-string">&quot;input_ids&quot;</span>]))`}}),xs=new j({props:{code:"461",highlighted:'<span class="hljs-number">461</span>'}}),qs=new j({props:{code:`inputs = tokenizer(question, long_context, max_length=384, truncation="only_second")
print(tokenizer.decode(inputs["input_ids"]))`,highlighted:`inputs = tokenizer(question, long_context, max_length=<span class="hljs-number">384</span>, truncation=<span class="hljs-string">&quot;only_second&quot;</span>)
<span class="hljs-built_in">print</span>(tokenizer.decode(inputs[<span class="hljs-string">&quot;input_ids&quot;</span>]))`}}),ks=new j({props:{code:`













`,highlighted:`<span class="hljs-string">&quot;&quot;&quot;
[CLS] Which deep learning libraries back [UNK] Transformers? [SEP] [UNK] Transformers : State of the Art NLP

[UNK] Transformers provides thousands of pretrained models to perform tasks on texts such as classification, information extraction,
question answering, summarization, translation, text generation and more in over 100 languages.
Its aim is to make cutting-edge NLP easier to use for everyone.

[UNK] Transformers provides APIs to quickly download and use those pretrained models on a given text, fine-tune them on your own datasets and
then share them with the community on our model hub. At the same time, each python module defining an architecture is fully standalone and
can be modified to enable quick research experiments.

Why should I use transformers?

1. Easy-to-use state-of-the-art models:
  - High performance on NLU and NLG tasks.
  - Low barrier to entry for educators and practitioners.
  - Few user-facing abstractions with just three classes to learn.
  - A unified API for using all our pretrained models.
  - Lower compute costs, smaller carbon footprint:

2. Researchers can share trained models instead of always retraining.
  - Practitioners can reduce compute time and production costs.
  - Dozens of architectures with over 10,000 pretrained models, some in more than 100 languages.

3. Choose the right framework for every part of a model&#x27;s lifetime:
  - Train state-of-the-art models in 3 lines of code.
  - Move a single model between TF2.0/PyTorch frameworks at will.
  - Seamlessly pick the right framework for training, evaluation and production.

4. Easily customize a model or an example to your needs:
  - We provide examples for each architecture to reproduce the results published by its original authors.
  - Model internal [SEP]
&quot;&quot;&quot;</span>

<span class="hljs-string">&quot;&quot;&quot;
[CLS] Quelles sont les biblioth\xE8ques d&#x27;apprentissage profond qui soutiennent [UNK] Transformers ? [SEP] [UNK] Transformers : l&#x27;\xE9tat de l&#x27;art du NLP

[UNK] Transformers fournit des milliers de mod\xE8les pr\xE9-entra\xEEn\xE9s pour effectuer des t\xE2ches sur des textes telles que la classification, l&#x27;extraction d&#x27;informations, la r\xE9ponse \xE0 des questions, le r\xE9sum\xE9, la traduction, la g\xE9n\xE9ration de textes, etc,
la r\xE9ponse \xE0 des questions, le r\xE9sum\xE9, la traduction, la g\xE9n\xE9ration de texte et plus encore dans plus de 100 langues.
Son objectif est de rendre le traitement automatique des langues de pointe plus facile \xE0 utiliser pour tous.

Transformers [UNK] fournit des API permettant de t\xE9l\xE9charger et d&#x27;utiliser rapidement ces mod\xE8les pr\xE9-entra\xEEn\xE9s sur un texte donn\xE9, de les affiner sur vos propres ensembles de donn\xE9es et de les partager avec la communaut\xE9 sur notre site Web.
puis de les partager avec la communaut\xE9 sur notre hub de mod\xE8les. En m\xEAme temps, chaque module python d\xE9finissant une architecture est enti\xE8rement autonome et peut \xEAtre modifi\xE9 pour permettre des exp\xE9riences de recherche rapides.
peut \xEAtre modifi\xE9 pour permettre des exp\xE9riences de recherche rapides.

Pourquoi devrais-je utiliser des transformateurs ?

1. Des mod\xE8les de pointe faciles \xE0 utiliser :
  - Haute performance sur les t\xE2ches NLU et NLG.
  - Faible barri\xE8re \xE0 l&#x27;entr\xE9e pour les \xE9ducateurs et les praticiens.
  - Peu d&#x27;abstractions pour l&#x27;utilisateur avec seulement trois classes \xE0 apprendre.
  - Une API unifi\xE9e pour utiliser tous nos mod\xE8les pr\xE9-entra\xEEn\xE9s.
  - Des co\xFBts de calcul plus faibles, une empreinte carbone r\xE9duite :

2. Les chercheurs peuvent partager les mod\xE8les form\xE9s au lieu de toujours les reformer.
  - Les praticiens peuvent r\xE9duire le temps de calcul et les co\xFBts de production.
  - Des dizaines d&#x27;architectures avec plus de 10 000 mod\xE8les pr\xE9-form\xE9s, certains dans plus de 100 langues.

3. Choisissez le cadre appropri\xE9 pour chaque \xE9tape de la vie d&#x27;un mod\xE8le :
  - Entra\xEEnez des mod\xE8les de pointe en 3 lignes de code.
  - D\xE9placez un seul mod\xE8le entre les frameworks TF2.0/PyTorch \xE0 volont\xE9.
  - Choisissez de mani\xE8re transparente le bon framework pour l&#x27;entra\xEEnement, l&#x27;\xE9valuation et la production.

4. Adaptez facilement un mod\xE8le ou un exemple \xE0 vos besoins :
  - Nous fournissons des exemples pour chaque architecture afin de reproduire les r\xE9sultats publi\xE9s par ses auteurs originaux.
  - Mod\xE8le interne [SEP]
&quot;&quot;&quot;</span>`}}),ws=new j({props:{code:"",highlighted:`sentence = <span class="hljs-string">&quot;This sentence is not too long but we are going to split it anyway.&quot;</span>
<span class="hljs-comment"># &quot;Cette phrase n&#x27;est pas trop longue mais nous allons la diviser quand m\xEAme.&quot;</span>
inputs = tokenizer(
    sentence, truncation=<span class="hljs-literal">True</span>, return_overflowing_tokens=<span class="hljs-literal">True</span>, max_length=<span class="hljs-number">6</span>, stride=<span class="hljs-number">2</span>
)

<span class="hljs-keyword">for</span> ids <span class="hljs-keyword">in</span> inputs[<span class="hljs-string">&quot;input_ids&quot;</span>]:
    <span class="hljs-built_in">print</span>(tokenizer.decode(ids))`}}),js=new j({props:{code:`'[CLS] This sentence is not [SEP]'
'[CLS] is not too long [SEP]'
'[CLS] too long but we [SEP]'
'[CLS] but we are going [SEP]'
'[CLS] are going to split [SEP]'
'[CLS] to split it anyway [SEP]'
'[CLS] it anyway. [SEP]'`,highlighted:`<span class="hljs-string">&#x27;[CLS] This sentence is not [SEP]&#x27;</span>
<span class="hljs-string">&#x27;[CLS] is not too long [SEP]&#x27;</span>
<span class="hljs-string">&#x27;[CLS] too long but we [SEP]&#x27;</span>
<span class="hljs-string">&#x27;[CLS] but we are going [SEP]&#x27;</span>
<span class="hljs-string">&#x27;[CLS] are going to split [SEP]&#x27;</span>
<span class="hljs-string">&#x27;[CLS] to split it anyway [SEP]&#x27;</span>
<span class="hljs-string">&#x27;[CLS] it anyway. [SEP]&#x27;</span>`}}),Es=new j({props:{code:"print(inputs.keys())",highlighted:'<span class="hljs-built_in">print</span>(inputs.keys())'}}),ys=new j({props:{code:"dict_keys(['input_ids', 'attention_mask', 'overflow_to_sample_mapping'])",highlighted:'dict_keys([<span class="hljs-string">&#x27;input_ids&#x27;</span>, <span class="hljs-string">&#x27;attention_mask&#x27;</span>, <span class="hljs-string">&#x27;overflow_to_sample_mapping&#x27;</span>])'}}),Ps=new j({props:{code:'print(inputs["overflow_to_sample_mapping"])',highlighted:'<span class="hljs-built_in">print</span>(inputs[<span class="hljs-string">&quot;overflow_to_sample_mapping&quot;</span>])'}}),Cs=new j({props:{code:"[0, 0, 0, 0, 0, 0, 0]",highlighted:'[<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>]'}}),zs=new j({props:{code:"",highlighted:`sentences = [
    <span class="hljs-string">&quot;This sentence is not too long but we are going to split it anyway.&quot;</span>,
    <span class="hljs-comment"># Cette phrase n&#x27;est pas trop longue mais nous allons la diviser quand m\xEAme.</span>
    <span class="hljs-string">&quot;This sentence is shorter but will still get split.&quot;</span>,
    <span class="hljs-comment"># Cette phrase est plus courte mais sera quand m\xEAme divis\xE9e.</span>
]
inputs = tokenizer(
    sentences, truncation=<span class="hljs-literal">True</span>, return_overflowing_tokens=<span class="hljs-literal">True</span>, max_length=<span class="hljs-number">6</span>, stride=<span class="hljs-number">2</span>
)

<span class="hljs-built_in">print</span>(inputs[<span class="hljs-string">&quot;overflow_to_sample_mapping&quot;</span>])`}}),Ns=new j({props:{code:"[0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1]",highlighted:'[<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>]'}}),Ss=new j({props:{code:`inputs = tokenizer(
    question,
    long_context,
    stride=128,
    max_length=384,
    padding="longest",
    truncation="only_second",
    return_overflowing_tokens=True,
    return_offsets_mapping=True,
)`,highlighted:`inputs = tokenizer(
    question,
    long_context,
    stride=<span class="hljs-number">128</span>,
    max_length=<span class="hljs-number">384</span>,
    padding=<span class="hljs-string">&quot;longest&quot;</span>,
    truncation=<span class="hljs-string">&quot;only_second&quot;</span>,
    return_overflowing_tokens=<span class="hljs-literal">True</span>,
    return_offsets_mapping=<span class="hljs-literal">True</span>,
)`}});const Ou=[oc,rc],Rs=[];function Iu(e,l){return e[0]==="pt"?0:1}ve=Iu(k),be=Rs[ve]=Ou[ve](k),Ts=new j({props:{code:"",highlighted:`outputs = model(**inputs)

start_logits = outputs.start_logits
end_logits = outputs.end_logits
<span class="hljs-built_in">print</span>(start_logits.shape, end_logits.shape)`}});const Fu=[ic,lc],Hs=[];function Uu(e,l){return e[0]==="pt"?0:1}$e=Uu(k),ge=Hs[$e]=Fu[$e](k);const Gu=[pc,uc],Qs=[];function Ju(e,l){return e[0]==="pt"?0:1}xe=Ju(k),qe=Qs[xe]=Gu[xe](k);const Ru=[cc,mc],Ks=[];function Hu(e,l){return e[0]==="pt"?0:1}ke=Hu(k),we=Ks[ke]=Ru[ke](k);const Qu=[fc,dc],Vs=[];function Ku(e,l){return e[0]==="pt"?0:1}return je=Ku(k),Ee=Vs[je]=Qu[je](k),Ls=new j({props:{code:"[(0, 18, 0.33867), (173, 184, 0.97149)]",highlighted:'[(<span class="hljs-number">0</span>, <span class="hljs-number">18</span>, <span class="hljs-number">0.33867</span>), (<span class="hljs-number">173</span>, <span class="hljs-number">184</span>, <span class="hljs-number">0.97149</span>)]'}}),Ze=new Hr({props:{$$slots:{default:[hc]},$$scope:{ctx:k}}}),Ds=new j({props:{code:`for candidate, offset in zip(candidates, offsets):
    start_token, end_token, score = candidate
    start_char, _ = offset[start_token]
    _, end_char = offset[end_token]
    answer = long_context[start_char:end_char]
    result = {"answer": answer, "start": start_char, "end": end_char, "score": score}
    print(result)`,highlighted:`<span class="hljs-keyword">for</span> candidate, offset <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(candidates, offsets):
    start_token, end_token, score = candidate
    start_char, _ = offset[start_token]
    _, end_char = offset[end_token]
    answer = long_context[start_char:end_char]
    result = {<span class="hljs-string">&quot;answer&quot;</span>: answer, <span class="hljs-string">&quot;start&quot;</span>: start_char, <span class="hljs-string">&quot;end&quot;</span>: end_char, <span class="hljs-string">&quot;score&quot;</span>: score}
    <span class="hljs-built_in">print</span>(result)`}}),Ms=new j({props:{code:`{'answer': '\\n\u{1F917} Transformers: State of the Art NLP', 'start': 0, 'end': 37, 'score': 0.33867}
{'answer': 'Jax, PyTorch and TensorFlow', 'start': 1892, 'end': 1919, 'score': 0.97149}`,highlighted:`{<span class="hljs-string">&#x27;answer&#x27;</span>: <span class="hljs-string">&#x27;\\n\u{1F917} Transformers: State of the Art NLP&#x27;</span>, <span class="hljs-string">&#x27;start&#x27;</span>: <span class="hljs-number">0</span>, <span class="hljs-string">&#x27;end&#x27;</span>: <span class="hljs-number">37</span>, <span class="hljs-string">&#x27;score&#x27;</span>: <span class="hljs-number">0.33867</span>}
{<span class="hljs-string">&#x27;answer&#x27;</span>: <span class="hljs-string">&#x27;Jax, PyTorch and TensorFlow&#x27;</span>, <span class="hljs-string">&#x27;start&#x27;</span>: <span class="hljs-number">1892</span>, <span class="hljs-string">&#x27;end&#x27;</span>: <span class="hljs-number">1919</span>, <span class="hljs-string">&#x27;score&#x27;</span>: <span class="hljs-number">0.97149</span>}`}}),es=new Hr({props:{$$slots:{default:[_c]},$$scope:{ctx:k}}}),{c(){a=i("meta"),c=d(),$(n.$$.fragment),v=d(),b=i("h1"),w=i("a"),P=i("span"),$(z.$$.fragment),S=d(),C=i("span"),L=i("i"),D=r("Tokenizer"),M=r(" rapide dans le pipeline de QA"),H=d(),y.c(),B=d(),O=i("p"),Ie=r("Nous allons maintenant nous plonger dans le pipeline de "),Gt=i("code"),Kr=r("question-answering"),Vr=r(" et voir comment exploiter les "),Jt=i("em"),Wr=r("offsets"),Br=r(" pour extraire d\u2019u ncontexte la r\xE9ponse \xE0 la question pos\xE9e. Nous verrons ensuite comment g\xE9rer les contextes tr\xE8s longs qui finissent par \xEAtre tronqu\xE9s. Vous pouvez sauter cette section si vous n\u2019\xEAtes pas int\xE9ress\xE9 par la t\xE2che de r\xE9ponse aux questions."),fa=d(),oe.c(),Zs=d(),Fe=i("h2"),Re=i("a"),Rt=i("span"),$(ns.$$.fragment),Yr=d(),et=i("span"),Xr=r("Utilisation du pipeline de "),Ht=i("code"),Zr=r("question-answering"),ha=d(),Pe=i("p"),eo=r("Comme nous l\u2019avons vu dans le "),st=i("a"),so=r("chapitre 1"),to=r(", nous pouvons utiliser le pipeline de "),Qt=i("code"),no=r("question-answering"),ao=r(" comme ceci pour obtenir une r\xE9ponse \xE0 une question :"),_a=d(),$(as.$$.fragment),va=d(),$(rs.$$.fragment),ba=d(),tt=i("p"),ro=r("Contrairement aux autres pipelines, qui ne peuvent pas tronquer et diviser les textes dont la longueur est sup\xE9rieure \xE0 la longueur maximale accept\xE9e par le mod\xE8le (et qui peuvent donc manquer des informations \xE0 la fin d\u2019un document), ce pipeline peut traiter des contextes tr\xE8s longs et retournera la r\xE9ponse \xE0 la question m\xEAme si elle se trouve \xE0 la fin :"),$a=d(),$(os.$$.fragment),ga=d(),$(ls.$$.fragment),xa=d(),nt=i("p"),oo=r("Voyons comment il fait tout cela !"),qa=d(),Ue=i("h3"),He=i("a"),Kt=i("span"),$(is.$$.fragment),lo=d(),Vt=i("span"),io=r("Utilisation d'un mod\xE8le pour r\xE9pondre \xE0 des questions"),ka=d(),I=i("p"),uo=r("Comme avec n\u2019importe quel autre pipeline, nous commen\xE7ons par tokeniser notre entr\xE9e et l\u2019envoyons ensuite \xE0 travers le mod\xE8le. Le "),Wt=i("em"),po=r("checkpoint"),mo=r(" utilis\xE9 par d\xE9faut pour le pipeline de "),Bt=i("code"),co=r("question-answering"),fo=r(" est "),us=i("a"),Yt=i("code"),ho=r("distilbert-base-cased-distilled-squad"),_o=r(" (le \xAB squad \xBB dans le nom vient du jeu de donn\xE9es sur lequel le mod\xE8le a \xE9t\xE9 "),Xt=i("em"),vo=r("finetun\xE9"),bo=r(", nous parlerons davantage de ce jeu de donn\xE9es dans le "),at=i("a"),$o=r("chapitre 7"),go=r(") :"),wa=d(),ie.c(),rt=d(),ot=i("p"),xo=r("Notez que nous tokenizons la question et le contexte comme une paire, la question en premier."),ja=d(),Ge=i("div"),ps=i("img"),qo=d(),ms=i("img"),Ea=d(),F=i("p"),ko=r("Les mod\xE8les de r\xE9ponse aux questions fonctionnent un peu diff\xE9remment des mod\xE8les que nous avons vus jusqu\u2019\xE0 pr\xE9sent. En utilisant l\u2019image ci-dessus comme exemple, le mod\xE8le a \xE9t\xE9 entra\xEEn\xE9 \xE0 pr\xE9dire l\u2019index du "),Zt=i("em"),wo=r("token"),jo=r(" de d\xE9but de la r\xE9ponse (ici 21) et l\u2019index du "),en=i("em"),Eo=r("token"),yo=r(" o\xF9 la r\xE9ponse se termine (ici 24). C\u2019est pourquoi ces mod\xE8les ne retournent pas un tenseur de logits mais deux : un pour les logits correspondant au "),sn=i("em"),Po=r("token"),Co=r(" de d\xE9but de la r\xE9ponse, et un pour les logits correspondant au "),tn=i("em"),zo=r("token"),No=r(" de fin de la r\xE9ponse. Puisque dans ce cas nous n\u2019avons qu\u2019une seule entr\xE9e contenant 66 "),nn=i("em"),So=r("tokens"),To=r(", nous obtenons :"),ya=d(),$(cs.$$.fragment),Pa=d(),pe.c(),lt=d(),A=i("p"),Lo=r("Pour convertir ces logits en probabilit\xE9s, nous allons appliquer une fonction softmax. Mais avant cela, nous devons nous assurer de masquer les indices qui ne font pas partie du contexte. Notre entr\xE9e est "),an=i("code"),Do=r("[CLS] question [SEP] contexte [SEP]"),Mo=r(" donc nous devons masquer les "),rn=i("em"),Ao=r("tokens"),Oo=r(" de la question ainsi que le "),on=i("em"),Io=r("token"),Fo=d(),ln=i("code"),Uo=r("[SEP]"),Go=r(". Nous garderons cependant le "),un=i("em"),Jo=r("token"),Ro=d(),pn=i("code"),Ho=r("[CLS]"),Qo=r(" car certains mod\xE8les l\u2019utilisent pour indiquer que la r\xE9ponse n\u2019est pas dans le contexte."),Ca=d(),Qe=i("p"),Ko=r("Puisque nous appliquerons une fonction softmax par la suite, il nous suffit de remplacer les logits que nous voulons masquer par un grand nombre n\xE9gatif. Ici, nous utilisons "),mn=i("code"),Vo=r("-10000"),Wo=r(" :"),za=d(),ce.c(),it=d(),ut=i("p"),Bo=r("Maintenant que nous avons correctement masqu\xE9 les logits correspondant aux positions que nous ne voulons pas pr\xE9dire, nous pouvons appliquer la softmax :"),Na=d(),fe.c(),pt=d(),U=i("p"),Yo=r("A ce stade, nous pourrions prendre l\u2019argmax des probabilit\xE9s de d\xE9but et de fin mais nous pourrions nous retrouver avec un indice de d\xE9but sup\xE9rieur \xE0 l\u2019indice de fin. Nous devons donc prendre quelques pr\xE9cautions suppl\xE9mentaires. Nous allons calculer les probabilit\xE9s de chaque "),cn=i("code"),Xo=r("start_index"),Zo=r(" et "),dn=i("code"),el=r("end_index"),sl=r(" possible o\xF9 "),fn=i("code"),tl=r("start_index<=end_index"),nl=r(", puis nous prendrons le "),hn=i("em"),al=r("tuple"),rl=d(),_n=i("code"),ol=r("(start_index, end_index)"),ll=r(" avec la plus grande probabilit\xE9."),Sa=d(),R=i("p"),il=r("En supposant que les \xE9v\xE9nements \xAB La r\xE9ponse commence \xE0 "),vn=i("code"),ul=r("start_index"),pl=r(" \xBB et \xAB La r\xE9ponse se termine \xE0 "),bn=i("code"),ml=r("end_index"),cl=r(" \xBB sont ind\xE9pendants, la probabilit\xE9 que la r\xE9ponse commence \xE0 "),$n=i("code"),dl=r("end_index"),fl=r(" et se termine \xE0 "),gn=i("code"),hl=r("end_index"),_l=r(` est :
`),Ta=new zm,La=d(),Ce=i("p"),vl=r("Ainsi, pour calculer tous les scores, il suffit de calculer tous les produits "),Da=new zm,Ma=r(" o\xF9 "),xn=i("code"),bl=r("start_index <= end_index"),$l=r("."),Aa=d(),mt=i("p"),gl=r("Calculons d\u2019abord tous les produits possibles :"),Oa=d(),$(ds.$$.fragment),Ia=d(),_e.c(),ct=d(),Q=i("p"),xl=r("Il ne nous reste plus qu\u2019\xE0 obtenir l\u2019indice du maximum. Puisque PyTorch retourne l\u2019index dans le tenseur aplati, nous devons utiliser les op\xE9rations division "),qn=i("code"),ql=r("//"),kl=r(" et modulo "),kn=i("code"),wl=r("%"),jl=r(" pour obtenir le "),wn=i("code"),El=r("start_index"),yl=r(" et le "),jn=i("code"),Pl=r("end_index"),Cl=r(" :"),Fa=d(),$(fs.$$.fragment),Ua=d(),dt=i("p"),zl=r("Nous n\u2019avons pas encore tout \xE0 fait termin\xE9, mais au moins nous avons d\xE9j\xE0 le score correct pour la r\xE9ponse (vous pouvez le v\xE9rifier en le comparant au premier r\xE9sultat de la section pr\xE9c\xE9dente) :"),Ga=d(),$(hs.$$.fragment),Ja=d(),$(Ke.$$.fragment),Ra=d(),G=i("p"),Nl=r("Nous avons les "),En=i("code"),Sl=r("start_index"),Tl=r(" et "),yn=i("code"),Ll=r("end_index"),Dl=r(" de la r\xE9ponse en termes de "),Pn=i("em"),Ml=r("tokens"),Al=r(". Maintenant nous devons juste convertir en indices de caract\xE8res dans le contexte. C\u2019est l\xE0 que les "),Cn=i("em"),Ol=r("offsets"),Il=r(" seront super utiles. Nous pouvons les saisir et les utiliser comme nous l\u2019avons fait dans la t\xE2che de classification des "),zn=i("em"),Fl=r("tokens"),Ul=r(" :"),Ha=d(),$(_s.$$.fragment),Qa=d(),ft=i("p"),Gl=r("Il ne nous reste plus qu\u2019\xE0 tout formater pour obtenir notre r\xE9sultat :"),Ka=d(),$(vs.$$.fragment),Va=d(),$(bs.$$.fragment),Wa=d(),ht=i("p"),Jl=r("Super ! C\u2019est la m\xEAme chose que dans notre premier exemple !"),Ba=d(),$(Ve.$$.fragment),Ya=d(),Je=i("h2"),We=i("a"),Nn=i("span"),$($s.$$.fragment),Rl=d(),Sn=i("span"),Hl=r("Gestion des contextes longs"),Xa=d(),ze=i("p"),Ql=r("Si nous essayons de tokeniser la question et le long contexte que nous avons utilis\xE9 dans l\u2019exemple pr\xE9c\xE9demment, nous obtenons un nombre de "),Tn=i("em"),Kl=r("tokens"),Vl=r(" sup\xE9rieur \xE0 la longueur maximale utilis\xE9e dans le pipeline "),Ln=i("code"),Wl=r("question-answering"),Bl=r(" (qui est de 384) :"),Za=d(),$(gs.$$.fragment),er=d(),$(xs.$$.fragment),sr=d(),Be=i("p"),Yl=r("Nous devrons donc tronquer nos entr\xE9es \xE0 cette longueur maximale. Il y a plusieurs fa\xE7ons de le faire mais nous ne voulons pas tronquer la question, seulement le contexte. Puisque le contexte est la deuxi\xE8me phrase, nous utilisons la strat\xE9gie de troncature "),Dn=i("code"),Xl=r('"only_second"'),Zl=r(". Le probl\xE8me qui se pose alors est que la r\xE9ponse \xE0 la question peut ne pas se trouver dans le contexte tronqu\xE9. Ici, par exemple, nous avons choisi une question dont la r\xE9ponse se trouve vers la fin du contexte, et lorsque nous la tronquons, cette r\xE9ponse n\u2019est pas pr\xE9sente :"),tr=d(),$(qs.$$.fragment),nr=d(),$(ks.$$.fragment),ar=d(),Ye=i("p"),ei=r("Cela signifie que le mod\xE8le a du mal \xE0 trouver la bonne r\xE9ponse. Pour r\xE9soudre ce probl\xE8me, le pipeline de "),Mn=i("code"),si=r("question-answering"),ti=r(" nous permet de diviser le contexte en morceaux plus petits, en sp\xE9cifiant la longueur maximale. Pour s\u2019assurer que nous ne divisons pas le contexte exactement au mauvais endroit pour permettre de trouver la r\xE9ponse, il inclut \xE9galement un certain chevauchement entre les morceaux."),rr=d(),Y=i("p"),ni=r("Nous pouvons demander au "),An=i("em"),ai=r("tokenizer"),ri=r(" (rapide ou lent) de le faire pour nous en ajoutant "),On=i("code"),oi=r("return_overflowing_tokens=True"),li=r(", et nous pouvons sp\xE9cifier le chevauchement que nous voulons avec l\u2019argument "),In=i("code"),ii=r("stride"),ui=r(". Voici un exemple, en utilisant une phrase plus petite :"),or=d(),$(ws.$$.fragment),lr=d(),$(js.$$.fragment),ir=d(),K=i("p"),pi=r("Comme on peut le voir, la phrase a \xE9t\xE9 d\xE9coup\xE9e en morceaux de telle sorte que chaque entr\xE9e dans "),Fn=i("code"),mi=r('inputs["input_ids"]'),ci=r(" a au maximum 6 "),Un=i("em"),di=r("tokens"),fi=r(" (il faudrait ajouter du "),Gn=i("em"),hi=r("padding"),_i=r(" pour que la derni\xE8re entr\xE9e ait la m\xEAme taille que les autres) et il y a un chevauchement de 2 "),Jn=i("em"),vi=r("tokens"),bi=r(" entre chacune des entr\xE9es."),ur=d(),_t=i("p"),$i=r("Regardons de plus pr\xE8s le r\xE9sultat de la tok\xE9nisation :"),pr=d(),$(Es.$$.fragment),mr=d(),$(ys.$$.fragment),cr=d(),Ne=i("p"),gi=r("Comme pr\xE9vu, nous obtenons les identifiants d\u2019entr\xE9e et un masque d\u2019attention. La derni\xE8re cl\xE9, "),Rn=i("code"),xi=r("overflow_to_sample_mapping"),qi=r(", est une carte qui nous indique \xE0 quelle phrase correspond chacun des r\xE9sultats. Ici nous avons 7 r\xE9sultats qui proviennent tous de la (seule) phrase que nous avons pass\xE9e au "),Hn=i("em"),ki=r("tokenizer"),wi=r(" :"),dr=d(),$(Ps.$$.fragment),fr=d(),$(Cs.$$.fragment),hr=d(),vt=i("p"),ji=r("C\u2019est plus utile lorsque nous tokenisons plusieurs phrases ensemble. Par exemple :"),_r=d(),$(zs.$$.fragment),vr=d(),bt=i("p"),Ei=r("nous donne :"),br=d(),$(Ns.$$.fragment),$r=d(),$t=i("p"),yi=r("ce qui signifie que la premi\xE8re phrase est divis\xE9e en 7 morceaux comme pr\xE9c\xE9demment et que les 4 morceaux suivants proviennent de la deuxi\xE8me phrase."),gr=d(),T=i("p"),Pi=r("Revenons maintenant \xE0 notre contexte long. Par d\xE9faut, le pipeline "),Qn=i("code"),Ci=r("question-answering"),zi=r(" utilise une longueur maximale de 384 et un "),Kn=i("em"),Ni=r("stride"),Si=r(" de 128, qui correspondent \xE0 la fa\xE7on dont le mod\xE8le a \xE9t\xE9 "),Vn=i("em"),Ti=r("finetun\xE9"),Li=r(" (vous pouvez ajuster ces param\xE8tres en passant les arguments "),Wn=i("code"),Di=r("max_seq_len"),Mi=r(" et "),Bn=i("code"),Ai=r("stride"),Oi=r(" lorsque vous appelez le pipeline). Nous utiliserons donc ces param\xE8tres lors de la tokenisation. Nous ajouterons aussi du "),Yn=i("em"),Ii=r("padding"),Fi=r(" (pour avoir des \xE9chantillons de m\xEAme longueur afin de pouvoir construire des tenseurs) ainsi que demander les "),Xn=i("em"),Ui=r("offsets"),Gi=r(" :"),xr=d(),$(Ss.$$.fragment),qr=d(),V=i("p"),Ji=r("Ces "),Zn=i("code"),Ri=r("inputs"),Hi=r(" contiendront les identifiants d\u2019entr\xE9e, les masques d\u2019attention que le mod\xE8le attend, ainsi que les "),ea=i("em"),Qi=r("offsets"),Ki=r(" et le "),sa=i("code"),Vi=r("overflow_to_sample_mapping"),Wi=r(" dont on vient de parler. Puisque ces deux \xE9l\xE9ments ne sont pas des param\xE8tres utilis\xE9s par le mod\xE8le, nous allons les sortir des "),ta=i("code"),Bi=r("inputs"),Yi=r(" (et nous ne stockerons pas la correspondance puisqu\u2019elle n\u2019est pas utile ici) avant de le convertir en tenseur :"),kr=d(),be.c(),gt=d(),xt=i("p"),Xi=r("Notre contexte long a \xE9t\xE9 divis\xE9 en deux, ce qui signifie qu\u2019apr\xE8s avoir travers\xE9 notre mod\xE8le, nous aurons deux ensembles de logits de d\xE9but et de fin :"),wr=d(),$(Ts.$$.fragment),jr=d(),ge.c(),qt=d(),X=i("p"),Zi=r("Comme pr\xE9c\xE9demment, nous masquons d\u2019abord les "),na=i("em"),eu=r("tokens"),su=r(" qui ne font pas partie du contexte avant de prendre le softmax. Nous masquons \xE9galement tous les "),aa=i("em"),tu=r("tokens"),nu=r(" de "),ra=i("em"),au=r("padding"),ru=r(" (tels que signal\xE9s par le masque d\u2019attention) :"),Er=d(),qe.c(),kt=d(),wt=i("p"),ou=r("Ensuite, nous pouvons utiliser la fonction softmax pour convertir nos logits en probabilit\xE9s :"),yr=d(),we.c(),jt=d(),Et=i("p"),lu=r("L\u2019\xE9tape suivante est similaire \xE0 ce que nous avons fait pour le petit contexte mais nous la r\xE9p\xE9tons pour chacun de nos deux morceaux. Nous attribuons un score \xE0 tous les espaces de r\xE9ponse possibles puis nous prenons l\u2019espace ayant le meilleur score :"),Pr=d(),Ee.c(),yt=d(),$(Ls.$$.fragment),Cr=d(),Xe=i("p"),iu=r("Ces deux candidats correspondent aux meilleures r\xE9ponses que le mod\xE8le a pu trouver dans chaque morceau. Le mod\xE8le est beaucoup plus confiant dans le fait que la bonne r\xE9ponse se trouve dans la deuxi\xE8me partie (ce qui est bon signe !). Il ne nous reste plus qu\u2019\xE0 faire correspondre ces deux espaces de "),oa=i("em"),uu=r("tokens"),pu=r(" \xE0 des espaces de caract\xE8res dans le contexte (nous n\u2019avons besoin de faire correspondre que le second pour avoir notre r\xE9ponse, mais il est int\xE9ressant de voir ce que le mod\xE8le a choisi dans le premier morceau)."),zr=d(),$(Ze.$$.fragment),Nr=d(),Se=i("p"),mu=r("Le "),la=i("code"),cu=r("offsets"),du=r(" que nous avons saisi plus t\xF4t est en fait une liste d\u2019"),ia=i("em"),fu=r("offsets"),hu=r(" avec une liste par morceau de texte :"),Sr=d(),$(Ds.$$.fragment),Tr=d(),$(Ms.$$.fragment),Lr=d(),Pt=i("p"),_u=r("Si nous ignorons le premier r\xE9sultat, nous obtenons le m\xEAme r\xE9sultat que notre pipeline pour ce long contexte !"),Dr=d(),$(es.$$.fragment),Mr=d(),Te=i("p"),vu=r("Ceci conclut notre plong\xE9e en profondeur dans les capacit\xE9s du "),ua=i("em"),bu=r("tokenizer"),$u=r(". Nous mettrons \xE0 nouveau tout cela en pratique dans le prochain chapitre, lorsque nous vous montrerons comment "),pa=i("em"),gu=r("finetuner"),xu=r(" un mod\xE8le sur une s\xE9rie de t\xE2ches NLP courantes."),this.h()},l(e){const l=Fm('[data-svelte="svelte-1phssyn"]',document.head);a=u(l,"META",{name:!0,content:!0}),l.forEach(t),c=f(e),g(n.$$.fragment,e),v=f(e),b=u(e,"H1",{class:!0});var Ws=p(b);w=u(Ws,"A",{id:!0,class:!0,href:!0});var Ct=p(w);P=u(Ct,"SPAN",{});var zt=p(P);g(z.$$.fragment,zt),zt.forEach(t),Ct.forEach(t),S=f(Ws),C=u(Ws,"SPAN",{});var Bs=p(C);L=u(Bs,"I",{});var Nt=p(L);D=o(Nt,"Tokenizer"),Nt.forEach(t),M=o(Bs," rapide dans le pipeline de QA"),Bs.forEach(t),Ws.forEach(t),H=f(e),y.l(e),B=f(e),O=u(e,"P",{});var Le=p(O);Ie=o(Le,"Nous allons maintenant nous plonger dans le pipeline de "),Gt=u(Le,"CODE",{});var St=p(Gt);Kr=o(St,"question-answering"),St.forEach(t),Vr=o(Le," et voir comment exploiter les "),Jt=u(Le,"EM",{});var Tt=p(Jt);Wr=o(Tt,"offsets"),Tt.forEach(t),Br=o(Le," pour extraire d\u2019u ncontexte la r\xE9ponse \xE0 la question pos\xE9e. Nous verrons ensuite comment g\xE9rer les contextes tr\xE8s longs qui finissent par \xEAtre tronqu\xE9s. Vous pouvez sauter cette section si vous n\u2019\xEAtes pas int\xE9ress\xE9 par la t\xE2che de r\xE9ponse aux questions."),Le.forEach(t),fa=f(e),oe.l(e),Zs=f(e),Fe=u(e,"H2",{class:!0});var Ys=p(Fe);Re=u(Ys,"A",{id:!0,class:!0,href:!0});var ma=p(Re);Rt=u(ma,"SPAN",{});var Lt=p(Rt);g(ns.$$.fragment,Lt),Lt.forEach(t),ma.forEach(t),Yr=f(Ys),et=u(Ys,"SPAN",{});var Xs=p(et);Xr=o(Xs,"Utilisation du pipeline de "),Ht=u(Xs,"CODE",{});var Dt=p(Ht);Zr=o(Dt,"question-answering"),Dt.forEach(t),Xs.forEach(t),Ys.forEach(t),ha=f(e),Pe=u(e,"P",{});var De=p(Pe);eo=o(De,"Comme nous l\u2019avons vu dans le "),st=u(De,"A",{href:!0});var Mt=p(st);so=o(Mt,"chapitre 1"),Mt.forEach(t),to=o(De,", nous pouvons utiliser le pipeline de "),Qt=u(De,"CODE",{});var ca=p(Qt);no=o(ca,"question-answering"),ca.forEach(t),ao=o(De," comme ceci pour obtenir une r\xE9ponse \xE0 une question :"),De.forEach(t),_a=f(e),g(as.$$.fragment,e),va=f(e),g(rs.$$.fragment,e),ba=f(e),tt=u(e,"P",{});var da=p(tt);ro=o(da,"Contrairement aux autres pipelines, qui ne peuvent pas tronquer et diviser les textes dont la longueur est sup\xE9rieure \xE0 la longueur maximale accept\xE9e par le mod\xE8le (et qui peuvent donc manquer des informations \xE0 la fin d\u2019un document), ce pipeline peut traiter des contextes tr\xE8s longs et retournera la r\xE9ponse \xE0 la question m\xEAme si elle se trouve \xE0 la fin :"),da.forEach(t),$a=f(e),g(os.$$.fragment,e),ga=f(e),g(ls.$$.fragment,e),xa=f(e),nt=u(e,"P",{});var Vu=p(nt);oo=o(Vu,"Voyons comment il fait tout cela !"),Vu.forEach(t),qa=f(e),Ue=u(e,"H3",{class:!0});var Or=p(Ue);He=u(Or,"A",{id:!0,class:!0,href:!0});var Wu=p(He);Kt=u(Wu,"SPAN",{});var Bu=p(Kt);g(is.$$.fragment,Bu),Bu.forEach(t),Wu.forEach(t),lo=f(Or),Vt=u(Or,"SPAN",{});var Yu=p(Vt);io=o(Yu,"Utilisation d'un mod\xE8le pour r\xE9pondre \xE0 des questions"),Yu.forEach(t),Or.forEach(t),ka=f(e),I=u(e,"P",{});var Z=p(I);uo=o(Z,"Comme avec n\u2019importe quel autre pipeline, nous commen\xE7ons par tokeniser notre entr\xE9e et l\u2019envoyons ensuite \xE0 travers le mod\xE8le. Le "),Wt=u(Z,"EM",{});var Xu=p(Wt);po=o(Xu,"checkpoint"),Xu.forEach(t),mo=o(Z," utilis\xE9 par d\xE9faut pour le pipeline de "),Bt=u(Z,"CODE",{});var Zu=p(Bt);co=o(Zu,"question-answering"),Zu.forEach(t),fo=o(Z," est "),us=u(Z,"A",{href:!0,rel:!0});var ep=p(us);Yt=u(ep,"CODE",{});var sp=p(Yt);ho=o(sp,"distilbert-base-cased-distilled-squad"),sp.forEach(t),ep.forEach(t),_o=o(Z," (le \xAB squad \xBB dans le nom vient du jeu de donn\xE9es sur lequel le mod\xE8le a \xE9t\xE9 "),Xt=u(Z,"EM",{});var tp=p(Xt);vo=o(tp,"finetun\xE9"),tp.forEach(t),bo=o(Z,", nous parlerons davantage de ce jeu de donn\xE9es dans le "),at=u(Z,"A",{href:!0});var np=p(at);$o=o(np,"chapitre 7"),np.forEach(t),go=o(Z,") :"),Z.forEach(t),wa=f(e),ie.l(e),rt=f(e),ot=u(e,"P",{});var ap=p(ot);xo=o(ap,"Notez que nous tokenizons la question et le contexte comme une paire, la question en premier."),ap.forEach(t),ja=f(e),Ge=u(e,"DIV",{class:!0});var Ir=p(Ge);ps=u(Ir,"IMG",{class:!0,src:!0,alt:!0}),qo=f(Ir),ms=u(Ir,"IMG",{class:!0,src:!0,alt:!0}),Ir.forEach(t),Ea=f(e),F=u(e,"P",{});var ee=p(F);ko=o(ee,"Les mod\xE8les de r\xE9ponse aux questions fonctionnent un peu diff\xE9remment des mod\xE8les que nous avons vus jusqu\u2019\xE0 pr\xE9sent. En utilisant l\u2019image ci-dessus comme exemple, le mod\xE8le a \xE9t\xE9 entra\xEEn\xE9 \xE0 pr\xE9dire l\u2019index du "),Zt=u(ee,"EM",{});var rp=p(Zt);wo=o(rp,"token"),rp.forEach(t),jo=o(ee," de d\xE9but de la r\xE9ponse (ici 21) et l\u2019index du "),en=u(ee,"EM",{});var op=p(en);Eo=o(op,"token"),op.forEach(t),yo=o(ee," o\xF9 la r\xE9ponse se termine (ici 24). C\u2019est pourquoi ces mod\xE8les ne retournent pas un tenseur de logits mais deux : un pour les logits correspondant au "),sn=u(ee,"EM",{});var lp=p(sn);Po=o(lp,"token"),lp.forEach(t),Co=o(ee," de d\xE9but de la r\xE9ponse, et un pour les logits correspondant au "),tn=u(ee,"EM",{});var ip=p(tn);zo=o(ip,"token"),ip.forEach(t),No=o(ee," de fin de la r\xE9ponse. Puisque dans ce cas nous n\u2019avons qu\u2019une seule entr\xE9e contenant 66 "),nn=u(ee,"EM",{});var up=p(nn);So=o(up,"tokens"),up.forEach(t),To=o(ee,", nous obtenons :"),ee.forEach(t),ya=f(e),g(cs.$$.fragment,e),Pa=f(e),pe.l(e),lt=f(e),A=u(e,"P",{});var W=p(A);Lo=o(W,"Pour convertir ces logits en probabilit\xE9s, nous allons appliquer une fonction softmax. Mais avant cela, nous devons nous assurer de masquer les indices qui ne font pas partie du contexte. Notre entr\xE9e est "),an=u(W,"CODE",{});var pp=p(an);Do=o(pp,"[CLS] question [SEP] contexte [SEP]"),pp.forEach(t),Mo=o(W," donc nous devons masquer les "),rn=u(W,"EM",{});var mp=p(rn);Ao=o(mp,"tokens"),mp.forEach(t),Oo=o(W," de la question ainsi que le "),on=u(W,"EM",{});var cp=p(on);Io=o(cp,"token"),cp.forEach(t),Fo=f(W),ln=u(W,"CODE",{});var dp=p(ln);Uo=o(dp,"[SEP]"),dp.forEach(t),Go=o(W,". Nous garderons cependant le "),un=u(W,"EM",{});var fp=p(un);Jo=o(fp,"token"),fp.forEach(t),Ro=f(W),pn=u(W,"CODE",{});var hp=p(pn);Ho=o(hp,"[CLS]"),hp.forEach(t),Qo=o(W," car certains mod\xE8les l\u2019utilisent pour indiquer que la r\xE9ponse n\u2019est pas dans le contexte."),W.forEach(t),Ca=f(e),Qe=u(e,"P",{});var Fr=p(Qe);Ko=o(Fr,"Puisque nous appliquerons une fonction softmax par la suite, il nous suffit de remplacer les logits que nous voulons masquer par un grand nombre n\xE9gatif. Ici, nous utilisons "),mn=u(Fr,"CODE",{});var _p=p(mn);Vo=o(_p,"-10000"),_p.forEach(t),Wo=o(Fr," :"),Fr.forEach(t),za=f(e),ce.l(e),it=f(e),ut=u(e,"P",{});var vp=p(ut);Bo=o(vp,"Maintenant que nous avons correctement masqu\xE9 les logits correspondant aux positions que nous ne voulons pas pr\xE9dire, nous pouvons appliquer la softmax :"),vp.forEach(t),Na=f(e),fe.l(e),pt=f(e),U=u(e,"P",{});var se=p(U);Yo=o(se,"A ce stade, nous pourrions prendre l\u2019argmax des probabilit\xE9s de d\xE9but et de fin mais nous pourrions nous retrouver avec un indice de d\xE9but sup\xE9rieur \xE0 l\u2019indice de fin. Nous devons donc prendre quelques pr\xE9cautions suppl\xE9mentaires. Nous allons calculer les probabilit\xE9s de chaque "),cn=u(se,"CODE",{});var bp=p(cn);Xo=o(bp,"start_index"),bp.forEach(t),Zo=o(se," et "),dn=u(se,"CODE",{});var $p=p(dn);el=o($p,"end_index"),$p.forEach(t),sl=o(se," possible o\xF9 "),fn=u(se,"CODE",{});var gp=p(fn);tl=o(gp,"start_index<=end_index"),gp.forEach(t),nl=o(se,", puis nous prendrons le "),hn=u(se,"EM",{});var xp=p(hn);al=o(xp,"tuple"),xp.forEach(t),rl=f(se),_n=u(se,"CODE",{});var qp=p(_n);ol=o(qp,"(start_index, end_index)"),qp.forEach(t),ll=o(se," avec la plus grande probabilit\xE9."),se.forEach(t),Sa=f(e),R=u(e,"P",{});var ye=p(R);il=o(ye,"En supposant que les \xE9v\xE9nements \xAB La r\xE9ponse commence \xE0 "),vn=u(ye,"CODE",{});var kp=p(vn);ul=o(kp,"start_index"),kp.forEach(t),pl=o(ye," \xBB et \xAB La r\xE9ponse se termine \xE0 "),bn=u(ye,"CODE",{});var wp=p(bn);ml=o(wp,"end_index"),wp.forEach(t),cl=o(ye," \xBB sont ind\xE9pendants, la probabilit\xE9 que la r\xE9ponse commence \xE0 "),$n=u(ye,"CODE",{});var jp=p($n);dl=o(jp,"end_index"),jp.forEach(t),fl=o(ye," et se termine \xE0 "),gn=u(ye,"CODE",{});var Ep=p(gn);hl=o(Ep,"end_index"),Ep.forEach(t),_l=o(ye,` est :
`),Ta=Nm(ye),ye.forEach(t),La=f(e),Ce=u(e,"P",{});var At=p(Ce);vl=o(At,"Ainsi, pour calculer tous les scores, il suffit de calculer tous les produits "),Da=Nm(At),Ma=o(At," o\xF9 "),xn=u(At,"CODE",{});var yp=p(xn);bl=o(yp,"start_index <= end_index"),yp.forEach(t),$l=o(At,"."),At.forEach(t),Aa=f(e),mt=u(e,"P",{});var Pp=p(mt);gl=o(Pp,"Calculons d\u2019abord tous les produits possibles :"),Pp.forEach(t),Oa=f(e),g(ds.$$.fragment,e),Ia=f(e),_e.l(e),ct=f(e),Q=u(e,"P",{});var Me=p(Q);xl=o(Me,"Il ne nous reste plus qu\u2019\xE0 obtenir l\u2019indice du maximum. Puisque PyTorch retourne l\u2019index dans le tenseur aplati, nous devons utiliser les op\xE9rations division "),qn=u(Me,"CODE",{});var Cp=p(qn);ql=o(Cp,"//"),Cp.forEach(t),kl=o(Me," et modulo "),kn=u(Me,"CODE",{});var zp=p(kn);wl=o(zp,"%"),zp.forEach(t),jl=o(Me," pour obtenir le "),wn=u(Me,"CODE",{});var Np=p(wn);El=o(Np,"start_index"),Np.forEach(t),yl=o(Me," et le "),jn=u(Me,"CODE",{});var Sp=p(jn);Pl=o(Sp,"end_index"),Sp.forEach(t),Cl=o(Me," :"),Me.forEach(t),Fa=f(e),g(fs.$$.fragment,e),Ua=f(e),dt=u(e,"P",{});var Tp=p(dt);zl=o(Tp,"Nous n\u2019avons pas encore tout \xE0 fait termin\xE9, mais au moins nous avons d\xE9j\xE0 le score correct pour la r\xE9ponse (vous pouvez le v\xE9rifier en le comparant au premier r\xE9sultat de la section pr\xE9c\xE9dente) :"),Tp.forEach(t),Ga=f(e),g(hs.$$.fragment,e),Ja=f(e),g(Ke.$$.fragment,e),Ra=f(e),G=u(e,"P",{});var te=p(G);Nl=o(te,"Nous avons les "),En=u(te,"CODE",{});var Lp=p(En);Sl=o(Lp,"start_index"),Lp.forEach(t),Tl=o(te," et "),yn=u(te,"CODE",{});var Dp=p(yn);Ll=o(Dp,"end_index"),Dp.forEach(t),Dl=o(te," de la r\xE9ponse en termes de "),Pn=u(te,"EM",{});var Mp=p(Pn);Ml=o(Mp,"tokens"),Mp.forEach(t),Al=o(te,". Maintenant nous devons juste convertir en indices de caract\xE8res dans le contexte. C\u2019est l\xE0 que les "),Cn=u(te,"EM",{});var Ap=p(Cn);Ol=o(Ap,"offsets"),Ap.forEach(t),Il=o(te," seront super utiles. Nous pouvons les saisir et les utiliser comme nous l\u2019avons fait dans la t\xE2che de classification des "),zn=u(te,"EM",{});var Op=p(zn);Fl=o(Op,"tokens"),Op.forEach(t),Ul=o(te," :"),te.forEach(t),Ha=f(e),g(_s.$$.fragment,e),Qa=f(e),ft=u(e,"P",{});var Ip=p(ft);Gl=o(Ip,"Il ne nous reste plus qu\u2019\xE0 tout formater pour obtenir notre r\xE9sultat :"),Ip.forEach(t),Ka=f(e),g(vs.$$.fragment,e),Va=f(e),g(bs.$$.fragment,e),Wa=f(e),ht=u(e,"P",{});var Fp=p(ht);Jl=o(Fp,"Super ! C\u2019est la m\xEAme chose que dans notre premier exemple !"),Fp.forEach(t),Ba=f(e),g(Ve.$$.fragment,e),Ya=f(e),Je=u(e,"H2",{class:!0});var Ur=p(Je);We=u(Ur,"A",{id:!0,class:!0,href:!0});var Up=p(We);Nn=u(Up,"SPAN",{});var Gp=p(Nn);g($s.$$.fragment,Gp),Gp.forEach(t),Up.forEach(t),Rl=f(Ur),Sn=u(Ur,"SPAN",{});var Jp=p(Sn);Hl=o(Jp,"Gestion des contextes longs"),Jp.forEach(t),Ur.forEach(t),Xa=f(e),ze=u(e,"P",{});var Ot=p(ze);Ql=o(Ot,"Si nous essayons de tokeniser la question et le long contexte que nous avons utilis\xE9 dans l\u2019exemple pr\xE9c\xE9demment, nous obtenons un nombre de "),Tn=u(Ot,"EM",{});var Rp=p(Tn);Kl=o(Rp,"tokens"),Rp.forEach(t),Vl=o(Ot," sup\xE9rieur \xE0 la longueur maximale utilis\xE9e dans le pipeline "),Ln=u(Ot,"CODE",{});var Hp=p(Ln);Wl=o(Hp,"question-answering"),Hp.forEach(t),Bl=o(Ot," (qui est de 384) :"),Ot.forEach(t),Za=f(e),g(gs.$$.fragment,e),er=f(e),g(xs.$$.fragment,e),sr=f(e),Be=u(e,"P",{});var Gr=p(Be);Yl=o(Gr,"Nous devrons donc tronquer nos entr\xE9es \xE0 cette longueur maximale. Il y a plusieurs fa\xE7ons de le faire mais nous ne voulons pas tronquer la question, seulement le contexte. Puisque le contexte est la deuxi\xE8me phrase, nous utilisons la strat\xE9gie de troncature "),Dn=u(Gr,"CODE",{});var Qp=p(Dn);Xl=o(Qp,'"only_second"'),Qp.forEach(t),Zl=o(Gr,". Le probl\xE8me qui se pose alors est que la r\xE9ponse \xE0 la question peut ne pas se trouver dans le contexte tronqu\xE9. Ici, par exemple, nous avons choisi une question dont la r\xE9ponse se trouve vers la fin du contexte, et lorsque nous la tronquons, cette r\xE9ponse n\u2019est pas pr\xE9sente :"),Gr.forEach(t),tr=f(e),g(qs.$$.fragment,e),nr=f(e),g(ks.$$.fragment,e),ar=f(e),Ye=u(e,"P",{});var Jr=p(Ye);ei=o(Jr,"Cela signifie que le mod\xE8le a du mal \xE0 trouver la bonne r\xE9ponse. Pour r\xE9soudre ce probl\xE8me, le pipeline de "),Mn=u(Jr,"CODE",{});var Kp=p(Mn);si=o(Kp,"question-answering"),Kp.forEach(t),ti=o(Jr," nous permet de diviser le contexte en morceaux plus petits, en sp\xE9cifiant la longueur maximale. Pour s\u2019assurer que nous ne divisons pas le contexte exactement au mauvais endroit pour permettre de trouver la r\xE9ponse, il inclut \xE9galement un certain chevauchement entre les morceaux."),Jr.forEach(t),rr=f(e),Y=u(e,"P",{});var ss=p(Y);ni=o(ss,"Nous pouvons demander au "),An=u(ss,"EM",{});var Vp=p(An);ai=o(Vp,"tokenizer"),Vp.forEach(t),ri=o(ss," (rapide ou lent) de le faire pour nous en ajoutant "),On=u(ss,"CODE",{});var Wp=p(On);oi=o(Wp,"return_overflowing_tokens=True"),Wp.forEach(t),li=o(ss,", et nous pouvons sp\xE9cifier le chevauchement que nous voulons avec l\u2019argument "),In=u(ss,"CODE",{});var Bp=p(In);ii=o(Bp,"stride"),Bp.forEach(t),ui=o(ss,". Voici un exemple, en utilisant une phrase plus petite :"),ss.forEach(t),or=f(e),g(ws.$$.fragment,e),lr=f(e),g(js.$$.fragment,e),ir=f(e),K=u(e,"P",{});var Ae=p(K);pi=o(Ae,"Comme on peut le voir, la phrase a \xE9t\xE9 d\xE9coup\xE9e en morceaux de telle sorte que chaque entr\xE9e dans "),Fn=u(Ae,"CODE",{});var Yp=p(Fn);mi=o(Yp,'inputs["input_ids"]'),Yp.forEach(t),ci=o(Ae," a au maximum 6 "),Un=u(Ae,"EM",{});var Xp=p(Un);di=o(Xp,"tokens"),Xp.forEach(t),fi=o(Ae," (il faudrait ajouter du "),Gn=u(Ae,"EM",{});var Zp=p(Gn);hi=o(Zp,"padding"),Zp.forEach(t),_i=o(Ae," pour que la derni\xE8re entr\xE9e ait la m\xEAme taille que les autres) et il y a un chevauchement de 2 "),Jn=u(Ae,"EM",{});var em=p(Jn);vi=o(em,"tokens"),em.forEach(t),bi=o(Ae," entre chacune des entr\xE9es."),Ae.forEach(t),ur=f(e),_t=u(e,"P",{});var sm=p(_t);$i=o(sm,"Regardons de plus pr\xE8s le r\xE9sultat de la tok\xE9nisation :"),sm.forEach(t),pr=f(e),g(Es.$$.fragment,e),mr=f(e),g(ys.$$.fragment,e),cr=f(e),Ne=u(e,"P",{});var It=p(Ne);gi=o(It,"Comme pr\xE9vu, nous obtenons les identifiants d\u2019entr\xE9e et un masque d\u2019attention. La derni\xE8re cl\xE9, "),Rn=u(It,"CODE",{});var tm=p(Rn);xi=o(tm,"overflow_to_sample_mapping"),tm.forEach(t),qi=o(It,", est une carte qui nous indique \xE0 quelle phrase correspond chacun des r\xE9sultats. Ici nous avons 7 r\xE9sultats qui proviennent tous de la (seule) phrase que nous avons pass\xE9e au "),Hn=u(It,"EM",{});var nm=p(Hn);ki=o(nm,"tokenizer"),nm.forEach(t),wi=o(It," :"),It.forEach(t),dr=f(e),g(Ps.$$.fragment,e),fr=f(e),g(Cs.$$.fragment,e),hr=f(e),vt=u(e,"P",{});var am=p(vt);ji=o(am,"C\u2019est plus utile lorsque nous tokenisons plusieurs phrases ensemble. Par exemple :"),am.forEach(t),_r=f(e),g(zs.$$.fragment,e),vr=f(e),bt=u(e,"P",{});var rm=p(bt);Ei=o(rm,"nous donne :"),rm.forEach(t),br=f(e),g(Ns.$$.fragment,e),$r=f(e),$t=u(e,"P",{});var om=p($t);yi=o(om,"ce qui signifie que la premi\xE8re phrase est divis\xE9e en 7 morceaux comme pr\xE9c\xE9demment et que les 4 morceaux suivants proviennent de la deuxi\xE8me phrase."),om.forEach(t),gr=f(e),T=u(e,"P",{});var J=p(T);Pi=o(J,"Revenons maintenant \xE0 notre contexte long. Par d\xE9faut, le pipeline "),Qn=u(J,"CODE",{});var lm=p(Qn);Ci=o(lm,"question-answering"),lm.forEach(t),zi=o(J," utilise une longueur maximale de 384 et un "),Kn=u(J,"EM",{});var im=p(Kn);Ni=o(im,"stride"),im.forEach(t),Si=o(J," de 128, qui correspondent \xE0 la fa\xE7on dont le mod\xE8le a \xE9t\xE9 "),Vn=u(J,"EM",{});var um=p(Vn);Ti=o(um,"finetun\xE9"),um.forEach(t),Li=o(J," (vous pouvez ajuster ces param\xE8tres en passant les arguments "),Wn=u(J,"CODE",{});var pm=p(Wn);Di=o(pm,"max_seq_len"),pm.forEach(t),Mi=o(J," et "),Bn=u(J,"CODE",{});var mm=p(Bn);Ai=o(mm,"stride"),mm.forEach(t),Oi=o(J," lorsque vous appelez le pipeline). Nous utiliserons donc ces param\xE8tres lors de la tokenisation. Nous ajouterons aussi du "),Yn=u(J,"EM",{});var cm=p(Yn);Ii=o(cm,"padding"),cm.forEach(t),Fi=o(J," (pour avoir des \xE9chantillons de m\xEAme longueur afin de pouvoir construire des tenseurs) ainsi que demander les "),Xn=u(J,"EM",{});var dm=p(Xn);Ui=o(dm,"offsets"),dm.forEach(t),Gi=o(J," :"),J.forEach(t),xr=f(e),g(Ss.$$.fragment,e),qr=f(e),V=u(e,"P",{});var Oe=p(V);Ji=o(Oe,"Ces "),Zn=u(Oe,"CODE",{});var fm=p(Zn);Ri=o(fm,"inputs"),fm.forEach(t),Hi=o(Oe," contiendront les identifiants d\u2019entr\xE9e, les masques d\u2019attention que le mod\xE8le attend, ainsi que les "),ea=u(Oe,"EM",{});var hm=p(ea);Qi=o(hm,"offsets"),hm.forEach(t),Ki=o(Oe," et le "),sa=u(Oe,"CODE",{});var _m=p(sa);Vi=o(_m,"overflow_to_sample_mapping"),_m.forEach(t),Wi=o(Oe," dont on vient de parler. Puisque ces deux \xE9l\xE9ments ne sont pas des param\xE8tres utilis\xE9s par le mod\xE8le, nous allons les sortir des "),ta=u(Oe,"CODE",{});var vm=p(ta);Bi=o(vm,"inputs"),vm.forEach(t),Yi=o(Oe," (et nous ne stockerons pas la correspondance puisqu\u2019elle n\u2019est pas utile ici) avant de le convertir en tenseur :"),Oe.forEach(t),kr=f(e),be.l(e),gt=f(e),xt=u(e,"P",{});var bm=p(xt);Xi=o(bm,"Notre contexte long a \xE9t\xE9 divis\xE9 en deux, ce qui signifie qu\u2019apr\xE8s avoir travers\xE9 notre mod\xE8le, nous aurons deux ensembles de logits de d\xE9but et de fin :"),bm.forEach(t),wr=f(e),g(Ts.$$.fragment,e),jr=f(e),ge.l(e),qt=f(e),X=u(e,"P",{});var ts=p(X);Zi=o(ts,"Comme pr\xE9c\xE9demment, nous masquons d\u2019abord les "),na=u(ts,"EM",{});var $m=p(na);eu=o($m,"tokens"),$m.forEach(t),su=o(ts," qui ne font pas partie du contexte avant de prendre le softmax. Nous masquons \xE9galement tous les "),aa=u(ts,"EM",{});var gm=p(aa);tu=o(gm,"tokens"),gm.forEach(t),nu=o(ts," de "),ra=u(ts,"EM",{});var xm=p(ra);au=o(xm,"padding"),xm.forEach(t),ru=o(ts," (tels que signal\xE9s par le masque d\u2019attention) :"),ts.forEach(t),Er=f(e),qe.l(e),kt=f(e),wt=u(e,"P",{});var qm=p(wt);ou=o(qm,"Ensuite, nous pouvons utiliser la fonction softmax pour convertir nos logits en probabilit\xE9s :"),qm.forEach(t),yr=f(e),we.l(e),jt=f(e),Et=u(e,"P",{});var km=p(Et);lu=o(km,"L\u2019\xE9tape suivante est similaire \xE0 ce que nous avons fait pour le petit contexte mais nous la r\xE9p\xE9tons pour chacun de nos deux morceaux. Nous attribuons un score \xE0 tous les espaces de r\xE9ponse possibles puis nous prenons l\u2019espace ayant le meilleur score :"),km.forEach(t),Pr=f(e),Ee.l(e),yt=f(e),g(Ls.$$.fragment,e),Cr=f(e),Xe=u(e,"P",{});var Rr=p(Xe);iu=o(Rr,"Ces deux candidats correspondent aux meilleures r\xE9ponses que le mod\xE8le a pu trouver dans chaque morceau. Le mod\xE8le est beaucoup plus confiant dans le fait que la bonne r\xE9ponse se trouve dans la deuxi\xE8me partie (ce qui est bon signe !). Il ne nous reste plus qu\u2019\xE0 faire correspondre ces deux espaces de "),oa=u(Rr,"EM",{});var wm=p(oa);uu=o(wm,"tokens"),wm.forEach(t),pu=o(Rr," \xE0 des espaces de caract\xE8res dans le contexte (nous n\u2019avons besoin de faire correspondre que le second pour avoir notre r\xE9ponse, mais il est int\xE9ressant de voir ce que le mod\xE8le a choisi dans le premier morceau)."),Rr.forEach(t),zr=f(e),g(Ze.$$.fragment,e),Nr=f(e),Se=u(e,"P",{});var Ft=p(Se);mu=o(Ft,"Le "),la=u(Ft,"CODE",{});var jm=p(la);cu=o(jm,"offsets"),jm.forEach(t),du=o(Ft," que nous avons saisi plus t\xF4t est en fait une liste d\u2019"),ia=u(Ft,"EM",{});var Em=p(ia);fu=o(Em,"offsets"),Em.forEach(t),hu=o(Ft," avec une liste par morceau de texte :"),Ft.forEach(t),Sr=f(e),g(Ds.$$.fragment,e),Tr=f(e),g(Ms.$$.fragment,e),Lr=f(e),Pt=u(e,"P",{});var ym=p(Pt);_u=o(ym,"Si nous ignorons le premier r\xE9sultat, nous obtenons le m\xEAme r\xE9sultat que notre pipeline pour ce long contexte !"),ym.forEach(t),Dr=f(e),g(es.$$.fragment,e),Mr=f(e),Te=u(e,"P",{});var Ut=p(Te);vu=o(Ut,"Ceci conclut notre plong\xE9e en profondeur dans les capacit\xE9s du "),ua=u(Ut,"EM",{});var Pm=p(ua);bu=o(Pm,"tokenizer"),Pm.forEach(t),$u=o(Ut,". Nous mettrons \xE0 nouveau tout cela en pratique dans le prochain chapitre, lorsque nous vous montrerons comment "),pa=u(Ut,"EM",{});var Cm=p(pa);gu=o(Cm,"finetuner"),Cm.forEach(t),xu=o(Ut," un mod\xE8le sur une s\xE9rie de t\xE2ches NLP courantes."),Ut.forEach(t),this.h()},h(){N(a,"name","hf:doc:metadata"),N(a,"content",JSON.stringify(bc)),N(w,"id","itokenizeri-rapide-dans-le-pipeline-de-qa"),N(w,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),N(w,"href","#itokenizeri-rapide-dans-le-pipeline-de-qa"),N(b,"class","relative group"),N(Re,"id","utilisation-du-pipeline-de-questionanswering"),N(Re,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),N(Re,"href","#utilisation-du-pipeline-de-questionanswering"),N(Fe,"class","relative group"),N(st,"href","/course/fr/chapter1"),N(He,"id","utilisation-dun-modle-pour-rpondre-des-questions"),N(He,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),N(He,"href","#utilisation-dun-modle-pour-rpondre-des-questions"),N(Ue,"class","relative group"),N(us,"href","https://huggingface.co/distilbert-base-cased-distilled-squad"),N(us,"rel","nofollow"),N(at,"href","/course/fr/chapter7/7"),N(ps,"class","block dark:hidden"),Sm(ps.src,qu="https://huggingface.co/datasets/huggingface-course/documentation-images/resolve/main/en/chapter6/question_tokens.svg")||N(ps,"src",qu),N(ps,"alt","An example of tokenization of question and context"),N(ms,"class","hidden dark:block"),Sm(ms.src,ku="https://huggingface.co/datasets/huggingface-course/documentation-images/resolve/main/en/chapter6/question_tokens-dark.svg")||N(ms,"src",ku),N(ms,"alt","An example of tokenization of question and context"),N(Ge,"class","flex justify-center"),Ta.a=null,Da.a=Ma,N(We,"id","gestion-des-contextes-longs"),N(We,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),N(We,"href","#gestion-des-contextes-longs"),N(Je,"class","relative group")},m(e,l){s(document.head,a),m(e,c,l),x(n,e,l),m(e,v,l),m(e,b,l),s(b,w),s(w,P),x(z,P,null),s(b,S),s(b,C),s(C,L),s(L,D),s(C,M),m(e,H,l),As[E].m(e,l),m(e,B,l),m(e,O,l),s(O,Ie),s(O,Gt),s(Gt,Kr),s(O,Vr),s(O,Jt),s(Jt,Wr),s(O,Br),m(e,fa,l),Os[re].m(e,l),m(e,Zs,l),m(e,Fe,l),s(Fe,Re),s(Re,Rt),x(ns,Rt,null),s(Fe,Yr),s(Fe,et),s(et,Xr),s(et,Ht),s(Ht,Zr),m(e,ha,l),m(e,Pe,l),s(Pe,eo),s(Pe,st),s(st,so),s(Pe,to),s(Pe,Qt),s(Qt,no),s(Pe,ao),m(e,_a,l),x(as,e,l),m(e,va,l),x(rs,e,l),m(e,ba,l),m(e,tt,l),s(tt,ro),m(e,$a,l),x(os,e,l),m(e,ga,l),x(ls,e,l),m(e,xa,l),m(e,nt,l),s(nt,oo),m(e,qa,l),m(e,Ue,l),s(Ue,He),s(He,Kt),x(is,Kt,null),s(Ue,lo),s(Ue,Vt),s(Vt,io),m(e,ka,l),m(e,I,l),s(I,uo),s(I,Wt),s(Wt,po),s(I,mo),s(I,Bt),s(Bt,co),s(I,fo),s(I,us),s(us,Yt),s(Yt,ho),s(I,_o),s(I,Xt),s(Xt,vo),s(I,bo),s(I,at),s(at,$o),s(I,go),m(e,wa,l),Is[le].m(e,l),m(e,rt,l),m(e,ot,l),s(ot,xo),m(e,ja,l),m(e,Ge,l),s(Ge,ps),s(Ge,qo),s(Ge,ms),m(e,Ea,l),m(e,F,l),s(F,ko),s(F,Zt),s(Zt,wo),s(F,jo),s(F,en),s(en,Eo),s(F,yo),s(F,sn),s(sn,Po),s(F,Co),s(F,tn),s(tn,zo),s(F,No),s(F,nn),s(nn,So),s(F,To),m(e,ya,l),x(cs,e,l),m(e,Pa,l),Fs[ue].m(e,l),m(e,lt,l),m(e,A,l),s(A,Lo),s(A,an),s(an,Do),s(A,Mo),s(A,rn),s(rn,Ao),s(A,Oo),s(A,on),s(on,Io),s(A,Fo),s(A,ln),s(ln,Uo),s(A,Go),s(A,un),s(un,Jo),s(A,Ro),s(A,pn),s(pn,Ho),s(A,Qo),m(e,Ca,l),m(e,Qe,l),s(Qe,Ko),s(Qe,mn),s(mn,Vo),s(Qe,Wo),m(e,za,l),Us[me].m(e,l),m(e,it,l),m(e,ut,l),s(ut,Bo),m(e,Na,l),Gs[de].m(e,l),m(e,pt,l),m(e,U,l),s(U,Yo),s(U,cn),s(cn,Xo),s(U,Zo),s(U,dn),s(dn,el),s(U,sl),s(U,fn),s(fn,tl),s(U,nl),s(U,hn),s(hn,al),s(U,rl),s(U,_n),s(_n,ol),s(U,ll),m(e,Sa,l),m(e,R,l),s(R,il),s(R,vn),s(vn,ul),s(R,pl),s(R,bn),s(bn,ml),s(R,cl),s(R,$n),s($n,dl),s(R,fl),s(R,gn),s(gn,hl),s(R,_l),Ta.m(Dm,R),m(e,La,l),m(e,Ce,l),s(Ce,vl),Da.m(Mm,Ce),s(Ce,Ma),s(Ce,xn),s(xn,bl),s(Ce,$l),m(e,Aa,l),m(e,mt,l),s(mt,gl),m(e,Oa,l),x(ds,e,l),m(e,Ia,l),Js[he].m(e,l),m(e,ct,l),m(e,Q,l),s(Q,xl),s(Q,qn),s(qn,ql),s(Q,kl),s(Q,kn),s(kn,wl),s(Q,jl),s(Q,wn),s(wn,El),s(Q,yl),s(Q,jn),s(jn,Pl),s(Q,Cl),m(e,Fa,l),x(fs,e,l),m(e,Ua,l),m(e,dt,l),s(dt,zl),m(e,Ga,l),x(hs,e,l),m(e,Ja,l),x(Ke,e,l),m(e,Ra,l),m(e,G,l),s(G,Nl),s(G,En),s(En,Sl),s(G,Tl),s(G,yn),s(yn,Ll),s(G,Dl),s(G,Pn),s(Pn,Ml),s(G,Al),s(G,Cn),s(Cn,Ol),s(G,Il),s(G,zn),s(zn,Fl),s(G,Ul),m(e,Ha,l),x(_s,e,l),m(e,Qa,l),m(e,ft,l),s(ft,Gl),m(e,Ka,l),x(vs,e,l),m(e,Va,l),x(bs,e,l),m(e,Wa,l),m(e,ht,l),s(ht,Jl),m(e,Ba,l),x(Ve,e,l),m(e,Ya,l),m(e,Je,l),s(Je,We),s(We,Nn),x($s,Nn,null),s(Je,Rl),s(Je,Sn),s(Sn,Hl),m(e,Xa,l),m(e,ze,l),s(ze,Ql),s(ze,Tn),s(Tn,Kl),s(ze,Vl),s(ze,Ln),s(Ln,Wl),s(ze,Bl),m(e,Za,l),x(gs,e,l),m(e,er,l),x(xs,e,l),m(e,sr,l),m(e,Be,l),s(Be,Yl),s(Be,Dn),s(Dn,Xl),s(Be,Zl),m(e,tr,l),x(qs,e,l),m(e,nr,l),x(ks,e,l),m(e,ar,l),m(e,Ye,l),s(Ye,ei),s(Ye,Mn),s(Mn,si),s(Ye,ti),m(e,rr,l),m(e,Y,l),s(Y,ni),s(Y,An),s(An,ai),s(Y,ri),s(Y,On),s(On,oi),s(Y,li),s(Y,In),s(In,ii),s(Y,ui),m(e,or,l),x(ws,e,l),m(e,lr,l),x(js,e,l),m(e,ir,l),m(e,K,l),s(K,pi),s(K,Fn),s(Fn,mi),s(K,ci),s(K,Un),s(Un,di),s(K,fi),s(K,Gn),s(Gn,hi),s(K,_i),s(K,Jn),s(Jn,vi),s(K,bi),m(e,ur,l),m(e,_t,l),s(_t,$i),m(e,pr,l),x(Es,e,l),m(e,mr,l),x(ys,e,l),m(e,cr,l),m(e,Ne,l),s(Ne,gi),s(Ne,Rn),s(Rn,xi),s(Ne,qi),s(Ne,Hn),s(Hn,ki),s(Ne,wi),m(e,dr,l),x(Ps,e,l),m(e,fr,l),x(Cs,e,l),m(e,hr,l),m(e,vt,l),s(vt,ji),m(e,_r,l),x(zs,e,l),m(e,vr,l),m(e,bt,l),s(bt,Ei),m(e,br,l),x(Ns,e,l),m(e,$r,l),m(e,$t,l),s($t,yi),m(e,gr,l),m(e,T,l),s(T,Pi),s(T,Qn),s(Qn,Ci),s(T,zi),s(T,Kn),s(Kn,Ni),s(T,Si),s(T,Vn),s(Vn,Ti),s(T,Li),s(T,Wn),s(Wn,Di),s(T,Mi),s(T,Bn),s(Bn,Ai),s(T,Oi),s(T,Yn),s(Yn,Ii),s(T,Fi),s(T,Xn),s(Xn,Ui),s(T,Gi),m(e,xr,l),x(Ss,e,l),m(e,qr,l),m(e,V,l),s(V,Ji),s(V,Zn),s(Zn,Ri),s(V,Hi),s(V,ea),s(ea,Qi),s(V,Ki),s(V,sa),s(sa,Vi),s(V,Wi),s(V,ta),s(ta,Bi),s(V,Yi),m(e,kr,l),Rs[ve].m(e,l),m(e,gt,l),m(e,xt,l),s(xt,Xi),m(e,wr,l),x(Ts,e,l),m(e,jr,l),Hs[$e].m(e,l),m(e,qt,l),m(e,X,l),s(X,Zi),s(X,na),s(na,eu),s(X,su),s(X,aa),s(aa,tu),s(X,nu),s(X,ra),s(ra,au),s(X,ru),m(e,Er,l),Qs[xe].m(e,l),m(e,kt,l),m(e,wt,l),s(wt,ou),m(e,yr,l),Ks[ke].m(e,l),m(e,jt,l),m(e,Et,l),s(Et,lu),m(e,Pr,l),Vs[je].m(e,l),m(e,yt,l),x(Ls,e,l),m(e,Cr,l),m(e,Xe,l),s(Xe,iu),s(Xe,oa),s(oa,uu),s(Xe,pu),m(e,zr,l),x(Ze,e,l),m(e,Nr,l),m(e,Se,l),s(Se,mu),s(Se,la),s(la,cu),s(Se,du),s(Se,ia),s(ia,fu),s(Se,hu),m(e,Sr,l),x(Ds,e,l),m(e,Tr,l),x(Ms,e,l),m(e,Lr,l),m(e,Pt,l),s(Pt,_u),m(e,Dr,l),x(es,e,l),m(e,Mr,l),m(e,Te,l),s(Te,vu),s(Te,ua),s(ua,bu),s(Te,$u),s(Te,pa),s(pa,gu),s(Te,xu),Ar=!0},p(e,[l]){const Ws={};l&1&&(Ws.fw=e[0]),n.$set(Ws);let Ct=E;E=ju(e),E!==Ct&&(ae(),h(As[Ct],1,1,()=>{As[Ct]=null}),ne(),y=As[E],y||(y=As[E]=wu[E](e),y.c()),_(y,1),y.m(B.parentNode,B));let zt=re;re=yu(e),re!==zt&&(ae(),h(Os[zt],1,1,()=>{Os[zt]=null}),ne(),oe=Os[re],oe||(oe=Os[re]=Eu[re](e),oe.c()),_(oe,1),oe.m(Zs.parentNode,Zs));let Bs=le;le=Cu(e),le!==Bs&&(ae(),h(Is[Bs],1,1,()=>{Is[Bs]=null}),ne(),ie=Is[le],ie||(ie=Is[le]=Pu[le](e),ie.c()),_(ie,1),ie.m(rt.parentNode,rt));let Nt=ue;ue=Nu(e),ue!==Nt&&(ae(),h(Fs[Nt],1,1,()=>{Fs[Nt]=null}),ne(),pe=Fs[ue],pe||(pe=Fs[ue]=zu[ue](e),pe.c()),_(pe,1),pe.m(lt.parentNode,lt));let Le=me;me=Tu(e),me!==Le&&(ae(),h(Us[Le],1,1,()=>{Us[Le]=null}),ne(),ce=Us[me],ce||(ce=Us[me]=Su[me](e),ce.c()),_(ce,1),ce.m(it.parentNode,it));let St=de;de=Du(e),de!==St&&(ae(),h(Gs[St],1,1,()=>{Gs[St]=null}),ne(),fe=Gs[de],fe||(fe=Gs[de]=Lu[de](e),fe.c()),_(fe,1),fe.m(pt.parentNode,pt));let Tt=he;he=Au(e),he!==Tt&&(ae(),h(Js[Tt],1,1,()=>{Js[Tt]=null}),ne(),_e=Js[he],_e||(_e=Js[he]=Mu[he](e),_e.c()),_(_e,1),_e.m(ct.parentNode,ct));const Ys={};l&2&&(Ys.$$scope={dirty:l,ctx:e}),Ke.$set(Ys);const ma={};l&2&&(ma.$$scope={dirty:l,ctx:e}),Ve.$set(ma);let Lt=ve;ve=Iu(e),ve!==Lt&&(ae(),h(Rs[Lt],1,1,()=>{Rs[Lt]=null}),ne(),be=Rs[ve],be||(be=Rs[ve]=Ou[ve](e),be.c()),_(be,1),be.m(gt.parentNode,gt));let Xs=$e;$e=Uu(e),$e!==Xs&&(ae(),h(Hs[Xs],1,1,()=>{Hs[Xs]=null}),ne(),ge=Hs[$e],ge||(ge=Hs[$e]=Fu[$e](e),ge.c()),_(ge,1),ge.m(qt.parentNode,qt));let Dt=xe;xe=Ju(e),xe!==Dt&&(ae(),h(Qs[Dt],1,1,()=>{Qs[Dt]=null}),ne(),qe=Qs[xe],qe||(qe=Qs[xe]=Gu[xe](e),qe.c()),_(qe,1),qe.m(kt.parentNode,kt));let De=ke;ke=Hu(e),ke!==De&&(ae(),h(Ks[De],1,1,()=>{Ks[De]=null}),ne(),we=Ks[ke],we||(we=Ks[ke]=Ru[ke](e),we.c()),_(we,1),we.m(jt.parentNode,jt));let Mt=je;je=Ku(e),je!==Mt&&(ae(),h(Vs[Mt],1,1,()=>{Vs[Mt]=null}),ne(),Ee=Vs[je],Ee||(Ee=Vs[je]=Qu[je](e),Ee.c()),_(Ee,1),Ee.m(yt.parentNode,yt));const ca={};l&2&&(ca.$$scope={dirty:l,ctx:e}),Ze.$set(ca);const da={};l&2&&(da.$$scope={dirty:l,ctx:e}),es.$set(da)},i(e){Ar||(_(n.$$.fragment,e),_(z.$$.fragment,e),_(y),_(oe),_(ns.$$.fragment,e),_(as.$$.fragment,e),_(rs.$$.fragment,e),_(os.$$.fragment,e),_(ls.$$.fragment,e),_(is.$$.fragment,e),_(ie),_(cs.$$.fragment,e),_(pe),_(ce),_(fe),_(ds.$$.fragment,e),_(_e),_(fs.$$.fragment,e),_(hs.$$.fragment,e),_(Ke.$$.fragment,e),_(_s.$$.fragment,e),_(vs.$$.fragment,e),_(bs.$$.fragment,e),_(Ve.$$.fragment,e),_($s.$$.fragment,e),_(gs.$$.fragment,e),_(xs.$$.fragment,e),_(qs.$$.fragment,e),_(ks.$$.fragment,e),_(ws.$$.fragment,e),_(js.$$.fragment,e),_(Es.$$.fragment,e),_(ys.$$.fragment,e),_(Ps.$$.fragment,e),_(Cs.$$.fragment,e),_(zs.$$.fragment,e),_(Ns.$$.fragment,e),_(Ss.$$.fragment,e),_(be),_(Ts.$$.fragment,e),_(ge),_(qe),_(we),_(Ee),_(Ls.$$.fragment,e),_(Ze.$$.fragment,e),_(Ds.$$.fragment,e),_(Ms.$$.fragment,e),_(es.$$.fragment,e),Ar=!0)},o(e){h(n.$$.fragment,e),h(z.$$.fragment,e),h(y),h(oe),h(ns.$$.fragment,e),h(as.$$.fragment,e),h(rs.$$.fragment,e),h(os.$$.fragment,e),h(ls.$$.fragment,e),h(is.$$.fragment,e),h(ie),h(cs.$$.fragment,e),h(pe),h(ce),h(fe),h(ds.$$.fragment,e),h(_e),h(fs.$$.fragment,e),h(hs.$$.fragment,e),h(Ke.$$.fragment,e),h(_s.$$.fragment,e),h(vs.$$.fragment,e),h(bs.$$.fragment,e),h(Ve.$$.fragment,e),h($s.$$.fragment,e),h(gs.$$.fragment,e),h(xs.$$.fragment,e),h(qs.$$.fragment,e),h(ks.$$.fragment,e),h(ws.$$.fragment,e),h(js.$$.fragment,e),h(Es.$$.fragment,e),h(ys.$$.fragment,e),h(Ps.$$.fragment,e),h(Cs.$$.fragment,e),h(zs.$$.fragment,e),h(Ns.$$.fragment,e),h(Ss.$$.fragment,e),h(be),h(Ts.$$.fragment,e),h(ge),h(qe),h(we),h(Ee),h(Ls.$$.fragment,e),h(Ze.$$.fragment,e),h(Ds.$$.fragment,e),h(Ms.$$.fragment,e),h(es.$$.fragment,e),Ar=!1},d(e){t(a),e&&t(c),q(n,e),e&&t(v),e&&t(b),q(z),e&&t(H),As[E].d(e),e&&t(B),e&&t(O),e&&t(fa),Os[re].d(e),e&&t(Zs),e&&t(Fe),q(ns),e&&t(ha),e&&t(Pe),e&&t(_a),q(as,e),e&&t(va),q(rs,e),e&&t(ba),e&&t(tt),e&&t($a),q(os,e),e&&t(ga),q(ls,e),e&&t(xa),e&&t(nt),e&&t(qa),e&&t(Ue),q(is),e&&t(ka),e&&t(I),e&&t(wa),Is[le].d(e),e&&t(rt),e&&t(ot),e&&t(ja),e&&t(Ge),e&&t(Ea),e&&t(F),e&&t(ya),q(cs,e),e&&t(Pa),Fs[ue].d(e),e&&t(lt),e&&t(A),e&&t(Ca),e&&t(Qe),e&&t(za),Us[me].d(e),e&&t(it),e&&t(ut),e&&t(Na),Gs[de].d(e),e&&t(pt),e&&t(U),e&&t(Sa),e&&t(R),e&&t(La),e&&t(Ce),e&&t(Aa),e&&t(mt),e&&t(Oa),q(ds,e),e&&t(Ia),Js[he].d(e),e&&t(ct),e&&t(Q),e&&t(Fa),q(fs,e),e&&t(Ua),e&&t(dt),e&&t(Ga),q(hs,e),e&&t(Ja),q(Ke,e),e&&t(Ra),e&&t(G),e&&t(Ha),q(_s,e),e&&t(Qa),e&&t(ft),e&&t(Ka),q(vs,e),e&&t(Va),q(bs,e),e&&t(Wa),e&&t(ht),e&&t(Ba),q(Ve,e),e&&t(Ya),e&&t(Je),q($s),e&&t(Xa),e&&t(ze),e&&t(Za),q(gs,e),e&&t(er),q(xs,e),e&&t(sr),e&&t(Be),e&&t(tr),q(qs,e),e&&t(nr),q(ks,e),e&&t(ar),e&&t(Ye),e&&t(rr),e&&t(Y),e&&t(or),q(ws,e),e&&t(lr),q(js,e),e&&t(ir),e&&t(K),e&&t(ur),e&&t(_t),e&&t(pr),q(Es,e),e&&t(mr),q(ys,e),e&&t(cr),e&&t(Ne),e&&t(dr),q(Ps,e),e&&t(fr),q(Cs,e),e&&t(hr),e&&t(vt),e&&t(_r),q(zs,e),e&&t(vr),e&&t(bt),e&&t(br),q(Ns,e),e&&t($r),e&&t($t),e&&t(gr),e&&t(T),e&&t(xr),q(Ss,e),e&&t(qr),e&&t(V),e&&t(kr),Rs[ve].d(e),e&&t(gt),e&&t(xt),e&&t(wr),q(Ts,e),e&&t(jr),Hs[$e].d(e),e&&t(qt),e&&t(X),e&&t(Er),Qs[xe].d(e),e&&t(kt),e&&t(wt),e&&t(yr),Ks[ke].d(e),e&&t(jt),e&&t(Et),e&&t(Pr),Vs[je].d(e),e&&t(yt),q(Ls,e),e&&t(Cr),e&&t(Xe),e&&t(zr),q(Ze,e),e&&t(Nr),e&&t(Se),e&&t(Sr),q(Ds,e),e&&t(Tr),q(Ms,e),e&&t(Lr),e&&t(Pt),e&&t(Dr),q(es,e),e&&t(Mr),e&&t(Te)}}}const bc={local:"itokenizeri-rapide-dans-le-pipeline-de-qa",sections:[{local:"utilisation-du-pipeline-de-questionanswering",sections:[{local:"utilisation-dun-modle-pour-rpondre-des-questions",title:"Utilisation d'un mod\xE8le pour r\xE9pondre \xE0 des questions"}],title:"Utilisation du pipeline de `question-answering`"},{local:"gestion-des-contextes-longs",title:"Gestion des contextes longs"}],title:"<i>Tokenizer</i> rapide dans le pipeline de QA"};function $c(k,a,c){let n="pt";return Um(()=>{const v=new URLSearchParams(window.location.search);c(0,n=v.get("fw")||"pt")}),[n]}class yc extends Am{constructor(a){super();Om(this,a,$c,vc,Im,{})}}export{yc as default,bc as metadata};
