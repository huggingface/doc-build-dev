import{S as Pc,i as Nc,s as Hc,e as n,k as d,w as v,t as a,M as Fc,c as r,d as s,m as p,x as y,a as l,h as o,b as E,N as Ac,f as So,G as t,g as c,y as k,o as g,p as Ao,q as b,B as x,v as Lc,n as Oo}from"../../chunks/vendor-hf-doc-builder.js";import{T as Oc}from"../../chunks/Tip-hf-doc-builder.js";import{Y as Rc}from"../../chunks/Youtube-hf-doc-builder.js";import{I as _a}from"../../chunks/IconCopyLink-hf-doc-builder.js";import{C as O}from"../../chunks/CodeBlock-hf-doc-builder.js";import{D as Ic}from"../../chunks/DocNotebookDropdown-hf-doc-builder.js";import{F as Mc}from"../../chunks/FrameworkSwitchCourse-hf-doc-builder.js";function Wc(W){let u,$;return u=new Ic({props:{classNames:"absolute z-10 right-0 top-0",options:[{label:"Google Colab",value:"https://colab.research.google.com/github/huggingface/notebooks/blob/master/course/chapter5/section6_tf.ipynb"},{label:"Aws Studio",value:"https://studiolab.sagemaker.aws/import/github/huggingface/notebooks/blob/master/course/chapter5/section6_tf.ipynb"}]}}),{c(){v(u.$$.fragment)},l(h){y(u.$$.fragment,h)},m(h,j){k(u,h,j),$=!0},i(h){$||(b(u.$$.fragment,h),$=!0)},o(h){g(u.$$.fragment,h),$=!1},d(h){x(u,h)}}}function Uc(W){let u,$;return u=new Ic({props:{classNames:"absolute z-10 right-0 top-0",options:[{label:"Google Colab",value:"https://colab.research.google.com/github/huggingface/notebooks/blob/master/course/chapter5/section6_pt.ipynb"},{label:"Aws Studio",value:"https://studiolab.sagemaker.aws/import/github/huggingface/notebooks/blob/master/course/chapter5/section6_pt.ipynb"}]}}),{c(){v(u.$$.fragment)},l(h){y(u.$$.fragment,h)},m(h,j){k(u,h,j),$=!0},i(h){$||(b(u.$$.fragment,h),$=!0)},o(h){g(u.$$.fragment,h),$=!1},d(h){x(u,h)}}}function Gc(W){let u,$,h,j,f,w,I,_,S,q,M,P,A,N,H,L,G,T,F,Y;return{c(){u=n("p"),$=a("\u270F\uFE0F "),h=n("strong"),j=a("Try it out!"),f=a(" See if you can use "),w=n("code"),I=a("Dataset.map()"),_=a(" to explode the "),S=n("code"),q=a("comments"),M=a(" column of "),P=n("code"),A=a("issues_dataset"),N=d(),H=n("em"),L=a("without"),G=a(" resorting to the use of Pandas. This is a little tricky; you might find the "),T=n("a"),F=a("\u201CBatch mapping\u201D"),Y=a(" section of the \u{1F917} Datasets documentation useful for this task."),this.h()},l(U){u=r(U,"P",{});var D=l(u);$=o(D,"\u270F\uFE0F "),h=r(D,"STRONG",{});var z=l(h);j=o(z,"Try it out!"),z.forEach(s),f=o(D," See if you can use "),w=r(D,"CODE",{});var m=l(w);I=o(m,"Dataset.map()"),m.forEach(s),_=o(D," to explode the "),S=r(D,"CODE",{});var C=l(S);q=o(C,"comments"),C.forEach(s),M=o(D," column of "),P=r(D,"CODE",{});var R=l(P);A=o(R,"issues_dataset"),R.forEach(s),N=p(D),H=r(D,"EM",{});var J=l(H);L=o(J,"without"),J.forEach(s),G=o(D," resorting to the use of Pandas. This is a little tricky; you might find the "),T=r(D,"A",{href:!0,rel:!0});var ne=l(T);F=o(ne,"\u201CBatch mapping\u201D"),ne.forEach(s),Y=o(D," section of the \u{1F917} Datasets documentation useful for this task."),D.forEach(s),this.h()},h(){E(T,"href","https://huggingface.co/docs/datasets/v1.12.1/about_map_batch.html?batch-mapping#batch-mapping"),E(T,"rel","nofollow")},m(U,D){c(U,u,D),t(u,$),t(u,h),t(h,j),t(u,f),t(u,w),t(w,I),t(u,_),t(u,S),t(S,q),t(u,M),t(u,P),t(P,A),t(u,N),t(u,H),t(H,L),t(u,G),t(u,T),t(T,F),t(u,Y)},d(U){U&&s(u)}}}function zc(W){let u,$,h,j,f,w,I,_,S,q,M,P,A,N,H,L,G;return u=new O({props:{code:"",highlighted:`<span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> AutoTokenizer, TFAutoModel

model_ckpt = <span class="hljs-string">&quot;sentence-transformers/multi-qa-mpnet-base-dot-v1&quot;</span>
tokenizer = AutoTokenizer.from_pretrained(model_ckpt)
model = TFAutoModel.from_pretrained(model_ckpt, from_pt=<span class="hljs-literal">True</span>)`}}),{c(){v(u.$$.fragment),$=d(),h=n("p"),j=a("Note that we\u2019ve set "),f=n("code"),w=a("from_pt=True"),I=a(" as an argument of the "),_=n("code"),S=a("from_pretrained()"),q=a(" method. That\u2019s because the "),M=n("code"),P=a("multi-qa-mpnet-base-dot-v1"),A=a(" checkpoint only has PyTorch weights, so setting "),N=n("code"),H=a("from_pt=True"),L=a(" will automatically convert them to the TensorFlow format for us. As you can see, it is very simple to switch between frameworks in \u{1F917} Transformers!")},l(T){y(u.$$.fragment,T),$=p(T),h=r(T,"P",{});var F=l(h);j=o(F,"Note that we\u2019ve set "),f=r(F,"CODE",{});var Y=l(f);w=o(Y,"from_pt=True"),Y.forEach(s),I=o(F," as an argument of the "),_=r(F,"CODE",{});var U=l(_);S=o(U,"from_pretrained()"),U.forEach(s),q=o(F," method. That\u2019s because the "),M=r(F,"CODE",{});var D=l(M);P=o(D,"multi-qa-mpnet-base-dot-v1"),D.forEach(s),A=o(F," checkpoint only has PyTorch weights, so setting "),N=r(F,"CODE",{});var z=l(N);H=o(z,"from_pt=True"),z.forEach(s),L=o(F," will automatically convert them to the TensorFlow format for us. As you can see, it is very simple to switch between frameworks in \u{1F917} Transformers!"),F.forEach(s)},m(T,F){k(u,T,F),c(T,$,F),c(T,h,F),t(h,j),t(h,f),t(f,w),t(h,I),t(h,_),t(_,S),t(h,q),t(h,M),t(M,P),t(h,A),t(h,N),t(N,H),t(h,L),G=!0},i(T){G||(b(u.$$.fragment,T),G=!0)},o(T){g(u.$$.fragment,T),G=!1},d(T){x(u,T),T&&s($),T&&s(h)}}}function Bc(W){let u,$,h,j,f,w,I;return u=new O({props:{code:"",highlighted:`<span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> AutoTokenizer, AutoModel

model_ckpt = <span class="hljs-string">&quot;sentence-transformers/multi-qa-mpnet-base-dot-v1&quot;</span>
tokenizer = AutoTokenizer.from_pretrained(model_ckpt)
model = AutoModel.from_pretrained(model_ckpt)`}}),w=new O({props:{code:"",highlighted:`<span class="hljs-keyword">import</span> torch

device = torch.device(<span class="hljs-string">&quot;cuda&quot;</span>)
model.to(device)`}}),{c(){v(u.$$.fragment),$=d(),h=n("p"),j=a("To speed up the embedding process, it helps to place the model and inputs on a GPU device, so let\u2019s do that now:"),f=d(),v(w.$$.fragment)},l(_){y(u.$$.fragment,_),$=p(_),h=r(_,"P",{});var S=l(h);j=o(S,"To speed up the embedding process, it helps to place the model and inputs on a GPU device, so let\u2019s do that now:"),S.forEach(s),f=p(_),y(w.$$.fragment,_)},m(_,S){k(u,_,S),c(_,$,S),c(_,h,S),t(h,j),c(_,f,S),k(w,_,S),I=!0},i(_){I||(b(u.$$.fragment,_),b(w.$$.fragment,_),I=!0)},o(_){g(u.$$.fragment,_),g(w.$$.fragment,_),I=!1},d(_){x(u,_),_&&s($),_&&s(h),_&&s(f),x(w,_)}}}function Yc(W){let u,$,h,j,f,w,I,_,S,q,M,P,A,N,H,L,G,T,F,Y,U,D,z;return u=new O({props:{code:`def get_embeddings(text_list):
    encoded_input = tokenizer(
        text_list, padding=True, truncation=True, return_tensors="tf"
    )
    encoded_input = {k: v for k, v in encoded_input.items()}
    model_output = model(**encoded_input)
    return cls_pooling(model_output)`,highlighted:`<span class="hljs-keyword">def</span> <span class="hljs-title function_">get_embeddings</span>(<span class="hljs-params">text_list</span>):
    encoded_input = tokenizer(
        text_list, padding=<span class="hljs-literal">True</span>, truncation=<span class="hljs-literal">True</span>, return_tensors=<span class="hljs-string">&quot;tf&quot;</span>
    )
    encoded_input = {k: v <span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span> encoded_input.items()}
    model_output = model(**encoded_input)
    <span class="hljs-keyword">return</span> cls_pooling(model_output)`}}),w=new O({props:{code:`embedding = get_embeddings(comments_dataset["text"][0])
embedding.shape`,highlighted:`embedding = get_embeddings(comments_dataset[<span class="hljs-string">&quot;text&quot;</span>][<span class="hljs-number">0</span>])
embedding.shape`}}),_=new O({props:{code:"TensorShape([1, 768])",highlighted:'TensorShape([<span class="hljs-number">1</span>, <span class="hljs-number">768</span>])'}}),D=new O({props:{code:`embeddings_dataset = comments_dataset.map(
    lambda x: {"embeddings": get_embeddings(x["text"]).numpy()[0]}
)`,highlighted:`embeddings_dataset = comments_dataset.<span class="hljs-built_in">map</span>(
    <span class="hljs-keyword">lambda</span> x: {<span class="hljs-string">&quot;embeddings&quot;</span>: get_embeddings(x[<span class="hljs-string">&quot;text&quot;</span>]).numpy()[<span class="hljs-number">0</span>]}
)`}}),{c(){v(u.$$.fragment),$=d(),h=n("p"),j=a("We can test the function works by feeding it the first text entry in our corpus and inspecting the output shape:"),f=d(),v(w.$$.fragment),I=d(),v(_.$$.fragment),S=d(),q=n("p"),M=a("Great, we\u2019ve converted the first entry in our corpus into a 768-dimensional vector! We can use "),P=n("code"),A=a("Dataset.map()"),N=a(" to apply our "),H=n("code"),L=a("get_embeddings()"),G=a(" function to each row in our corpus, so let\u2019s create a new "),T=n("code"),F=a("embeddings"),Y=a(" column as follows:"),U=d(),v(D.$$.fragment)},l(m){y(u.$$.fragment,m),$=p(m),h=r(m,"P",{});var C=l(h);j=o(C,"We can test the function works by feeding it the first text entry in our corpus and inspecting the output shape:"),C.forEach(s),f=p(m),y(w.$$.fragment,m),I=p(m),y(_.$$.fragment,m),S=p(m),q=r(m,"P",{});var R=l(q);M=o(R,"Great, we\u2019ve converted the first entry in our corpus into a 768-dimensional vector! We can use "),P=r(R,"CODE",{});var J=l(P);A=o(J,"Dataset.map()"),J.forEach(s),N=o(R," to apply our "),H=r(R,"CODE",{});var ne=l(H);L=o(ne,"get_embeddings()"),ne.forEach(s),G=o(R," function to each row in our corpus, so let\u2019s create a new "),T=r(R,"CODE",{});var ce=l(T);F=o(ce,"embeddings"),ce.forEach(s),Y=o(R," column as follows:"),R.forEach(s),U=p(m),y(D.$$.fragment,m)},m(m,C){k(u,m,C),c(m,$,C),c(m,h,C),t(h,j),c(m,f,C),k(w,m,C),c(m,I,C),k(_,m,C),c(m,S,C),c(m,q,C),t(q,M),t(q,P),t(P,A),t(q,N),t(q,H),t(H,L),t(q,G),t(q,T),t(T,F),t(q,Y),c(m,U,C),k(D,m,C),z=!0},i(m){z||(b(u.$$.fragment,m),b(w.$$.fragment,m),b(_.$$.fragment,m),b(D.$$.fragment,m),z=!0)},o(m){g(u.$$.fragment,m),g(w.$$.fragment,m),g(_.$$.fragment,m),g(D.$$.fragment,m),z=!1},d(m){x(u,m),m&&s($),m&&s(h),m&&s(f),x(w,m),m&&s(I),x(_,m),m&&s(S),m&&s(q),m&&s(U),x(D,m)}}}function Jc(W){let u,$,h,j,f,w,I,_,S,q,M,P,A,N,H,L,G,T,F,Y,U,D,z;return u=new O({props:{code:`def get_embeddings(text_list):
    encoded_input = tokenizer(
        text_list, padding=True, truncation=True, return_tensors="pt"
    )
    encoded_input = {k: v.to(device) for k, v in encoded_input.items()}
    model_output = model(**encoded_input)
    return cls_pooling(model_output)`,highlighted:`<span class="hljs-keyword">def</span> <span class="hljs-title function_">get_embeddings</span>(<span class="hljs-params">text_list</span>):
    encoded_input = tokenizer(
        text_list, padding=<span class="hljs-literal">True</span>, truncation=<span class="hljs-literal">True</span>, return_tensors=<span class="hljs-string">&quot;pt&quot;</span>
    )
    encoded_input = {k: v.to(device) <span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span> encoded_input.items()}
    model_output = model(**encoded_input)
    <span class="hljs-keyword">return</span> cls_pooling(model_output)`}}),w=new O({props:{code:`embedding = get_embeddings(comments_dataset["text"][0])
embedding.shape`,highlighted:`embedding = get_embeddings(comments_dataset[<span class="hljs-string">&quot;text&quot;</span>][<span class="hljs-number">0</span>])
embedding.shape`}}),_=new O({props:{code:"torch.Size([1, 768])",highlighted:'torch.Size([<span class="hljs-number">1</span>, <span class="hljs-number">768</span>])'}}),D=new O({props:{code:`embeddings_dataset = comments_dataset.map(
    lambda x: {"embeddings": get_embeddings(x["text"]).detach().cpu().numpy()[0]}
)`,highlighted:`embeddings_dataset = comments_dataset.<span class="hljs-built_in">map</span>(
    <span class="hljs-keyword">lambda</span> x: {<span class="hljs-string">&quot;embeddings&quot;</span>: get_embeddings(x[<span class="hljs-string">&quot;text&quot;</span>]).detach().cpu().numpy()[<span class="hljs-number">0</span>]}
)`}}),{c(){v(u.$$.fragment),$=d(),h=n("p"),j=a("We can test the function works by feeding it the first text entry in our corpus and inspecting the output shape:"),f=d(),v(w.$$.fragment),I=d(),v(_.$$.fragment),S=d(),q=n("p"),M=a("Great, we\u2019ve converted the first entry in our corpus into a 768-dimensional vector! We can use "),P=n("code"),A=a("Dataset.map()"),N=a(" to apply our "),H=n("code"),L=a("get_embeddings()"),G=a(" function to each row in our corpus, so let\u2019s create a new "),T=n("code"),F=a("embeddings"),Y=a(" column as follows:"),U=d(),v(D.$$.fragment)},l(m){y(u.$$.fragment,m),$=p(m),h=r(m,"P",{});var C=l(h);j=o(C,"We can test the function works by feeding it the first text entry in our corpus and inspecting the output shape:"),C.forEach(s),f=p(m),y(w.$$.fragment,m),I=p(m),y(_.$$.fragment,m),S=p(m),q=r(m,"P",{});var R=l(q);M=o(R,"Great, we\u2019ve converted the first entry in our corpus into a 768-dimensional vector! We can use "),P=r(R,"CODE",{});var J=l(P);A=o(J,"Dataset.map()"),J.forEach(s),N=o(R," to apply our "),H=r(R,"CODE",{});var ne=l(H);L=o(ne,"get_embeddings()"),ne.forEach(s),G=o(R," function to each row in our corpus, so let\u2019s create a new "),T=r(R,"CODE",{});var ce=l(T);F=o(ce,"embeddings"),ce.forEach(s),Y=o(R," column as follows:"),R.forEach(s),U=p(m),y(D.$$.fragment,m)},m(m,C){k(u,m,C),c(m,$,C),c(m,h,C),t(h,j),c(m,f,C),k(w,m,C),c(m,I,C),k(_,m,C),c(m,S,C),c(m,q,C),t(q,M),t(q,P),t(P,A),t(q,N),t(q,H),t(H,L),t(q,G),t(q,T),t(T,F),t(q,Y),c(m,U,C),k(D,m,C),z=!0},i(m){z||(b(u.$$.fragment,m),b(w.$$.fragment,m),b(_.$$.fragment,m),b(D.$$.fragment,m),z=!0)},o(m){g(u.$$.fragment,m),g(w.$$.fragment,m),g(_.$$.fragment,m),g(D.$$.fragment,m),z=!1},d(m){x(u,m),m&&s($),m&&s(h),m&&s(f),x(w,m),m&&s(I),x(_,m),m&&s(S),m&&s(q),m&&s(U),x(D,m)}}}function Vc(W){let u,$,h,j;return u=new O({props:{code:`question = "How can I load a dataset offline?"
question_embedding = get_embeddings([question]).numpy()
question_embedding.shape`,highlighted:`question = <span class="hljs-string">&quot;How can I load a dataset offline?&quot;</span>
question_embedding = get_embeddings([question]).numpy()
question_embedding.shape`}}),h=new O({props:{code:"(1, 768)",highlighted:'(<span class="hljs-number">1</span>, <span class="hljs-number">768</span>)'}}),{c(){v(u.$$.fragment),$=d(),v(h.$$.fragment)},l(f){y(u.$$.fragment,f),$=p(f),y(h.$$.fragment,f)},m(f,w){k(u,f,w),c(f,$,w),k(h,f,w),j=!0},i(f){j||(b(u.$$.fragment,f),b(h.$$.fragment,f),j=!0)},o(f){g(u.$$.fragment,f),g(h.$$.fragment,f),j=!1},d(f){x(u,f),f&&s($),x(h,f)}}}function Qc(W){let u,$,h,j;return u=new O({props:{code:`question = "How can I load a dataset offline?"
question_embedding = get_embeddings([question]).cpu().detach().numpy()
question_embedding.shape`,highlighted:`question = <span class="hljs-string">&quot;How can I load a dataset offline?&quot;</span>
question_embedding = get_embeddings([question]).cpu().detach().numpy()
question_embedding.shape`}}),h=new O({props:{code:"torch.Size([1, 768])",highlighted:'torch.Size([<span class="hljs-number">1</span>, <span class="hljs-number">768</span>])'}}),{c(){v(u.$$.fragment),$=d(),v(h.$$.fragment)},l(f){y(u.$$.fragment,f),$=p(f),y(h.$$.fragment,f)},m(f,w){k(u,f,w),c(f,$,w),k(h,f,w),j=!0},i(f){j||(b(u.$$.fragment,f),b(h.$$.fragment,f),j=!0)},o(f){g(u.$$.fragment,f),g(h.$$.fragment,f),j=!1},d(f){x(u,f),f&&s($),x(h,f)}}}function Xc(W){let u,$,h,j,f,w,I,_,S,q,M;return{c(){u=n("p"),$=a("\u270F\uFE0F "),h=n("strong"),j=a("Try it out!"),f=a(" Create your own query and see whether you can find an answer in the retrieved documents. You might have to increase the "),w=n("code"),I=a("k"),_=a(" parameter in "),S=n("code"),q=a("Dataset.get_nearest_examples()"),M=a(" to broaden the search.")},l(P){u=r(P,"P",{});var A=l(u);$=o(A,"\u270F\uFE0F "),h=r(A,"STRONG",{});var N=l(h);j=o(N,"Try it out!"),N.forEach(s),f=o(A," Create your own query and see whether you can find an answer in the retrieved documents. You might have to increase the "),w=r(A,"CODE",{});var H=l(w);I=o(H,"k"),H.forEach(s),_=o(A," parameter in "),S=r(A,"CODE",{});var L=l(S);q=o(L,"Dataset.get_nearest_examples()"),L.forEach(s),M=o(A," to broaden the search."),A.forEach(s)},m(P,A){c(P,u,A),t(u,$),t(u,h),t(h,j),t(u,f),t(u,w),t(w,I),t(u,_),t(u,S),t(S,q),t(u,M)},d(P){P&&s(u)}}}function Kc(W){let u,$,h,j,f,w,I,_,S,q,M,P,A,N,H,L,G,T,F,Y,U,D,z,m,C,R,J,ne,ce,Io,ga,ge,Po,Ct,No,Ho,ss,Fo,Lo,ba,St,Ro,wa,Ce,Ye,Ml,Mo,Je,Wl,$a,Se,Ie,as,Ve,Wo,os,Uo,va,At,Go,ya,Qe,ka,be,zo,ns,Bo,Yo,Ot,Jo,Vo,xa,Xe,Ea,Ke,ja,V,Qo,rs,Xo,Ko,ls,Zo,en,is,tn,sn,cs,an,on,ds,nn,rn,qa,Ze,Da,et,Ta,Q,ln,ps,cn,dn,us,pn,un,ms,mn,hn,hs,fn,_n,fs,gn,bn,Ca,tt,Sa,st,Aa,K,wn,_s,$n,vn,gs,yn,kn,Pe,bs,xn,En,jn,ws,qn,Dn,Oa,at,Ia,Ne,Tn,$s,Cn,Sn,Pa,ot,Na,nt,Ha,He,An,vs,On,In,Fa,rt,La,ee,ys,Z,Ra,Pn,ks,Nn,Hn,xs,Fn,Ln,Es,Rn,Mn,js,Wn,Un,de,te,qs,Gn,zn,Ds,Bn,Yn,Ts,Jn,Vn,Cs,Qn,Xn,Ss,Kn,Zn,se,As,er,tr,Os,sr,ar,Is,or,nr,Ps,rr,lr,Ns,ir,cr,ae,Hs,dr,pr,Fs,ur,mr,Ls,hr,fr,Rs,_r,gr,Ms,br,wr,oe,Ws,$r,vr,Us,yr,kr,Gs,xr,Er,zs,jr,qr,Bs,Dr,Ma,re,Tr,Ys,Cr,Sr,Js,Ar,Or,Vs,Ir,Pr,Wa,lt,Ua,it,Ga,It,Nr,za,Fe,Ba,Le,Hr,Qs,Fr,Lr,Ya,ct,Ja,Pt,Rr,Va,dt,Qa,pt,Xa,we,Mr,Xs,Wr,Ur,Ks,Gr,zr,Ka,ut,Za,Nt,Br,eo,Ae,Re,Zs,mt,Yr,ea,Jr,to,B,Vr,Ht,Qr,Xr,ta,Kr,Zr,sa,el,tl,ht,sl,al,aa,ol,nl,ft,rl,ll,oa,il,cl,so,pe,ue,Ft,$e,dl,na,pl,ul,ra,ml,hl,ao,_t,oo,Lt,fl,no,me,he,Rt,Mt,_l,ro,Oe,Me,la,gt,gl,ia,bl,lo,ve,wl,ca,$l,vl,bt,yl,kl,io,ye,xl,da,El,jl,pa,ql,Dl,co,wt,po,We,Tl,ua,Cl,Sl,uo,fe,_e,Wt,Ut,Al,mo,$t,ho,ke,Ol,ma,Il,Pl,ha,Nl,Hl,fo,vt,_o,Gt,Fl,go,yt,bo,kt,wo,zt,Ll,$o,Ue,vo;h=new Mc({props:{fw:W[0]}}),_=new _a({});const Ul=[Uc,Wc],xt=[];function Gl(e,i){return e[0]==="pt"?0:1}A=Gl(W),N=xt[A]=Ul[A](W),D=new Rc({props:{id:"OATCgQtNX2o"}}),J=new _a({}),Ve=new _a({}),Qe=new O({props:{code:"",highlighted:`<span class="hljs-keyword">from</span> huggingface_hub <span class="hljs-keyword">import</span> hf_hub_url

data_files = hf_hub_url(
    repo_id=<span class="hljs-string">&quot;lewtun/github-issues&quot;</span>,
    filename=<span class="hljs-string">&quot;datasets-issues-with-hf-doc-builder.jsonl&quot;</span>,
    repo_type=<span class="hljs-string">&quot;dataset&quot;</span>,
)`}}),Xe=new O({props:{code:"",highlighted:`<span class="hljs-keyword">from</span> datasets <span class="hljs-keyword">import</span> load_dataset

issues_dataset = load_dataset(<span class="hljs-string">&quot;json&quot;</span>, data_files=data_files, split=<span class="hljs-string">&quot;train&quot;</span>)
issues_dataset`}}),Ke=new O({props:{code:`Dataset({
    features: ['url', 'repository_url', 'labels_url', 'comments_url', 'events_url', 'html_url', 'id', 'node_id', 'number', 'title', 'user', 'labels', 'state', 'locked', 'assignee', 'assignees', 'milestone', 'comments', 'created_at', 'updated_at', 'closed_at', 'author_association', 'active_lock_reason', 'pull_request', 'body', 'performed_via_github_app', 'is_pull_request'],
    num_rows: 2855
})`,highlighted:`Dataset({
    features: [<span class="hljs-string">&#x27;url&#x27;</span>, <span class="hljs-string">&#x27;repository_url&#x27;</span>, <span class="hljs-string">&#x27;labels_url&#x27;</span>, <span class="hljs-string">&#x27;comments_url&#x27;</span>, <span class="hljs-string">&#x27;events_url&#x27;</span>, <span class="hljs-string">&#x27;html_url&#x27;</span>, <span class="hljs-string">&#x27;id&#x27;</span>, <span class="hljs-string">&#x27;node_id&#x27;</span>, <span class="hljs-string">&#x27;number&#x27;</span>, <span class="hljs-string">&#x27;title&#x27;</span>, <span class="hljs-string">&#x27;user&#x27;</span>, <span class="hljs-string">&#x27;labels&#x27;</span>, <span class="hljs-string">&#x27;state&#x27;</span>, <span class="hljs-string">&#x27;locked&#x27;</span>, <span class="hljs-string">&#x27;assignee&#x27;</span>, <span class="hljs-string">&#x27;assignees&#x27;</span>, <span class="hljs-string">&#x27;milestone&#x27;</span>, <span class="hljs-string">&#x27;comments&#x27;</span>, <span class="hljs-string">&#x27;created_at&#x27;</span>, <span class="hljs-string">&#x27;updated_at&#x27;</span>, <span class="hljs-string">&#x27;closed_at&#x27;</span>, <span class="hljs-string">&#x27;author_association&#x27;</span>, <span class="hljs-string">&#x27;active_lock_reason&#x27;</span>, <span class="hljs-string">&#x27;pull_request&#x27;</span>, <span class="hljs-string">&#x27;body&#x27;</span>, <span class="hljs-string">&#x27;performed_via_github_app&#x27;</span>, <span class="hljs-string">&#x27;is_pull_request&#x27;</span>],
    num_rows: <span class="hljs-number">2855</span>
})`}}),Ze=new O({props:{code:`issues_dataset = issues_dataset.filter(
    lambda x: (x["is_pull_request"] == False and len(x["comments"]) > 0)
)
issues_dataset`,highlighted:`issues_dataset = issues_dataset.<span class="hljs-built_in">filter</span>(
    <span class="hljs-keyword">lambda</span> x: (x[<span class="hljs-string">&quot;is_pull_request&quot;</span>] == <span class="hljs-literal">False</span> <span class="hljs-keyword">and</span> <span class="hljs-built_in">len</span>(x[<span class="hljs-string">&quot;comments&quot;</span>]) &gt; <span class="hljs-number">0</span>)
)
issues_dataset`}}),et=new O({props:{code:`Dataset({
    features: ['url', 'repository_url', 'labels_url', 'comments_url', 'events_url', 'html_url', 'id', 'node_id', 'number', 'title', 'user', 'labels', 'state', 'locked', 'assignee', 'assignees', 'milestone', 'comments', 'created_at', 'updated_at', 'closed_at', 'author_association', 'active_lock_reason', 'pull_request', 'body', 'performed_via_github_app', 'is_pull_request'],
    num_rows: 771
})`,highlighted:`Dataset({
    features: [<span class="hljs-string">&#x27;url&#x27;</span>, <span class="hljs-string">&#x27;repository_url&#x27;</span>, <span class="hljs-string">&#x27;labels_url&#x27;</span>, <span class="hljs-string">&#x27;comments_url&#x27;</span>, <span class="hljs-string">&#x27;events_url&#x27;</span>, <span class="hljs-string">&#x27;html_url&#x27;</span>, <span class="hljs-string">&#x27;id&#x27;</span>, <span class="hljs-string">&#x27;node_id&#x27;</span>, <span class="hljs-string">&#x27;number&#x27;</span>, <span class="hljs-string">&#x27;title&#x27;</span>, <span class="hljs-string">&#x27;user&#x27;</span>, <span class="hljs-string">&#x27;labels&#x27;</span>, <span class="hljs-string">&#x27;state&#x27;</span>, <span class="hljs-string">&#x27;locked&#x27;</span>, <span class="hljs-string">&#x27;assignee&#x27;</span>, <span class="hljs-string">&#x27;assignees&#x27;</span>, <span class="hljs-string">&#x27;milestone&#x27;</span>, <span class="hljs-string">&#x27;comments&#x27;</span>, <span class="hljs-string">&#x27;created_at&#x27;</span>, <span class="hljs-string">&#x27;updated_at&#x27;</span>, <span class="hljs-string">&#x27;closed_at&#x27;</span>, <span class="hljs-string">&#x27;author_association&#x27;</span>, <span class="hljs-string">&#x27;active_lock_reason&#x27;</span>, <span class="hljs-string">&#x27;pull_request&#x27;</span>, <span class="hljs-string">&#x27;body&#x27;</span>, <span class="hljs-string">&#x27;performed_via_github_app&#x27;</span>, <span class="hljs-string">&#x27;is_pull_request&#x27;</span>],
    num_rows: <span class="hljs-number">771</span>
})`}}),tt=new O({props:{code:`columns = issues_dataset.column_names
columns_to_keep = ["title", "body", "html_url", "comments"]
columns_to_remove = set(columns_to_keep).symmetric_difference(columns)
issues_dataset = issues_dataset.remove_columns(columns_to_remove)
issues_dataset`,highlighted:`columns = issues_dataset.column_names
columns_to_keep = [<span class="hljs-string">&quot;title&quot;</span>, <span class="hljs-string">&quot;body&quot;</span>, <span class="hljs-string">&quot;html_url&quot;</span>, <span class="hljs-string">&quot;comments&quot;</span>]
columns_to_remove = <span class="hljs-built_in">set</span>(columns_to_keep).symmetric_difference(columns)
issues_dataset = issues_dataset.remove_columns(columns_to_remove)
issues_dataset`}}),st=new O({props:{code:`Dataset({
    features: ['html_url', 'title', 'comments', 'body'],
    num_rows: 771
})`,highlighted:`Dataset({
    features: [<span class="hljs-string">&#x27;html_url&#x27;</span>, <span class="hljs-string">&#x27;title&#x27;</span>, <span class="hljs-string">&#x27;comments&#x27;</span>, <span class="hljs-string">&#x27;body&#x27;</span>],
    num_rows: <span class="hljs-number">771</span>
})`}}),at=new O({props:{code:`issues_dataset.set_format("pandas")
df = issues_dataset[:]`,highlighted:`issues_dataset.set_format(<span class="hljs-string">&quot;pandas&quot;</span>)
df = issues_dataset[:]`}}),ot=new O({props:{code:'df["comments"][0].tolist()',highlighted:'df[<span class="hljs-string">&quot;comments&quot;</span>][<span class="hljs-number">0</span>].tolist()'}}),nt=new O({props:{code:`['the bug code locate in \uFF1A\\r\\n    if data_args.task_name is not None:\\r\\n        # Downloading and loading a dataset from the hub.\\r\\n        datasets = load_dataset("glue", data_args.task_name, cache_dir=model_args.cache_dir)',
 'Hi @jinec,\\r\\n\\r\\nFrom time to time we get this kind of \`ConnectionError\` coming from the github.com website: https://raw.githubusercontent.com\\r\\n\\r\\nNormally, it should work if you wait a little and then retry.\\r\\n\\r\\nCould you please confirm if the problem persists?',
 'cannot connect\uFF0Ceven by Web browser\uFF0Cplease check that  there is some  problems\u3002',
 'I can access https://raw.githubusercontent.com/huggingface/datasets/1.7.0/datasets/glue/glue.py without problem...']`,highlighted:`[<span class="hljs-string">&#x27;the bug code locate in \uFF1A\\r\\n    if data_args.task_name is not None:\\r\\n        # Downloading and loading a dataset from the hub.\\r\\n        datasets = load_dataset(&quot;glue&quot;, data_args.task_name, cache_dir=model_args.cache_dir)&#x27;</span>,
 <span class="hljs-string">&#x27;Hi @jinec,\\r\\n\\r\\nFrom time to time we get this kind of \`ConnectionError\` coming from the github.com website: https://raw.githubusercontent.com\\r\\n\\r\\nNormally, it should work if you wait a little and then retry.\\r\\n\\r\\nCould you please confirm if the problem persists?&#x27;</span>,
 <span class="hljs-string">&#x27;cannot connect\uFF0Ceven by Web browser\uFF0Cplease check that  there is some  problems\u3002&#x27;</span>,
 <span class="hljs-string">&#x27;I can access https://raw.githubusercontent.com/huggingface/datasets/1.7.0/datasets/glue/glue.py without problem...&#x27;</span>]`}}),rt=new O({props:{code:`comments_df = df.explode("comments", ignore_index=True)
comments_df.head(4)`,highlighted:`comments_df = df.explode(<span class="hljs-string">&quot;comments&quot;</span>, ignore_index=<span class="hljs-literal">True</span>)
comments_df.head(<span class="hljs-number">4</span>)`}}),lt=new O({props:{code:"",highlighted:`<span class="hljs-keyword">from</span> datasets <span class="hljs-keyword">import</span> Dataset

comments_dataset = Dataset.from_pandas(comments_df)
comments_dataset`}}),it=new O({props:{code:`Dataset({
    features: ['html_url', 'title', 'comments', 'body'],
    num_rows: 2842
})`,highlighted:`Dataset({
    features: [<span class="hljs-string">&#x27;html_url&#x27;</span>, <span class="hljs-string">&#x27;title&#x27;</span>, <span class="hljs-string">&#x27;comments&#x27;</span>, <span class="hljs-string">&#x27;body&#x27;</span>],
    num_rows: <span class="hljs-number">2842</span>
})`}}),Fe=new Oc({props:{$$slots:{default:[Gc]},$$scope:{ctx:W}}}),ct=new O({props:{code:`comments_dataset = comments_dataset.map(
    lambda x: {"comment_length": len(x["comments"].split())}
)`,highlighted:`comments_dataset = comments_dataset.<span class="hljs-built_in">map</span>(
    <span class="hljs-keyword">lambda</span> x: {<span class="hljs-string">&quot;comment_length&quot;</span>: <span class="hljs-built_in">len</span>(x[<span class="hljs-string">&quot;comments&quot;</span>].split())}
)`}}),dt=new O({props:{code:`comments_dataset = comments_dataset.filter(lambda x: x["comment_length"] > 15)
comments_dataset`,highlighted:`comments_dataset = comments_dataset.<span class="hljs-built_in">filter</span>(<span class="hljs-keyword">lambda</span> x: x[<span class="hljs-string">&quot;comment_length&quot;</span>] &gt; <span class="hljs-number">15</span>)
comments_dataset`}}),pt=new O({props:{code:`Dataset({
    features: ['html_url', 'title', 'comments', 'body', 'comment_length'],
    num_rows: 2098
})`,highlighted:`Dataset({
    features: [<span class="hljs-string">&#x27;html_url&#x27;</span>, <span class="hljs-string">&#x27;title&#x27;</span>, <span class="hljs-string">&#x27;comments&#x27;</span>, <span class="hljs-string">&#x27;body&#x27;</span>, <span class="hljs-string">&#x27;comment_length&#x27;</span>],
    num_rows: <span class="hljs-number">2098</span>
})`}}),ut=new O({props:{code:`
`,highlighted:`<span class="hljs-keyword">def</span> <span class="hljs-title function_">concatenate_text</span>(<span class="hljs-params">examples</span>):
    <span class="hljs-keyword">return</span> {
        <span class="hljs-string">&quot;text&quot;</span>: examples[<span class="hljs-string">&quot;title&quot;</span>]
        + <span class="hljs-string">&quot; \\n &quot;</span>
        + examples[<span class="hljs-string">&quot;body&quot;</span>]
        + <span class="hljs-string">&quot; \\n &quot;</span>
        + examples[<span class="hljs-string">&quot;comments&quot;</span>]
    }


comments_dataset = comments_dataset.<span class="hljs-built_in">map</span>(concatenate_text)`}}),mt=new _a({});const zl=[Bc,zc],Et=[];function Bl(e,i){return e[0]==="pt"?0:1}pe=Bl(W),ue=Et[pe]=zl[pe](W),_t=new O({props:{code:`def cls_pooling(model_output):
    return model_output.last_hidden_state[:, 0]`,highlighted:`<span class="hljs-keyword">def</span> <span class="hljs-title function_">cls_pooling</span>(<span class="hljs-params">model_output</span>):
    <span class="hljs-keyword">return</span> model_output.last_hidden_state[:, <span class="hljs-number">0</span>]`}});const Yl=[Jc,Yc],jt=[];function Jl(e,i){return e[0]==="pt"?0:1}me=Jl(W),he=jt[me]=Yl[me](W),gt=new _a({}),wt=new O({props:{code:'embeddings_dataset.add_faiss_index(column="embeddings")',highlighted:'embeddings_dataset.add_faiss_index(column=<span class="hljs-string">&quot;embeddings&quot;</span>)'}});const Vl=[Qc,Vc],qt=[];function Ql(e,i){return e[0]==="pt"?0:1}return fe=Ql(W),_e=qt[fe]=Vl[fe](W),$t=new O({props:{code:`scores, samples = embeddings_dataset.get_nearest_examples(
    "embeddings", question_embedding, k=5
)`,highlighted:`scores, samples = embeddings_dataset.get_nearest_examples(
    <span class="hljs-string">&quot;embeddings&quot;</span>, question_embedding, k=<span class="hljs-number">5</span>
)`}}),vt=new O({props:{code:"",highlighted:`<span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd

samples_df = pd.DataFrame.from_dict(samples)
samples_df[<span class="hljs-string">&quot;scores&quot;</span>] = scores
samples_df.sort_values(<span class="hljs-string">&quot;scores&quot;</span>, ascending=<span class="hljs-literal">False</span>, inplace=<span class="hljs-literal">True</span>)`}}),yt=new O({props:{code:`for _, row in samples_df.iterrows():
    print(f"COMMENT: {row.comments}")
    print(f"SCORE: {row.scores}")
    print(f"TITLE: {row.title}")
    print(f"URL: {row.html_url}")
    print("=" * 50)
    print()`,highlighted:`<span class="hljs-keyword">for</span> _, row <span class="hljs-keyword">in</span> samples_df.iterrows():
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;COMMENT: <span class="hljs-subst">{row.comments}</span>&quot;</span>)
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;SCORE: <span class="hljs-subst">{row.scores}</span>&quot;</span>)
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;TITLE: <span class="hljs-subst">{row.title}</span>&quot;</span>)
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;URL: <span class="hljs-subst">{row.html_url}</span>&quot;</span>)
    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;=&quot;</span> * <span class="hljs-number">50</span>)
    <span class="hljs-built_in">print</span>()`}}),kt=new O({props:{code:`














`,highlighted:`<span class="hljs-string">&quot;&quot;&quot;
COMMENT: Requiring online connection is a deal breaker in some cases unfortunately so it&#x27;d be great if offline mode is added similar to how \`transformers\` loads models offline fine.

@mandubian&#x27;s second bullet point suggests that there&#x27;s a workaround allowing you to use your offline (custom?) dataset with \`datasets\`. Could you please elaborate on how that should look like?
SCORE: 25.505046844482422
TITLE: Discussion using datasets in offline mode
URL: https://github.com/huggingface/datasets/issues/824
==================================================

COMMENT: The local dataset builders (csv, text , json and pandas) are now part of the \`datasets\` package since #1726 :)
You can now use them offline
\\\`\\\`\\\`python
datasets = load_dataset(&quot;text&quot;, data_files=data_files)
\\\`\\\`\\\`

We&#x27;ll do a new release soon
SCORE: 24.555509567260742
TITLE: Discussion using datasets in offline mode
URL: https://github.com/huggingface/datasets/issues/824
==================================================

COMMENT: I opened a PR that allows to reload modules that have already been loaded once even if there&#x27;s no internet.

Let me know if you know other ways that can make the offline mode experience better. I&#x27;d be happy to add them :)

I already note the &quot;freeze&quot; modules option, to prevent local modules updates. It would be a cool feature.

----------

&gt; @mandubian&#x27;s second bullet point suggests that there&#x27;s a workaround allowing you to use your offline (custom?) dataset with \`datasets\`. Could you please elaborate on how that should look like?

Indeed \`load_dataset\` allows to load remote dataset script (squad, glue, etc.) but also you own local ones.
For example if you have a dataset script at \`./my_dataset/my_dataset.py\` then you can do
\\\`\\\`\\\`python
load_dataset(&quot;./my_dataset&quot;)
\\\`\\\`\\\`
and the dataset script will generate your dataset once and for all.

----------

About I&#x27;m looking into having \`csv\`, \`json\`, \`text\`, \`pandas\` dataset builders already included in the \`datasets\` package, so that they are available offline by default, as opposed to the other datasets that require the script to be downloaded.
cf #1724
SCORE: 24.14896583557129
TITLE: Discussion using datasets in offline mode
URL: https://github.com/huggingface/datasets/issues/824
==================================================

COMMENT: &gt; here is my way to load a dataset offline, but it **requires** an online machine
&gt;
&gt; 1. (online machine)
&gt;
&gt; \`\`\`
&gt;
&gt; import datasets
&gt;
&gt; data = datasets.load_dataset(...)
&gt;
&gt; data.save_to_disk(/YOUR/DATASET/DIR)
&gt;
&gt; \`\`\`
&gt;
&gt; 2. copy the dir from online to the offline machine
&gt;
&gt; 3. (offline machine)
&gt;
&gt; \`\`\`
&gt;
&gt; import datasets
&gt;
&gt; data = datasets.load_from_disk(/SAVED/DATA/DIR)
&gt;
&gt; \`\`\`
&gt;
&gt;
&gt;
&gt; HTH.


SCORE: 22.893993377685547
TITLE: Discussion using datasets in offline mode
URL: https://github.com/huggingface/datasets/issues/824
==================================================

COMMENT: here is my way to load a dataset offline, but it **requires** an online machine
1. (online machine)
\\\`\\\`\\\`
import datasets
data = datasets.load_dataset(...)
data.save_to_disk(/YOUR/DATASET/DIR)
\\\`\\\`\\\`
2. copy the dir from online to the offline machine
3. (offline machine)
\\\`\\\`\\\`
import datasets
data = datasets.load_from_disk(/SAVED/DATA/DIR)
\\\`\\\`\\\`

HTH.
SCORE: 22.406635284423828
TITLE: Discussion using datasets in offline mode
URL: https://github.com/huggingface/datasets/issues/824
==================================================
&quot;&quot;&quot;</span>`}}),Ue=new Oc({props:{$$slots:{default:[Xc]},$$scope:{ctx:W}}}),{c(){u=n("meta"),$=d(),v(h.$$.fragment),j=d(),f=n("h1"),w=n("a"),I=n("span"),v(_.$$.fragment),S=d(),q=n("span"),M=a("Semantic search with FAISS"),P=d(),N.c(),H=d(),L=n("p"),G=a("In "),T=n("a"),F=a("section 5"),Y=a(", we created a dataset of GitHub issues and comments from the \u{1F917} Datasets repository. In this section we\u2019ll use this information to build a search engine that can help us find answers to our most pressing questions about the library!"),U=d(),v(D.$$.fragment),z=d(),m=n("h2"),C=n("a"),R=n("span"),v(J.$$.fragment),ne=d(),ce=n("span"),Io=a("Using embeddings for semantic search"),ga=d(),ge=n("p"),Po=a("As we saw in "),Ct=n("a"),No=a("Chapter 1"),Ho=a(", Transformer-based language models represent each token in a span of text as an "),ss=n("em"),Fo=a("embedding vector"),Lo=a(". It turns out that one can \u201Cpool\u201D the individual embeddings to create a vector representation for whole sentences, paragraphs, or (in some cases) documents. These embeddings can then be used to find similar documents in the corpus by computing the dot-product similarity (or some other similarity metric) between each embedding and returning the documents with the greatest overlap."),ba=d(),St=n("p"),Ro=a("In this section we\u2019ll use embeddings to develop a semantic search engine. These search engines offer several advantages over conventional approaches that are based on matching keywords in a query with the documents."),wa=d(),Ce=n("div"),Ye=n("img"),Mo=d(),Je=n("img"),$a=d(),Se=n("h2"),Ie=n("a"),as=n("span"),v(Ve.$$.fragment),Wo=d(),os=n("span"),Uo=a("Loading and preparing the dataset"),va=d(),At=n("p"),Go=a("The first thing we need to do is download our dataset of GitHub issues, so let\u2019s use the \u{1F917} Hub library to resolve the URL where our file is stored on the Hugging Face Hub:"),ya=d(),v(Qe.$$.fragment),ka=d(),be=n("p"),zo=a("With the URL stored in "),ns=n("code"),Bo=a("data_files"),Yo=a(", we can then load the remote dataset using the method introduced in "),Ot=n("a"),Jo=a("section 2"),Vo=a(":"),xa=d(),v(Xe.$$.fragment),Ea=d(),v(Ke.$$.fragment),ja=d(),V=n("p"),Qo=a("Here we\u2019ve specified the default "),rs=n("code"),Xo=a("train"),Ko=a(" split in "),ls=n("code"),Zo=a("load_dataset()"),en=a(", so it returns a "),is=n("code"),tn=a("Dataset"),sn=a(" instead of a "),cs=n("code"),an=a("DatasetDict"),on=a(". The first order of business is to filter out the pull requests, as these tend to be rarely used for answering user queries and will introduce noise in our search engine. As should be familiar by now, we can use the "),ds=n("code"),nn=a("Dataset.filter()"),rn=a(" function to exclude these rows in our dataset. While we\u2019re at it, let\u2019s also filter out rows with no comments, since these provide no answers to user queries:"),qa=d(),v(Ze.$$.fragment),Da=d(),v(et.$$.fragment),Ta=d(),Q=n("p"),ln=a("We can see that there are a lot of columns in our dataset, most of which we don\u2019t need to build our search engine. From a search perspective, the most informative columns are "),ps=n("code"),cn=a("title"),dn=a(", "),us=n("code"),pn=a("body"),un=a(", and "),ms=n("code"),mn=a("comments"),hn=a(", while "),hs=n("code"),fn=a("html_url"),_n=a(" provides us with a link back to the source issue. Let\u2019s use the "),fs=n("code"),gn=a("Dataset.remove_columns()"),bn=a(" function to drop the rest:"),Ca=d(),v(tt.$$.fragment),Sa=d(),v(st.$$.fragment),Aa=d(),K=n("p"),wn=a("To create our embeddings we\u2019ll augment each comment with the issue\u2019s title and body, since these fields often include useful contextual information. Because our "),_s=n("code"),$n=a("comments"),vn=a(" column is currently a list of comments for each issue, we need to \u201Cexplode\u201D the column so that each row consists of an "),gs=n("code"),yn=a("(html_url, title, body, comment)"),kn=a(" tuple. In Pandas we can do this with the "),Pe=n("a"),bs=n("code"),xn=a("DataFrame.explode()"),En=a(" function"),jn=a(", which creates a new row for each element in a list-like column, while replicating all the other column values. To see this in action, let\u2019s first switch to the Pandas  "),ws=n("code"),qn=a("DataFrame"),Dn=a(" format:"),Oa=d(),v(at.$$.fragment),Ia=d(),Ne=n("p"),Tn=a("If we inspect the first row in this "),$s=n("code"),Cn=a("DataFrame"),Sn=a(" we can see there are four comments associated with this issue:"),Pa=d(),v(ot.$$.fragment),Na=d(),v(nt.$$.fragment),Ha=d(),He=n("p"),An=a("When we explode "),vs=n("code"),On=a("df"),In=a(", we expect to get one row for each of these comments. Let\u2019s check if that\u2019s the case:"),Fa=d(),v(rt.$$.fragment),La=d(),ee=n("table"),ys=n("thead"),Z=n("tr"),Ra=n("th"),Pn=d(),ks=n("th"),Nn=a("html_url"),Hn=d(),xs=n("th"),Fn=a("title"),Ln=d(),Es=n("th"),Rn=a("comments"),Mn=d(),js=n("th"),Wn=a("body"),Un=d(),de=n("tbody"),te=n("tr"),qs=n("th"),Gn=a("0"),zn=d(),Ds=n("td"),Bn=a("https://github.com/huggingface/datasets/issues/2787"),Yn=d(),Ts=n("td"),Jn=a("ConnectionError: Couldn't reach https://raw.githubusercontent.com"),Vn=d(),Cs=n("td"),Qn=a("the bug code locate in \uFF1A\\r\\n    if data_args.task_name is not None..."),Xn=d(),Ss=n("td"),Kn=a("Hello,\\r\\nI am trying to run run_glue.py and it gives me this error..."),Zn=d(),se=n("tr"),As=n("th"),er=a("1"),tr=d(),Os=n("td"),sr=a("https://github.com/huggingface/datasets/issues/2787"),ar=d(),Is=n("td"),or=a("ConnectionError: Couldn't reach https://raw.githubusercontent.com"),nr=d(),Ps=n("td"),rr=a("Hi @jinec,\\r\\n\\r\\nFrom time to time we get this kind of `ConnectionError` coming from the github.com website: https://raw.githubusercontent.com..."),lr=d(),Ns=n("td"),ir=a("Hello,\\r\\nI am trying to run run_glue.py and it gives me this error..."),cr=d(),ae=n("tr"),Hs=n("th"),dr=a("2"),pr=d(),Fs=n("td"),ur=a("https://github.com/huggingface/datasets/issues/2787"),mr=d(),Ls=n("td"),hr=a("ConnectionError: Couldn't reach https://raw.githubusercontent.com"),fr=d(),Rs=n("td"),_r=a("cannot connect\uFF0Ceven by Web browser\uFF0Cplease check that  there is some  problems\u3002"),gr=d(),Ms=n("td"),br=a("Hello,\\r\\nI am trying to run run_glue.py and it gives me this error..."),wr=d(),oe=n("tr"),Ws=n("th"),$r=a("3"),vr=d(),Us=n("td"),yr=a("https://github.com/huggingface/datasets/issues/2787"),kr=d(),Gs=n("td"),xr=a("ConnectionError: Couldn't reach https://raw.githubusercontent.com"),Er=d(),zs=n("td"),jr=a("I can access https://raw.githubusercontent.com/huggingface/datasets/1.7.0/datasets/glue/glue.py without problem..."),qr=d(),Bs=n("td"),Dr=a("Hello,\\r\\nI am trying to run run_glue.py and it gives me this error..."),Ma=d(),re=n("p"),Tr=a("Great, we can see the rows have been replicated, with the "),Ys=n("code"),Cr=a("comments"),Sr=a(" column containing the individual comments! Now that we\u2019re finished with Pandas, we can quickly switch back to a "),Js=n("code"),Ar=a("Dataset"),Or=a(" by loading the "),Vs=n("code"),Ir=a("DataFrame"),Pr=a(" in memory:"),Wa=d(),v(lt.$$.fragment),Ua=d(),v(it.$$.fragment),Ga=d(),It=n("p"),Nr=a("Okay, this has given us a few thousand comments to work with!"),za=d(),v(Fe.$$.fragment),Ba=d(),Le=n("p"),Hr=a("Now that we have one comment per row, let\u2019s create a new "),Qs=n("code"),Fr=a("comments_length"),Lr=a(" column that contains the number of words per comment:"),Ya=d(),v(ct.$$.fragment),Ja=d(),Pt=n("p"),Rr=a("We can use this new column to filter out short comments, which typically include things like \u201Ccc @lewtun\u201D or \u201CThanks!\u201D that are not relevant for our search engine. There\u2019s no precise number to select for the filter, but around 15 words seems like a good start:"),Va=d(),v(dt.$$.fragment),Qa=d(),v(pt.$$.fragment),Xa=d(),we=n("p"),Mr=a("Having cleaned up our dataset a bit, let\u2019s concatenate the issue title, description, and comments together in a new "),Xs=n("code"),Wr=a("text"),Ur=a(" column. As usual, we\u2019ll write a simple function that we can pass to "),Ks=n("code"),Gr=a("Dataset.map()"),zr=a(":"),Ka=d(),v(ut.$$.fragment),Za=d(),Nt=n("p"),Br=a("We\u2019re finally ready to create some embeddings! Let\u2019s take a look."),eo=d(),Ae=n("h2"),Re=n("a"),Zs=n("span"),v(mt.$$.fragment),Yr=d(),ea=n("span"),Jr=a("Creating text embeddings"),to=d(),B=n("p"),Vr=a("We saw in "),Ht=n("a"),Qr=a("Chapter 2"),Xr=a(" that we can obtain token embeddings by using the "),ta=n("code"),Kr=a("AutoModel"),Zr=a(" class. All we need to do is pick a suitable checkpoint to load the model from. Fortunately, there\u2019s a library called "),sa=n("code"),el=a("sentence-transformers"),tl=a(" that is dedicated to creating embeddings. As described in the library\u2019s "),ht=n("a"),sl=a("documentation"),al=a(", our use case is an example of "),aa=n("em"),ol=a("asymmetric semantic search"),nl=a(" because we have a short query whose answer we\u2019d like to find in a longer document, like a an issue comment. The handy "),ft=n("a"),rl=a("model overview table"),ll=a(" in the documentation indicates that the "),oa=n("code"),il=a("multi-qa-mpnet-base-dot-v1"),cl=a(" checkpoint has the best performance for semantic search, so we\u2019ll use that for our application. We\u2019ll also load the tokenizer using the same checkpoint:"),so=d(),ue.c(),Ft=d(),$e=n("p"),dl=a("As we mentioned earlier, we\u2019d like to represent each entry in our GitHub issues corpus as a single vector, so we need to \u201Cpool\u201D or average our token embeddings in some way. One popular approach is to perform "),na=n("em"),pl=a("CLS pooling"),ul=a(" on our model\u2019s outputs, where we simply collect the last hidden state for the special "),ra=n("code"),ml=a("[CLS]"),hl=a(" token. The following function does the trick for us:"),ao=d(),v(_t.$$.fragment),oo=d(),Lt=n("p"),fl=a("Next, we\u2019ll create a helper function that will tokenize a list of documents, place the tensors on the GPU, feed them to the model, and finally apply CLS pooling to the outputs:"),no=d(),he.c(),Rt=d(),Mt=n("p"),_l=a("Notice that we\u2019ve converted the embeddings to NumPy arrays \u2014 that\u2019s because \u{1F917} Datasets requires this format when we try to index them with FAISS, which we\u2019ll do next."),ro=d(),Oe=n("h2"),Me=n("a"),la=n("span"),v(gt.$$.fragment),gl=d(),ia=n("span"),bl=a("Using FAISS for efficient similarity search"),lo=d(),ve=n("p"),wl=a("Now that we have a dataset of embeddings, we need some way to search over them. To do this, we\u2019ll use a special data structure in \u{1F917} Datasets called a "),ca=n("em"),$l=a("FAISS index"),vl=a(". "),bt=n("a"),yl=a("FAISS"),kl=a(" (short for Facebook AI Similarity Search) is a library that provides efficient algorithms to quickly search and cluster embedding vectors."),io=d(),ye=n("p"),xl=a("The basic idea behind FAISS is to create a special data structure called an "),da=n("em"),El=a("index"),jl=a(" that allows one to find which embeddings are similar to an input embedding. Creating a FAISS index in \u{1F917} Datasets is simple \u2014 we use the "),pa=n("code"),ql=a("Dataset.add_faiss_index()"),Dl=a(" function and specify which column of our dataset we\u2019d like to index:"),co=d(),v(wt.$$.fragment),po=d(),We=n("p"),Tl=a("We can now perform queries on this index by doing a nearest neighbor lookup with the "),ua=n("code"),Cl=a("Dataset.get_nearest_examples()"),Sl=a(" function. Let\u2019s test this out by first embedding a question as follows:"),uo=d(),_e.c(),Wt=d(),Ut=n("p"),Al=a("Just like with the documents, we now have a 768-dimensional vector representing the query, which we can compare against the whole corpus to find the most similar embeddings:"),mo=d(),v($t.$$.fragment),ho=d(),ke=n("p"),Ol=a("The "),ma=n("code"),Il=a("Dataset.get_nearest_examples()"),Pl=a(" function returns a tuple of scores that rank the overlap between the query and the document, and a corresponding set of samples (here, the 5 best matches). Let\u2019s collect these in a "),ha=n("code"),Nl=a("pandas.DataFrame"),Hl=a(" so we can easily sort them:"),fo=d(),v(vt.$$.fragment),_o=d(),Gt=n("p"),Fl=a("Now we can iterate over the first few rows to see how well our query matched the available comments:"),go=d(),v(yt.$$.fragment),bo=d(),v(kt.$$.fragment),wo=d(),zt=n("p"),Ll=a("Not bad! Our second hit seems to match the query."),$o=d(),v(Ue.$$.fragment),this.h()},l(e){const i=Fc('[data-svelte="svelte-1phssyn"]',document.head);u=r(i,"META",{name:!0,content:!0}),i.forEach(s),$=p(e),y(h.$$.fragment,e),j=p(e),f=r(e,"H1",{class:!0});var Dt=l(f);w=r(Dt,"A",{id:!0,class:!0,href:!0});var Bt=l(w);I=r(Bt,"SPAN",{});var fa=l(I);y(_.$$.fragment,fa),fa.forEach(s),Bt.forEach(s),S=p(Dt),q=r(Dt,"SPAN",{});var Yt=l(q);M=o(Yt,"Semantic search with FAISS"),Yt.forEach(s),Dt.forEach(s),P=p(e),N.l(e),H=p(e),L=r(e,"P",{});var Ge=l(L);G=o(Ge,"In "),T=r(Ge,"A",{href:!0});var Jt=l(T);F=o(Jt,"section 5"),Jt.forEach(s),Y=o(Ge,", we created a dataset of GitHub issues and comments from the \u{1F917} Datasets repository. In this section we\u2019ll use this information to build a search engine that can help us find answers to our most pressing questions about the library!"),Ge.forEach(s),U=p(e),y(D.$$.fragment,e),z=p(e),m=r(e,"H2",{class:!0});var Tt=l(m);C=r(Tt,"A",{id:!0,class:!0,href:!0});var Xl=l(C);R=r(Xl,"SPAN",{});var Kl=l(R);y(J.$$.fragment,Kl),Kl.forEach(s),Xl.forEach(s),ne=p(Tt),ce=r(Tt,"SPAN",{});var Zl=l(ce);Io=o(Zl,"Using embeddings for semantic search"),Zl.forEach(s),Tt.forEach(s),ga=p(e),ge=r(e,"P",{});var Vt=l(ge);Po=o(Vt,"As we saw in "),Ct=r(Vt,"A",{href:!0});var ei=l(Ct);No=o(ei,"Chapter 1"),ei.forEach(s),Ho=o(Vt,", Transformer-based language models represent each token in a span of text as an "),ss=r(Vt,"EM",{});var ti=l(ss);Fo=o(ti,"embedding vector"),ti.forEach(s),Lo=o(Vt,". It turns out that one can \u201Cpool\u201D the individual embeddings to create a vector representation for whole sentences, paragraphs, or (in some cases) documents. These embeddings can then be used to find similar documents in the corpus by computing the dot-product similarity (or some other similarity metric) between each embedding and returning the documents with the greatest overlap."),Vt.forEach(s),ba=p(e),St=r(e,"P",{});var si=l(St);Ro=o(si,"In this section we\u2019ll use embeddings to develop a semantic search engine. These search engines offer several advantages over conventional approaches that are based on matching keywords in a query with the documents."),si.forEach(s),wa=p(e),Ce=r(e,"DIV",{class:!0});var yo=l(Ce);Ye=r(yo,"IMG",{class:!0,src:!0,alt:!0}),Mo=p(yo),Je=r(yo,"IMG",{class:!0,src:!0,alt:!0}),yo.forEach(s),$a=p(e),Se=r(e,"H2",{class:!0});var ko=l(Se);Ie=r(ko,"A",{id:!0,class:!0,href:!0});var ai=l(Ie);as=r(ai,"SPAN",{});var oi=l(as);y(Ve.$$.fragment,oi),oi.forEach(s),ai.forEach(s),Wo=p(ko),os=r(ko,"SPAN",{});var ni=l(os);Uo=o(ni,"Loading and preparing the dataset"),ni.forEach(s),ko.forEach(s),va=p(e),At=r(e,"P",{});var ri=l(At);Go=o(ri,"The first thing we need to do is download our dataset of GitHub issues, so let\u2019s use the \u{1F917} Hub library to resolve the URL where our file is stored on the Hugging Face Hub:"),ri.forEach(s),ya=p(e),y(Qe.$$.fragment,e),ka=p(e),be=r(e,"P",{});var Qt=l(be);zo=o(Qt,"With the URL stored in "),ns=r(Qt,"CODE",{});var li=l(ns);Bo=o(li,"data_files"),li.forEach(s),Yo=o(Qt,", we can then load the remote dataset using the method introduced in "),Ot=r(Qt,"A",{href:!0});var ii=l(Ot);Jo=o(ii,"section 2"),ii.forEach(s),Vo=o(Qt,":"),Qt.forEach(s),xa=p(e),y(Xe.$$.fragment,e),Ea=p(e),y(Ke.$$.fragment,e),ja=p(e),V=r(e,"P",{});var le=l(V);Qo=o(le,"Here we\u2019ve specified the default "),rs=r(le,"CODE",{});var ci=l(rs);Xo=o(ci,"train"),ci.forEach(s),Ko=o(le," split in "),ls=r(le,"CODE",{});var di=l(ls);Zo=o(di,"load_dataset()"),di.forEach(s),en=o(le,", so it returns a "),is=r(le,"CODE",{});var pi=l(is);tn=o(pi,"Dataset"),pi.forEach(s),sn=o(le," instead of a "),cs=r(le,"CODE",{});var ui=l(cs);an=o(ui,"DatasetDict"),ui.forEach(s),on=o(le,". The first order of business is to filter out the pull requests, as these tend to be rarely used for answering user queries and will introduce noise in our search engine. As should be familiar by now, we can use the "),ds=r(le,"CODE",{});var mi=l(ds);nn=o(mi,"Dataset.filter()"),mi.forEach(s),rn=o(le," function to exclude these rows in our dataset. While we\u2019re at it, let\u2019s also filter out rows with no comments, since these provide no answers to user queries:"),le.forEach(s),qa=p(e),y(Ze.$$.fragment,e),Da=p(e),y(et.$$.fragment,e),Ta=p(e),Q=r(e,"P",{});var ie=l(Q);ln=o(ie,"We can see that there are a lot of columns in our dataset, most of which we don\u2019t need to build our search engine. From a search perspective, the most informative columns are "),ps=r(ie,"CODE",{});var hi=l(ps);cn=o(hi,"title"),hi.forEach(s),dn=o(ie,", "),us=r(ie,"CODE",{});var fi=l(us);pn=o(fi,"body"),fi.forEach(s),un=o(ie,", and "),ms=r(ie,"CODE",{});var _i=l(ms);mn=o(_i,"comments"),_i.forEach(s),hn=o(ie,", while "),hs=r(ie,"CODE",{});var gi=l(hs);fn=o(gi,"html_url"),gi.forEach(s),_n=o(ie," provides us with a link back to the source issue. Let\u2019s use the "),fs=r(ie,"CODE",{});var bi=l(fs);gn=o(bi,"Dataset.remove_columns()"),bi.forEach(s),bn=o(ie," function to drop the rest:"),ie.forEach(s),Ca=p(e),y(tt.$$.fragment,e),Sa=p(e),y(st.$$.fragment,e),Aa=p(e),K=r(e,"P",{});var xe=l(K);wn=o(xe,"To create our embeddings we\u2019ll augment each comment with the issue\u2019s title and body, since these fields often include useful contextual information. Because our "),_s=r(xe,"CODE",{});var wi=l(_s);$n=o(wi,"comments"),wi.forEach(s),vn=o(xe," column is currently a list of comments for each issue, we need to \u201Cexplode\u201D the column so that each row consists of an "),gs=r(xe,"CODE",{});var $i=l(gs);yn=o($i,"(html_url, title, body, comment)"),$i.forEach(s),kn=o(xe," tuple. In Pandas we can do this with the "),Pe=r(xe,"A",{href:!0,rel:!0});var Rl=l(Pe);bs=r(Rl,"CODE",{});var vi=l(bs);xn=o(vi,"DataFrame.explode()"),vi.forEach(s),En=o(Rl," function"),Rl.forEach(s),jn=o(xe,", which creates a new row for each element in a list-like column, while replicating all the other column values. To see this in action, let\u2019s first switch to the Pandas  "),ws=r(xe,"CODE",{});var yi=l(ws);qn=o(yi,"DataFrame"),yi.forEach(s),Dn=o(xe," format:"),xe.forEach(s),Oa=p(e),y(at.$$.fragment,e),Ia=p(e),Ne=r(e,"P",{});var xo=l(Ne);Tn=o(xo,"If we inspect the first row in this "),$s=r(xo,"CODE",{});var ki=l($s);Cn=o(ki,"DataFrame"),ki.forEach(s),Sn=o(xo," we can see there are four comments associated with this issue:"),xo.forEach(s),Pa=p(e),y(ot.$$.fragment,e),Na=p(e),y(nt.$$.fragment,e),Ha=p(e),He=r(e,"P",{});var Eo=l(He);An=o(Eo,"When we explode "),vs=r(Eo,"CODE",{});var xi=l(vs);On=o(xi,"df"),xi.forEach(s),In=o(Eo,", we expect to get one row for each of these comments. Let\u2019s check if that\u2019s the case:"),Eo.forEach(s),Fa=p(e),y(rt.$$.fragment,e),La=p(e),ee=r(e,"TABLE",{border:!0,class:!0,style:!0});var jo=l(ee);ys=r(jo,"THEAD",{});var Ei=l(ys);Z=r(Ei,"TR",{style:!0});var Ee=l(Z);Ra=r(Ee,"TH",{}),l(Ra).forEach(s),Pn=p(Ee),ks=r(Ee,"TH",{});var ji=l(ks);Nn=o(ji,"html_url"),ji.forEach(s),Hn=p(Ee),xs=r(Ee,"TH",{});var qi=l(xs);Fn=o(qi,"title"),qi.forEach(s),Ln=p(Ee),Es=r(Ee,"TH",{});var Di=l(Es);Rn=o(Di,"comments"),Di.forEach(s),Mn=p(Ee),js=r(Ee,"TH",{});var Ti=l(js);Wn=o(Ti,"body"),Ti.forEach(s),Ee.forEach(s),Ei.forEach(s),Un=p(jo),de=r(jo,"TBODY",{});var ze=l(de);te=r(ze,"TR",{});var je=l(te);qs=r(je,"TH",{});var Ci=l(qs);Gn=o(Ci,"0"),Ci.forEach(s),zn=p(je),Ds=r(je,"TD",{});var Si=l(Ds);Bn=o(Si,"https://github.com/huggingface/datasets/issues/2787"),Si.forEach(s),Yn=p(je),Ts=r(je,"TD",{});var Ai=l(Ts);Jn=o(Ai,"ConnectionError: Couldn't reach https://raw.githubusercontent.com"),Ai.forEach(s),Vn=p(je),Cs=r(je,"TD",{});var Oi=l(Cs);Qn=o(Oi,"the bug code locate in \uFF1A\\r\\n    if data_args.task_name is not None..."),Oi.forEach(s),Xn=p(je),Ss=r(je,"TD",{});var Ii=l(Ss);Kn=o(Ii,"Hello,\\r\\nI am trying to run run_glue.py and it gives me this error..."),Ii.forEach(s),je.forEach(s),Zn=p(ze),se=r(ze,"TR",{});var qe=l(se);As=r(qe,"TH",{});var Pi=l(As);er=o(Pi,"1"),Pi.forEach(s),tr=p(qe),Os=r(qe,"TD",{});var Ni=l(Os);sr=o(Ni,"https://github.com/huggingface/datasets/issues/2787"),Ni.forEach(s),ar=p(qe),Is=r(qe,"TD",{});var Hi=l(Is);or=o(Hi,"ConnectionError: Couldn't reach https://raw.githubusercontent.com"),Hi.forEach(s),nr=p(qe),Ps=r(qe,"TD",{});var Fi=l(Ps);rr=o(Fi,"Hi @jinec,\\r\\n\\r\\nFrom time to time we get this kind of `ConnectionError` coming from the github.com website: https://raw.githubusercontent.com..."),Fi.forEach(s),lr=p(qe),Ns=r(qe,"TD",{});var Li=l(Ns);ir=o(Li,"Hello,\\r\\nI am trying to run run_glue.py and it gives me this error..."),Li.forEach(s),qe.forEach(s),cr=p(ze),ae=r(ze,"TR",{});var De=l(ae);Hs=r(De,"TH",{});var Ri=l(Hs);dr=o(Ri,"2"),Ri.forEach(s),pr=p(De),Fs=r(De,"TD",{});var Mi=l(Fs);ur=o(Mi,"https://github.com/huggingface/datasets/issues/2787"),Mi.forEach(s),mr=p(De),Ls=r(De,"TD",{});var Wi=l(Ls);hr=o(Wi,"ConnectionError: Couldn't reach https://raw.githubusercontent.com"),Wi.forEach(s),fr=p(De),Rs=r(De,"TD",{});var Ui=l(Rs);_r=o(Ui,"cannot connect\uFF0Ceven by Web browser\uFF0Cplease check that  there is some  problems\u3002"),Ui.forEach(s),gr=p(De),Ms=r(De,"TD",{});var Gi=l(Ms);br=o(Gi,"Hello,\\r\\nI am trying to run run_glue.py and it gives me this error..."),Gi.forEach(s),De.forEach(s),wr=p(ze),oe=r(ze,"TR",{});var Te=l(oe);Ws=r(Te,"TH",{});var zi=l(Ws);$r=o(zi,"3"),zi.forEach(s),vr=p(Te),Us=r(Te,"TD",{});var Bi=l(Us);yr=o(Bi,"https://github.com/huggingface/datasets/issues/2787"),Bi.forEach(s),kr=p(Te),Gs=r(Te,"TD",{});var Yi=l(Gs);xr=o(Yi,"ConnectionError: Couldn't reach https://raw.githubusercontent.com"),Yi.forEach(s),Er=p(Te),zs=r(Te,"TD",{});var Ji=l(zs);jr=o(Ji,"I can access https://raw.githubusercontent.com/huggingface/datasets/1.7.0/datasets/glue/glue.py without problem..."),Ji.forEach(s),qr=p(Te),Bs=r(Te,"TD",{});var Vi=l(Bs);Dr=o(Vi,"Hello,\\r\\nI am trying to run run_glue.py and it gives me this error..."),Vi.forEach(s),Te.forEach(s),ze.forEach(s),jo.forEach(s),Ma=p(e),re=r(e,"P",{});var Be=l(re);Tr=o(Be,"Great, we can see the rows have been replicated, with the "),Ys=r(Be,"CODE",{});var Qi=l(Ys);Cr=o(Qi,"comments"),Qi.forEach(s),Sr=o(Be," column containing the individual comments! Now that we\u2019re finished with Pandas, we can quickly switch back to a "),Js=r(Be,"CODE",{});var Xi=l(Js);Ar=o(Xi,"Dataset"),Xi.forEach(s),Or=o(Be," by loading the "),Vs=r(Be,"CODE",{});var Ki=l(Vs);Ir=o(Ki,"DataFrame"),Ki.forEach(s),Pr=o(Be," in memory:"),Be.forEach(s),Wa=p(e),y(lt.$$.fragment,e),Ua=p(e),y(it.$$.fragment,e),Ga=p(e),It=r(e,"P",{});var Zi=l(It);Nr=o(Zi,"Okay, this has given us a few thousand comments to work with!"),Zi.forEach(s),za=p(e),y(Fe.$$.fragment,e),Ba=p(e),Le=r(e,"P",{});var qo=l(Le);Hr=o(qo,"Now that we have one comment per row, let\u2019s create a new "),Qs=r(qo,"CODE",{});var ec=l(Qs);Fr=o(ec,"comments_length"),ec.forEach(s),Lr=o(qo," column that contains the number of words per comment:"),qo.forEach(s),Ya=p(e),y(ct.$$.fragment,e),Ja=p(e),Pt=r(e,"P",{});var tc=l(Pt);Rr=o(tc,"We can use this new column to filter out short comments, which typically include things like \u201Ccc @lewtun\u201D or \u201CThanks!\u201D that are not relevant for our search engine. There\u2019s no precise number to select for the filter, but around 15 words seems like a good start:"),tc.forEach(s),Va=p(e),y(dt.$$.fragment,e),Qa=p(e),y(pt.$$.fragment,e),Xa=p(e),we=r(e,"P",{});var Xt=l(we);Mr=o(Xt,"Having cleaned up our dataset a bit, let\u2019s concatenate the issue title, description, and comments together in a new "),Xs=r(Xt,"CODE",{});var sc=l(Xs);Wr=o(sc,"text"),sc.forEach(s),Ur=o(Xt," column. As usual, we\u2019ll write a simple function that we can pass to "),Ks=r(Xt,"CODE",{});var ac=l(Ks);Gr=o(ac,"Dataset.map()"),ac.forEach(s),zr=o(Xt,":"),Xt.forEach(s),Ka=p(e),y(ut.$$.fragment,e),Za=p(e),Nt=r(e,"P",{});var oc=l(Nt);Br=o(oc,"We\u2019re finally ready to create some embeddings! Let\u2019s take a look."),oc.forEach(s),eo=p(e),Ae=r(e,"H2",{class:!0});var Do=l(Ae);Re=r(Do,"A",{id:!0,class:!0,href:!0});var nc=l(Re);Zs=r(nc,"SPAN",{});var rc=l(Zs);y(mt.$$.fragment,rc),rc.forEach(s),nc.forEach(s),Yr=p(Do),ea=r(Do,"SPAN",{});var lc=l(ea);Jr=o(lc,"Creating text embeddings"),lc.forEach(s),Do.forEach(s),to=p(e),B=r(e,"P",{});var X=l(B);Vr=o(X,"We saw in "),Ht=r(X,"A",{href:!0});var ic=l(Ht);Qr=o(ic,"Chapter 2"),ic.forEach(s),Xr=o(X," that we can obtain token embeddings by using the "),ta=r(X,"CODE",{});var cc=l(ta);Kr=o(cc,"AutoModel"),cc.forEach(s),Zr=o(X," class. All we need to do is pick a suitable checkpoint to load the model from. Fortunately, there\u2019s a library called "),sa=r(X,"CODE",{});var dc=l(sa);el=o(dc,"sentence-transformers"),dc.forEach(s),tl=o(X," that is dedicated to creating embeddings. As described in the library\u2019s "),ht=r(X,"A",{href:!0,rel:!0});var pc=l(ht);sl=o(pc,"documentation"),pc.forEach(s),al=o(X,", our use case is an example of "),aa=r(X,"EM",{});var uc=l(aa);ol=o(uc,"asymmetric semantic search"),uc.forEach(s),nl=o(X," because we have a short query whose answer we\u2019d like to find in a longer document, like a an issue comment. The handy "),ft=r(X,"A",{href:!0,rel:!0});var mc=l(ft);rl=o(mc,"model overview table"),mc.forEach(s),ll=o(X," in the documentation indicates that the "),oa=r(X,"CODE",{});var hc=l(oa);il=o(hc,"multi-qa-mpnet-base-dot-v1"),hc.forEach(s),cl=o(X," checkpoint has the best performance for semantic search, so we\u2019ll use that for our application. We\u2019ll also load the tokenizer using the same checkpoint:"),X.forEach(s),so=p(e),ue.l(e),Ft=p(e),$e=r(e,"P",{});var Kt=l($e);dl=o(Kt,"As we mentioned earlier, we\u2019d like to represent each entry in our GitHub issues corpus as a single vector, so we need to \u201Cpool\u201D or average our token embeddings in some way. One popular approach is to perform "),na=r(Kt,"EM",{});var fc=l(na);pl=o(fc,"CLS pooling"),fc.forEach(s),ul=o(Kt," on our model\u2019s outputs, where we simply collect the last hidden state for the special "),ra=r(Kt,"CODE",{});var _c=l(ra);ml=o(_c,"[CLS]"),_c.forEach(s),hl=o(Kt," token. The following function does the trick for us:"),Kt.forEach(s),ao=p(e),y(_t.$$.fragment,e),oo=p(e),Lt=r(e,"P",{});var gc=l(Lt);fl=o(gc,"Next, we\u2019ll create a helper function that will tokenize a list of documents, place the tensors on the GPU, feed them to the model, and finally apply CLS pooling to the outputs:"),gc.forEach(s),no=p(e),he.l(e),Rt=p(e),Mt=r(e,"P",{});var bc=l(Mt);_l=o(bc,"Notice that we\u2019ve converted the embeddings to NumPy arrays \u2014 that\u2019s because \u{1F917} Datasets requires this format when we try to index them with FAISS, which we\u2019ll do next."),bc.forEach(s),ro=p(e),Oe=r(e,"H2",{class:!0});var To=l(Oe);Me=r(To,"A",{id:!0,class:!0,href:!0});var wc=l(Me);la=r(wc,"SPAN",{});var $c=l(la);y(gt.$$.fragment,$c),$c.forEach(s),wc.forEach(s),gl=p(To),ia=r(To,"SPAN",{});var vc=l(ia);bl=o(vc,"Using FAISS for efficient similarity search"),vc.forEach(s),To.forEach(s),lo=p(e),ve=r(e,"P",{});var Zt=l(ve);wl=o(Zt,"Now that we have a dataset of embeddings, we need some way to search over them. To do this, we\u2019ll use a special data structure in \u{1F917} Datasets called a "),ca=r(Zt,"EM",{});var yc=l(ca);$l=o(yc,"FAISS index"),yc.forEach(s),vl=o(Zt,". "),bt=r(Zt,"A",{href:!0,rel:!0});var kc=l(bt);yl=o(kc,"FAISS"),kc.forEach(s),kl=o(Zt," (short for Facebook AI Similarity Search) is a library that provides efficient algorithms to quickly search and cluster embedding vectors."),Zt.forEach(s),io=p(e),ye=r(e,"P",{});var es=l(ye);xl=o(es,"The basic idea behind FAISS is to create a special data structure called an "),da=r(es,"EM",{});var xc=l(da);El=o(xc,"index"),xc.forEach(s),jl=o(es," that allows one to find which embeddings are similar to an input embedding. Creating a FAISS index in \u{1F917} Datasets is simple \u2014 we use the "),pa=r(es,"CODE",{});var Ec=l(pa);ql=o(Ec,"Dataset.add_faiss_index()"),Ec.forEach(s),Dl=o(es," function and specify which column of our dataset we\u2019d like to index:"),es.forEach(s),co=p(e),y(wt.$$.fragment,e),po=p(e),We=r(e,"P",{});var Co=l(We);Tl=o(Co,"We can now perform queries on this index by doing a nearest neighbor lookup with the "),ua=r(Co,"CODE",{});var jc=l(ua);Cl=o(jc,"Dataset.get_nearest_examples()"),jc.forEach(s),Sl=o(Co," function. Let\u2019s test this out by first embedding a question as follows:"),Co.forEach(s),uo=p(e),_e.l(e),Wt=p(e),Ut=r(e,"P",{});var qc=l(Ut);Al=o(qc,"Just like with the documents, we now have a 768-dimensional vector representing the query, which we can compare against the whole corpus to find the most similar embeddings:"),qc.forEach(s),mo=p(e),y($t.$$.fragment,e),ho=p(e),ke=r(e,"P",{});var ts=l(ke);Ol=o(ts,"The "),ma=r(ts,"CODE",{});var Dc=l(ma);Il=o(Dc,"Dataset.get_nearest_examples()"),Dc.forEach(s),Pl=o(ts," function returns a tuple of scores that rank the overlap between the query and the document, and a corresponding set of samples (here, the 5 best matches). Let\u2019s collect these in a "),ha=r(ts,"CODE",{});var Tc=l(ha);Nl=o(Tc,"pandas.DataFrame"),Tc.forEach(s),Hl=o(ts," so we can easily sort them:"),ts.forEach(s),fo=p(e),y(vt.$$.fragment,e),_o=p(e),Gt=r(e,"P",{});var Cc=l(Gt);Fl=o(Cc,"Now we can iterate over the first few rows to see how well our query matched the available comments:"),Cc.forEach(s),go=p(e),y(yt.$$.fragment,e),bo=p(e),y(kt.$$.fragment,e),wo=p(e),zt=r(e,"P",{});var Sc=l(zt);Ll=o(Sc,"Not bad! Our second hit seems to match the query."),Sc.forEach(s),$o=p(e),y(Ue.$$.fragment,e),this.h()},h(){E(u,"name","hf:doc:metadata"),E(u,"content",JSON.stringify(Zc)),E(w,"id","semantic-search-with-faiss"),E(w,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),E(w,"href","#semantic-search-with-faiss"),E(f,"class","relative group"),E(T,"href","/course/chapter5/5"),E(C,"id","using-embeddings-for-semantic-search"),E(C,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),E(C,"href","#using-embeddings-for-semantic-search"),E(m,"class","relative group"),E(Ct,"href","/course/chapter1"),E(Ye,"class","block dark:hidden"),Ac(Ye.src,Ml="https://huggingface.co/datasets/huggingface-course/documentation-images/resolve/main/en/chapter5/semantic-search.svg")||E(Ye,"src",Ml),E(Ye,"alt","Semantic search."),E(Je,"class","hidden dark:block"),Ac(Je.src,Wl="https://huggingface.co/datasets/huggingface-course/documentation-images/resolve/main/en/chapter5/semantic-search-dark.svg")||E(Je,"src",Wl),E(Je,"alt","Semantic search."),E(Ce,"class","flex justify-center"),E(Ie,"id","loading-and-preparing-the-dataset"),E(Ie,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),E(Ie,"href","#loading-and-preparing-the-dataset"),E(Se,"class","relative group"),E(Ot,"href","/course/chapter5/2"),E(Pe,"href","https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.explode.html"),E(Pe,"rel","nofollow"),So(Z,"text-align","right"),E(ee,"border","1"),E(ee,"class","dataframe"),So(ee,"table-layout","fixed"),So(ee,"word-wrap","break-word"),So(ee,"width","100%"),E(Re,"id","creating-text-embeddings"),E(Re,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),E(Re,"href","#creating-text-embeddings"),E(Ae,"class","relative group"),E(Ht,"href","/course/chapter2"),E(ht,"href","https://www.sbert.net/examples/applications/semantic-search/README.html#symmetric-vs-asymmetric-semantic-search"),E(ht,"rel","nofollow"),E(ft,"href","https://www.sbert.net/docs/pretrained_models.html#model-overview"),E(ft,"rel","nofollow"),E(Me,"id","using-faiss-for-efficient-similarity-search"),E(Me,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),E(Me,"href","#using-faiss-for-efficient-similarity-search"),E(Oe,"class","relative group"),E(bt,"href","https://faiss.ai/"),E(bt,"rel","nofollow")},m(e,i){t(document.head,u),c(e,$,i),k(h,e,i),c(e,j,i),c(e,f,i),t(f,w),t(w,I),k(_,I,null),t(f,S),t(f,q),t(q,M),c(e,P,i),xt[A].m(e,i),c(e,H,i),c(e,L,i),t(L,G),t(L,T),t(T,F),t(L,Y),c(e,U,i),k(D,e,i),c(e,z,i),c(e,m,i),t(m,C),t(C,R),k(J,R,null),t(m,ne),t(m,ce),t(ce,Io),c(e,ga,i),c(e,ge,i),t(ge,Po),t(ge,Ct),t(Ct,No),t(ge,Ho),t(ge,ss),t(ss,Fo),t(ge,Lo),c(e,ba,i),c(e,St,i),t(St,Ro),c(e,wa,i),c(e,Ce,i),t(Ce,Ye),t(Ce,Mo),t(Ce,Je),c(e,$a,i),c(e,Se,i),t(Se,Ie),t(Ie,as),k(Ve,as,null),t(Se,Wo),t(Se,os),t(os,Uo),c(e,va,i),c(e,At,i),t(At,Go),c(e,ya,i),k(Qe,e,i),c(e,ka,i),c(e,be,i),t(be,zo),t(be,ns),t(ns,Bo),t(be,Yo),t(be,Ot),t(Ot,Jo),t(be,Vo),c(e,xa,i),k(Xe,e,i),c(e,Ea,i),k(Ke,e,i),c(e,ja,i),c(e,V,i),t(V,Qo),t(V,rs),t(rs,Xo),t(V,Ko),t(V,ls),t(ls,Zo),t(V,en),t(V,is),t(is,tn),t(V,sn),t(V,cs),t(cs,an),t(V,on),t(V,ds),t(ds,nn),t(V,rn),c(e,qa,i),k(Ze,e,i),c(e,Da,i),k(et,e,i),c(e,Ta,i),c(e,Q,i),t(Q,ln),t(Q,ps),t(ps,cn),t(Q,dn),t(Q,us),t(us,pn),t(Q,un),t(Q,ms),t(ms,mn),t(Q,hn),t(Q,hs),t(hs,fn),t(Q,_n),t(Q,fs),t(fs,gn),t(Q,bn),c(e,Ca,i),k(tt,e,i),c(e,Sa,i),k(st,e,i),c(e,Aa,i),c(e,K,i),t(K,wn),t(K,_s),t(_s,$n),t(K,vn),t(K,gs),t(gs,yn),t(K,kn),t(K,Pe),t(Pe,bs),t(bs,xn),t(Pe,En),t(K,jn),t(K,ws),t(ws,qn),t(K,Dn),c(e,Oa,i),k(at,e,i),c(e,Ia,i),c(e,Ne,i),t(Ne,Tn),t(Ne,$s),t($s,Cn),t(Ne,Sn),c(e,Pa,i),k(ot,e,i),c(e,Na,i),k(nt,e,i),c(e,Ha,i),c(e,He,i),t(He,An),t(He,vs),t(vs,On),t(He,In),c(e,Fa,i),k(rt,e,i),c(e,La,i),c(e,ee,i),t(ee,ys),t(ys,Z),t(Z,Ra),t(Z,Pn),t(Z,ks),t(ks,Nn),t(Z,Hn),t(Z,xs),t(xs,Fn),t(Z,Ln),t(Z,Es),t(Es,Rn),t(Z,Mn),t(Z,js),t(js,Wn),t(ee,Un),t(ee,de),t(de,te),t(te,qs),t(qs,Gn),t(te,zn),t(te,Ds),t(Ds,Bn),t(te,Yn),t(te,Ts),t(Ts,Jn),t(te,Vn),t(te,Cs),t(Cs,Qn),t(te,Xn),t(te,Ss),t(Ss,Kn),t(de,Zn),t(de,se),t(se,As),t(As,er),t(se,tr),t(se,Os),t(Os,sr),t(se,ar),t(se,Is),t(Is,or),t(se,nr),t(se,Ps),t(Ps,rr),t(se,lr),t(se,Ns),t(Ns,ir),t(de,cr),t(de,ae),t(ae,Hs),t(Hs,dr),t(ae,pr),t(ae,Fs),t(Fs,ur),t(ae,mr),t(ae,Ls),t(Ls,hr),t(ae,fr),t(ae,Rs),t(Rs,_r),t(ae,gr),t(ae,Ms),t(Ms,br),t(de,wr),t(de,oe),t(oe,Ws),t(Ws,$r),t(oe,vr),t(oe,Us),t(Us,yr),t(oe,kr),t(oe,Gs),t(Gs,xr),t(oe,Er),t(oe,zs),t(zs,jr),t(oe,qr),t(oe,Bs),t(Bs,Dr),c(e,Ma,i),c(e,re,i),t(re,Tr),t(re,Ys),t(Ys,Cr),t(re,Sr),t(re,Js),t(Js,Ar),t(re,Or),t(re,Vs),t(Vs,Ir),t(re,Pr),c(e,Wa,i),k(lt,e,i),c(e,Ua,i),k(it,e,i),c(e,Ga,i),c(e,It,i),t(It,Nr),c(e,za,i),k(Fe,e,i),c(e,Ba,i),c(e,Le,i),t(Le,Hr),t(Le,Qs),t(Qs,Fr),t(Le,Lr),c(e,Ya,i),k(ct,e,i),c(e,Ja,i),c(e,Pt,i),t(Pt,Rr),c(e,Va,i),k(dt,e,i),c(e,Qa,i),k(pt,e,i),c(e,Xa,i),c(e,we,i),t(we,Mr),t(we,Xs),t(Xs,Wr),t(we,Ur),t(we,Ks),t(Ks,Gr),t(we,zr),c(e,Ka,i),k(ut,e,i),c(e,Za,i),c(e,Nt,i),t(Nt,Br),c(e,eo,i),c(e,Ae,i),t(Ae,Re),t(Re,Zs),k(mt,Zs,null),t(Ae,Yr),t(Ae,ea),t(ea,Jr),c(e,to,i),c(e,B,i),t(B,Vr),t(B,Ht),t(Ht,Qr),t(B,Xr),t(B,ta),t(ta,Kr),t(B,Zr),t(B,sa),t(sa,el),t(B,tl),t(B,ht),t(ht,sl),t(B,al),t(B,aa),t(aa,ol),t(B,nl),t(B,ft),t(ft,rl),t(B,ll),t(B,oa),t(oa,il),t(B,cl),c(e,so,i),Et[pe].m(e,i),c(e,Ft,i),c(e,$e,i),t($e,dl),t($e,na),t(na,pl),t($e,ul),t($e,ra),t(ra,ml),t($e,hl),c(e,ao,i),k(_t,e,i),c(e,oo,i),c(e,Lt,i),t(Lt,fl),c(e,no,i),jt[me].m(e,i),c(e,Rt,i),c(e,Mt,i),t(Mt,_l),c(e,ro,i),c(e,Oe,i),t(Oe,Me),t(Me,la),k(gt,la,null),t(Oe,gl),t(Oe,ia),t(ia,bl),c(e,lo,i),c(e,ve,i),t(ve,wl),t(ve,ca),t(ca,$l),t(ve,vl),t(ve,bt),t(bt,yl),t(ve,kl),c(e,io,i),c(e,ye,i),t(ye,xl),t(ye,da),t(da,El),t(ye,jl),t(ye,pa),t(pa,ql),t(ye,Dl),c(e,co,i),k(wt,e,i),c(e,po,i),c(e,We,i),t(We,Tl),t(We,ua),t(ua,Cl),t(We,Sl),c(e,uo,i),qt[fe].m(e,i),c(e,Wt,i),c(e,Ut,i),t(Ut,Al),c(e,mo,i),k($t,e,i),c(e,ho,i),c(e,ke,i),t(ke,Ol),t(ke,ma),t(ma,Il),t(ke,Pl),t(ke,ha),t(ha,Nl),t(ke,Hl),c(e,fo,i),k(vt,e,i),c(e,_o,i),c(e,Gt,i),t(Gt,Fl),c(e,go,i),k(yt,e,i),c(e,bo,i),k(kt,e,i),c(e,wo,i),c(e,zt,i),t(zt,Ll),c(e,$o,i),k(Ue,e,i),vo=!0},p(e,[i]){const Dt={};i&1&&(Dt.fw=e[0]),h.$set(Dt);let Bt=A;A=Gl(e),A!==Bt&&(Oo(),g(xt[Bt],1,1,()=>{xt[Bt]=null}),Ao(),N=xt[A],N||(N=xt[A]=Ul[A](e),N.c()),b(N,1),N.m(H.parentNode,H));const fa={};i&2&&(fa.$$scope={dirty:i,ctx:e}),Fe.$set(fa);let Yt=pe;pe=Bl(e),pe!==Yt&&(Oo(),g(Et[Yt],1,1,()=>{Et[Yt]=null}),Ao(),ue=Et[pe],ue||(ue=Et[pe]=zl[pe](e),ue.c()),b(ue,1),ue.m(Ft.parentNode,Ft));let Ge=me;me=Jl(e),me!==Ge&&(Oo(),g(jt[Ge],1,1,()=>{jt[Ge]=null}),Ao(),he=jt[me],he||(he=jt[me]=Yl[me](e),he.c()),b(he,1),he.m(Rt.parentNode,Rt));let Jt=fe;fe=Ql(e),fe!==Jt&&(Oo(),g(qt[Jt],1,1,()=>{qt[Jt]=null}),Ao(),_e=qt[fe],_e||(_e=qt[fe]=Vl[fe](e),_e.c()),b(_e,1),_e.m(Wt.parentNode,Wt));const Tt={};i&2&&(Tt.$$scope={dirty:i,ctx:e}),Ue.$set(Tt)},i(e){vo||(b(h.$$.fragment,e),b(_.$$.fragment,e),b(N),b(D.$$.fragment,e),b(J.$$.fragment,e),b(Ve.$$.fragment,e),b(Qe.$$.fragment,e),b(Xe.$$.fragment,e),b(Ke.$$.fragment,e),b(Ze.$$.fragment,e),b(et.$$.fragment,e),b(tt.$$.fragment,e),b(st.$$.fragment,e),b(at.$$.fragment,e),b(ot.$$.fragment,e),b(nt.$$.fragment,e),b(rt.$$.fragment,e),b(lt.$$.fragment,e),b(it.$$.fragment,e),b(Fe.$$.fragment,e),b(ct.$$.fragment,e),b(dt.$$.fragment,e),b(pt.$$.fragment,e),b(ut.$$.fragment,e),b(mt.$$.fragment,e),b(ue),b(_t.$$.fragment,e),b(he),b(gt.$$.fragment,e),b(wt.$$.fragment,e),b(_e),b($t.$$.fragment,e),b(vt.$$.fragment,e),b(yt.$$.fragment,e),b(kt.$$.fragment,e),b(Ue.$$.fragment,e),vo=!0)},o(e){g(h.$$.fragment,e),g(_.$$.fragment,e),g(N),g(D.$$.fragment,e),g(J.$$.fragment,e),g(Ve.$$.fragment,e),g(Qe.$$.fragment,e),g(Xe.$$.fragment,e),g(Ke.$$.fragment,e),g(Ze.$$.fragment,e),g(et.$$.fragment,e),g(tt.$$.fragment,e),g(st.$$.fragment,e),g(at.$$.fragment,e),g(ot.$$.fragment,e),g(nt.$$.fragment,e),g(rt.$$.fragment,e),g(lt.$$.fragment,e),g(it.$$.fragment,e),g(Fe.$$.fragment,e),g(ct.$$.fragment,e),g(dt.$$.fragment,e),g(pt.$$.fragment,e),g(ut.$$.fragment,e),g(mt.$$.fragment,e),g(ue),g(_t.$$.fragment,e),g(he),g(gt.$$.fragment,e),g(wt.$$.fragment,e),g(_e),g($t.$$.fragment,e),g(vt.$$.fragment,e),g(yt.$$.fragment,e),g(kt.$$.fragment,e),g(Ue.$$.fragment,e),vo=!1},d(e){s(u),e&&s($),x(h,e),e&&s(j),e&&s(f),x(_),e&&s(P),xt[A].d(e),e&&s(H),e&&s(L),e&&s(U),x(D,e),e&&s(z),e&&s(m),x(J),e&&s(ga),e&&s(ge),e&&s(ba),e&&s(St),e&&s(wa),e&&s(Ce),e&&s($a),e&&s(Se),x(Ve),e&&s(va),e&&s(At),e&&s(ya),x(Qe,e),e&&s(ka),e&&s(be),e&&s(xa),x(Xe,e),e&&s(Ea),x(Ke,e),e&&s(ja),e&&s(V),e&&s(qa),x(Ze,e),e&&s(Da),x(et,e),e&&s(Ta),e&&s(Q),e&&s(Ca),x(tt,e),e&&s(Sa),x(st,e),e&&s(Aa),e&&s(K),e&&s(Oa),x(at,e),e&&s(Ia),e&&s(Ne),e&&s(Pa),x(ot,e),e&&s(Na),x(nt,e),e&&s(Ha),e&&s(He),e&&s(Fa),x(rt,e),e&&s(La),e&&s(ee),e&&s(Ma),e&&s(re),e&&s(Wa),x(lt,e),e&&s(Ua),x(it,e),e&&s(Ga),e&&s(It),e&&s(za),x(Fe,e),e&&s(Ba),e&&s(Le),e&&s(Ya),x(ct,e),e&&s(Ja),e&&s(Pt),e&&s(Va),x(dt,e),e&&s(Qa),x(pt,e),e&&s(Xa),e&&s(we),e&&s(Ka),x(ut,e),e&&s(Za),e&&s(Nt),e&&s(eo),e&&s(Ae),x(mt),e&&s(to),e&&s(B),e&&s(so),Et[pe].d(e),e&&s(Ft),e&&s($e),e&&s(ao),x(_t,e),e&&s(oo),e&&s(Lt),e&&s(no),jt[me].d(e),e&&s(Rt),e&&s(Mt),e&&s(ro),e&&s(Oe),x(gt),e&&s(lo),e&&s(ve),e&&s(io),e&&s(ye),e&&s(co),x(wt,e),e&&s(po),e&&s(We),e&&s(uo),qt[fe].d(e),e&&s(Wt),e&&s(Ut),e&&s(mo),x($t,e),e&&s(ho),e&&s(ke),e&&s(fo),x(vt,e),e&&s(_o),e&&s(Gt),e&&s(go),x(yt,e),e&&s(bo),x(kt,e),e&&s(wo),e&&s(zt),e&&s($o),x(Ue,e)}}}const Zc={local:"semantic-search-with-faiss",sections:[{local:"using-embeddings-for-semantic-search",title:"Using embeddings for semantic search"},{local:"loading-and-preparing-the-dataset",title:"Loading and preparing the dataset"},{local:"creating-text-embeddings",title:"Creating text embeddings"},{local:"using-faiss-for-efficient-similarity-search",title:"Using FAISS for efficient similarity search"}],title:"Semantic search with FAISS"};function ed(W,u,$){let h="pt";return Lc(()=>{const j=new URLSearchParams(window.location.search);$(0,h=j.get("fw")||"pt")}),[h]}class id extends Pc{constructor(u){super();Nc(this,u,ed,Kc,Hc,{})}}export{id as default,Zc as metadata};
