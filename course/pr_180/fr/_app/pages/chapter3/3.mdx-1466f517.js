import{S as Zl,i as ei,s as ti,e as n,k as d,w as _,t as o,M as si,c as r,d as s,m as c,x as E,a as l,h as a,b as v,F as t,g as u,y as q,q as $,o as b,B as g,v as oi}from"../../chunks/vendor-1e8b365d.js";import{T as Ql}from"../../chunks/Tip-62b14c6e.js";import{Y as ai}from"../../chunks/Youtube-c2a8cc39.js";import{I as gr}from"../../chunks/IconCopyLink-483c28ba.js";import{C as V}from"../../chunks/CodeBlock-e5764662.js";import{D as ni}from"../../chunks/DocNotebookDropdown-37d928d3.js";import{F as ri}from"../../chunks/FrameworkSwitchCourse-7f8f0f31.js";function li(Ce){let p,S,f,M,T,C,R,A,L,j,te,U,ee,ue;return{c(){p=n("p"),S=o("\u{1F4A1} Si vous voulez t\xE9l\xE9charger automatiquement votre mod\xE8le sur le "),f=n("em"),M=o("Hub"),T=o(" pendant l\u2019entra\xEEnement, passez "),C=n("code"),R=o("push_to_hub=True"),A=o(" dans le "),L=n("code"),j=o("TrainingArguments"),te=o(". Nous en apprendrons plus \xE0 ce sujet au "),U=n("a"),ee=o("Chapitre 4"),ue=o("."),this.h()},l(B){p=r(B,"P",{});var w=l(p);S=a(w,"\u{1F4A1} Si vous voulez t\xE9l\xE9charger automatiquement votre mod\xE8le sur le "),f=r(w,"EM",{});var h=l(f);M=a(h,"Hub"),h.forEach(s),T=a(w," pendant l\u2019entra\xEEnement, passez "),C=r(w,"CODE",{});var Ge=l(C);R=a(Ge,"push_to_hub=True"),Ge.forEach(s),A=a(w," dans le "),L=r(w,"CODE",{});var de=l(L);j=a(de,"TrainingArguments"),de.forEach(s),te=a(w,". Nous en apprendrons plus \xE0 ce sujet au "),U=r(w,"A",{href:!0});var Re=l(U);ee=a(Re,"Chapitre 4"),Re.forEach(s),ue=a(w,"."),w.forEach(s),this.h()},h(){v(U,"href","/course/fr/chapter4/3")},m(B,w){u(B,p,w),t(p,S),t(p,f),t(f,M),t(p,T),t(p,C),t(C,R),t(p,A),t(p,L),t(L,j),t(p,te),t(p,U),t(U,ee),t(p,ue)},d(B){B&&s(p)}}}function ii(Ce){let p,S,f,M,T,C,R,A;return{c(){p=n("p"),S=o("\u270F\uFE0F "),f=n("strong"),M=o("Essayez !"),T=d(),C=n("em"),R=o("Finetunez"),A=o(" un mod\xE8le sur le jeu de donn\xE9es GLUE SST-2, en utilisant le traitement des donn\xE9es que vous avez fait dans la section 2.")},l(L){p=r(L,"P",{});var j=l(p);S=a(j,"\u270F\uFE0F "),f=r(j,"STRONG",{});var te=l(f);M=a(te,"Essayez !"),te.forEach(s),T=c(j),C=r(j,"EM",{});var U=l(C);R=a(U,"Finetunez"),U.forEach(s),A=a(j," un mod\xE8le sur le jeu de donn\xE9es GLUE SST-2, en utilisant le traitement des donn\xE9es que vous avez fait dans la section 2."),j.forEach(s)},m(L,j){u(L,p,j),t(p,S),t(p,f),t(f,M),t(p,T),t(p,C),t(C,R),t(p,A)},d(L){L&&s(p)}}}function ui(Ce){let p,S,f,M,T,C,R,A,L,j,te,U,ee,ue,B,w,h,Ge,de,Re,uo,et,co,po,tt,mo,fo,st,vo,ho,ot,_o,Eo,ke,qo,$o,qs,Be,bo,$s,je,bs,re,ce,at,ze,go,nt,Co,gs,D,ko,rt,jo,zo,lt,To,wo,it,Po,Do,ut,xo,Oo,dt,yo,Ao,Cs,Te,ks,pe,js,se,Lo,Ve,So,Mo,ct,Uo,No,zs,we,Ts,me,Fo,We,Io,Go,ws,x,Ro,pt,Bo,Vo,mt,Wo,Ho,ft,Yo,Jo,vt,Xo,Ko,ht,Qo,Zo,Ps,Pe,Ds,O,ea,_t,ta,sa,Et,oa,aa,qt,na,ra,$t,la,ia,bt,ua,da,xs,W,ca,gt,pa,ma,Ct,fa,va,kt,ha,_a,Os,De,ys,fe,Ea,jt,qa,$a,As,ve,P,ba,zt,ga,Ca,Tt,ka,ja,wt,za,Ta,Pt,wa,Pa,Dt,Da,xa,xt,Oa,ya,Aa,le,La,Ot,Sa,Ma,yt,Ua,Na,Ls,ie,he,At,xe,Fa,Lt,Ia,Ss,z,Ga,St,Ra,Ba,Mt,Va,Wa,Ut,Ha,Ya,Nt,Ja,Xa,Ft,Ka,Qa,It,Za,en,Ms,Oe,Us,ye,Ns,m,tn,Gt,sn,on,Rt,an,nn,Bt,rn,ln,Vt,un,dn,Wt,cn,pn,Ht,mn,fn,Yt,vn,hn,Jt,_n,En,Xt,qn,$n,Fs,N,bn,Kt,gn,Cn,Qt,kn,jn,He,zn,Tn,Zt,wn,Pn,Is,Ae,Gs,y,Dn,es,xn,On,ts,yn,An,ss,Ln,Sn,os,Mn,Un,as,Nn,Fn,Rs,Le,Bs,Se,Vs,H,In,Me,Gn,Rn,ns,Bn,Vn,rs,Wn,Hn,Ws,_e,Yn,ls,Jn,Xn,Hs,Ue,Ys,oe,Kn,is,Qn,Zn,us,er,tr,Js,Ne,Xs,Y,sr,ds,or,ar,cs,nr,rr,ps,lr,ir,Ks,Fe,Qs,Ye,ur,Zs,ae,dr,ms,cr,pr,fs,mr,fr,eo,J,vr,vs,hr,_r,hs,Er,qr,Je,$r,br,to,Ee,so;return f=new ri({props:{fw:Ce[0]}}),A=new gr({}),ee=new ni({props:{classNames:"absolute z-10 right-0 top-0",options:[{label:"Google Colab",value:"https://colab.research.google.com/github/huggingface/notebooks/blob/master/course/chapter3/section3.ipynb"},{label:"Aws Studio",value:"https://studiolab.sagemaker.aws/import/github/huggingface/notebooks/blob/master/course/chapter3/section3.ipynb"}]}}),B=new ai({props:{id:"nvBXf7s7vTI"}}),je=new V({props:{code:`from datasets import load_dataset
from transformers import AutoTokenizer, DataCollatorWithPadding

raw_datasets = load_dataset("glue", "mrpc")
checkpoint = "bert-base-uncased"
tokenizer = AutoTokenizer.from_pretrained(checkpoint)


def tokenize_function(example):
    return tokenizer(example["sentence1"], example["sentence2"], truncation=True)


tokenized_datasets = raw_datasets.map(tokenize_function, batched=True)
data_collator = DataCollatorWithPadding(tokenizer=tokenizer)`,highlighted:`<span class="hljs-keyword">from</span> datasets <span class="hljs-keyword">import</span> load_dataset
<span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> AutoTokenizer, DataCollatorWithPadding

raw_datasets = load_dataset(<span class="hljs-string">&quot;glue&quot;</span>, <span class="hljs-string">&quot;mrpc&quot;</span>)
checkpoint = <span class="hljs-string">&quot;bert-base-uncased&quot;</span>
tokenizer = AutoTokenizer.from_pretrained(checkpoint)


<span class="hljs-keyword">def</span> <span class="hljs-title function_">tokenize_function</span>(<span class="hljs-params">example</span>):
    <span class="hljs-keyword">return</span> tokenizer(example[<span class="hljs-string">&quot;sentence1&quot;</span>], example[<span class="hljs-string">&quot;sentence2&quot;</span>], truncation=<span class="hljs-literal">True</span>)


tokenized_datasets = raw_datasets.<span class="hljs-built_in">map</span>(tokenize_function, batched=<span class="hljs-literal">True</span>)
data_collator = DataCollatorWithPadding(tokenizer=tokenizer)`}}),ze=new gr({}),Te=new V({props:{code:`from transformers import TrainingArguments

training_args = TrainingArguments("test-trainer")`,highlighted:`<span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> TrainingArguments

training_args = TrainingArguments(<span class="hljs-string">&quot;test-trainer&quot;</span>)`}}),pe=new Ql({props:{$$slots:{default:[li]},$$scope:{ctx:Ce}}}),we=new V({props:{code:`from transformers import AutoModelForSequenceClassification

model = AutoModelForSequenceClassification.from_pretrained(checkpoint, num_labels=2)`,highlighted:`<span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> AutoModelForSequenceClassification

model = AutoModelForSequenceClassification.from_pretrained(checkpoint, num_labels=<span class="hljs-number">2</span>)`}}),Pe=new V({props:{code:`from transformers import Trainer

trainer = Trainer(
    model,
    training_args,
    train_dataset=tokenized_datasets["train"],
    eval_dataset=tokenized_datasets["validation"],
    data_collator=data_collator,
    tokenizer=tokenizer,
)`,highlighted:`<span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> Trainer

trainer = Trainer(
    model,
    training_args,
    train_dataset=tokenized_datasets[<span class="hljs-string">&quot;train&quot;</span>],
    eval_dataset=tokenized_datasets[<span class="hljs-string">&quot;validation&quot;</span>],
    data_collator=data_collator,
    tokenizer=tokenizer,
)`}}),De=new V({props:{code:"trainer.train()",highlighted:"trainer.train()"}}),xe=new gr({}),Oe=new V({props:{code:`predictions = trainer.predict(tokenized_datasets["validation"])
print(predictions.predictions.shape, predictions.label_ids.shape)`,highlighted:`predictions = trainer.predict(tokenized_datasets[<span class="hljs-string">&quot;validation&quot;</span>])
<span class="hljs-built_in">print</span>(predictions.predictions.shape, predictions.label_ids.shape)`}}),ye=new V({props:{code:"(408, 2) (408,)",highlighted:'(<span class="hljs-number">408</span>, <span class="hljs-number">2</span>) (<span class="hljs-number">408</span>,)'}}),Ae=new V({props:{code:`import numpy as np

preds = np.argmax(predictions.predictions, axis=-1)`,highlighted:`<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np

preds = np.argmax(predictions.predictions, axis=-<span class="hljs-number">1</span>)`}}),Le=new V({props:{code:`from datasets import load_metric

metric = load_metric("glue", "mrpc")
metric.compute(predictions=preds, references=predictions.label_ids)`,highlighted:`<span class="hljs-keyword">from</span> datasets <span class="hljs-keyword">import</span> load_metric

metric = load_metric(<span class="hljs-string">&quot;glue&quot;</span>, <span class="hljs-string">&quot;mrpc&quot;</span>)
metric.compute(predictions=preds, references=predictions.label_ids)`}}),Se=new V({props:{code:"{'accuracy': 0.8578431372549019, 'f1': 0.8996539792387542}",highlighted:'{<span class="hljs-string">&#x27;accuracy&#x27;</span>: <span class="hljs-number">0.8578431372549019</span>, <span class="hljs-string">&#x27;f1&#x27;</span>: <span class="hljs-number">0.8996539792387542</span>}'}}),Ue=new V({props:{code:`def compute_metrics(eval_preds):
    metric = load_metric("glue", "mrpc")
    logits, labels = eval_preds
    predictions = np.argmax(logits, axis=-1)
    return metric.compute(predictions=predictions, references=labels)`,highlighted:`<span class="hljs-keyword">def</span> <span class="hljs-title function_">compute_metrics</span>(<span class="hljs-params">eval_preds</span>):
    metric = load_metric(<span class="hljs-string">&quot;glue&quot;</span>, <span class="hljs-string">&quot;mrpc&quot;</span>)
    logits, labels = eval_preds
    predictions = np.argmax(logits, axis=-<span class="hljs-number">1</span>)
    <span class="hljs-keyword">return</span> metric.compute(predictions=predictions, references=labels)`}}),Ne=new V({props:{code:`training_args = TrainingArguments("test-trainer", evaluation_strategy="epoch")
model = AutoModelForSequenceClassification.from_pretrained(checkpoint, num_labels=2)

trainer = Trainer(
    model,
    training_args,
    train_dataset=tokenized_datasets["train"],
    eval_dataset=tokenized_datasets["validation"],
    data_collator=data_collator,
    tokenizer=tokenizer,
    compute_metrics=compute_metrics,
)`,highlighted:`training_args = TrainingArguments(<span class="hljs-string">&quot;test-trainer&quot;</span>, evaluation_strategy=<span class="hljs-string">&quot;epoch&quot;</span>)
model = AutoModelForSequenceClassification.from_pretrained(checkpoint, num_labels=<span class="hljs-number">2</span>)

trainer = Trainer(
    model,
    training_args,
    train_dataset=tokenized_datasets[<span class="hljs-string">&quot;train&quot;</span>],
    eval_dataset=tokenized_datasets[<span class="hljs-string">&quot;validation&quot;</span>],
    data_collator=data_collator,
    tokenizer=tokenizer,
    compute_metrics=compute_metrics,
)`}}),Fe=new V({props:{code:"trainer.train()",highlighted:'trainer.trai<span class="hljs-meta">n</span>()'}}),Ee=new Ql({props:{$$slots:{default:[ii]},$$scope:{ctx:Ce}}}),{c(){p=n("meta"),S=d(),_(f.$$.fragment),M=d(),T=n("h1"),C=n("a"),R=n("span"),_(A.$$.fragment),L=d(),j=n("span"),te=o("*Finetuner* un mod\xE8le avec l'API Trainer"),U=d(),_(ee.$$.fragment),ue=d(),_(B.$$.fragment),w=d(),h=n("p"),Ge=o("La biblioth\xE8que \u{1F917} "),de=n("em"),Re=o("Transformers"),uo=o(" fournit une classe "),et=n("code"),co=o("Trainer"),po=o(" pour vous aider \xE0 "),tt=n("em"),mo=o("finetuner"),fo=o(" n\u2019importe lequel des mod\xE8les pr\xE9-entra\xEEn\xE9s qu\u2019elle met \xE0 disposition sur votre jeu de donn\xE9es. Une fois que vous avez fait tout le travail de pr\xE9traitement des donn\xE9es dans la derni\xE8re section, il ne vous reste que quelques \xE9tapes pour d\xE9finir le "),st=n("code"),vo=o("Trainer"),ho=o(". La partie la plus difficile sera probablement de pr\xE9parer l\u2019environnement pour ex\xE9cuter "),ot=n("code"),_o=o("Trainer.train()"),Eo=o(", car elle fonctionnera tr\xE8s lentement sur un CPU. Si vous n\u2019avez pas de GPU, vous pouvez avoir acc\xE8s \xE0 des GPUs ou TPUs gratuits sur "),ke=n("a"),qo=o("Google Colab"),$o=o("."),qs=d(),Be=n("p"),bo=o("Les exemples de code ci-dessous supposent que vous avez d\xE9j\xE0 ex\xE9cut\xE9 les exemples de la section pr\xE9c\xE9dente. Voici un bref r\xE9sum\xE9 de ce dont vous avez besoin :"),$s=d(),_(je.$$.fragment),bs=d(),re=n("h3"),ce=n("a"),at=n("span"),_(ze.$$.fragment),go=d(),nt=n("span"),Co=o("Entra\xEEnement"),gs=d(),D=n("p"),ko=o("La premi\xE8re \xE9tape avant de pouvoir d\xE9finir notre "),rt=n("code"),jo=o("Trainer"),zo=o(" est de d\xE9finir une classe "),lt=n("code"),To=o("TrainingArguments"),wo=o(" qui contiendra tous les hyperparam\xE8tres que le "),it=n("code"),Po=o("Trainer"),Do=o(" utilisera pour l\u2019entra\xEEnement et l\u2019\xE9valuation. Le seul argument que vous devez fournir est un r\xE9pertoire o\xF9 le mod\xE8le entra\xEEn\xE9 sera sauvegard\xE9, ainsi que les "),ut=n("em"),xo=o("checkpoints"),Oo=o(". Pour tout le reste, vous pouvez laisser les valeurs par d\xE9faut, qui devraient fonctionner assez bien pour un "),dt=n("em"),yo=o("finetuning"),Ao=o(" de base."),Cs=d(),_(Te.$$.fragment),ks=d(),_(pe.$$.fragment),js=d(),se=n("p"),Lo=o("La deuxi\xE8me \xE9tape consiste \xE0 d\xE9finir notre mod\xE8le. Comme dans le "),Ve=n("a"),So=o("chapitre pr\xE9c\xE9dent"),Mo=o(", nous utiliserons la classe "),ct=n("code"),Uo=o("AutoModelForSequenceClassification"),No=o(", avec deux labels :"),zs=d(),_(we.$$.fragment),Ts=d(),me=n("p"),Fo=o("Vous remarquerez que contrairement au "),We=n("a"),Io=o("Chapitre 2"),Go=o(", vous obtenez un message d\u2019avertissement apr\xE8s l\u2019instanciation de ce mod\xE8le pr\xE9-entra\xEEn\xE9. C\u2019est parce que BERT n\u2019a pas \xE9t\xE9 pr\xE9-entra\xEEn\xE9 \xE0 la classification de paires de phrases, donc la t\xEAte du mod\xE8le pr\xE9-entra\xEEn\xE9 a \xE9t\xE9 supprim\xE9e et une nouvelle t\xEAte adapt\xE9e \xE0 la classification de s\xE9quences a \xE9t\xE9 ajout\xE9e \xE0 la place. Les messages d\u2019avertissement indiquent que certains poids n\u2019ont pas \xE9t\xE9 utilis\xE9s (ceux correspondant \xE0 la t\xEAte de pr\xE9-entra\xEEnement abandonn\xE9e) et que d\u2019autres ont \xE9t\xE9 initialis\xE9s de mani\xE8re al\xE9atoire (ceux pour la nouvelle t\xEAte). Il conclut en vous encourageant \xE0 entra\xEEner le mod\xE8le, ce qui est exactement ce que nous allons faire maintenant."),ws=d(),x=n("p"),Ro=o("Une fois que nous avons notre mod\xE8le, nous pouvons d\xE9finir un "),pt=n("code"),Bo=o("Trainer"),Vo=o(" en lui passant tous les objets construits jusqu\u2019\xE0 pr\xE9sent : le "),mt=n("code"),Wo=o("model"),Ho=o(", le "),ft=n("code"),Yo=o("training_args"),Jo=o(", les jeux de donn\xE9es d\u2019entra\xEEnement et de validation, notre "),vt=n("code"),Xo=o("data_collator"),Ko=o(", et notre "),ht=n("code"),Qo=o("tokenizer"),Zo=o(" :"),Ps=d(),_(Pe.$$.fragment),Ds=d(),O=n("p"),ea=o("Notez que lorsque vous passez le "),_t=n("code"),ta=o("tokenizer"),sa=o(" comme nous l\u2019avons fait ici, le "),Et=n("code"),oa=o("data_collator"),aa=o(" par d\xE9faut utilis\xE9 par le "),qt=n("code"),na=o("Trainer"),ra=o(" sera un "),$t=n("code"),la=o("DataCollatorWithPadding"),ia=o(" comme d\xE9fini pr\xE9c\xE9demment. Ainsi, vous pouvez sauter la ligne "),bt=n("code"),ua=o("data_collator=data_collator"),da=o(" dans cet appel. Il \xE9tait quand m\xEAme important de vous montrer cette partie du traitement dans la section 2 !"),xs=d(),W=n("p"),ca=o("Pour "),gt=n("em"),pa=o("finetuner"),ma=o(" le mod\xE8le sur notre jeu de donn\xE9es, il suffit d\u2019appeler la m\xE9thode "),Ct=n("code"),fa=o("train()"),va=o(" de notre "),kt=n("code"),ha=o("Trainer"),_a=o(" :"),Os=d(),_(De.$$.fragment),ys=d(),fe=n("p"),Ea=o("Cela lancera le "),jt=n("em"),qa=o("finetuning"),$a=o(" (qui devrait prendre quelques minutes sur un GPU) et indiquera la perte d\u2019entra\xEEnement tous les 500 pas. Cependant, elle ne vous dira pas si votre mod\xE8le fonctionne bien (ou mal). Ceci est d\xFB au fait que :"),As=d(),ve=n("ol"),P=n("li"),ba=o("nous n\u2019avons pas dit au "),zt=n("code"),ga=o("Trainer"),Ca=o(" d\u2019\xE9valuer pendant l\u2019entra\xEEnement en r\xE9glant "),Tt=n("code"),ka=o("evaluation_strategy"),ja=o(" \xE0 soit "),wt=n("code"),za=o('"steps"'),Ta=o(" (\xE9valuer chaque "),Pt=n("code"),wa=o("eval_steps"),Pa=o(") ou "),Dt=n("code"),Da=o('"epoch"'),xa=o(" (\xE9valuer \xE0 la fin de chaque "),xt=n("em"),Oa=o("epoch"),ya=o(")."),Aa=d(),le=n("li"),La=o("nous n\u2019avons pas fourni au "),Ot=n("code"),Sa=o("Trainer"),Ma=o(" une fonction "),yt=n("code"),Ua=o("compute_metrics()"),Na=o(" pour calculer une m\xE9trique pendant ladite \xE9valuation (sinon l\u2019\xE9valuation aurait juste affich\xE9 la perte, qui n\u2019est pas un nombre tr\xE8s intuitif)."),Ls=d(),ie=n("h3"),he=n("a"),At=n("span"),_(xe.$$.fragment),Fa=d(),Lt=n("span"),Ia=o("Evaluation"),Ss=d(),z=n("p"),Ga=o("Voyons comment nous pouvons construire une fonction "),St=n("code"),Ra=o("compute_metrics()"),Ba=o(" utile et l\u2019utiliser la prochaine fois que nous entra\xEEnons. La fonction doit prendre un objet "),Mt=n("code"),Va=o("EvalPrediction"),Wa=o(" (qui est un "),Ut=n("em"),Ha=o("tuple"),Ya=o(" nomm\xE9 avec un champ "),Nt=n("code"),Ja=o("predictions"),Xa=o(" et un champ "),Ft=n("code"),Ka=o("label_ids"),Qa=o(") et retournera un dictionnaire de cha\xEEnes de caract\xE8res vers des flottants (les cha\xEEnes de caract\xE8res \xE9tant les noms des m\xE9triques retourn\xE9es, et les flottants leurs valeurs). Pour obtenir des pr\xE9dictions de notre mod\xE8le, nous pouvons utiliser la commande "),It=n("code"),Za=o("Trainer.predict()"),en=o(" :"),Ms=d(),_(Oe.$$.fragment),Us=d(),_(ye.$$.fragment),Ns=d(),m=n("p"),tn=o("La sortie de la m\xE9thode "),Gt=n("code"),sn=o("predict()"),on=o(" est un autre "),Rt=n("em"),an=o("tuple"),nn=o(" nomm\xE9 avec trois champs : "),Bt=n("code"),rn=o("predictions"),ln=o(", "),Vt=n("code"),un=o("label_ids"),dn=o(", et "),Wt=n("code"),cn=o("metrics"),pn=o(". Le champ "),Ht=n("code"),mn=o("metrics"),fn=o(" contiendra juste la perte sur le jeu de donn\xE9es pass\xE9, ainsi que quelques mesures de temps (combien de temps il a fallu pour pr\xE9dire, au total et en moyenne). Une fois que nous aurons compl\xE9t\xE9 notre fonction "),Yt=n("code"),vn=o("compute_metrics()"),hn=o(" et que nous l\u2019aurons pass\xE9 au "),Jt=n("code"),_n=o("Trainer"),En=o(", ce champ contiendra \xE9galement les m\xE9triques retourn\xE9es par "),Xt=n("code"),qn=o("compute_metrics()"),$n=o("."),Fs=d(),N=n("p"),bn=o("Comme vous pouvez le voir, "),Kt=n("code"),gn=o("predictions"),Cn=o(" est un tableau bidimensionnel de forme 408 x 2 (408 \xE9tant le nombre d\u2019\xE9l\xE9ments dans le jeu de donn\xE9es que nous avons utilis\xE9). Ce sont les logits pour chaque \xE9l\xE9ment du jeu de donn\xE9es que nous avons pass\xE9 \xE0 "),Qt=n("code"),kn=o("predict()"),jn=o(" (comme vous l\u2019avez vu dans le "),He=n("a"),zn=o("chapitre pr\xE9c\xE9dent"),Tn=o(", tous les "),Zt=n("em"),wn=o("transformers"),Pn=o(" retournent des logits). Pour les transformer en pr\xE9dictions que nous pouvons comparer \xE0 nos \xE9tiquettes, nous devons prendre l\u2019indice avec la valeur maximale sur le second axe :"),Is=d(),_(Ae.$$.fragment),Gs=d(),y=n("p"),Dn=o("Nous pouvons maintenant comparer ces "),es=n("code"),xn=o("preds"),On=o(" aux \xE9tiquettes. Pour construire notre fonction "),ts=n("code"),yn=o("compute_metric()"),An=o(", nous allons nous appuyer sur les m\xE9triques de la biblioth\xE8que \u{1F917} "),ss=n("em"),Ln=o("Datasets"),Sn=o(". Nous pouvons charger les m\xE9triques associ\xE9es au jeu de donn\xE9es MRPC aussi facilement que nous avons charg\xE9 le jeu de donn\xE9es, cette fois avec la fonction "),os=n("code"),Mn=o("load_metric()"),Un=o(". L\u2019objet retourn\xE9 poss\xE8de une m\xE9thode "),as=n("code"),Nn=o("compute()"),Fn=o(" que nous pouvons utiliser pour effectuer le calcul de la m\xE9trique :"),Rs=d(),_(Le.$$.fragment),Bs=d(),_(Se.$$.fragment),Vs=d(),H=n("p"),In=o("Les r\xE9sultats exacts que vous obtiendrez peuvent varier, car l\u2019initialisation al\xE9atoire de la t\xEAte du mod\xE8le peut modifier les m\xE9triques obtenues. Ici, nous pouvons voir que notre mod\xE8le a une pr\xE9cision de 85,78% sur l\u2019ensemble de validation et un score F1 de 89,97. Ce sont les deux m\xE9triques utilis\xE9es pour \xE9valuer les r\xE9sultats sur le jeu de donn\xE9es MRPC pour le benchmark GLUE. Le tableau du papier de "),Me=n("a"),Gn=o("BERT"),Rn=o(" indique un score F1 de 88,9 pour le mod\xE8le de base. Il s\u2019agissait du mod\xE8le "),ns=n("code"),Bn=o("uncased"),Vn=o(" alors que nous utilisons actuellement le mod\xE8le "),rs=n("code"),Wn=o("cased"),Hn=o(", ce qui explique le meilleur r\xE9sultat."),Ws=d(),_e=n("p"),Yn=o("En regroupant le tout, nous obtenons notre fonction "),ls=n("code"),Jn=o("compute_metrics()"),Xn=o(" :"),Hs=d(),_(Ue.$$.fragment),Ys=d(),oe=n("p"),Kn=o("Et pour le voir utilis\xE9 en action pour rapporter les m\xE9triques \xE0 la fin de chaque \xE9poque, voici comment nous d\xE9finissons un nouveau "),is=n("code"),Qn=o("Trainer"),Zn=o(" avec cette fonction "),us=n("code"),er=o("compute_metrics()"),tr=o(" :"),Js=d(),_(Ne.$$.fragment),Xs=d(),Y=n("p"),sr=o("Notez que nous cr\xE9ons un nouveau "),ds=n("code"),or=o("TrainingArguments"),ar=o(" avec sa "),cs=n("code"),nr=o("evaluation_strategy"),rr=o(" d\xE9finie sur "),ps=n("code"),lr=o('"epoch"'),ir=o(" et un nouveau mod\xE8le. Sinon, nous ne ferions que continuer l\u2019entra\xEEnement du mod\xE8le que nous avons d\xE9j\xE0 entra\xEEn\xE9. Pour lancer un nouveau cycle d\u2019entra\xEEnement, nous ex\xE9cutons :"),Ks=d(),_(Fe.$$.fragment),Qs=d(),Ye=n("p"),ur=o("Cette fois, il indiquera la perte et les mesures de validation \xE0 la fin de chaque \xE9poque, en plus de la perte d\u2019entra\xEEnement. Encore une fois, le score exact de pr\xE9cision/F1 que vous atteignez peut \xEAtre un peu diff\xE9rent de ce que nous avons trouv\xE9, en raison de l\u2019initialisation al\xE9atoire de la t\xEAte du mod\xE8le, mais il devrait \xEAtre dans la m\xEAme fourchette."),Zs=d(),ae=n("p"),dr=o("Le "),ms=n("code"),cr=o("Trainer"),pr=o(" fonctionnera sur plusieurs GPUs ou TPUs et fournit beaucoup d\u2019options, comme l\u2019entra\xEEnement en pr\xE9cision mixte (utilisez "),fs=n("code"),mr=o("fp16 = True"),fr=o(" dans vos arguments d\u2019entra\xEEnement). Nous passerons en revue tout ce qu\u2019il supporte dans le chapitre 10."),eo=d(),J=n("p"),vr=o("Ceci conclut l\u2019introduction au "),vs=n("em"),hr=o("fine-tuning"),_r=o(" en utilisant l\u2019API "),hs=n("code"),Er=o("Trainer"),qr=o(". Un exemple d\u2019utilisation pour les t\xE2ches de NLP les plus communes es donn\xE9 dans le "),Je=n("a"),$r=o("Chapitre 7"),br=o(", mais pour l\u2019instant regardons comment faire la m\xEAme chose en PyTorch pur."),to=d(),_(Ee.$$.fragment),this.h()},l(e){const i=si('[data-svelte="svelte-1phssyn"]',document.head);p=r(i,"META",{name:!0,content:!0}),i.forEach(s),S=c(e),E(f.$$.fragment,e),M=c(e),T=r(e,"H1",{class:!0});var Ie=l(T);C=r(Ie,"A",{id:!0,class:!0,href:!0});var _s=l(C);R=r(_s,"SPAN",{});var Es=l(R);E(A.$$.fragment,Es),Es.forEach(s),_s.forEach(s),L=c(Ie),j=r(Ie,"SPAN",{});var Cr=l(j);te=a(Cr,"*Finetuner* un mod\xE8le avec l'API Trainer"),Cr.forEach(s),Ie.forEach(s),U=c(e),E(ee.$$.fragment,e),ue=c(e),E(B.$$.fragment,e),w=c(e),h=r(e,"P",{});var F=l(h);Ge=a(F,"La biblioth\xE8que \u{1F917} "),de=r(F,"EM",{});var kr=l(de);Re=a(kr,"Transformers"),kr.forEach(s),uo=a(F," fournit une classe "),et=r(F,"CODE",{});var jr=l(et);co=a(jr,"Trainer"),jr.forEach(s),po=a(F," pour vous aider \xE0 "),tt=r(F,"EM",{});var zr=l(tt);mo=a(zr,"finetuner"),zr.forEach(s),fo=a(F," n\u2019importe lequel des mod\xE8les pr\xE9-entra\xEEn\xE9s qu\u2019elle met \xE0 disposition sur votre jeu de donn\xE9es. Une fois que vous avez fait tout le travail de pr\xE9traitement des donn\xE9es dans la derni\xE8re section, il ne vous reste que quelques \xE9tapes pour d\xE9finir le "),st=r(F,"CODE",{});var Tr=l(st);vo=a(Tr,"Trainer"),Tr.forEach(s),ho=a(F,". La partie la plus difficile sera probablement de pr\xE9parer l\u2019environnement pour ex\xE9cuter "),ot=r(F,"CODE",{});var wr=l(ot);_o=a(wr,"Trainer.train()"),wr.forEach(s),Eo=a(F,", car elle fonctionnera tr\xE8s lentement sur un CPU. Si vous n\u2019avez pas de GPU, vous pouvez avoir acc\xE8s \xE0 des GPUs ou TPUs gratuits sur "),ke=r(F,"A",{href:!0,rel:!0});var Pr=l(ke);qo=a(Pr,"Google Colab"),Pr.forEach(s),$o=a(F,"."),F.forEach(s),qs=c(e),Be=r(e,"P",{});var Dr=l(Be);bo=a(Dr,"Les exemples de code ci-dessous supposent que vous avez d\xE9j\xE0 ex\xE9cut\xE9 les exemples de la section pr\xE9c\xE9dente. Voici un bref r\xE9sum\xE9 de ce dont vous avez besoin :"),Dr.forEach(s),$s=c(e),E(je.$$.fragment,e),bs=c(e),re=r(e,"H3",{class:!0});var oo=l(re);ce=r(oo,"A",{id:!0,class:!0,href:!0});var xr=l(ce);at=r(xr,"SPAN",{});var Or=l(at);E(ze.$$.fragment,Or),Or.forEach(s),xr.forEach(s),go=c(oo),nt=r(oo,"SPAN",{});var yr=l(nt);Co=a(yr,"Entra\xEEnement"),yr.forEach(s),oo.forEach(s),gs=c(e),D=r(e,"P",{});var X=l(D);ko=a(X,"La premi\xE8re \xE9tape avant de pouvoir d\xE9finir notre "),rt=r(X,"CODE",{});var Ar=l(rt);jo=a(Ar,"Trainer"),Ar.forEach(s),zo=a(X," est de d\xE9finir une classe "),lt=r(X,"CODE",{});var Lr=l(lt);To=a(Lr,"TrainingArguments"),Lr.forEach(s),wo=a(X," qui contiendra tous les hyperparam\xE8tres que le "),it=r(X,"CODE",{});var Sr=l(it);Po=a(Sr,"Trainer"),Sr.forEach(s),Do=a(X," utilisera pour l\u2019entra\xEEnement et l\u2019\xE9valuation. Le seul argument que vous devez fournir est un r\xE9pertoire o\xF9 le mod\xE8le entra\xEEn\xE9 sera sauvegard\xE9, ainsi que les "),ut=r(X,"EM",{});var Mr=l(ut);xo=a(Mr,"checkpoints"),Mr.forEach(s),Oo=a(X,". Pour tout le reste, vous pouvez laisser les valeurs par d\xE9faut, qui devraient fonctionner assez bien pour un "),dt=r(X,"EM",{});var Ur=l(dt);yo=a(Ur,"finetuning"),Ur.forEach(s),Ao=a(X," de base."),X.forEach(s),Cs=c(e),E(Te.$$.fragment,e),ks=c(e),E(pe.$$.fragment,e),js=c(e),se=r(e,"P",{});var Xe=l(se);Lo=a(Xe,"La deuxi\xE8me \xE9tape consiste \xE0 d\xE9finir notre mod\xE8le. Comme dans le "),Ve=r(Xe,"A",{href:!0});var Nr=l(Ve);So=a(Nr,"chapitre pr\xE9c\xE9dent"),Nr.forEach(s),Mo=a(Xe,", nous utiliserons la classe "),ct=r(Xe,"CODE",{});var Fr=l(ct);Uo=a(Fr,"AutoModelForSequenceClassification"),Fr.forEach(s),No=a(Xe,", avec deux labels :"),Xe.forEach(s),zs=c(e),E(we.$$.fragment,e),Ts=c(e),me=r(e,"P",{});var ao=l(me);Fo=a(ao,"Vous remarquerez que contrairement au "),We=r(ao,"A",{href:!0});var Ir=l(We);Io=a(Ir,"Chapitre 2"),Ir.forEach(s),Go=a(ao,", vous obtenez un message d\u2019avertissement apr\xE8s l\u2019instanciation de ce mod\xE8le pr\xE9-entra\xEEn\xE9. C\u2019est parce que BERT n\u2019a pas \xE9t\xE9 pr\xE9-entra\xEEn\xE9 \xE0 la classification de paires de phrases, donc la t\xEAte du mod\xE8le pr\xE9-entra\xEEn\xE9 a \xE9t\xE9 supprim\xE9e et une nouvelle t\xEAte adapt\xE9e \xE0 la classification de s\xE9quences a \xE9t\xE9 ajout\xE9e \xE0 la place. Les messages d\u2019avertissement indiquent que certains poids n\u2019ont pas \xE9t\xE9 utilis\xE9s (ceux correspondant \xE0 la t\xEAte de pr\xE9-entra\xEEnement abandonn\xE9e) et que d\u2019autres ont \xE9t\xE9 initialis\xE9s de mani\xE8re al\xE9atoire (ceux pour la nouvelle t\xEAte). Il conclut en vous encourageant \xE0 entra\xEEner le mod\xE8le, ce qui est exactement ce que nous allons faire maintenant."),ao.forEach(s),ws=c(e),x=r(e,"P",{});var K=l(x);Ro=a(K,"Une fois que nous avons notre mod\xE8le, nous pouvons d\xE9finir un "),pt=r(K,"CODE",{});var Gr=l(pt);Bo=a(Gr,"Trainer"),Gr.forEach(s),Vo=a(K," en lui passant tous les objets construits jusqu\u2019\xE0 pr\xE9sent : le "),mt=r(K,"CODE",{});var Rr=l(mt);Wo=a(Rr,"model"),Rr.forEach(s),Ho=a(K,", le "),ft=r(K,"CODE",{});var Br=l(ft);Yo=a(Br,"training_args"),Br.forEach(s),Jo=a(K,", les jeux de donn\xE9es d\u2019entra\xEEnement et de validation, notre "),vt=r(K,"CODE",{});var Vr=l(vt);Xo=a(Vr,"data_collator"),Vr.forEach(s),Ko=a(K,", et notre "),ht=r(K,"CODE",{});var Wr=l(ht);Qo=a(Wr,"tokenizer"),Wr.forEach(s),Zo=a(K," :"),K.forEach(s),Ps=c(e),E(Pe.$$.fragment,e),Ds=c(e),O=r(e,"P",{});var Q=l(O);ea=a(Q,"Notez que lorsque vous passez le "),_t=r(Q,"CODE",{});var Hr=l(_t);ta=a(Hr,"tokenizer"),Hr.forEach(s),sa=a(Q," comme nous l\u2019avons fait ici, le "),Et=r(Q,"CODE",{});var Yr=l(Et);oa=a(Yr,"data_collator"),Yr.forEach(s),aa=a(Q," par d\xE9faut utilis\xE9 par le "),qt=r(Q,"CODE",{});var Jr=l(qt);na=a(Jr,"Trainer"),Jr.forEach(s),ra=a(Q," sera un "),$t=r(Q,"CODE",{});var Xr=l($t);la=a(Xr,"DataCollatorWithPadding"),Xr.forEach(s),ia=a(Q," comme d\xE9fini pr\xE9c\xE9demment. Ainsi, vous pouvez sauter la ligne "),bt=r(Q,"CODE",{});var Kr=l(bt);ua=a(Kr,"data_collator=data_collator"),Kr.forEach(s),da=a(Q," dans cet appel. Il \xE9tait quand m\xEAme important de vous montrer cette partie du traitement dans la section 2 !"),Q.forEach(s),xs=c(e),W=r(e,"P",{});var qe=l(W);ca=a(qe,"Pour "),gt=r(qe,"EM",{});var Qr=l(gt);pa=a(Qr,"finetuner"),Qr.forEach(s),ma=a(qe," le mod\xE8le sur notre jeu de donn\xE9es, il suffit d\u2019appeler la m\xE9thode "),Ct=r(qe,"CODE",{});var Zr=l(Ct);fa=a(Zr,"train()"),Zr.forEach(s),va=a(qe," de notre "),kt=r(qe,"CODE",{});var el=l(kt);ha=a(el,"Trainer"),el.forEach(s),_a=a(qe," :"),qe.forEach(s),Os=c(e),E(De.$$.fragment,e),ys=c(e),fe=r(e,"P",{});var no=l(fe);Ea=a(no,"Cela lancera le "),jt=r(no,"EM",{});var tl=l(jt);qa=a(tl,"finetuning"),tl.forEach(s),$a=a(no," (qui devrait prendre quelques minutes sur un GPU) et indiquera la perte d\u2019entra\xEEnement tous les 500 pas. Cependant, elle ne vous dira pas si votre mod\xE8le fonctionne bien (ou mal). Ceci est d\xFB au fait que :"),no.forEach(s),As=c(e),ve=r(e,"OL",{});var ro=l(ve);P=r(ro,"LI",{});var I=l(P);ba=a(I,"nous n\u2019avons pas dit au "),zt=r(I,"CODE",{});var sl=l(zt);ga=a(sl,"Trainer"),sl.forEach(s),Ca=a(I," d\u2019\xE9valuer pendant l\u2019entra\xEEnement en r\xE9glant "),Tt=r(I,"CODE",{});var ol=l(Tt);ka=a(ol,"evaluation_strategy"),ol.forEach(s),ja=a(I," \xE0 soit "),wt=r(I,"CODE",{});var al=l(wt);za=a(al,'"steps"'),al.forEach(s),Ta=a(I," (\xE9valuer chaque "),Pt=r(I,"CODE",{});var nl=l(Pt);wa=a(nl,"eval_steps"),nl.forEach(s),Pa=a(I,") ou "),Dt=r(I,"CODE",{});var rl=l(Dt);Da=a(rl,'"epoch"'),rl.forEach(s),xa=a(I," (\xE9valuer \xE0 la fin de chaque "),xt=r(I,"EM",{});var ll=l(xt);Oa=a(ll,"epoch"),ll.forEach(s),ya=a(I,")."),I.forEach(s),Aa=c(ro),le=r(ro,"LI",{});var Ke=l(le);La=a(Ke,"nous n\u2019avons pas fourni au "),Ot=r(Ke,"CODE",{});var il=l(Ot);Sa=a(il,"Trainer"),il.forEach(s),Ma=a(Ke," une fonction "),yt=r(Ke,"CODE",{});var ul=l(yt);Ua=a(ul,"compute_metrics()"),ul.forEach(s),Na=a(Ke," pour calculer une m\xE9trique pendant ladite \xE9valuation (sinon l\u2019\xE9valuation aurait juste affich\xE9 la perte, qui n\u2019est pas un nombre tr\xE8s intuitif)."),Ke.forEach(s),ro.forEach(s),Ls=c(e),ie=r(e,"H3",{class:!0});var lo=l(ie);he=r(lo,"A",{id:!0,class:!0,href:!0});var dl=l(he);At=r(dl,"SPAN",{});var cl=l(At);E(xe.$$.fragment,cl),cl.forEach(s),dl.forEach(s),Fa=c(lo),Lt=r(lo,"SPAN",{});var pl=l(Lt);Ia=a(pl,"Evaluation"),pl.forEach(s),lo.forEach(s),Ss=c(e),z=r(e,"P",{});var G=l(z);Ga=a(G,"Voyons comment nous pouvons construire une fonction "),St=r(G,"CODE",{});var ml=l(St);Ra=a(ml,"compute_metrics()"),ml.forEach(s),Ba=a(G," utile et l\u2019utiliser la prochaine fois que nous entra\xEEnons. La fonction doit prendre un objet "),Mt=r(G,"CODE",{});var fl=l(Mt);Va=a(fl,"EvalPrediction"),fl.forEach(s),Wa=a(G," (qui est un "),Ut=r(G,"EM",{});var vl=l(Ut);Ha=a(vl,"tuple"),vl.forEach(s),Ya=a(G," nomm\xE9 avec un champ "),Nt=r(G,"CODE",{});var hl=l(Nt);Ja=a(hl,"predictions"),hl.forEach(s),Xa=a(G," et un champ "),Ft=r(G,"CODE",{});var _l=l(Ft);Ka=a(_l,"label_ids"),_l.forEach(s),Qa=a(G,") et retournera un dictionnaire de cha\xEEnes de caract\xE8res vers des flottants (les cha\xEEnes de caract\xE8res \xE9tant les noms des m\xE9triques retourn\xE9es, et les flottants leurs valeurs). Pour obtenir des pr\xE9dictions de notre mod\xE8le, nous pouvons utiliser la commande "),It=r(G,"CODE",{});var El=l(It);Za=a(El,"Trainer.predict()"),El.forEach(s),en=a(G," :"),G.forEach(s),Ms=c(e),E(Oe.$$.fragment,e),Us=c(e),E(ye.$$.fragment,e),Ns=c(e),m=r(e,"P",{});var k=l(m);tn=a(k,"La sortie de la m\xE9thode "),Gt=r(k,"CODE",{});var ql=l(Gt);sn=a(ql,"predict()"),ql.forEach(s),on=a(k," est un autre "),Rt=r(k,"EM",{});var $l=l(Rt);an=a($l,"tuple"),$l.forEach(s),nn=a(k," nomm\xE9 avec trois champs : "),Bt=r(k,"CODE",{});var bl=l(Bt);rn=a(bl,"predictions"),bl.forEach(s),ln=a(k,", "),Vt=r(k,"CODE",{});var gl=l(Vt);un=a(gl,"label_ids"),gl.forEach(s),dn=a(k,", et "),Wt=r(k,"CODE",{});var Cl=l(Wt);cn=a(Cl,"metrics"),Cl.forEach(s),pn=a(k,". Le champ "),Ht=r(k,"CODE",{});var kl=l(Ht);mn=a(kl,"metrics"),kl.forEach(s),fn=a(k," contiendra juste la perte sur le jeu de donn\xE9es pass\xE9, ainsi que quelques mesures de temps (combien de temps il a fallu pour pr\xE9dire, au total et en moyenne). Une fois que nous aurons compl\xE9t\xE9 notre fonction "),Yt=r(k,"CODE",{});var jl=l(Yt);vn=a(jl,"compute_metrics()"),jl.forEach(s),hn=a(k," et que nous l\u2019aurons pass\xE9 au "),Jt=r(k,"CODE",{});var zl=l(Jt);_n=a(zl,"Trainer"),zl.forEach(s),En=a(k,", ce champ contiendra \xE9galement les m\xE9triques retourn\xE9es par "),Xt=r(k,"CODE",{});var Tl=l(Xt);qn=a(Tl,"compute_metrics()"),Tl.forEach(s),$n=a(k,"."),k.forEach(s),Fs=c(e),N=r(e,"P",{});var ne=l(N);bn=a(ne,"Comme vous pouvez le voir, "),Kt=r(ne,"CODE",{});var wl=l(Kt);gn=a(wl,"predictions"),wl.forEach(s),Cn=a(ne," est un tableau bidimensionnel de forme 408 x 2 (408 \xE9tant le nombre d\u2019\xE9l\xE9ments dans le jeu de donn\xE9es que nous avons utilis\xE9). Ce sont les logits pour chaque \xE9l\xE9ment du jeu de donn\xE9es que nous avons pass\xE9 \xE0 "),Qt=r(ne,"CODE",{});var Pl=l(Qt);kn=a(Pl,"predict()"),Pl.forEach(s),jn=a(ne," (comme vous l\u2019avez vu dans le "),He=r(ne,"A",{href:!0});var Dl=l(He);zn=a(Dl,"chapitre pr\xE9c\xE9dent"),Dl.forEach(s),Tn=a(ne,", tous les "),Zt=r(ne,"EM",{});var xl=l(Zt);wn=a(xl,"transformers"),xl.forEach(s),Pn=a(ne," retournent des logits). Pour les transformer en pr\xE9dictions que nous pouvons comparer \xE0 nos \xE9tiquettes, nous devons prendre l\u2019indice avec la valeur maximale sur le second axe :"),ne.forEach(s),Is=c(e),E(Ae.$$.fragment,e),Gs=c(e),y=r(e,"P",{});var Z=l(y);Dn=a(Z,"Nous pouvons maintenant comparer ces "),es=r(Z,"CODE",{});var Ol=l(es);xn=a(Ol,"preds"),Ol.forEach(s),On=a(Z," aux \xE9tiquettes. Pour construire notre fonction "),ts=r(Z,"CODE",{});var yl=l(ts);yn=a(yl,"compute_metric()"),yl.forEach(s),An=a(Z,", nous allons nous appuyer sur les m\xE9triques de la biblioth\xE8que \u{1F917} "),ss=r(Z,"EM",{});var Al=l(ss);Ln=a(Al,"Datasets"),Al.forEach(s),Sn=a(Z,". Nous pouvons charger les m\xE9triques associ\xE9es au jeu de donn\xE9es MRPC aussi facilement que nous avons charg\xE9 le jeu de donn\xE9es, cette fois avec la fonction "),os=r(Z,"CODE",{});var Ll=l(os);Mn=a(Ll,"load_metric()"),Ll.forEach(s),Un=a(Z,". L\u2019objet retourn\xE9 poss\xE8de une m\xE9thode "),as=r(Z,"CODE",{});var Sl=l(as);Nn=a(Sl,"compute()"),Sl.forEach(s),Fn=a(Z," que nous pouvons utiliser pour effectuer le calcul de la m\xE9trique :"),Z.forEach(s),Rs=c(e),E(Le.$$.fragment,e),Bs=c(e),E(Se.$$.fragment,e),Vs=c(e),H=r(e,"P",{});var $e=l(H);In=a($e,"Les r\xE9sultats exacts que vous obtiendrez peuvent varier, car l\u2019initialisation al\xE9atoire de la t\xEAte du mod\xE8le peut modifier les m\xE9triques obtenues. Ici, nous pouvons voir que notre mod\xE8le a une pr\xE9cision de 85,78% sur l\u2019ensemble de validation et un score F1 de 89,97. Ce sont les deux m\xE9triques utilis\xE9es pour \xE9valuer les r\xE9sultats sur le jeu de donn\xE9es MRPC pour le benchmark GLUE. Le tableau du papier de "),Me=r($e,"A",{href:!0,rel:!0});var Ml=l(Me);Gn=a(Ml,"BERT"),Ml.forEach(s),Rn=a($e," indique un score F1 de 88,9 pour le mod\xE8le de base. Il s\u2019agissait du mod\xE8le "),ns=r($e,"CODE",{});var Ul=l(ns);Bn=a(Ul,"uncased"),Ul.forEach(s),Vn=a($e," alors que nous utilisons actuellement le mod\xE8le "),rs=r($e,"CODE",{});var Nl=l(rs);Wn=a(Nl,"cased"),Nl.forEach(s),Hn=a($e,", ce qui explique le meilleur r\xE9sultat."),$e.forEach(s),Ws=c(e),_e=r(e,"P",{});var io=l(_e);Yn=a(io,"En regroupant le tout, nous obtenons notre fonction "),ls=r(io,"CODE",{});var Fl=l(ls);Jn=a(Fl,"compute_metrics()"),Fl.forEach(s),Xn=a(io," :"),io.forEach(s),Hs=c(e),E(Ue.$$.fragment,e),Ys=c(e),oe=r(e,"P",{});var Qe=l(oe);Kn=a(Qe,"Et pour le voir utilis\xE9 en action pour rapporter les m\xE9triques \xE0 la fin de chaque \xE9poque, voici comment nous d\xE9finissons un nouveau "),is=r(Qe,"CODE",{});var Il=l(is);Qn=a(Il,"Trainer"),Il.forEach(s),Zn=a(Qe," avec cette fonction "),us=r(Qe,"CODE",{});var Gl=l(us);er=a(Gl,"compute_metrics()"),Gl.forEach(s),tr=a(Qe," :"),Qe.forEach(s),Js=c(e),E(Ne.$$.fragment,e),Xs=c(e),Y=r(e,"P",{});var be=l(Y);sr=a(be,"Notez que nous cr\xE9ons un nouveau "),ds=r(be,"CODE",{});var Rl=l(ds);or=a(Rl,"TrainingArguments"),Rl.forEach(s),ar=a(be," avec sa "),cs=r(be,"CODE",{});var Bl=l(cs);nr=a(Bl,"evaluation_strategy"),Bl.forEach(s),rr=a(be," d\xE9finie sur "),ps=r(be,"CODE",{});var Vl=l(ps);lr=a(Vl,'"epoch"'),Vl.forEach(s),ir=a(be," et un nouveau mod\xE8le. Sinon, nous ne ferions que continuer l\u2019entra\xEEnement du mod\xE8le que nous avons d\xE9j\xE0 entra\xEEn\xE9. Pour lancer un nouveau cycle d\u2019entra\xEEnement, nous ex\xE9cutons :"),be.forEach(s),Ks=c(e),E(Fe.$$.fragment,e),Qs=c(e),Ye=r(e,"P",{});var Wl=l(Ye);ur=a(Wl,"Cette fois, il indiquera la perte et les mesures de validation \xE0 la fin de chaque \xE9poque, en plus de la perte d\u2019entra\xEEnement. Encore une fois, le score exact de pr\xE9cision/F1 que vous atteignez peut \xEAtre un peu diff\xE9rent de ce que nous avons trouv\xE9, en raison de l\u2019initialisation al\xE9atoire de la t\xEAte du mod\xE8le, mais il devrait \xEAtre dans la m\xEAme fourchette."),Wl.forEach(s),Zs=c(e),ae=r(e,"P",{});var Ze=l(ae);dr=a(Ze,"Le "),ms=r(Ze,"CODE",{});var Hl=l(ms);cr=a(Hl,"Trainer"),Hl.forEach(s),pr=a(Ze," fonctionnera sur plusieurs GPUs ou TPUs et fournit beaucoup d\u2019options, comme l\u2019entra\xEEnement en pr\xE9cision mixte (utilisez "),fs=r(Ze,"CODE",{});var Yl=l(fs);mr=a(Yl,"fp16 = True"),Yl.forEach(s),fr=a(Ze," dans vos arguments d\u2019entra\xEEnement). Nous passerons en revue tout ce qu\u2019il supporte dans le chapitre 10."),Ze.forEach(s),eo=c(e),J=r(e,"P",{});var ge=l(J);vr=a(ge,"Ceci conclut l\u2019introduction au "),vs=r(ge,"EM",{});var Jl=l(vs);hr=a(Jl,"fine-tuning"),Jl.forEach(s),_r=a(ge," en utilisant l\u2019API "),hs=r(ge,"CODE",{});var Xl=l(hs);Er=a(Xl,"Trainer"),Xl.forEach(s),qr=a(ge,". Un exemple d\u2019utilisation pour les t\xE2ches de NLP les plus communes es donn\xE9 dans le "),Je=r(ge,"A",{href:!0});var Kl=l(Je);$r=a(Kl,"Chapitre 7"),Kl.forEach(s),br=a(ge,", mais pour l\u2019instant regardons comment faire la m\xEAme chose en PyTorch pur."),ge.forEach(s),to=c(e),E(Ee.$$.fragment,e),this.h()},h(){v(p,"name","hf:doc:metadata"),v(p,"content",JSON.stringify(di)),v(C,"id","finetuner-un-modle-avec-lapi-trainer"),v(C,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),v(C,"href","#finetuner-un-modle-avec-lapi-trainer"),v(T,"class","relative group"),v(ke,"href","https://colab.research.google.com/"),v(ke,"rel","nofollow"),v(ce,"id","entranement"),v(ce,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),v(ce,"href","#entranement"),v(re,"class","relative group"),v(Ve,"href","/course/fr/chapter2"),v(We,"href","/course/fr/chapter2"),v(he,"id","evaluation"),v(he,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),v(he,"href","#evaluation"),v(ie,"class","relative group"),v(He,"href","/course/fr/chapter2"),v(Me,"href","https://arxiv.org/pdf/1810.04805.pdf"),v(Me,"rel","nofollow"),v(Je,"href","/course/fr/chapter7")},m(e,i){t(document.head,p),u(e,S,i),q(f,e,i),u(e,M,i),u(e,T,i),t(T,C),t(C,R),q(A,R,null),t(T,L),t(T,j),t(j,te),u(e,U,i),q(ee,e,i),u(e,ue,i),q(B,e,i),u(e,w,i),u(e,h,i),t(h,Ge),t(h,de),t(de,Re),t(h,uo),t(h,et),t(et,co),t(h,po),t(h,tt),t(tt,mo),t(h,fo),t(h,st),t(st,vo),t(h,ho),t(h,ot),t(ot,_o),t(h,Eo),t(h,ke),t(ke,qo),t(h,$o),u(e,qs,i),u(e,Be,i),t(Be,bo),u(e,$s,i),q(je,e,i),u(e,bs,i),u(e,re,i),t(re,ce),t(ce,at),q(ze,at,null),t(re,go),t(re,nt),t(nt,Co),u(e,gs,i),u(e,D,i),t(D,ko),t(D,rt),t(rt,jo),t(D,zo),t(D,lt),t(lt,To),t(D,wo),t(D,it),t(it,Po),t(D,Do),t(D,ut),t(ut,xo),t(D,Oo),t(D,dt),t(dt,yo),t(D,Ao),u(e,Cs,i),q(Te,e,i),u(e,ks,i),q(pe,e,i),u(e,js,i),u(e,se,i),t(se,Lo),t(se,Ve),t(Ve,So),t(se,Mo),t(se,ct),t(ct,Uo),t(se,No),u(e,zs,i),q(we,e,i),u(e,Ts,i),u(e,me,i),t(me,Fo),t(me,We),t(We,Io),t(me,Go),u(e,ws,i),u(e,x,i),t(x,Ro),t(x,pt),t(pt,Bo),t(x,Vo),t(x,mt),t(mt,Wo),t(x,Ho),t(x,ft),t(ft,Yo),t(x,Jo),t(x,vt),t(vt,Xo),t(x,Ko),t(x,ht),t(ht,Qo),t(x,Zo),u(e,Ps,i),q(Pe,e,i),u(e,Ds,i),u(e,O,i),t(O,ea),t(O,_t),t(_t,ta),t(O,sa),t(O,Et),t(Et,oa),t(O,aa),t(O,qt),t(qt,na),t(O,ra),t(O,$t),t($t,la),t(O,ia),t(O,bt),t(bt,ua),t(O,da),u(e,xs,i),u(e,W,i),t(W,ca),t(W,gt),t(gt,pa),t(W,ma),t(W,Ct),t(Ct,fa),t(W,va),t(W,kt),t(kt,ha),t(W,_a),u(e,Os,i),q(De,e,i),u(e,ys,i),u(e,fe,i),t(fe,Ea),t(fe,jt),t(jt,qa),t(fe,$a),u(e,As,i),u(e,ve,i),t(ve,P),t(P,ba),t(P,zt),t(zt,ga),t(P,Ca),t(P,Tt),t(Tt,ka),t(P,ja),t(P,wt),t(wt,za),t(P,Ta),t(P,Pt),t(Pt,wa),t(P,Pa),t(P,Dt),t(Dt,Da),t(P,xa),t(P,xt),t(xt,Oa),t(P,ya),t(ve,Aa),t(ve,le),t(le,La),t(le,Ot),t(Ot,Sa),t(le,Ma),t(le,yt),t(yt,Ua),t(le,Na),u(e,Ls,i),u(e,ie,i),t(ie,he),t(he,At),q(xe,At,null),t(ie,Fa),t(ie,Lt),t(Lt,Ia),u(e,Ss,i),u(e,z,i),t(z,Ga),t(z,St),t(St,Ra),t(z,Ba),t(z,Mt),t(Mt,Va),t(z,Wa),t(z,Ut),t(Ut,Ha),t(z,Ya),t(z,Nt),t(Nt,Ja),t(z,Xa),t(z,Ft),t(Ft,Ka),t(z,Qa),t(z,It),t(It,Za),t(z,en),u(e,Ms,i),q(Oe,e,i),u(e,Us,i),q(ye,e,i),u(e,Ns,i),u(e,m,i),t(m,tn),t(m,Gt),t(Gt,sn),t(m,on),t(m,Rt),t(Rt,an),t(m,nn),t(m,Bt),t(Bt,rn),t(m,ln),t(m,Vt),t(Vt,un),t(m,dn),t(m,Wt),t(Wt,cn),t(m,pn),t(m,Ht),t(Ht,mn),t(m,fn),t(m,Yt),t(Yt,vn),t(m,hn),t(m,Jt),t(Jt,_n),t(m,En),t(m,Xt),t(Xt,qn),t(m,$n),u(e,Fs,i),u(e,N,i),t(N,bn),t(N,Kt),t(Kt,gn),t(N,Cn),t(N,Qt),t(Qt,kn),t(N,jn),t(N,He),t(He,zn),t(N,Tn),t(N,Zt),t(Zt,wn),t(N,Pn),u(e,Is,i),q(Ae,e,i),u(e,Gs,i),u(e,y,i),t(y,Dn),t(y,es),t(es,xn),t(y,On),t(y,ts),t(ts,yn),t(y,An),t(y,ss),t(ss,Ln),t(y,Sn),t(y,os),t(os,Mn),t(y,Un),t(y,as),t(as,Nn),t(y,Fn),u(e,Rs,i),q(Le,e,i),u(e,Bs,i),q(Se,e,i),u(e,Vs,i),u(e,H,i),t(H,In),t(H,Me),t(Me,Gn),t(H,Rn),t(H,ns),t(ns,Bn),t(H,Vn),t(H,rs),t(rs,Wn),t(H,Hn),u(e,Ws,i),u(e,_e,i),t(_e,Yn),t(_e,ls),t(ls,Jn),t(_e,Xn),u(e,Hs,i),q(Ue,e,i),u(e,Ys,i),u(e,oe,i),t(oe,Kn),t(oe,is),t(is,Qn),t(oe,Zn),t(oe,us),t(us,er),t(oe,tr),u(e,Js,i),q(Ne,e,i),u(e,Xs,i),u(e,Y,i),t(Y,sr),t(Y,ds),t(ds,or),t(Y,ar),t(Y,cs),t(cs,nr),t(Y,rr),t(Y,ps),t(ps,lr),t(Y,ir),u(e,Ks,i),q(Fe,e,i),u(e,Qs,i),u(e,Ye,i),t(Ye,ur),u(e,Zs,i),u(e,ae,i),t(ae,dr),t(ae,ms),t(ms,cr),t(ae,pr),t(ae,fs),t(fs,mr),t(ae,fr),u(e,eo,i),u(e,J,i),t(J,vr),t(J,vs),t(vs,hr),t(J,_r),t(J,hs),t(hs,Er),t(J,qr),t(J,Je),t(Je,$r),t(J,br),u(e,to,i),q(Ee,e,i),so=!0},p(e,[i]){const Ie={};i&1&&(Ie.fw=e[0]),f.$set(Ie);const _s={};i&2&&(_s.$$scope={dirty:i,ctx:e}),pe.$set(_s);const Es={};i&2&&(Es.$$scope={dirty:i,ctx:e}),Ee.$set(Es)},i(e){so||($(f.$$.fragment,e),$(A.$$.fragment,e),$(ee.$$.fragment,e),$(B.$$.fragment,e),$(je.$$.fragment,e),$(ze.$$.fragment,e),$(Te.$$.fragment,e),$(pe.$$.fragment,e),$(we.$$.fragment,e),$(Pe.$$.fragment,e),$(De.$$.fragment,e),$(xe.$$.fragment,e),$(Oe.$$.fragment,e),$(ye.$$.fragment,e),$(Ae.$$.fragment,e),$(Le.$$.fragment,e),$(Se.$$.fragment,e),$(Ue.$$.fragment,e),$(Ne.$$.fragment,e),$(Fe.$$.fragment,e),$(Ee.$$.fragment,e),so=!0)},o(e){b(f.$$.fragment,e),b(A.$$.fragment,e),b(ee.$$.fragment,e),b(B.$$.fragment,e),b(je.$$.fragment,e),b(ze.$$.fragment,e),b(Te.$$.fragment,e),b(pe.$$.fragment,e),b(we.$$.fragment,e),b(Pe.$$.fragment,e),b(De.$$.fragment,e),b(xe.$$.fragment,e),b(Oe.$$.fragment,e),b(ye.$$.fragment,e),b(Ae.$$.fragment,e),b(Le.$$.fragment,e),b(Se.$$.fragment,e),b(Ue.$$.fragment,e),b(Ne.$$.fragment,e),b(Fe.$$.fragment,e),b(Ee.$$.fragment,e),so=!1},d(e){s(p),e&&s(S),g(f,e),e&&s(M),e&&s(T),g(A),e&&s(U),g(ee,e),e&&s(ue),g(B,e),e&&s(w),e&&s(h),e&&s(qs),e&&s(Be),e&&s($s),g(je,e),e&&s(bs),e&&s(re),g(ze),e&&s(gs),e&&s(D),e&&s(Cs),g(Te,e),e&&s(ks),g(pe,e),e&&s(js),e&&s(se),e&&s(zs),g(we,e),e&&s(Ts),e&&s(me),e&&s(ws),e&&s(x),e&&s(Ps),g(Pe,e),e&&s(Ds),e&&s(O),e&&s(xs),e&&s(W),e&&s(Os),g(De,e),e&&s(ys),e&&s(fe),e&&s(As),e&&s(ve),e&&s(Ls),e&&s(ie),g(xe),e&&s(Ss),e&&s(z),e&&s(Ms),g(Oe,e),e&&s(Us),g(ye,e),e&&s(Ns),e&&s(m),e&&s(Fs),e&&s(N),e&&s(Is),g(Ae,e),e&&s(Gs),e&&s(y),e&&s(Rs),g(Le,e),e&&s(Bs),g(Se,e),e&&s(Vs),e&&s(H),e&&s(Ws),e&&s(_e),e&&s(Hs),g(Ue,e),e&&s(Ys),e&&s(oe),e&&s(Js),g(Ne,e),e&&s(Xs),e&&s(Y),e&&s(Ks),g(Fe,e),e&&s(Qs),e&&s(Ye),e&&s(Zs),e&&s(ae),e&&s(eo),e&&s(J),e&&s(to),g(Ee,e)}}}const di={local:"finetuner-un-modle-avec-lapi-trainer",sections:[{local:"entranement",title:"Entra\xEEnement"},{local:"evaluation",title:"Evaluation"}],title:"*Finetuner* un mod\xE8le avec l'API Trainer"};function ci(Ce,p,S){let f="pt";return oi(()=>{const M=new URLSearchParams(window.location.search);S(0,f=M.get("fw")||"pt")}),[f]}class qi extends Zl{constructor(p){super();ei(this,p,ci,ui,ti,{})}}export{qi as default,di as metadata};
