import{S as ct,i as pt,s as mt,e as u,k,w as N,t as l,M as ut,c as d,d as t,m as _,x as H,a as b,h as n,b as v,N as it,G as o,g as m,y as B,o as z,p as rt,q as C,B as I,v as dt,n as lt}from"../../chunks/vendor-hf-doc-builder.js";import{T as ft,D as nt}from"../../chunks/DocNotebookDropdown-hf-doc-builder.js";import{I as ht}from"../../chunks/IconCopyLink-hf-doc-builder.js";import{C as re}from"../../chunks/CodeBlock-hf-doc-builder.js";import{F as bt}from"../../chunks/FrameworkSwitchCourse-hf-doc-builder.js";function gt(M){let i,c;return i=new nt({props:{classNames:"absolute z-10 right-0 top-0",options:[{label:"Google Colab",value:"https://colab.research.google.com/github/huggingface/notebooks/blob/master/course/chapter4/section2_tf.ipynb"},{label:"Aws Studio",value:"https://studiolab.sagemaker.aws/import/github/huggingface/notebooks/blob/master/course/chapter4/section2_tf.ipynb"}]}}),{c(){N(i.$$.fragment)},l(s){H(i.$$.fragment,s)},m(s,$){B(i,s,$),c=!0},i(s){c||(C(i.$$.fragment,s),c=!0)},o(s){z(i.$$.fragment,s),c=!1},d(s){I(i,s)}}}function kt(M){let i,c;return i=new nt({props:{classNames:"absolute z-10 right-0 top-0",options:[{label:"Google Colab",value:"https://colab.research.google.com/github/huggingface/notebooks/blob/master/course/chapter4/section2_pt.ipynb"},{label:"Aws Studio",value:"https://studiolab.sagemaker.aws/import/github/huggingface/notebooks/blob/master/course/chapter4/section2_pt.ipynb"}]}}),{c(){N(i.$$.fragment)},l(s){H(i.$$.fragment,s)},m(s,$){B(i,s,$),c=!0},i(s){c||(C(i.$$.fragment,s),c=!0)},o(s){z(i.$$.fragment,s),c=!1},d(s){I(i,s)}}}function _t(M){let i,c,s,$,f,w,x,E,D,j,S,T,g,h,q;return i=new re({props:{code:"",highlighted:`<span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> CamembertTokenizer, TFCamembertForMaskedLM

tokenizer = CamembertTokenizer.from_pretrained(<span class="hljs-string">&quot;camembert-base&quot;</span>)
model = TFCamembertForMaskedLM.from_pretrained(<span class="hljs-string">&quot;camembert-base&quot;</span>)`}}),h=new re({props:{code:"",highlighted:`<span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> AutoTokenizer, TFAutoModelForMaskedLM

tokenizer = AutoTokenizer.from_pretrained(<span class="hljs-string">&quot;camembert-base&quot;</span>)
model = TFAutoModelForMaskedLM.from_pretrained(<span class="hljs-string">&quot;camembert-base&quot;</span>)`}}),{c(){N(i.$$.fragment),c=k(),s=u("p"),$=l("Tuttavia, noi consigliamo di usare le "),f=u("a"),w=l("classi "),x=u("code"),E=l("TFAuto*"),D=l(" quando possibile, poich\xE9 sono progettate per essere agnostiche rispetto al tipo di architettura del modello. Mentre il codice di esempio precedente limita gli utenti a caricare i checkpoint supportati dall\u2019architettura CamemBERT, usare le classi "),j=u("code"),S=l("TFAuto*"),T=l(" rende facile il passaggio da un checkpoint ad un altro:"),g=k(),N(h.$$.fragment),this.h()},l(a){H(i.$$.fragment,a),c=_(a),s=d(a,"P",{});var p=b(s);$=n(p,"Tuttavia, noi consigliamo di usare le "),f=d(p,"A",{href:!0,rel:!0});var A=b(f);w=n(A,"classi "),x=d(A,"CODE",{});var L=b(x);E=n(L,"TFAuto*"),L.forEach(t),A.forEach(t),D=n(p," quando possibile, poich\xE9 sono progettate per essere agnostiche rispetto al tipo di architettura del modello. Mentre il codice di esempio precedente limita gli utenti a caricare i checkpoint supportati dall\u2019architettura CamemBERT, usare le classi "),j=d(p,"CODE",{});var G=b(j);S=n(G,"TFAuto*"),G.forEach(t),T=n(p," rende facile il passaggio da un checkpoint ad un altro:"),p.forEach(t),g=_(a),H(h.$$.fragment,a),this.h()},h(){v(f,"href","https://huggingface.co/transformers/model_doc/auto.html?highlight=auto#auto-classes"),v(f,"rel","nofollow")},m(a,p){B(i,a,p),m(a,c,p),m(a,s,p),o(s,$),o(s,f),o(f,w),o(f,x),o(x,E),o(s,D),o(s,j),o(j,S),o(s,T),m(a,g,p),B(h,a,p),q=!0},i(a){q||(C(i.$$.fragment,a),C(h.$$.fragment,a),q=!0)},o(a){z(i.$$.fragment,a),z(h.$$.fragment,a),q=!1},d(a){I(i,a),a&&t(c),a&&t(s),a&&t(g),I(h,a)}}}function $t(M){let i,c,s,$,f,w,x,E,D,j,S,T,g,h,q;return i=new re({props:{code:"",highlighted:`<span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> CamembertTokenizer, CamembertForMaskedLM

tokenizer = CamembertTokenizer.from_pretrained(<span class="hljs-string">&quot;camembert-base&quot;</span>)
model = CamembertForMaskedLM.from_pretrained(<span class="hljs-string">&quot;camembert-base&quot;</span>)`}}),h=new re({props:{code:"",highlighted:`<span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> AutoTokenizer, AutoModelForMaskedLM

tokenizer = AutoTokenizer.from_pretrained(<span class="hljs-string">&quot;camembert-base&quot;</span>)
model = AutoModelForMaskedLM.from_pretrained(<span class="hljs-string">&quot;camembert-base&quot;</span>)`}}),{c(){N(i.$$.fragment),c=k(),s=u("p"),$=l("Tuttavia, noi consigliamo di usare le "),f=u("a"),w=l("classi "),x=u("code"),E=l("Auto*"),D=l(" quando possibile, poich\xE9 sono progettate per essere agnostiche rispetto al tipo di architettura del modello. Mentre il codice di esempio precedente limita gli utenti a caricare i checkpoint supportati dall\u2019architettura CamemBERT, usare le classi "),j=u("code"),S=l("Auto*"),T=l(" rende facile il passaggio da un checkpoint ad un altro:"),g=k(),N(h.$$.fragment),this.h()},l(a){H(i.$$.fragment,a),c=_(a),s=d(a,"P",{});var p=b(s);$=n(p,"Tuttavia, noi consigliamo di usare le "),f=d(p,"A",{href:!0,rel:!0});var A=b(f);w=n(A,"classi "),x=d(A,"CODE",{});var L=b(x);E=n(L,"Auto*"),L.forEach(t),A.forEach(t),D=n(p," quando possibile, poich\xE9 sono progettate per essere agnostiche rispetto al tipo di architettura del modello. Mentre il codice di esempio precedente limita gli utenti a caricare i checkpoint supportati dall\u2019architettura CamemBERT, usare le classi "),j=d(p,"CODE",{});var G=b(j);S=n(G,"Auto*"),G.forEach(t),T=n(p," rende facile il passaggio da un checkpoint ad un altro:"),p.forEach(t),g=_(a),H(h.$$.fragment,a),this.h()},h(){v(f,"href","https://huggingface.co/transformers/model_doc/auto.html?highlight=auto#auto-classes"),v(f,"rel","nofollow")},m(a,p){B(i,a,p),m(a,c,p),m(a,s,p),o(s,$),o(s,f),o(f,w),o(f,x),o(x,E),o(s,D),o(s,j),o(j,S),o(s,T),m(a,g,p),B(h,a,p),q=!0},i(a){q||(C(i.$$.fragment,a),C(h.$$.fragment,a),q=!0)},o(a){z(i.$$.fragment,a),z(h.$$.fragment,a),q=!1},d(a){I(i,a),a&&t(c),a&&t(s),a&&t(g),I(h,a)}}}function vt(M){let i;return{c(){i=l("Quando usate un modello pre-addestrato, assicuratevi di controllare come \xE8 stato addestrato, su quali dataset, i suoi limiti e i suoi bias. Tutte queste informazioni dovrebbero essere indicate sul cartellino del modello.")},l(c){i=n(c,"Quando usate un modello pre-addestrato, assicuratevi di controllare come \xE8 stato addestrato, su quali dataset, i suoi limiti e i suoi bias. Tutte queste informazioni dovrebbero essere indicate sul cartellino del modello.")},m(c,s){m(c,i,s)},d(c){c&&t(i)}}}function xt(M){let i,c,s,$,f,w,x,E,D,j,S,T,g,h,q,a,p,A,L,G,he,Q,J,Be,be,F,we,le,qe,Ee,ne,ze,Ce,ce,ye,Me,ge,K,ke,W,_e,y,Te,pe,Ae,Le,me,Fe,De,ue,Se,Pe,de,Oe,Ne,$e,X,Y,Ie,ve,se,He,xe,P,O,ae,R,je;s=new bt({props:{fw:M[0]}}),E=new ht({});const Ue=[kt,gt],Z=[];function Ge(e,r){return e[0]==="pt"?0:1}g=Ge(M),h=Z[g]=Ue[g](M),K=new re({props:{code:"",highlighted:`<span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> pipeline

camembert_fill_mask = pipeline(<span class="hljs-string">&quot;fill-mask&quot;</span>, model=<span class="hljs-string">&quot;camembert-base&quot;</span>)
results = camembert_fill_mask(<span class="hljs-string">&quot;Le camembert est &lt;mask&gt; :)&quot;</span>)`}}),W=new re({props:{code:`[
  {'sequence': 'Le camembert est d\xE9licieux :)', 'score': 0.49091005325317383, 'token': 7200, 'token_str': 'd\xE9licieux'}, 
  {'sequence': 'Le camembert est excellent :)', 'score': 0.1055697426199913, 'token': 2183, 'token_str': 'excellent'}, 
  {'sequence': 'Le camembert est succulent :)', 'score': 0.03453313186764717, 'token': 26202, 'token_str': 'succulent'}, 
  {'sequence': 'Le camembert est meilleur :)', 'score': 0.0330314114689827, 'token': 528, 'token_str': 'meilleur'}, 
  {'sequence': 'Le camembert est parfait :)', 'score': 0.03007650189101696, 'token': 1654, 'token_str': 'parfait'}
]`,highlighted:`[
  {<span class="hljs-string">&#x27;sequence&#x27;</span>: <span class="hljs-string">&#x27;Le camembert est d\xE9licieux :)&#x27;</span>, <span class="hljs-string">&#x27;score&#x27;</span>: <span class="hljs-number">0.49091005325317383</span>, <span class="hljs-string">&#x27;token&#x27;</span>: <span class="hljs-number">7200</span>, <span class="hljs-string">&#x27;token_str&#x27;</span>: <span class="hljs-string">&#x27;d\xE9licieux&#x27;</span>}, 
  {<span class="hljs-string">&#x27;sequence&#x27;</span>: <span class="hljs-string">&#x27;Le camembert est excellent :)&#x27;</span>, <span class="hljs-string">&#x27;score&#x27;</span>: <span class="hljs-number">0.1055697426199913</span>, <span class="hljs-string">&#x27;token&#x27;</span>: <span class="hljs-number">2183</span>, <span class="hljs-string">&#x27;token_str&#x27;</span>: <span class="hljs-string">&#x27;excellent&#x27;</span>}, 
  {<span class="hljs-string">&#x27;sequence&#x27;</span>: <span class="hljs-string">&#x27;Le camembert est succulent :)&#x27;</span>, <span class="hljs-string">&#x27;score&#x27;</span>: <span class="hljs-number">0.03453313186764717</span>, <span class="hljs-string">&#x27;token&#x27;</span>: <span class="hljs-number">26202</span>, <span class="hljs-string">&#x27;token_str&#x27;</span>: <span class="hljs-string">&#x27;succulent&#x27;</span>}, 
  {<span class="hljs-string">&#x27;sequence&#x27;</span>: <span class="hljs-string">&#x27;Le camembert est meilleur :)&#x27;</span>, <span class="hljs-string">&#x27;score&#x27;</span>: <span class="hljs-number">0.0330314114689827</span>, <span class="hljs-string">&#x27;token&#x27;</span>: <span class="hljs-number">528</span>, <span class="hljs-string">&#x27;token_str&#x27;</span>: <span class="hljs-string">&#x27;meilleur&#x27;</span>}, 
  {<span class="hljs-string">&#x27;sequence&#x27;</span>: <span class="hljs-string">&#x27;Le camembert est parfait :)&#x27;</span>, <span class="hljs-string">&#x27;score&#x27;</span>: <span class="hljs-number">0.03007650189101696</span>, <span class="hljs-string">&#x27;token&#x27;</span>: <span class="hljs-number">1654</span>, <span class="hljs-string">&#x27;token_str&#x27;</span>: <span class="hljs-string">&#x27;parfait&#x27;</span>}
]`}});const Re=[$t,_t],ee=[];function Ve(e,r){return e[0]==="pt"?0:1}return P=Ve(M),O=ee[P]=Re[P](M),R=new ft({props:{$$slots:{default:[vt]},$$scope:{ctx:M}}}),{c(){i=u("meta"),c=k(),N(s.$$.fragment),$=k(),f=u("h1"),w=u("a"),x=u("span"),N(E.$$.fragment),D=k(),j=u("span"),S=l("Usare modelli pre-addestrati"),T=k(),h.c(),q=k(),a=u("p"),p=l("Usando l\u2019Hub diventa molto facile selzionare il modello appropriato, cos\xEC da poterlo usare in qualsiasi altro framework con solo poche righe di codice. Vediamo ora come usare un di questi modelli, e come contribuire allo sviluppo della comunit\xE0."),A=k(),L=u("p"),G=l("Ad esempio assumiamo di stare cercando un modello francese sviluppato per ricostruire token mancanti (mask filling)."),he=k(),Q=u("div"),J=u("img"),be=k(),F=u("p"),we=l("Selezioniamo il checkpoint "),le=u("code"),qe=l("camembert-base"),Ee=l(" per provarlo. L\u2019identificatore "),ne=u("code"),ze=l("camembert-base"),Ce=l(" \xE8 tutto quello che serve per inizializzarlo! Come si \xE8 visto in precedenti capitoli, \xE8 possibile istanziare il modello usando la funzione "),ce=u("code"),ye=l("pipeline()"),Me=l(":"),ge=k(),N(K.$$.fragment),ke=k(),N(W.$$.fragment),_e=k(),y=u("p"),Te=l("Come potete vedere, caricare un modello all\u2019interno di una pipeline \xE8 molto semplice. L\u2019unico elemento da tenere in considerazione \xE8 che il checkpoint scelto sia adatto all\u2019utilizzo che intendete farne. Ad esempio, noi abbiamo caricato il checkpoint "),pe=u("code"),Ae=l("camembert-base"),Le=l(" all\u2019interno del pipeline "),me=u("code"),Fe=l("fill-mask"),De=l(", che \xE8 corretto. Ma se dovessimo caricare questo checkpoint in un pipeline di classificazione del testo ("),ue=u("code"),Se=l("text-classification"),Pe=l("), i risultati non avrebbero senso perch\xE9 l\u2019head di "),de=u("code"),Oe=l("camembert-base"),Ne=l(" non \xE8 adatto per questo obiettivo! Si consiglia di usare il filtro per obiettivi nell\u2019interfaccia dell\u2019Hub di Hugging Face per selezionare il checkpoint appropriato:"),$e=k(),X=u("div"),Y=u("img"),ve=k(),se=u("p"),He=l("Potete anche istanziare il checkpoint usando direttamente l\u2019architettura del modello:"),xe=k(),O.c(),ae=k(),N(R.$$.fragment),this.h()},l(e){const r=ut('[data-svelte="svelte-1phssyn"]',document.head);i=d(r,"META",{name:!0,content:!0}),r.forEach(t),c=_(e),H(s.$$.fragment,e),$=_(e),f=d(e,"H1",{class:!0});var te=b(f);w=d(te,"A",{id:!0,class:!0,href:!0});var oe=b(w);x=d(oe,"SPAN",{});var ie=b(x);H(E.$$.fragment,ie),ie.forEach(t),oe.forEach(t),D=_(te),j=d(te,"SPAN",{});var fe=b(j);S=n(fe,"Usare modelli pre-addestrati"),fe.forEach(t),te.forEach(t),T=_(e),h.l(e),q=_(e),a=d(e,"P",{});var Qe=b(a);p=n(Qe,"Usando l\u2019Hub diventa molto facile selzionare il modello appropriato, cos\xEC da poterlo usare in qualsiasi altro framework con solo poche righe di codice. Vediamo ora come usare un di questi modelli, e come contribuire allo sviluppo della comunit\xE0."),Qe.forEach(t),A=_(e),L=d(e,"P",{});var Je=b(L);G=n(Je,"Ad esempio assumiamo di stare cercando un modello francese sviluppato per ricostruire token mancanti (mask filling)."),Je.forEach(t),he=_(e),Q=d(e,"DIV",{class:!0});var Ke=b(Q);J=d(Ke,"IMG",{src:!0,alt:!0,width:!0}),Ke.forEach(t),be=_(e),F=d(e,"P",{});var V=b(F);we=n(V,"Selezioniamo il checkpoint "),le=d(V,"CODE",{});var We=b(le);qe=n(We,"camembert-base"),We.forEach(t),Ee=n(V," per provarlo. L\u2019identificatore "),ne=d(V,"CODE",{});var Xe=b(ne);ze=n(Xe,"camembert-base"),Xe.forEach(t),Ce=n(V," \xE8 tutto quello che serve per inizializzarlo! Come si \xE8 visto in precedenti capitoli, \xE8 possibile istanziare il modello usando la funzione "),ce=d(V,"CODE",{});var Ye=b(ce);ye=n(Ye,"pipeline()"),Ye.forEach(t),Me=n(V,":"),V.forEach(t),ge=_(e),H(K.$$.fragment,e),ke=_(e),H(W.$$.fragment,e),_e=_(e),y=d(e,"P",{});var U=b(y);Te=n(U,"Come potete vedere, caricare un modello all\u2019interno di una pipeline \xE8 molto semplice. L\u2019unico elemento da tenere in considerazione \xE8 che il checkpoint scelto sia adatto all\u2019utilizzo che intendete farne. Ad esempio, noi abbiamo caricato il checkpoint "),pe=d(U,"CODE",{});var Ze=b(pe);Ae=n(Ze,"camembert-base"),Ze.forEach(t),Le=n(U," all\u2019interno del pipeline "),me=d(U,"CODE",{});var et=b(me);Fe=n(et,"fill-mask"),et.forEach(t),De=n(U,", che \xE8 corretto. Ma se dovessimo caricare questo checkpoint in un pipeline di classificazione del testo ("),ue=d(U,"CODE",{});var tt=b(ue);Se=n(tt,"text-classification"),tt.forEach(t),Pe=n(U,"), i risultati non avrebbero senso perch\xE9 l\u2019head di "),de=d(U,"CODE",{});var st=b(de);Oe=n(st,"camembert-base"),st.forEach(t),Ne=n(U," non \xE8 adatto per questo obiettivo! Si consiglia di usare il filtro per obiettivi nell\u2019interfaccia dell\u2019Hub di Hugging Face per selezionare il checkpoint appropriato:"),U.forEach(t),$e=_(e),X=d(e,"DIV",{class:!0});var at=b(X);Y=d(at,"IMG",{src:!0,alt:!0,width:!0}),at.forEach(t),ve=_(e),se=d(e,"P",{});var ot=b(se);He=n(ot,"Potete anche istanziare il checkpoint usando direttamente l\u2019architettura del modello:"),ot.forEach(t),xe=_(e),O.l(e),ae=_(e),H(R.$$.fragment,e),this.h()},h(){v(i,"name","hf:doc:metadata"),v(i,"content",JSON.stringify(jt)),v(w,"id","usare-modelli-preaddestrati"),v(w,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),v(w,"href","#usare-modelli-preaddestrati"),v(f,"class","relative group"),it(J.src,Be="https://huggingface.co/datasets/huggingface-course/documentation-images/resolve/main/en/chapter4/camembert.gif")||v(J,"src",Be),v(J,"alt","Selecting the Camembert model."),v(J,"width","80%"),v(Q,"class","flex justify-center"),it(Y.src,Ie="https://huggingface.co/datasets/huggingface-course/documentation-images/resolve/main/en/chapter4/tasks.png")||v(Y,"src",Ie),v(Y,"alt","The task selector on the web interface."),v(Y,"width","80%"),v(X,"class","flex justify-center")},m(e,r){o(document.head,i),m(e,c,r),B(s,e,r),m(e,$,r),m(e,f,r),o(f,w),o(w,x),B(E,x,null),o(f,D),o(f,j),o(j,S),m(e,T,r),Z[g].m(e,r),m(e,q,r),m(e,a,r),o(a,p),m(e,A,r),m(e,L,r),o(L,G),m(e,he,r),m(e,Q,r),o(Q,J),m(e,be,r),m(e,F,r),o(F,we),o(F,le),o(le,qe),o(F,Ee),o(F,ne),o(ne,ze),o(F,Ce),o(F,ce),o(ce,ye),o(F,Me),m(e,ge,r),B(K,e,r),m(e,ke,r),B(W,e,r),m(e,_e,r),m(e,y,r),o(y,Te),o(y,pe),o(pe,Ae),o(y,Le),o(y,me),o(me,Fe),o(y,De),o(y,ue),o(ue,Se),o(y,Pe),o(y,de),o(de,Oe),o(y,Ne),m(e,$e,r),m(e,X,r),o(X,Y),m(e,ve,r),m(e,se,r),o(se,He),m(e,xe,r),ee[P].m(e,r),m(e,ae,r),B(R,e,r),je=!0},p(e,[r]){const te={};r&1&&(te.fw=e[0]),s.$set(te);let oe=g;g=Ge(e),g!==oe&&(lt(),z(Z[oe],1,1,()=>{Z[oe]=null}),rt(),h=Z[g],h||(h=Z[g]=Ue[g](e),h.c()),C(h,1),h.m(q.parentNode,q));let ie=P;P=Ve(e),P!==ie&&(lt(),z(ee[ie],1,1,()=>{ee[ie]=null}),rt(),O=ee[P],O||(O=ee[P]=Re[P](e),O.c()),C(O,1),O.m(ae.parentNode,ae));const fe={};r&2&&(fe.$$scope={dirty:r,ctx:e}),R.$set(fe)},i(e){je||(C(s.$$.fragment,e),C(E.$$.fragment,e),C(h),C(K.$$.fragment,e),C(W.$$.fragment,e),C(O),C(R.$$.fragment,e),je=!0)},o(e){z(s.$$.fragment,e),z(E.$$.fragment,e),z(h),z(K.$$.fragment,e),z(W.$$.fragment,e),z(O),z(R.$$.fragment,e),je=!1},d(e){t(i),e&&t(c),I(s,e),e&&t($),e&&t(f),I(E),e&&t(T),Z[g].d(e),e&&t(q),e&&t(a),e&&t(A),e&&t(L),e&&t(he),e&&t(Q),e&&t(be),e&&t(F),e&&t(ge),I(K,e),e&&t(ke),I(W,e),e&&t(_e),e&&t(y),e&&t($e),e&&t(X),e&&t(ve),e&&t(se),e&&t(xe),ee[P].d(e),e&&t(ae),I(R,e)}}}const jt={local:"usare-modelli-preaddestrati",title:"Usare modelli pre-addestrati"};function wt(M,i,c){let s="pt";return dt(()=>{const $=new URLSearchParams(window.location.search);c(0,s=$.get("fw")||"pt")}),[s]}class Mt extends ct{constructor(i){super();pt(this,i,wt,xt,mt,{})}}export{Mt as default,jt as metadata};
