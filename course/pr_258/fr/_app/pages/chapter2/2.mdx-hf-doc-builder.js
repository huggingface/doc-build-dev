import{S as Jp,i as Up,s as Bp,e as o,k as d,w as y,t as r,M as Rp,c as i,d as t,m as f,x,a as u,h as a,b as k,N as rr,G as s,g as m,y as P,o as b,p as ge,q as $,B as T,v as Qp,n as ke}from"../../chunks/vendor-hf-doc-builder.js";import{T as Vp}from"../../chunks/Tip-hf-doc-builder.js";import{Y as Gp}from"../../chunks/Youtube-hf-doc-builder.js";import{I as kt}from"../../chunks/IconCopyLink-hf-doc-builder.js";import{C as I}from"../../chunks/CodeBlock-hf-doc-builder.js";import{D as Hp}from"../../chunks/DocNotebookDropdown-hf-doc-builder.js";import{F as Yp}from"../../chunks/FrameworkSwitchCourse-hf-doc-builder.js";function Wp(E){let n,c;return n=new Hp({props:{classNames:"absolute z-10 right-0 top-0",options:[{label:"Google Colab",value:"https://colab.research.google.com/github/huggingface/notebooks/blob/master/course/chapter2/section2_tf.ipynb"},{label:"Aws Studio",value:"https://studiolab.sagemaker.aws/import/github/huggingface/notebooks/blob/master/course/chapter2/section2_tf.ipynb"}]}}),{c(){y(n.$$.fragment)},l(l){x(n.$$.fragment,l)},m(l,h){P(n,l,h),c=!0},i(l){c||($(n.$$.fragment,l),c=!0)},o(l){b(n.$$.fragment,l),c=!1},d(l){T(n,l)}}}function Xp(E){let n,c;return n=new Hp({props:{classNames:"absolute z-10 right-0 top-0",options:[{label:"Google Colab",value:"https://colab.research.google.com/github/huggingface/notebooks/blob/master/course/chapter2/section2_pt.ipynb"},{label:"Aws Studio",value:"https://studiolab.sagemaker.aws/import/github/huggingface/notebooks/blob/master/course/chapter2/section2_pt.ipynb"}]}}),{c(){y(n.$$.fragment)},l(l){x(n.$$.fragment,l)},m(l,h){P(n,l,h),c=!0},i(l){c||($(n.$$.fragment,l),c=!0)},o(l){b(n.$$.fragment,l),c=!1},d(l){T(n,l)}}}function Kp(E){let n;return{c(){n=r("Il s'agit de la premi\xE8re section dont le contenu est l\xE9g\xE8rement diff\xE9rent selon que vous utilisez PyTorch ou TensorFlow. Cliquez sur le bouton situ\xE9 au-dessus du titre pour s\xE9lectionner la plateforme que vous pr\xE9f\xE9rez !")},l(c){n=a(c,"Il s'agit de la premi\xE8re section dont le contenu est l\xE9g\xE8rement diff\xE9rent selon que vous utilisez PyTorch ou TensorFlow. Cliquez sur le bouton situ\xE9 au-dessus du titre pour s\xE9lectionner la plateforme que vous pr\xE9f\xE9rez !")},m(c,l){m(c,n,l)},d(c){c&&t(n)}}}function Zp(E){let n,c;return n=new Gp({props:{id:"wVN12smEvqg"}}),{c(){y(n.$$.fragment)},l(l){x(n.$$.fragment,l)},m(l,h){P(n,l,h),c=!0},i(l){c||($(n.$$.fragment,l),c=!0)},o(l){b(n.$$.fragment,l),c=!1},d(l){T(n,l)}}}function ec(E){let n,c;return n=new Gp({props:{id:"1pedAIvTWXk"}}),{c(){y(n.$$.fragment)},l(l){x(n.$$.fragment,l)},m(l,h){P(n,l,h),c=!0},i(l){c||($(n.$$.fragment,l),c=!0)},o(l){b(n.$$.fragment,l),c=!1},d(l){T(n,l)}}}function sc(E){let n,c;return n=new I({props:{code:`raw_inputs = [
    "I've been waiting for a HuggingFace course my whole life.",
    # J'ai attendu un cours de HuggingFace toute ma vie.
    "I hate this so much!",  # Je d\xE9teste tellement \xE7a !
]
inputs = tokenizer(raw_inputs, padding=True, truncation=True, return_tensors="tf")
print(inputs)`,highlighted:`raw_inputs = [
    <span class="hljs-string">&quot;I&#x27;ve been waiting for a HuggingFace course my whole life.&quot;</span>,
    <span class="hljs-comment"># J&#x27;ai attendu un cours de HuggingFace toute ma vie.</span>
    <span class="hljs-string">&quot;I hate this so much!&quot;</span>,  <span class="hljs-comment"># Je d\xE9teste tellement \xE7a !</span>
]
inputs = tokenizer(raw_inputs, padding=<span class="hljs-literal">True</span>, truncation=<span class="hljs-literal">True</span>, return_tensors=<span class="hljs-string">&quot;tf&quot;</span>)
<span class="hljs-built_in">print</span>(inputs)`}}),{c(){y(n.$$.fragment)},l(l){x(n.$$.fragment,l)},m(l,h){P(n,l,h),c=!0},i(l){c||($(n.$$.fragment,l),c=!0)},o(l){b(n.$$.fragment,l),c=!1},d(l){T(n,l)}}}function tc(E){let n,c;return n=new I({props:{code:`raw_inputs = [
    "I've been waiting for a HuggingFace course my whole life.",
    # J'ai attendu un cours de HuggingFace toute ma vie.
    "I hate this so much!",  # Je d\xE9teste tellement \xE7a !
]
inputs = tokenizer(raw_inputs, padding=True, truncation=True, return_tensors="pt")
print(inputs)`,highlighted:`raw_inputs = [
    <span class="hljs-string">&quot;I&#x27;ve been waiting for a HuggingFace course my whole life.&quot;</span>,
    <span class="hljs-comment"># J&#x27;ai attendu un cours de HuggingFace toute ma vie.</span>
    <span class="hljs-string">&quot;I hate this so much!&quot;</span>,  <span class="hljs-comment"># Je d\xE9teste tellement \xE7a !</span>
]
inputs = tokenizer(raw_inputs, padding=<span class="hljs-literal">True</span>, truncation=<span class="hljs-literal">True</span>, return_tensors=<span class="hljs-string">&quot;pt&quot;</span>)
<span class="hljs-built_in">print</span>(inputs)`}}),{c(){y(n.$$.fragment)},l(l){x(n.$$.fragment,l)},m(l,h){P(n,l,h),c=!0},i(l){c||($(n.$$.fragment,l),c=!0)},o(l){b(n.$$.fragment,l),c=!1},d(l){T(n,l)}}}function nc(E){let n,c,l,h,v;return h=new I({props:{code:`{
    'input_ids': <tf.Tensor: shape=(2, 16), dtype=int32, numpy=
        array([
            [  101,  1045,  1005,  2310,  2042,  3403,  2005,  1037, 17662, 12172,  2607,  2026,  2878,  2166,  1012,   102],
            [  101,  1045,  5223,  2023,  2061,  2172,   999,   102,     0,     0,     0,     0,     0,     0,     0,     0]
        ], dtype=int32)>, 
    'attention_mask': <tf.Tensor: shape=(2, 16), dtype=int32, numpy=
        array([
            [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
            [1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0]
        ], dtype=int32)>
}`,highlighted:`{
    <span class="hljs-string">&#x27;input_ids&#x27;</span>: &lt;tf.Tensor: shape=(<span class="hljs-number">2</span>, <span class="hljs-number">16</span>), dtype=int32, numpy=
        array([
            [  <span class="hljs-number">101</span>,  <span class="hljs-number">1045</span>,  <span class="hljs-number">1005</span>,  <span class="hljs-number">2310</span>,  <span class="hljs-number">2042</span>,  <span class="hljs-number">3403</span>,  <span class="hljs-number">2005</span>,  <span class="hljs-number">1037</span>, <span class="hljs-number">17662</span>, <span class="hljs-number">12172</span>,  <span class="hljs-number">2607</span>,  <span class="hljs-number">2026</span>,  <span class="hljs-number">2878</span>,  <span class="hljs-number">2166</span>,  <span class="hljs-number">1012</span>,   <span class="hljs-number">102</span>],
            [  <span class="hljs-number">101</span>,  <span class="hljs-number">1045</span>,  <span class="hljs-number">5223</span>,  <span class="hljs-number">2023</span>,  <span class="hljs-number">2061</span>,  <span class="hljs-number">2172</span>,   <span class="hljs-number">999</span>,   <span class="hljs-number">102</span>,     <span class="hljs-number">0</span>,     <span class="hljs-number">0</span>,     <span class="hljs-number">0</span>,     <span class="hljs-number">0</span>,     <span class="hljs-number">0</span>,     <span class="hljs-number">0</span>,     <span class="hljs-number">0</span>,     <span class="hljs-number">0</span>]
        ], dtype=int32)&gt;, 
    <span class="hljs-string">&#x27;attention_mask&#x27;</span>: &lt;tf.Tensor: shape=(<span class="hljs-number">2</span>, <span class="hljs-number">16</span>), dtype=int32, numpy=
        array([
            [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>],
            [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>]
        ], dtype=int32)&gt;
}`}}),{c(){n=o("p"),c=r("Voici \xE0 quoi ressemblent les r\xE9sultats sous forme de tenseurs TensorFlow :"),l=d(),y(h.$$.fragment)},l(_){n=i(_,"P",{});var M=u(n);c=a(M,"Voici \xE0 quoi ressemblent les r\xE9sultats sous forme de tenseurs TensorFlow :"),M.forEach(t),l=f(_),x(h.$$.fragment,_)},m(_,M){m(_,n,M),s(n,c),m(_,l,M),P(h,_,M),v=!0},i(_){v||($(h.$$.fragment,_),v=!0)},o(_){b(h.$$.fragment,_),v=!1},d(_){_&&t(n),_&&t(l),T(h,_)}}}function lc(E){let n,c,l,h,v;return h=new I({props:{code:`{
    'input_ids': tensor([
        [  101,  1045,  1005,  2310,  2042,  3403,  2005,  1037, 17662, 12172, 2607,  2026,  2878,  2166,  1012,   102],
        [  101,  1045,  5223,  2023,  2061,  2172,   999,   102,     0,     0,     0,     0,     0,     0,     0,     0]
    ]), 
    'attention_mask': tensor([
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
        [1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0]
    ])
}`,highlighted:`{
    <span class="hljs-string">&#x27;input_ids&#x27;</span>: tensor([
        [  <span class="hljs-number">101</span>,  <span class="hljs-number">1045</span>,  <span class="hljs-number">1005</span>,  <span class="hljs-number">2310</span>,  <span class="hljs-number">2042</span>,  <span class="hljs-number">3403</span>,  <span class="hljs-number">2005</span>,  <span class="hljs-number">1037</span>, <span class="hljs-number">17662</span>, <span class="hljs-number">12172</span>, <span class="hljs-number">2607</span>,  <span class="hljs-number">2026</span>,  <span class="hljs-number">2878</span>,  <span class="hljs-number">2166</span>,  <span class="hljs-number">1012</span>,   <span class="hljs-number">102</span>],
        [  <span class="hljs-number">101</span>,  <span class="hljs-number">1045</span>,  <span class="hljs-number">5223</span>,  <span class="hljs-number">2023</span>,  <span class="hljs-number">2061</span>,  <span class="hljs-number">2172</span>,   <span class="hljs-number">999</span>,   <span class="hljs-number">102</span>,     <span class="hljs-number">0</span>,     <span class="hljs-number">0</span>,     <span class="hljs-number">0</span>,     <span class="hljs-number">0</span>,     <span class="hljs-number">0</span>,     <span class="hljs-number">0</span>,     <span class="hljs-number">0</span>,     <span class="hljs-number">0</span>]
    ]), 
    <span class="hljs-string">&#x27;attention_mask&#x27;</span>: tensor([
        [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>],
        [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>]
    ])
}`}}),{c(){n=o("p"),c=r("Voici \xE0 quoi ressemblent les r\xE9sultats sous forme de tenseurs PyTorch :"),l=d(),y(h.$$.fragment)},l(_){n=i(_,"P",{});var M=u(n);c=a(M,"Voici \xE0 quoi ressemblent les r\xE9sultats sous forme de tenseurs PyTorch :"),M.forEach(t),l=f(_),x(h.$$.fragment,_)},m(_,M){m(_,n,M),s(n,c),m(_,l,M),P(h,_,M),v=!0},i(_){v||($(h.$$.fragment,_),v=!0)},o(_){b(h.$$.fragment,_),v=!1},d(_){_&&t(n),_&&t(l),T(h,_)}}}function rc(E){let n,c,l,h,v,_,M,N,C,z,D,g,q,A,L,S,U;return S=new I({props:{code:"",highlighted:`<span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> TFAutoModel

checkpoint = <span class="hljs-string">&quot;distilbert-base-uncased-finetuned-sst-2-english&quot;</span>
model = TFAutoModel.from_pretrained(checkpoint)`}}),{c(){n=o("p"),c=r("Nous pouvons t\xE9l\xE9charger notre mod\xE8le pr\xE9tra\xEEn\xE9 de la m\xEAme mani\xE8re que nous l\u2019avons fait avec notre "),l=o("em"),h=r("tokenizer"),v=r(". \u{1F917} "),_=o("em"),M=r("Transformers"),N=r(" fournit une classe "),C=o("code"),z=r("TFAutoModel"),D=r(" qui poss\xE8de \xE9galement une m\xE9thode "),g=o("code"),q=r("from_pretrained()"),A=r(" :"),L=d(),y(S.$$.fragment)},l(j){n=i(j,"P",{});var w=u(n);c=a(w,"Nous pouvons t\xE9l\xE9charger notre mod\xE8le pr\xE9tra\xEEn\xE9 de la m\xEAme mani\xE8re que nous l\u2019avons fait avec notre "),l=i(w,"EM",{});var X=u(l);h=a(X,"tokenizer"),X.forEach(t),v=a(w,". \u{1F917} "),_=i(w,"EM",{});var B=u(_);M=a(B,"Transformers"),B.forEach(t),N=a(w," fournit une classe "),C=i(w,"CODE",{});var ze=u(C);z=a(ze,"TFAutoModel"),ze.forEach(t),D=a(w," qui poss\xE8de \xE9galement une m\xE9thode "),g=i(w,"CODE",{});var K=u(g);q=a(K,"from_pretrained()"),K.forEach(t),A=a(w," :"),w.forEach(t),L=f(j),x(S.$$.fragment,j)},m(j,w){m(j,n,w),s(n,c),s(n,l),s(l,h),s(n,v),s(n,_),s(_,M),s(n,N),s(n,C),s(C,z),s(n,D),s(n,g),s(g,q),s(n,A),m(j,L,w),P(S,j,w),U=!0},i(j){U||($(S.$$.fragment,j),U=!0)},o(j){b(S.$$.fragment,j),U=!1},d(j){j&&t(n),j&&t(L),T(S,j)}}}function ac(E){let n,c,l,h,v,_,M,N,C,z,D,g,q,A,L,S,U;return S=new I({props:{code:"",highlighted:`<span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> AutoModel

checkpoint = <span class="hljs-string">&quot;distilbert-base-uncased-finetuned-sst-2-english&quot;</span>
model = AutoModel.from_pretrained(checkpoint)`}}),{c(){n=o("p"),c=r("Nous pouvons t\xE9l\xE9charger notre mod\xE8le pr\xE9-entra\xEEn\xE9 de la m\xEAme mani\xE8re que nous l\u2019avons fait avec notre "),l=o("em"),h=r("tokenizer"),v=r(". \u{1F917} "),_=o("em"),M=r("Transformers"),N=r(" fournit une classe "),C=o("code"),z=r("AutoModel"),D=r(" qui poss\xE8de \xE9galement une m\xE9thode "),g=o("code"),q=r("from_pretrained()"),A=r(" :"),L=d(),y(S.$$.fragment)},l(j){n=i(j,"P",{});var w=u(n);c=a(w,"Nous pouvons t\xE9l\xE9charger notre mod\xE8le pr\xE9-entra\xEEn\xE9 de la m\xEAme mani\xE8re que nous l\u2019avons fait avec notre "),l=i(w,"EM",{});var X=u(l);h=a(X,"tokenizer"),X.forEach(t),v=a(w,". \u{1F917} "),_=i(w,"EM",{});var B=u(_);M=a(B,"Transformers"),B.forEach(t),N=a(w," fournit une classe "),C=i(w,"CODE",{});var ze=u(C);z=a(ze,"AutoModel"),ze.forEach(t),D=a(w," qui poss\xE8de \xE9galement une m\xE9thode "),g=i(w,"CODE",{});var K=u(g);q=a(K,"from_pretrained()"),K.forEach(t),A=a(w," :"),w.forEach(t),L=f(j),x(S.$$.fragment,j)},m(j,w){m(j,n,w),s(n,c),s(n,l),s(l,h),s(n,v),s(n,_),s(_,M),s(n,N),s(n,C),s(C,z),s(n,D),s(n,g),s(g,q),s(n,A),m(j,L,w),P(S,j,w),U=!0},i(j){U||($(S.$$.fragment,j),U=!0)},o(j){b(S.$$.fragment,j),U=!1},d(j){j&&t(n),j&&t(L),T(S,j)}}}function oc(E){let n,c,l,h;return n=new I({props:{code:`outputs = model(inputs)
print(outputs.last_hidden_state.shape)`,highlighted:`outputs = model(inputs)
<span class="hljs-built_in">print</span>(outputs.last_hidden_state.shape)`}}),l=new I({props:{code:"(2, 16, 768)",highlighted:'(<span class="hljs-number">2</span>, <span class="hljs-number">16</span>, <span class="hljs-number">768</span>)'}}),{c(){y(n.$$.fragment),c=d(),y(l.$$.fragment)},l(v){x(n.$$.fragment,v),c=f(v),x(l.$$.fragment,v)},m(v,_){P(n,v,_),m(v,c,_),P(l,v,_),h=!0},i(v){h||($(n.$$.fragment,v),$(l.$$.fragment,v),h=!0)},o(v){b(n.$$.fragment,v),b(l.$$.fragment,v),h=!1},d(v){T(n,v),v&&t(c),T(l,v)}}}function ic(E){let n,c,l,h;return n=new I({props:{code:`outputs = model(**inputs)
print(outputs.last_hidden_state.shape)`,highlighted:`outputs = model(**inputs)
<span class="hljs-built_in">print</span>(outputs.last_hidden_state.shape)`}}),l=new I({props:{code:"torch.Size([2, 16, 768])",highlighted:'torch.Size([<span class="hljs-number">2</span>, <span class="hljs-number">16</span>, <span class="hljs-number">768</span>])'}}),{c(){y(n.$$.fragment),c=d(),y(l.$$.fragment)},l(v){x(n.$$.fragment,v),c=f(v),x(l.$$.fragment,v)},m(v,_){P(n,v,_),m(v,c,_),P(l,v,_),h=!0},i(v){h||($(n.$$.fragment,v),$(l.$$.fragment,v),h=!0)},o(v){b(n.$$.fragment,v),b(l.$$.fragment,v),h=!1},d(v){T(n,v),v&&t(c),T(l,v)}}}function uc(E){let n,c,l,h,v,_,M,N,C,z,D;return z=new I({props:{code:"",highlighted:`<span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> TFAutoModelForSequenceClassification

checkpoint = <span class="hljs-string">&quot;distilbert-base-uncased-finetuned-sst-2-english&quot;</span>
model = TFAutoModelForSequenceClassification.from_pretrained(checkpoint)
outputs = model(inputs)`}}),{c(){n=o("p"),c=r("Pour notre exemple, nous avons besoin d\u2019un mod\xE8le avec une t\xEAte de classification de s\xE9quence (pour pouvoir classer les phrases comme positives ou n\xE9gatives). Donc, nous n\u2019utilisons pas r\xE9ellement la classe "),l=o("code"),h=r("TFAutoModel"),v=r(" mais plut\xF4t "),_=o("code"),M=r("TFAutoModelForSequenceClassification"),N=r(" :"),C=d(),y(z.$$.fragment)},l(g){n=i(g,"P",{});var q=u(n);c=a(q,"Pour notre exemple, nous avons besoin d\u2019un mod\xE8le avec une t\xEAte de classification de s\xE9quence (pour pouvoir classer les phrases comme positives ou n\xE9gatives). Donc, nous n\u2019utilisons pas r\xE9ellement la classe "),l=i(q,"CODE",{});var A=u(l);h=a(A,"TFAutoModel"),A.forEach(t),v=a(q," mais plut\xF4t "),_=i(q,"CODE",{});var L=u(_);M=a(L,"TFAutoModelForSequenceClassification"),L.forEach(t),N=a(q," :"),q.forEach(t),C=f(g),x(z.$$.fragment,g)},m(g,q){m(g,n,q),s(n,c),s(n,l),s(l,h),s(n,v),s(n,_),s(_,M),s(n,N),m(g,C,q),P(z,g,q),D=!0},i(g){D||($(z.$$.fragment,g),D=!0)},o(g){b(z.$$.fragment,g),D=!1},d(g){g&&t(n),g&&t(C),T(z,g)}}}function pc(E){let n,c,l,h,v,_,M,N,C,z,D;return z=new I({props:{code:"",highlighted:`<span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> AutoModelForSequenceClassification

checkpoint = <span class="hljs-string">&quot;distilbert-base-uncased-finetuned-sst-2-english&quot;</span>
model = AutoModelForSequenceClassification.from_pretrained(checkpoint)
outputs = model(**inputs)`}}),{c(){n=o("p"),c=r("Pour notre exemple, nous avons besoin d\u2019un mod\xE8le avec une t\xEAte de classification de s\xE9quence (pour pouvoir classer les phrases comme positives ou n\xE9gatives). Donc, nous n\u2019utilisons pas r\xE9ellement la classe "),l=o("code"),h=r("AutoModel"),v=r(" mais plut\xF4t "),_=o("code"),M=r("AutoModelForSequenceClassification"),N=r(" :"),C=d(),y(z.$$.fragment)},l(g){n=i(g,"P",{});var q=u(n);c=a(q,"Pour notre exemple, nous avons besoin d\u2019un mod\xE8le avec une t\xEAte de classification de s\xE9quence (pour pouvoir classer les phrases comme positives ou n\xE9gatives). Donc, nous n\u2019utilisons pas r\xE9ellement la classe "),l=i(q,"CODE",{});var A=u(l);h=a(A,"AutoModel"),A.forEach(t),v=a(q," mais plut\xF4t "),_=i(q,"CODE",{});var L=u(_);M=a(L,"AutoModelForSequenceClassification"),L.forEach(t),N=a(q," :"),q.forEach(t),C=f(g),x(z.$$.fragment,g)},m(g,q){m(g,n,q),s(n,c),s(n,l),s(l,h),s(n,v),s(n,_),s(_,M),s(n,N),m(g,C,q),P(z,g,q),D=!0},i(g){D||($(z.$$.fragment,g),D=!0)},o(g){b(z.$$.fragment,g),D=!1},d(g){g&&t(n),g&&t(C),T(z,g)}}}function cc(E){let n,c;return n=new I({props:{code:"(2, 2)",highlighted:'(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>)'}}),{c(){y(n.$$.fragment)},l(l){x(n.$$.fragment,l)},m(l,h){P(n,l,h),c=!0},i(l){c||($(n.$$.fragment,l),c=!0)},o(l){b(n.$$.fragment,l),c=!1},d(l){T(n,l)}}}function mc(E){let n,c;return n=new I({props:{code:"torch.Size([2, 2])",highlighted:'torch.Size([<span class="hljs-number">2</span>, <span class="hljs-number">2</span>])'}}),{c(){y(n.$$.fragment)},l(l){x(n.$$.fragment,l)},m(l,h){P(n,l,h),c=!0},i(l){c||($(n.$$.fragment,l),c=!0)},o(l){b(n.$$.fragment,l),c=!1},d(l){T(n,l)}}}function dc(E){let n,c;return n=new I({props:{code:`<tf.Tensor: shape=(2, 2), dtype=float32, numpy=
    array([[-1.5606991,  1.6122842],
           [ 4.169231 , -3.3464472]], dtype=float32)>`,highlighted:`&lt;tf.Tensor: shape=(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>), dtype=float32, numpy=
    array([[-<span class="hljs-number">1.5606991</span>,  <span class="hljs-number">1.6122842</span>],
           [ <span class="hljs-number">4.169231</span> , -<span class="hljs-number">3.3464472</span>]], dtype=float32)&gt;`}}),{c(){y(n.$$.fragment)},l(l){x(n.$$.fragment,l)},m(l,h){P(n,l,h),c=!0},i(l){c||($(n.$$.fragment,l),c=!0)},o(l){b(n.$$.fragment,l),c=!1},d(l){T(n,l)}}}function fc(E){let n,c;return n=new I({props:{code:`tensor([[-1.5607,  1.6123],
        [ 4.1692, -3.3464]], grad_fn=<AddmmBackward>)`,highlighted:`tensor([[-<span class="hljs-number">1.5607</span>,  <span class="hljs-number">1.6123</span>],
        [ <span class="hljs-number">4.1692</span>, -<span class="hljs-number">3.3464</span>]], grad_fn=&lt;AddmmBackward&gt;)`}}),{c(){y(n.$$.fragment)},l(l){x(n.$$.fragment,l)},m(l,h){P(n,l,h),c=!0},i(l){c||($(n.$$.fragment,l),c=!0)},o(l){b(n.$$.fragment,l),c=!1},d(l){T(n,l)}}}function hc(E){let n,c;return n=new I({props:{code:"",highlighted:`<span class="hljs-keyword">import</span> tensorflow <span class="hljs-keyword">as</span> tf

predictions = tf.math.softmax(outputs.logits, axis=-<span class="hljs-number">1</span>)
<span class="hljs-built_in">print</span>(predictions)`}}),{c(){y(n.$$.fragment)},l(l){x(n.$$.fragment,l)},m(l,h){P(n,l,h),c=!0},i(l){c||($(n.$$.fragment,l),c=!0)},o(l){b(n.$$.fragment,l),c=!1},d(l){T(n,l)}}}function _c(E){let n,c;return n=new I({props:{code:"",highlighted:`<span class="hljs-keyword">import</span> torch

predictions = torch.nn.functional.softmax(outputs.logits, dim=-<span class="hljs-number">1</span>)
<span class="hljs-built_in">print</span>(predictions)`}}),{c(){y(n.$$.fragment)},l(l){x(n.$$.fragment,l)},m(l,h){P(n,l,h),c=!0},i(l){c||($(n.$$.fragment,l),c=!0)},o(l){b(n.$$.fragment,l),c=!1},d(l){T(n,l)}}}function vc(E){let n,c;return n=new I({props:{code:`tf.Tensor(
[[4.01951671e-02 9.59804833e-01]
 [9.9945587e-01 5.4418424e-04]], shape=(2, 2), dtype=float32)`,highlighted:`tf.Tensor(
[[<span class="hljs-number">4.01951671e-02</span> <span class="hljs-number">9.59804833e-01</span>]
 [<span class="hljs-number">9.9945587e-01</span> <span class="hljs-number">5.4418424e-04</span>]], shape=(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>), dtype=float32)`}}),{c(){y(n.$$.fragment)},l(l){x(n.$$.fragment,l)},m(l,h){P(n,l,h),c=!0},i(l){c||($(n.$$.fragment,l),c=!0)},o(l){b(n.$$.fragment,l),c=!1},d(l){T(n,l)}}}function bc(E){let n,c;return n=new I({props:{code:`tensor([[4.0195e-02, 9.5980e-01],
        [9.9946e-01, 5.4418e-04]], grad_fn=<SoftmaxBackward>)`,highlighted:`tensor([[<span class="hljs-number">4.0195e-02</span>, <span class="hljs-number">9.5980e-01</span>],
        [<span class="hljs-number">9.9946e-01</span>, <span class="hljs-number">5.4418e-04</span>]], grad_fn=&lt;SoftmaxBackward&gt;)`}}),{c(){y(n.$$.fragment)},l(l){x(n.$$.fragment,l)},m(l,h){P(n,l,h),c=!0},i(l){c||($(n.$$.fragment,l),c=!0)},o(l){b(n.$$.fragment,l),c=!1},d(l){T(n,l)}}}function $c(E){let n,c,l,h,v,_,M,N;return{c(){n=o("p"),c=r("\u270F\uFE0F "),l=o("strong"),h=r("Essayez !"),v=r(" Choisissez deux (ou plus) textes de votre choix (en anglais) et faites-les passer par le pipeline "),_=o("code"),M=r("sentiment-analysis"),N=r(". Reproduisez ensuite vous-m\xEAme les \xE9tapes vues ici et v\xE9rifiez que vous obtenez les m\xEAmes r\xE9sultats !")},l(C){n=i(C,"P",{});var z=u(n);c=a(z,"\u270F\uFE0F "),l=i(z,"STRONG",{});var D=u(l);h=a(D,"Essayez !"),D.forEach(t),v=a(z," Choisissez deux (ou plus) textes de votre choix (en anglais) et faites-les passer par le pipeline "),_=i(z,"CODE",{});var g=u(_);M=a(g,"sentiment-analysis"),g.forEach(t),N=a(z,". Reproduisez ensuite vous-m\xEAme les \xE9tapes vues ici et v\xE9rifiez que vous obtenez les m\xEAmes r\xE9sultats !"),z.forEach(t)},m(C,z){m(C,n,z),s(n,c),s(n,l),s(l,h),s(n,v),s(n,_),s(_,M),s(n,N)},d(C){C&&t(n)}}}function Ec(E){let n,c,l,h,v,_,M,N,C,z,D,g,q,A,L,S,U,j,w,X,B,ze,K,ar,or,Wn,rs,Xn,Ls,ir,Kn,as,Zn,Fe,ur,Fs,pr,cr,el,Ce,os,zi,mr,is,Ci,sl,Os,dr,tl,Ne,Oe,jt,us,fr,Vs,hr,qt,_r,nl,je,vr,wt,br,$r,yt,Er,gr,ll,qe,ps,kr,xt,jr,qr,wr,cs,yr,Pt,xr,Pr,Tr,Tt,Mr,rl,V,zr,ms,Mt,Cr,Nr,zt,Ir,Ar,Ct,Dr,Sr,Nt,Lr,Fr,It,Or,Vr,al,R,Gr,At,Hr,Jr,Dt,Ur,Br,St,Rr,Qr,ds,Yr,Wr,ol,fs,il,Ve,Xr,Lt,Kr,Zr,ul,O,ea,Ft,sa,ta,Ot,na,la,Vt,ra,aa,Gt,oa,ia,Ht,ua,pa,Jt,ca,ma,pl,Ge,da,Ut,fa,ha,cl,ne,le,Gs,He,_a,Bt,va,ba,ml,re,ae,Hs,G,$a,Rt,Ea,ga,Qt,ka,ja,Yt,qa,wa,Wt,ya,xa,Xt,Pa,Ta,dl,Ie,Je,Kt,hs,Ma,Zt,za,fl,oe,ie,Js,Ue,Ca,en,Na,Ia,hl,Q,Aa,sn,Da,Sa,tn,La,Fa,nn,Oa,Va,Us,Ga,ln,Ha,Ja,_l,Bs,Ua,vl,we,Ba,rn,Ra,Qa,Rs,Ya,Wa,bl,Ae,Be,an,_s,Xa,on,Ka,$l,Re,Za,un,eo,so,El,ye,Qs,pn,to,no,lo,Ys,cn,ro,ao,oo,Ws,mn,io,uo,gl,Xs,po,kl,Ks,co,jl,ue,pe,Zs,Y,mo,dn,fo,ho,fn,_o,vo,hn,bo,$o,_n,Eo,go,ql,De,Qe,vn,vs,ko,bn,jo,wl,Se,bs,Ni,qo,$s,Ii,yl,Z,wo,$n,yo,xo,En,Po,To,gn,Mo,zo,xl,F,et,kn,Co,No,Io,jn,qn,Ao,Do,wn,yn,So,Lo,xn,Pn,Fo,Oo,Tn,Mn,Vo,Go,zn,Cn,Ho,Jo,Nn,In,Uo,Bo,An,Ro,Pl,ce,me,st,tt,Qo,Tl,Es,Ml,de,fe,nt,lt,Yo,zl,Le,Ye,Dn,gs,Wo,Sn,Xo,Cl,rt,Ko,Nl,ks,Il,he,_e,at,H,Zo,Ln,ei,si,Fn,ti,ni,On,li,ri,js,ai,oi,Vn,ii,ui,Al,ve,be,ot,$e,Ee,it,xe,pi,Gn,ci,mi,Hn,di,fi,Dl,We,hi,Jn,_i,vi,Sl,qs,Ll,ws,Fl,ut,bi,Ol,Xe,Un,$i,Ei,Bn,gi,Vl,Ke,ki,Rn,ji,qi,Gl,Ze,Hl;l=new Yp({props:{fw:E[0]}}),N=new kt({});const Ai=[Xp,Wp],ys=[];function Di(e,p){return e[0]==="pt"?0:1}q=Di(E),A=ys[q]=Ai[q](E),S=new Vp({props:{$$slots:{default:[Kp]},$$scope:{ctx:E}}});const Si=[ec,Zp],xs=[];function Li(e,p){return e[0]==="pt"?0:1}j=Li(E),w=xs[j]=Si[j](E),rs=new I({props:{code:"",highlighted:`<span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> pipeline

classifier = pipeline(<span class="hljs-string">&quot;sentiment-analysis&quot;</span>)
classifier(
    [
        <span class="hljs-string">&quot;I&#x27;ve been waiting for a HuggingFace course my whole life.&quot;</span>,
        <span class="hljs-comment"># J&#x27;ai attendu un cours de HuggingFace toute ma vie.</span>
        <span class="hljs-string">&quot;I hate this so much!&quot;</span>,  <span class="hljs-comment"># Je d\xE9teste tellement \xE7a !</span>
    ]
)`}}),as=new I({props:{code:`[{'label': 'POSITIVE', 'score': 0.9598047137260437},
 {'label': 'NEGATIVE', 'score': 0.9994558095932007}]`,highlighted:`[{<span class="hljs-string">&#x27;label&#x27;</span>: <span class="hljs-string">&#x27;POSITIVE&#x27;</span>, <span class="hljs-string">&#x27;score&#x27;</span>: <span class="hljs-number">0.9598047137260437</span>},
 {<span class="hljs-string">&#x27;label&#x27;</span>: <span class="hljs-string">&#x27;NEGATIVE&#x27;</span>, <span class="hljs-string">&#x27;score&#x27;</span>: <span class="hljs-number">0.9994558095932007</span>}]`}}),us=new kt({}),fs=new I({props:{code:"",highlighted:`<span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> AutoTokenizer

checkpoint = <span class="hljs-string">&quot;distilbert-base-uncased-finetuned-sst-2-english&quot;</span>
tokenizer = AutoTokenizer.from_pretrained(checkpoint)`}});const Fi=[tc,sc],Ps=[];function Oi(e,p){return e[0]==="pt"?0:1}ne=Oi(E),le=Ps[ne]=Fi[ne](E);const Vi=[lc,nc],Ts=[];function Gi(e,p){return e[0]==="pt"?0:1}re=Gi(E),ae=Ts[re]=Vi[re](E),hs=new kt({});const Hi=[ac,rc],Ms=[];function Ji(e,p){return e[0]==="pt"?0:1}oe=Ji(E),ie=Ms[oe]=Hi[oe](E),_s=new kt({});const Ui=[ic,oc],zs=[];function Bi(e,p){return e[0]==="pt"?0:1}ue=Bi(E),pe=zs[ue]=Ui[ue](E),vs=new kt({});const Ri=[pc,uc],Cs=[];function Qi(e,p){return e[0]==="pt"?0:1}ce=Qi(E),me=Cs[ce]=Ri[ce](E),Es=new I({props:{code:"print(outputs.logits.shape)",highlighted:'<span class="hljs-built_in">print</span>(outputs.logits.shape)'}});const Yi=[mc,cc],Ns=[];function Wi(e,p){return e[0]==="pt"?0:1}de=Wi(E),fe=Ns[de]=Yi[de](E),gs=new kt({}),ks=new I({props:{code:"print(outputs.logits)",highlighted:'<span class="hljs-built_in">print</span>(outputs.logits)'}});const Xi=[fc,dc],Is=[];function Ki(e,p){return e[0]==="pt"?0:1}he=Ki(E),_e=Is[he]=Xi[he](E);const Zi=[_c,hc],As=[];function eu(e,p){return e[0]==="pt"?0:1}ve=eu(E),be=As[ve]=Zi[ve](E);const su=[bc,vc],Ds=[];function tu(e,p){return e[0]==="pt"?0:1}return $e=tu(E),Ee=Ds[$e]=su[$e](E),qs=new I({props:{code:"model.config.id2label",highlighted:"model.config.id2label"}}),ws=new I({props:{code:"{0: 'NEGATIVE', 1: 'POSITIVE'}",highlighted:'{<span class="hljs-number">0</span>: <span class="hljs-string">&#x27;NEGATIVE&#x27;</span>, <span class="hljs-number">1</span>: <span class="hljs-string">&#x27;POSITIVE&#x27;</span>}'}}),Ze=new Vp({props:{$$slots:{default:[$c]},$$scope:{ctx:E}}}),{c(){n=o("meta"),c=d(),y(l.$$.fragment),h=d(),v=o("h1"),_=o("a"),M=o("span"),y(N.$$.fragment),C=d(),z=o("span"),D=r("Derri\xE8re le pipeline"),g=d(),A.c(),L=d(),y(S.$$.fragment),U=d(),w.c(),X=d(),B=o("p"),ze=r("Commen\xE7ons par un exemple complet en regardant ce qui s\u2019est pass\xE9 en coulisses lorsque nous avons ex\xE9cut\xE9 le code suivant dans le "),K=o("a"),ar=r("chapitre 1"),or=r(" :"),Wn=d(),y(rs.$$.fragment),Xn=d(),Ls=o("p"),ir=r("la sortie :"),Kn=d(),y(as.$$.fragment),Zn=d(),Fe=o("p"),ur=r("Comme nous l\u2019avons vu dans le "),Fs=o("a"),pr=r("chapitre 1"),cr=r(", ce pipeline regroupe trois \xE9tapes : le pr\xE9traitement, le passage des entr\xE9es dans le mod\xE8le et le post-traitement."),el=d(),Ce=o("div"),os=o("img"),mr=d(),is=o("img"),sl=d(),Os=o("p"),dr=r("Passons rapidement en revue chacun de ces \xE9l\xE9ments."),tl=d(),Ne=o("h2"),Oe=o("a"),jt=o("span"),y(us.$$.fragment),fr=d(),Vs=o("span"),hr=r("Pr\xE9traitement avec un "),qt=o("i"),_r=r("tokenizer"),nl=d(),je=o("p"),vr=r("Comme d\u2019autres r\xE9seaux de neurones, les "),wt=o("em"),br=r("transformers"),$r=r(" ne peuvent pas traiter directement le texte brut, donc la premi\xE8re \xE9tape de notre pipeline est de convertir les entr\xE9es textuelles en nombres afin que le mod\xE8le puisse les comprendre. Pour ce faire, nous utilisons un "),yt=o("em"),Er=r("tokenizer"),gr=r(", qui sera responsable de :"),ll=d(),qe=o("ul"),ps=o("li"),kr=r("diviser l\u2019entr\xE9e en mots, sous-mots, ou symboles (comme la ponctuation) qui sont appel\xE9s "),xt=o("em"),jr=r("tokens"),qr=r(","),wr=d(),cs=o("li"),yr=r("associer chaque "),Pt=o("em"),xr=r("token"),Pr=r(" \xE0 un nombre entier,"),Tr=d(),Tt=o("li"),Mr=r("ajouter des entr\xE9es suppl\xE9mentaires qui peuvent \xEAtre utiles au mod\xE8le."),rl=d(),V=o("p"),zr=r("Tout ce pr\xE9traitement doit \xEAtre effectu\xE9 exactement de la m\xEAme mani\xE8re que celui appliqu\xE9 lors du pr\xE9-entra\xEEnement du mod\xE8le. Nous devons donc d\u2019abord t\xE9l\xE9charger ces informations depuis le "),ms=o("a"),Mt=o("em"),Cr=r("Hub"),Nr=r(". Pour ce faire, nous utilisons la classe "),zt=o("code"),Ir=r("AutoTokenizer"),Ar=r(" et sa m\xE9thode "),Ct=o("code"),Dr=r("from_pretrained()"),Sr=r(". En utilisant le nom du "),Nt=o("em"),Lr=r("checkpoint"),Fr=r(" de notre mod\xE8le, elle va automatiquement r\xE9cup\xE9rer les donn\xE9es associ\xE9es au "),It=o("em"),Or=r("tokenizer"),Vr=r(" du mod\xE8le et les mettre en cache (afin qu\u2019elles ne soient t\xE9l\xE9charg\xE9es que la premi\xE8re fois que vous ex\xE9cutez le code ci-dessous)."),al=d(),R=o("p"),Gr=r("Puisque le "),At=o("em"),Hr=r("checkpoint"),Jr=r(" par d\xE9faut du pipeline "),Dt=o("code"),Ur=r("sentiment-analysis"),Br=r(" (analyse de sentiment) est "),St=o("code"),Rr=r("distilbert-base-uncased-finetuned-sst-2-english"),Qr=r(" (vous pouvez voir la carte de ce mod\xE8le "),ds=o("a"),Yr=r("ici"),Wr=r("), nous ex\xE9cutons ce qui suit :"),ol=d(),y(fs.$$.fragment),il=d(),Ve=o("p"),Xr=r("Une fois que nous avons le "),Lt=o("em"),Kr=r("tokenizer"),Zr=r(" nous pouvons lui passer directement nos phrases et obtenir un dictionnaire pr\xEAt \xE0 \xEAtre donn\xE9 \xE0 notre mod\xE8le ! La seule chose qui reste \xE0 faire est de convertir en tenseurs la liste des identifiants d\u2019entr\xE9e."),ul=d(),O=o("p"),ea=r("Vous pouvez utiliser \u{1F917} "),Ft=o("em"),sa=r("Transformers"),ta=r(" sans avoir \xE0 vous soucier du "),Ot=o("em"),na=r("framework"),la=r(" utilis\xE9 comme "),Vt=o("em"),ra=r("backend"),aa=r(". Il peut s\u2019agir de PyTorch, de TensorFlow ou de Flax pour certains mod\xE8les. Cependant, les "),Gt=o("em"),oa=r("transformers"),ia=r(" n\u2019acceptent que les "),Ht=o("em"),ua=r("tenseurs"),pa=r(" en entr\xE9e. Si c\u2019est la premi\xE8re fois que vous entendez parler de tenseurs, vous pouvez les consid\xE9rer comme des tableaux NumPy. Un tableau NumPy peut \xEAtre un scalaire (0D), un vecteur (1D), une matrice (2D), ou avoir davantage de dimensions. Les tenseurs des autres "),Jt=o("em"),ca=r("frameworks"),ma=r(" d\u2019apprentissage machine se comportent de mani\xE8re similaire et sont g\xE9n\xE9ralement aussi simples \xE0 instancier que les tableaux NumPy."),pl=d(),Ge=o("p"),da=r("Pour sp\xE9cifier le type de tenseurs que nous voulons r\xE9cup\xE9rer (PyTorch, TensorFlow, ou simplement NumPy), nous utilisons l\u2019argument "),Ut=o("code"),fa=r("return_tensors"),ha=r(" :"),cl=d(),le.c(),Gs=d(),He=o("p"),_a=r("Ne vous pr\xE9occupez pas encore du remplissage ("),Bt=o("em"),va=r("padding"),ba=r(") et de la troncature, nous les expliquerons plus tard. Les principales choses \xE0 retenir ici sont que vous pouvez passer une phrase ou une liste de phrases, ainsi que sp\xE9cifier le type de tenseurs que vous voulez r\xE9cup\xE9rer (si aucun type n\u2019est pass\xE9, par d\xE9faut vous obtiendrez une liste de listes comme r\xE9sultat)."),ml=d(),ae.c(),Hs=d(),G=o("p"),$a=r("La sortie elle-m\xEAme est un dictionnaire contenant deux cl\xE9s : "),Rt=o("code"),Ea=r("input_ids"),ga=r(" et "),Qt=o("code"),ka=r("attention_mask"),ja=r(". "),Yt=o("code"),qa=r("input_ids"),wa=r(" contient deux lignes d\u2019entiers (une pour chaque phrase) qui sont les identifiants uniques des "),Wt=o("em"),ya=r("tokens"),xa=r(" dans chaque phrase. Nous expliquerons ce qu\u2019est l\u2019"),Xt=o("code"),Pa=r("attention_mask"),Ta=r(" plus tard dans ce chapitre."),dl=d(),Ie=o("h2"),Je=o("a"),Kt=o("span"),y(hs.$$.fragment),Ma=d(),Zt=o("span"),za=r("Passage au mod\xE8le"),fl=d(),ie.c(),Js=d(),Ue=o("p"),Ca=r("Dans cet extrait de code, nous avons t\xE9l\xE9charg\xE9 le m\xEAme "),en=o("em"),Na=r("checkpoint"),Ia=r(" que nous avons utilis\xE9 dans notre pipeline auparavant (il devrait en fait avoir d\xE9j\xE0 \xE9t\xE9 mis en cache) et instanci\xE9 un mod\xE8le avec lui."),hl=d(),Q=o("p"),Aa=r("Cette architecture ne contient que le module de "),sn=o("em"),Da=r("transformer"),Sa=r(" de base : \xE9tant donn\xE9 certaines entr\xE9es, il produit ce que nous appellerons des "),tn=o("em"),La=r("\xE9tats cach\xE9s"),Fa=r(", \xE9galement connus sous le nom de "),nn=o("em"),Oa=r("caract\xE9ristiques"),Va=r(`.
Pour chaque entr\xE9e du mod\xE8le, nous r\xE9cup\xE9rons un vecteur en grande dimension repr\xE9sentant la `),Us=o("strong"),Ga=r("compr\xE9hension contextuelle de cette entr\xE9e par le "),ln=o("em"),Ha=r("transformer"),Ja=r("."),_l=d(),Bs=o("p"),Ua=r("Si cela ne fait pas sens, ne vous inqui\xE9tez pas. Nous expliquons tout plus tard."),vl=d(),we=o("p"),Ba=r("Bien que ces \xE9tats cach\xE9s puissent \xEAtre utiles en eux-m\xEAmes, ils sont g\xE9n\xE9ralement les entr\xE9es d\u2019une autre partie du mod\xE8le, connue sous le nom de "),rn=o("em"),Ra=r("t\xEAte"),Qa=r(". Dans le "),Rs=o("a"),Ya=r("chapitre 1"),Wa=r(", les diff\xE9rentes t\xE2ches auraient pu \xEAtre r\xE9alis\xE9es avec la m\xEAme architecture mais en ayant chacune d\u2019elles une t\xEAte diff\xE9rente."),bl=d(),Ae=o("h3"),Be=o("a"),an=o("span"),y(_s.$$.fragment),Xa=d(),on=o("span"),Ka=r("Un vecteur de grande dimension ?"),$l=d(),Re=o("p"),Za=r("Le vecteur produit en sortie par le "),un=o("em"),eo=r("transformer"),so=r(" est g\xE9n\xE9ralement de grande dimension. Il a g\xE9n\xE9ralement trois dimensions :"),El=d(),ye=o("ul"),Qs=o("li"),pn=o("strong"),to=r("la taille du lot"),no=r(" : le nombre de s\xE9quences trait\xE9es \xE0 la fois (2 dans notre exemple),"),lo=d(),Ys=o("li"),cn=o("strong"),ro=r("la longueur de la s\xE9quence"),ao=r(" : la longueur de la repr\xE9sentation num\xE9rique de la s\xE9quence (16 dans notre exemple),"),oo=d(),Ws=o("li"),mn=o("strong"),io=r("la taille cach\xE9e"),uo=r(" : la dimension du vecteur de chaque entr\xE9e du mod\xE8le."),gl=d(),Xs=o("p"),po=r("On dit qu\u2019il est de \xAB grande dimension \xBB en raison de la derni\xE8re valeur. La taille cach\xE9e peut \xEAtre tr\xE8s grande (g\xE9n\xE9ralement 768 pour les petits mod\xE8les et pour les grands mod\xE8les cela peut atteindre 3072 voire plus)."),kl=d(),Ks=o("p"),co=r("Nous pouvons le constater si nous alimentons notre mod\xE8le avec les entr\xE9es que nous avons pr\xE9trait\xE9es :"),jl=d(),pe.c(),Zs=d(),Y=o("p"),mo=r("Notez que les sorties des mod\xE8les de la biblioth\xE8que \u{1F917} "),dn=o("em"),fo=r("Transformers"),ho=r(" se comportent comme des "),fn=o("code"),_o=r("namedtuples"),vo=r(" ou des dictionnaires. Vous pouvez acc\xE9der aux \xE9l\xE9ments par attributs (comme nous l\u2019avons fait), par cl\xE9 ("),hn=o("code"),bo=r('outputs["last_hidden_state"]'),$o=r("), ou m\xEAme par l\u2019index si vous savez exactement o\xF9 se trouve la chose que vous cherchez ("),_n=o("code"),Eo=r("outputs[0]"),go=r(")."),ql=d(),De=o("h3"),Qe=o("a"),vn=o("span"),y(vs.$$.fragment),ko=d(),bn=o("span"),jo=r("Les t\xEAtes des mod\xE8les : donner du sens aux chiffres"),wl=r(`

Les t\xEAtes des mod\xE8les prennent en entr\xE9e le vecteur de grande dimension des \xE9tats cach\xE9s et le projettent sur une autre dimension. Elles sont g\xE9n\xE9ralement compos\xE9es d'une ou de quelques couches lin\xE9aires :
`),Se=o("div"),bs=o("img"),qo=d(),$s=o("img"),yl=d(),Z=o("p"),wo=r("La sortie du "),$n=o("em"),yo=r("transformer"),xo=r(` est envoy\xE9e directement \xE0 la t\xEAte du mod\xE8le pour \xEAtre trait\xE9e.
Dans ce diagramme, le mod\xE8le est repr\xE9sent\xE9 par sa couche d\u2019ench\xE2ssement et les couches suivantes. La couche d\u2019ench\xE2ssement convertit chaque identifiant d\u2019entr\xE9e dans l\u2019entr\xE9e tokenis\xE9e en un vecteur qui repr\xE9sente le `),En=o("em"),Po=r("token"),To=r(` associ\xE9. Les couches suivantes manipulent ces vecteurs en utilisant le m\xE9canisme d\u2019attention pour produire la repr\xE9sentation finale des phrases.
Il existe de nombreuses architectures diff\xE9rentes disponibles dans la biblioth\xE8que \u{1F917} `),gn=o("em"),Mo=r("Transformers"),zo=r(", chacune \xE9tant con\xE7ue autour de la prise en charge d\u2019une t\xE2che sp\xE9cifique. En voici une liste non exhaustive :"),xl=d(),F=o("ul"),et=o("li"),kn=o("code"),Co=r("*Model"),No=r(" (r\xE9cup\xE9rer les \xE9tats cach\xE9s)"),Io=d(),jn=o("li"),qn=o("code"),Ao=r("*ForCausalLM"),Do=d(),wn=o("li"),yn=o("code"),So=r("*ForMaskedLM"),Lo=d(),xn=o("li"),Pn=o("code"),Fo=r("*ForMultipleChoice"),Oo=d(),Tn=o("li"),Mn=o("code"),Vo=r("*ForQuestionAnswering"),Go=d(),zn=o("li"),Cn=o("code"),Ho=r("*ForSequenceClassification"),Jo=d(),Nn=o("li"),In=o("code"),Uo=r("*ForTokenClassification"),Bo=d(),An=o("li"),Ro=r("et autres \u{1F917}"),Pl=d(),me.c(),st=d(),tt=o("p"),Qo=r("Maintenant, si nous examinons la forme de nos entr\xE9es, la dimensionnalit\xE9 est beaucoup plus faible. La t\xEAte du mod\xE8le prend en entr\xE9e les vecteurs de grande dimension que nous avons vus pr\xE9c\xE9demment et elle produit des vecteurs contenant deux valeurs (une par \xE9tiquette) :"),Tl=d(),y(Es.$$.fragment),Ml=d(),fe.c(),nt=d(),lt=o("p"),Yo=r("Comme nous n\u2019avons que deux phrases et deux \xE9tiquettes, le r\xE9sultat que nous obtenons est de forme 2 x 2"),zl=d(),Le=o("h2"),Ye=o("a"),Dn=o("span"),y(gs.$$.fragment),Wo=d(),Sn=o("span"),Xo=r("Post-traitement de la sortie"),Cl=d(),rt=o("p"),Ko=r("Les valeurs que nous obtenons en sortie de notre mod\xE8le n\u2019ont pas n\xE9cessairement de sens en elles-m\xEAmes. Jetons-y un coup d\u2019\u0153il  :"),Nl=d(),y(ks.$$.fragment),Il=d(),_e.c(),at=d(),H=o("p"),Zo=r("Notre mod\xE8le a pr\xE9dit "),Ln=o("code"),ei=r("[-1.5607, 1.6123]"),si=r(" pour la premi\xE8re phrase et "),Fn=o("code"),ti=r("[ 4.1692, -3.3464]"),ni=r(" pour la seconde. Ce ne sont pas des probabilit\xE9s mais des "),On=o("em"),li=r("logits"),ri=r(", les scores bruts, non normalis\xE9s, produits par la derni\xE8re couche du mod\xE8le. Pour \xEAtre convertis en probabilit\xE9s, ils doivent passer par une couche "),js=o("a"),ai=r("SoftMax"),oi=r(" (tous les mod\xE8les de la biblioth\xE8que \u{1F917} "),Vn=o("em"),ii=r("Transformers"),ui=r(" sortent les logits car la fonction de perte de l\u2019entra\xEEnement fusionne g\xE9n\xE9ralement la derni\xE8re fonction d\u2019activation, comme la SoftMax, avec la fonction de perte r\xE9elle, comme l\u2019entropie crois\xE9e) :"),Al=d(),be.c(),ot=d(),Ee.c(),it=d(),xe=o("p"),pi=r("Maintenant nous pouvons voir que le mod\xE8le a pr\xE9dit "),Gn=o("code"),ci=r("[0.0402, 0.9598]"),mi=r(" pour la premi\xE8re phrase et "),Hn=o("code"),di=r("[0.9995, 0.0005]"),fi=r(" pour la seconde. Ce sont des scores de probabilit\xE9 reconnaissables."),Dl=d(),We=o("p"),hi=r("Pour obtenir les \xE9tiquettes correspondant \xE0 chaque position, nous pouvons inspecter l\u2019attribut "),Jn=o("code"),_i=r("id2label"),vi=r(" de la configuration du mod\xE8le (plus de d\xE9tails dans la section suivante) :"),Sl=d(),y(qs.$$.fragment),Ll=d(),y(ws.$$.fragment),Fl=d(),ut=o("p"),bi=r("Nous pouvons maintenant conclure que le mod\xE8le a pr\xE9dit ce qui suit :"),Ol=d(),Xe=o("ul"),Un=o("li"),$i=r("premi\xE8re phrase : NEGATIVE: 0.0402, POSITIVE: 0.9598"),Ei=d(),Bn=o("li"),gi=r("deuxi\xE8me phrase : NEGATIVE: 0.9995, POSITIVE: 0.0005"),Vl=d(),Ke=o("p"),ki=r("Nous avons reproduit avec succ\xE8s les trois \xE9tapes du pipeline : pr\xE9traitement avec les "),Rn=o("em"),ji=r("tokenizers"),qi=r(", passage des entr\xE9es dans le mod\xE8le et post-traitement ! Prenons maintenant le temps de nous plonger plus profond\xE9ment dans chacune de ces \xE9tapes."),Gl=d(),y(Ze.$$.fragment),this.h()},l(e){const p=Rp('[data-svelte="svelte-1phssyn"]',document.head);n=i(p,"META",{name:!0,content:!0}),p.forEach(t),c=f(e),x(l.$$.fragment,e),h=f(e),v=i(e,"H1",{class:!0});var Ss=u(v);_=i(Ss,"A",{id:!0,class:!0,href:!0});var pt=u(_);M=i(pt,"SPAN",{});var Qn=u(M);x(N.$$.fragment,Qn),Qn.forEach(t),pt.forEach(t),C=f(Ss),z=i(Ss,"SPAN",{});var ct=u(z);D=a(ct,"Derri\xE8re le pipeline"),ct.forEach(t),Ss.forEach(t),g=f(e),A.l(e),L=f(e),x(S.$$.fragment,e),U=f(e),w.l(e),X=f(e),B=i(e,"P",{});var es=u(B);ze=a(es,"Commen\xE7ons par un exemple complet en regardant ce qui s\u2019est pass\xE9 en coulisses lorsque nous avons ex\xE9cut\xE9 le code suivant dans le "),K=i(es,"A",{href:!0});var mt=u(K);ar=a(mt,"chapitre 1"),mt.forEach(t),or=a(es," :"),es.forEach(t),Wn=f(e),x(rs.$$.fragment,e),Xn=f(e),Ls=i(e,"P",{});var dt=u(Ls);ir=a(dt,"la sortie :"),dt.forEach(t),Kn=f(e),x(as.$$.fragment,e),Zn=f(e),Fe=i(e,"P",{});var ss=u(Fe);ur=a(ss,"Comme nous l\u2019avons vu dans le "),Fs=i(ss,"A",{href:!0});var ft=u(Fs);pr=a(ft,"chapitre 1"),ft.forEach(t),cr=a(ss,", ce pipeline regroupe trois \xE9tapes : le pr\xE9traitement, le passage des entr\xE9es dans le mod\xE8le et le post-traitement."),ss.forEach(t),el=f(e),Ce=i(e,"DIV",{class:!0});var ts=u(Ce);os=i(ts,"IMG",{class:!0,src:!0,alt:!0}),mr=f(ts),is=i(ts,"IMG",{class:!0,src:!0,alt:!0}),ts.forEach(t),sl=f(e),Os=i(e,"P",{});var ht=u(Os);dr=a(ht,"Passons rapidement en revue chacun de ces \xE9l\xE9ments."),ht.forEach(t),tl=f(e),Ne=i(e,"H2",{class:!0});var ns=u(Ne);Oe=i(ns,"A",{id:!0,class:!0,href:!0});var _t=u(Oe);jt=i(_t,"SPAN",{});var Yn=u(jt);x(us.$$.fragment,Yn),Yn.forEach(t),_t.forEach(t),fr=f(ns),Vs=i(ns,"SPAN",{});var wi=u(Vs);hr=a(wi,"Pr\xE9traitement avec un "),qt=i(wi,"I",{});var nu=u(qt);_r=a(nu,"tokenizer"),nu.forEach(t),wi.forEach(t),ns.forEach(t),nl=f(e),je=i(e,"P",{});var vt=u(je);vr=a(vt,"Comme d\u2019autres r\xE9seaux de neurones, les "),wt=i(vt,"EM",{});var lu=u(wt);br=a(lu,"transformers"),lu.forEach(t),$r=a(vt," ne peuvent pas traiter directement le texte brut, donc la premi\xE8re \xE9tape de notre pipeline est de convertir les entr\xE9es textuelles en nombres afin que le mod\xE8le puisse les comprendre. Pour ce faire, nous utilisons un "),yt=i(vt,"EM",{});var ru=u(yt);Er=a(ru,"tokenizer"),ru.forEach(t),gr=a(vt,", qui sera responsable de :"),vt.forEach(t),ll=f(e),qe=i(e,"UL",{});var bt=u(qe);ps=i(bt,"LI",{});var Jl=u(ps);kr=a(Jl,"diviser l\u2019entr\xE9e en mots, sous-mots, ou symboles (comme la ponctuation) qui sont appel\xE9s "),xt=i(Jl,"EM",{});var au=u(xt);jr=a(au,"tokens"),au.forEach(t),qr=a(Jl,","),Jl.forEach(t),wr=f(bt),cs=i(bt,"LI",{});var Ul=u(cs);yr=a(Ul,"associer chaque "),Pt=i(Ul,"EM",{});var ou=u(Pt);xr=a(ou,"token"),ou.forEach(t),Pr=a(Ul," \xE0 un nombre entier,"),Ul.forEach(t),Tr=f(bt),Tt=i(bt,"LI",{});var iu=u(Tt);Mr=a(iu,"ajouter des entr\xE9es suppl\xE9mentaires qui peuvent \xEAtre utiles au mod\xE8le."),iu.forEach(t),bt.forEach(t),rl=f(e),V=i(e,"P",{});var ee=u(V);zr=a(ee,"Tout ce pr\xE9traitement doit \xEAtre effectu\xE9 exactement de la m\xEAme mani\xE8re que celui appliqu\xE9 lors du pr\xE9-entra\xEEnement du mod\xE8le. Nous devons donc d\u2019abord t\xE9l\xE9charger ces informations depuis le "),ms=i(ee,"A",{href:!0,rel:!0});var uu=u(ms);Mt=i(uu,"EM",{});var pu=u(Mt);Cr=a(pu,"Hub"),pu.forEach(t),uu.forEach(t),Nr=a(ee,". Pour ce faire, nous utilisons la classe "),zt=i(ee,"CODE",{});var cu=u(zt);Ir=a(cu,"AutoTokenizer"),cu.forEach(t),Ar=a(ee," et sa m\xE9thode "),Ct=i(ee,"CODE",{});var mu=u(Ct);Dr=a(mu,"from_pretrained()"),mu.forEach(t),Sr=a(ee,". En utilisant le nom du "),Nt=i(ee,"EM",{});var du=u(Nt);Lr=a(du,"checkpoint"),du.forEach(t),Fr=a(ee," de notre mod\xE8le, elle va automatiquement r\xE9cup\xE9rer les donn\xE9es associ\xE9es au "),It=i(ee,"EM",{});var fu=u(It);Or=a(fu,"tokenizer"),fu.forEach(t),Vr=a(ee," du mod\xE8le et les mettre en cache (afin qu\u2019elles ne soient t\xE9l\xE9charg\xE9es que la premi\xE8re fois que vous ex\xE9cutez le code ci-dessous)."),ee.forEach(t),al=f(e),R=i(e,"P",{});var Pe=u(R);Gr=a(Pe,"Puisque le "),At=i(Pe,"EM",{});var hu=u(At);Hr=a(hu,"checkpoint"),hu.forEach(t),Jr=a(Pe," par d\xE9faut du pipeline "),Dt=i(Pe,"CODE",{});var _u=u(Dt);Ur=a(_u,"sentiment-analysis"),_u.forEach(t),Br=a(Pe," (analyse de sentiment) est "),St=i(Pe,"CODE",{});var vu=u(St);Rr=a(vu,"distilbert-base-uncased-finetuned-sst-2-english"),vu.forEach(t),Qr=a(Pe," (vous pouvez voir la carte de ce mod\xE8le "),ds=i(Pe,"A",{href:!0,rel:!0});var bu=u(ds);Yr=a(bu,"ici"),bu.forEach(t),Wr=a(Pe,"), nous ex\xE9cutons ce qui suit :"),Pe.forEach(t),ol=f(e),x(fs.$$.fragment,e),il=f(e),Ve=i(e,"P",{});var Bl=u(Ve);Xr=a(Bl,"Une fois que nous avons le "),Lt=i(Bl,"EM",{});var $u=u(Lt);Kr=a($u,"tokenizer"),$u.forEach(t),Zr=a(Bl," nous pouvons lui passer directement nos phrases et obtenir un dictionnaire pr\xEAt \xE0 \xEAtre donn\xE9 \xE0 notre mod\xE8le ! La seule chose qui reste \xE0 faire est de convertir en tenseurs la liste des identifiants d\u2019entr\xE9e."),Bl.forEach(t),ul=f(e),O=i(e,"P",{});var W=u(O);ea=a(W,"Vous pouvez utiliser \u{1F917} "),Ft=i(W,"EM",{});var Eu=u(Ft);sa=a(Eu,"Transformers"),Eu.forEach(t),ta=a(W," sans avoir \xE0 vous soucier du "),Ot=i(W,"EM",{});var gu=u(Ot);na=a(gu,"framework"),gu.forEach(t),la=a(W," utilis\xE9 comme "),Vt=i(W,"EM",{});var ku=u(Vt);ra=a(ku,"backend"),ku.forEach(t),aa=a(W,". Il peut s\u2019agir de PyTorch, de TensorFlow ou de Flax pour certains mod\xE8les. Cependant, les "),Gt=i(W,"EM",{});var ju=u(Gt);oa=a(ju,"transformers"),ju.forEach(t),ia=a(W," n\u2019acceptent que les "),Ht=i(W,"EM",{});var qu=u(Ht);ua=a(qu,"tenseurs"),qu.forEach(t),pa=a(W," en entr\xE9e. Si c\u2019est la premi\xE8re fois que vous entendez parler de tenseurs, vous pouvez les consid\xE9rer comme des tableaux NumPy. Un tableau NumPy peut \xEAtre un scalaire (0D), un vecteur (1D), une matrice (2D), ou avoir davantage de dimensions. Les tenseurs des autres "),Jt=i(W,"EM",{});var wu=u(Jt);ca=a(wu,"frameworks"),wu.forEach(t),ma=a(W," d\u2019apprentissage machine se comportent de mani\xE8re similaire et sont g\xE9n\xE9ralement aussi simples \xE0 instancier que les tableaux NumPy."),W.forEach(t),pl=f(e),Ge=i(e,"P",{});var Rl=u(Ge);da=a(Rl,"Pour sp\xE9cifier le type de tenseurs que nous voulons r\xE9cup\xE9rer (PyTorch, TensorFlow, ou simplement NumPy), nous utilisons l\u2019argument "),Ut=i(Rl,"CODE",{});var yu=u(Ut);fa=a(yu,"return_tensors"),yu.forEach(t),ha=a(Rl," :"),Rl.forEach(t),cl=f(e),le.l(e),Gs=f(e),He=i(e,"P",{});var Ql=u(He);_a=a(Ql,"Ne vous pr\xE9occupez pas encore du remplissage ("),Bt=i(Ql,"EM",{});var xu=u(Bt);va=a(xu,"padding"),xu.forEach(t),ba=a(Ql,") et de la troncature, nous les expliquerons plus tard. Les principales choses \xE0 retenir ici sont que vous pouvez passer une phrase ou une liste de phrases, ainsi que sp\xE9cifier le type de tenseurs que vous voulez r\xE9cup\xE9rer (si aucun type n\u2019est pass\xE9, par d\xE9faut vous obtiendrez une liste de listes comme r\xE9sultat)."),Ql.forEach(t),ml=f(e),ae.l(e),Hs=f(e),G=i(e,"P",{});var se=u(G);$a=a(se,"La sortie elle-m\xEAme est un dictionnaire contenant deux cl\xE9s : "),Rt=i(se,"CODE",{});var Pu=u(Rt);Ea=a(Pu,"input_ids"),Pu.forEach(t),ga=a(se," et "),Qt=i(se,"CODE",{});var Tu=u(Qt);ka=a(Tu,"attention_mask"),Tu.forEach(t),ja=a(se,". "),Yt=i(se,"CODE",{});var Mu=u(Yt);qa=a(Mu,"input_ids"),Mu.forEach(t),wa=a(se," contient deux lignes d\u2019entiers (une pour chaque phrase) qui sont les identifiants uniques des "),Wt=i(se,"EM",{});var zu=u(Wt);ya=a(zu,"tokens"),zu.forEach(t),xa=a(se," dans chaque phrase. Nous expliquerons ce qu\u2019est l\u2019"),Xt=i(se,"CODE",{});var Cu=u(Xt);Pa=a(Cu,"attention_mask"),Cu.forEach(t),Ta=a(se," plus tard dans ce chapitre."),se.forEach(t),dl=f(e),Ie=i(e,"H2",{class:!0});var Yl=u(Ie);Je=i(Yl,"A",{id:!0,class:!0,href:!0});var Nu=u(Je);Kt=i(Nu,"SPAN",{});var Iu=u(Kt);x(hs.$$.fragment,Iu),Iu.forEach(t),Nu.forEach(t),Ma=f(Yl),Zt=i(Yl,"SPAN",{});var Au=u(Zt);za=a(Au,"Passage au mod\xE8le"),Au.forEach(t),Yl.forEach(t),fl=f(e),ie.l(e),Js=f(e),Ue=i(e,"P",{});var Wl=u(Ue);Ca=a(Wl,"Dans cet extrait de code, nous avons t\xE9l\xE9charg\xE9 le m\xEAme "),en=i(Wl,"EM",{});var Du=u(en);Na=a(Du,"checkpoint"),Du.forEach(t),Ia=a(Wl," que nous avons utilis\xE9 dans notre pipeline auparavant (il devrait en fait avoir d\xE9j\xE0 \xE9t\xE9 mis en cache) et instanci\xE9 un mod\xE8le avec lui."),Wl.forEach(t),hl=f(e),Q=i(e,"P",{});var Te=u(Q);Aa=a(Te,"Cette architecture ne contient que le module de "),sn=i(Te,"EM",{});var Su=u(sn);Da=a(Su,"transformer"),Su.forEach(t),Sa=a(Te," de base : \xE9tant donn\xE9 certaines entr\xE9es, il produit ce que nous appellerons des "),tn=i(Te,"EM",{});var Lu=u(tn);La=a(Lu,"\xE9tats cach\xE9s"),Lu.forEach(t),Fa=a(Te,", \xE9galement connus sous le nom de "),nn=i(Te,"EM",{});var Fu=u(nn);Oa=a(Fu,"caract\xE9ristiques"),Fu.forEach(t),Va=a(Te,`.
Pour chaque entr\xE9e du mod\xE8le, nous r\xE9cup\xE9rons un vecteur en grande dimension repr\xE9sentant la `),Us=i(Te,"STRONG",{});var yi=u(Us);Ga=a(yi,"compr\xE9hension contextuelle de cette entr\xE9e par le "),ln=i(yi,"EM",{});var Ou=u(ln);Ha=a(Ou,"transformer"),Ou.forEach(t),yi.forEach(t),Ja=a(Te,"."),Te.forEach(t),_l=f(e),Bs=i(e,"P",{});var Vu=u(Bs);Ua=a(Vu,"Si cela ne fait pas sens, ne vous inqui\xE9tez pas. Nous expliquons tout plus tard."),Vu.forEach(t),vl=f(e),we=i(e,"P",{});var $t=u(we);Ba=a($t,"Bien que ces \xE9tats cach\xE9s puissent \xEAtre utiles en eux-m\xEAmes, ils sont g\xE9n\xE9ralement les entr\xE9es d\u2019une autre partie du mod\xE8le, connue sous le nom de "),rn=i($t,"EM",{});var Gu=u(rn);Ra=a(Gu,"t\xEAte"),Gu.forEach(t),Qa=a($t,". Dans le "),Rs=i($t,"A",{href:!0});var Hu=u(Rs);Ya=a(Hu,"chapitre 1"),Hu.forEach(t),Wa=a($t,", les diff\xE9rentes t\xE2ches auraient pu \xEAtre r\xE9alis\xE9es avec la m\xEAme architecture mais en ayant chacune d\u2019elles une t\xEAte diff\xE9rente."),$t.forEach(t),bl=f(e),Ae=i(e,"H3",{class:!0});var Xl=u(Ae);Be=i(Xl,"A",{id:!0,class:!0,href:!0});var Ju=u(Be);an=i(Ju,"SPAN",{});var Uu=u(an);x(_s.$$.fragment,Uu),Uu.forEach(t),Ju.forEach(t),Xa=f(Xl),on=i(Xl,"SPAN",{});var Bu=u(on);Ka=a(Bu,"Un vecteur de grande dimension ?"),Bu.forEach(t),Xl.forEach(t),$l=f(e),Re=i(e,"P",{});var Kl=u(Re);Za=a(Kl,"Le vecteur produit en sortie par le "),un=i(Kl,"EM",{});var Ru=u(un);eo=a(Ru,"transformer"),Ru.forEach(t),so=a(Kl," est g\xE9n\xE9ralement de grande dimension. Il a g\xE9n\xE9ralement trois dimensions :"),Kl.forEach(t),El=f(e),ye=i(e,"UL",{});var Et=u(ye);Qs=i(Et,"LI",{});var xi=u(Qs);pn=i(xi,"STRONG",{});var Qu=u(pn);to=a(Qu,"la taille du lot"),Qu.forEach(t),no=a(xi," : le nombre de s\xE9quences trait\xE9es \xE0 la fois (2 dans notre exemple),"),xi.forEach(t),lo=f(Et),Ys=i(Et,"LI",{});var Pi=u(Ys);cn=i(Pi,"STRONG",{});var Yu=u(cn);ro=a(Yu,"la longueur de la s\xE9quence"),Yu.forEach(t),ao=a(Pi," : la longueur de la repr\xE9sentation num\xE9rique de la s\xE9quence (16 dans notre exemple),"),Pi.forEach(t),oo=f(Et),Ws=i(Et,"LI",{});var Ti=u(Ws);mn=i(Ti,"STRONG",{});var Wu=u(mn);io=a(Wu,"la taille cach\xE9e"),Wu.forEach(t),uo=a(Ti," : la dimension du vecteur de chaque entr\xE9e du mod\xE8le."),Ti.forEach(t),Et.forEach(t),gl=f(e),Xs=i(e,"P",{});var Xu=u(Xs);po=a(Xu,"On dit qu\u2019il est de \xAB grande dimension \xBB en raison de la derni\xE8re valeur. La taille cach\xE9e peut \xEAtre tr\xE8s grande (g\xE9n\xE9ralement 768 pour les petits mod\xE8les et pour les grands mod\xE8les cela peut atteindre 3072 voire plus)."),Xu.forEach(t),kl=f(e),Ks=i(e,"P",{});var Ku=u(Ks);co=a(Ku,"Nous pouvons le constater si nous alimentons notre mod\xE8le avec les entr\xE9es que nous avons pr\xE9trait\xE9es :"),Ku.forEach(t),jl=f(e),pe.l(e),Zs=f(e),Y=i(e,"P",{});var Me=u(Y);mo=a(Me,"Notez que les sorties des mod\xE8les de la biblioth\xE8que \u{1F917} "),dn=i(Me,"EM",{});var Zu=u(dn);fo=a(Zu,"Transformers"),Zu.forEach(t),ho=a(Me," se comportent comme des "),fn=i(Me,"CODE",{});var ep=u(fn);_o=a(ep,"namedtuples"),ep.forEach(t),vo=a(Me," ou des dictionnaires. Vous pouvez acc\xE9der aux \xE9l\xE9ments par attributs (comme nous l\u2019avons fait), par cl\xE9 ("),hn=i(Me,"CODE",{});var sp=u(hn);bo=a(sp,'outputs["last_hidden_state"]'),sp.forEach(t),$o=a(Me,"), ou m\xEAme par l\u2019index si vous savez exactement o\xF9 se trouve la chose que vous cherchez ("),_n=i(Me,"CODE",{});var tp=u(_n);Eo=a(tp,"outputs[0]"),tp.forEach(t),go=a(Me,")."),Me.forEach(t),ql=f(e),De=i(e,"H3",{class:!0});var Zl=u(De);Qe=i(Zl,"A",{id:!0,class:!0,href:!0});var np=u(Qe);vn=i(np,"SPAN",{});var lp=u(vn);x(vs.$$.fragment,lp),lp.forEach(t),np.forEach(t),ko=f(Zl),bn=i(Zl,"SPAN",{});var rp=u(bn);jo=a(rp,"Les t\xEAtes des mod\xE8les : donner du sens aux chiffres"),rp.forEach(t),Zl.forEach(t),wl=a(e,`

Les t\xEAtes des mod\xE8les prennent en entr\xE9e le vecteur de grande dimension des \xE9tats cach\xE9s et le projettent sur une autre dimension. Elles sont g\xE9n\xE9ralement compos\xE9es d'une ou de quelques couches lin\xE9aires :
`),Se=i(e,"DIV",{class:!0});var er=u(Se);bs=i(er,"IMG",{class:!0,src:!0,alt:!0}),qo=f(er),$s=i(er,"IMG",{class:!0,src:!0,alt:!0}),er.forEach(t),yl=f(e),Z=i(e,"P",{});var ls=u(Z);wo=a(ls,"La sortie du "),$n=i(ls,"EM",{});var ap=u($n);yo=a(ap,"transformer"),ap.forEach(t),xo=a(ls,` est envoy\xE9e directement \xE0 la t\xEAte du mod\xE8le pour \xEAtre trait\xE9e.
Dans ce diagramme, le mod\xE8le est repr\xE9sent\xE9 par sa couche d\u2019ench\xE2ssement et les couches suivantes. La couche d\u2019ench\xE2ssement convertit chaque identifiant d\u2019entr\xE9e dans l\u2019entr\xE9e tokenis\xE9e en un vecteur qui repr\xE9sente le `),En=i(ls,"EM",{});var op=u(En);Po=a(op,"token"),op.forEach(t),To=a(ls,` associ\xE9. Les couches suivantes manipulent ces vecteurs en utilisant le m\xE9canisme d\u2019attention pour produire la repr\xE9sentation finale des phrases.
Il existe de nombreuses architectures diff\xE9rentes disponibles dans la biblioth\xE8que \u{1F917} `),gn=i(ls,"EM",{});var ip=u(gn);Mo=a(ip,"Transformers"),ip.forEach(t),zo=a(ls,", chacune \xE9tant con\xE7ue autour de la prise en charge d\u2019une t\xE2che sp\xE9cifique. En voici une liste non exhaustive :"),ls.forEach(t),xl=f(e),F=i(e,"UL",{});var J=u(F);et=i(J,"LI",{});var Mi=u(et);kn=i(Mi,"CODE",{});var up=u(kn);Co=a(up,"*Model"),up.forEach(t),No=a(Mi," (r\xE9cup\xE9rer les \xE9tats cach\xE9s)"),Mi.forEach(t),Io=f(J),jn=i(J,"LI",{});var pp=u(jn);qn=i(pp,"CODE",{});var cp=u(qn);Ao=a(cp,"*ForCausalLM"),cp.forEach(t),pp.forEach(t),Do=f(J),wn=i(J,"LI",{});var mp=u(wn);yn=i(mp,"CODE",{});var dp=u(yn);So=a(dp,"*ForMaskedLM"),dp.forEach(t),mp.forEach(t),Lo=f(J),xn=i(J,"LI",{});var fp=u(xn);Pn=i(fp,"CODE",{});var hp=u(Pn);Fo=a(hp,"*ForMultipleChoice"),hp.forEach(t),fp.forEach(t),Oo=f(J),Tn=i(J,"LI",{});var _p=u(Tn);Mn=i(_p,"CODE",{});var vp=u(Mn);Vo=a(vp,"*ForQuestionAnswering"),vp.forEach(t),_p.forEach(t),Go=f(J),zn=i(J,"LI",{});var bp=u(zn);Cn=i(bp,"CODE",{});var $p=u(Cn);Ho=a($p,"*ForSequenceClassification"),$p.forEach(t),bp.forEach(t),Jo=f(J),Nn=i(J,"LI",{});var Ep=u(Nn);In=i(Ep,"CODE",{});var gp=u(In);Uo=a(gp,"*ForTokenClassification"),gp.forEach(t),Ep.forEach(t),Bo=f(J),An=i(J,"LI",{});var kp=u(An);Ro=a(kp,"et autres \u{1F917}"),kp.forEach(t),J.forEach(t),Pl=f(e),me.l(e),st=f(e),tt=i(e,"P",{});var jp=u(tt);Qo=a(jp,"Maintenant, si nous examinons la forme de nos entr\xE9es, la dimensionnalit\xE9 est beaucoup plus faible. La t\xEAte du mod\xE8le prend en entr\xE9e les vecteurs de grande dimension que nous avons vus pr\xE9c\xE9demment et elle produit des vecteurs contenant deux valeurs (une par \xE9tiquette) :"),jp.forEach(t),Tl=f(e),x(Es.$$.fragment,e),Ml=f(e),fe.l(e),nt=f(e),lt=i(e,"P",{});var qp=u(lt);Yo=a(qp,"Comme nous n\u2019avons que deux phrases et deux \xE9tiquettes, le r\xE9sultat que nous obtenons est de forme 2 x 2"),qp.forEach(t),zl=f(e),Le=i(e,"H2",{class:!0});var sr=u(Le);Ye=i(sr,"A",{id:!0,class:!0,href:!0});var wp=u(Ye);Dn=i(wp,"SPAN",{});var yp=u(Dn);x(gs.$$.fragment,yp),yp.forEach(t),wp.forEach(t),Wo=f(sr),Sn=i(sr,"SPAN",{});var xp=u(Sn);Xo=a(xp,"Post-traitement de la sortie"),xp.forEach(t),sr.forEach(t),Cl=f(e),rt=i(e,"P",{});var Pp=u(rt);Ko=a(Pp,"Les valeurs que nous obtenons en sortie de notre mod\xE8le n\u2019ont pas n\xE9cessairement de sens en elles-m\xEAmes. Jetons-y un coup d\u2019\u0153il  :"),Pp.forEach(t),Nl=f(e),x(ks.$$.fragment,e),Il=f(e),_e.l(e),at=f(e),H=i(e,"P",{});var te=u(H);Zo=a(te,"Notre mod\xE8le a pr\xE9dit "),Ln=i(te,"CODE",{});var Tp=u(Ln);ei=a(Tp,"[-1.5607, 1.6123]"),Tp.forEach(t),si=a(te," pour la premi\xE8re phrase et "),Fn=i(te,"CODE",{});var Mp=u(Fn);ti=a(Mp,"[ 4.1692, -3.3464]"),Mp.forEach(t),ni=a(te," pour la seconde. Ce ne sont pas des probabilit\xE9s mais des "),On=i(te,"EM",{});var zp=u(On);li=a(zp,"logits"),zp.forEach(t),ri=a(te,", les scores bruts, non normalis\xE9s, produits par la derni\xE8re couche du mod\xE8le. Pour \xEAtre convertis en probabilit\xE9s, ils doivent passer par une couche "),js=i(te,"A",{href:!0,rel:!0});var Cp=u(js);ai=a(Cp,"SoftMax"),Cp.forEach(t),oi=a(te," (tous les mod\xE8les de la biblioth\xE8que \u{1F917} "),Vn=i(te,"EM",{});var Np=u(Vn);ii=a(Np,"Transformers"),Np.forEach(t),ui=a(te," sortent les logits car la fonction de perte de l\u2019entra\xEEnement fusionne g\xE9n\xE9ralement la derni\xE8re fonction d\u2019activation, comme la SoftMax, avec la fonction de perte r\xE9elle, comme l\u2019entropie crois\xE9e) :"),te.forEach(t),Al=f(e),be.l(e),ot=f(e),Ee.l(e),it=f(e),xe=i(e,"P",{});var gt=u(xe);pi=a(gt,"Maintenant nous pouvons voir que le mod\xE8le a pr\xE9dit "),Gn=i(gt,"CODE",{});var Ip=u(Gn);ci=a(Ip,"[0.0402, 0.9598]"),Ip.forEach(t),mi=a(gt," pour la premi\xE8re phrase et "),Hn=i(gt,"CODE",{});var Ap=u(Hn);di=a(Ap,"[0.9995, 0.0005]"),Ap.forEach(t),fi=a(gt," pour la seconde. Ce sont des scores de probabilit\xE9 reconnaissables."),gt.forEach(t),Dl=f(e),We=i(e,"P",{});var tr=u(We);hi=a(tr,"Pour obtenir les \xE9tiquettes correspondant \xE0 chaque position, nous pouvons inspecter l\u2019attribut "),Jn=i(tr,"CODE",{});var Dp=u(Jn);_i=a(Dp,"id2label"),Dp.forEach(t),vi=a(tr," de la configuration du mod\xE8le (plus de d\xE9tails dans la section suivante) :"),tr.forEach(t),Sl=f(e),x(qs.$$.fragment,e),Ll=f(e),x(ws.$$.fragment,e),Fl=f(e),ut=i(e,"P",{});var Sp=u(ut);bi=a(Sp,"Nous pouvons maintenant conclure que le mod\xE8le a pr\xE9dit ce qui suit :"),Sp.forEach(t),Ol=f(e),Xe=i(e,"UL",{});var nr=u(Xe);Un=i(nr,"LI",{});var Lp=u(Un);$i=a(Lp,"premi\xE8re phrase : NEGATIVE: 0.0402, POSITIVE: 0.9598"),Lp.forEach(t),Ei=f(nr),Bn=i(nr,"LI",{});var Fp=u(Bn);gi=a(Fp,"deuxi\xE8me phrase : NEGATIVE: 0.9995, POSITIVE: 0.0005"),Fp.forEach(t),nr.forEach(t),Vl=f(e),Ke=i(e,"P",{});var lr=u(Ke);ki=a(lr,"Nous avons reproduit avec succ\xE8s les trois \xE9tapes du pipeline : pr\xE9traitement avec les "),Rn=i(lr,"EM",{});var Op=u(Rn);ji=a(Op,"tokenizers"),Op.forEach(t),qi=a(lr,", passage des entr\xE9es dans le mod\xE8le et post-traitement ! Prenons maintenant le temps de nous plonger plus profond\xE9ment dans chacune de ces \xE9tapes."),lr.forEach(t),Gl=f(e),x(Ze.$$.fragment,e),this.h()},h(){k(n,"name","hf:doc:metadata"),k(n,"content",JSON.stringify(gc)),k(_,"id","derrire-le-pipeline"),k(_,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),k(_,"href","#derrire-le-pipeline"),k(v,"class","relative group"),k(K,"href","/course/chapter1"),k(Fs,"href","/course/fr/chapter1"),k(os,"class","block dark:hidden"),rr(os.src,zi="https://huggingface.co/datasets/huggingface-course/documentation-images/resolve/main/en/chapter2/full_nlp_pipeline.svg")||k(os,"src",zi),k(os,"alt","The full NLP pipeline: tokenization of text, conversion to IDs, and inference through the Transformer model and the model head."),k(is,"class","hidden dark:block"),rr(is.src,Ci="https://huggingface.co/datasets/huggingface-course/documentation-images/resolve/main/en/chapter2/full_nlp_pipeline-dark.svg")||k(is,"src",Ci),k(is,"alt","The full NLP pipeline: tokenization of text, conversion to IDs, and inference through the Transformer model and the model head."),k(Ce,"class","flex justify-center"),k(Oe,"id","prtraitement-avec-un-itokenizeri"),k(Oe,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),k(Oe,"href","#prtraitement-avec-un-itokenizeri"),k(Ne,"class","relative group"),k(ms,"href","https://huggingface.co/models"),k(ms,"rel","nofollow"),k(ds,"href","https://huggingface.co/distilbert-base-uncased-finetuned-sst-2-english"),k(ds,"rel","nofollow"),k(Je,"id","passage-au-modle"),k(Je,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),k(Je,"href","#passage-au-modle"),k(Ie,"class","relative group"),k(Rs,"href","/course/fr/chapter1"),k(Be,"id","un-vecteur-de-grande-dimension"),k(Be,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),k(Be,"href","#un-vecteur-de-grande-dimension"),k(Ae,"class","relative group"),k(Qe,"id","les-ttes-des-modles-donner-du-sens-aux-chiffres"),k(Qe,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),k(Qe,"href","#les-ttes-des-modles-donner-du-sens-aux-chiffres"),k(De,"class","relative group"),k(bs,"class","block dark:hidden"),rr(bs.src,Ni="https://huggingface.co/datasets/huggingface-course/documentation-images/resolve/main/en/chapter2/transformer_and_head.svg")||k(bs,"src",Ni),k(bs,"alt","A Transformer network alongside its head."),k($s,"class","hidden dark:block"),rr($s.src,Ii="https://huggingface.co/datasets/huggingface-course/documentation-images/resolve/main/en/chapter2/transformer_and_head-dark.svg")||k($s,"src",Ii),k($s,"alt","A Transformer network alongside its head."),k(Se,"class","flex justify-center"),k(Ye,"id","posttraitement-de-la-sortie"),k(Ye,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),k(Ye,"href","#posttraitement-de-la-sortie"),k(Le,"class","relative group"),k(js,"href","https://fr.wikipedia.org/wiki/Fonction_softmax"),k(js,"rel","nofollow")},m(e,p){s(document.head,n),m(e,c,p),P(l,e,p),m(e,h,p),m(e,v,p),s(v,_),s(_,M),P(N,M,null),s(v,C),s(v,z),s(z,D),m(e,g,p),ys[q].m(e,p),m(e,L,p),P(S,e,p),m(e,U,p),xs[j].m(e,p),m(e,X,p),m(e,B,p),s(B,ze),s(B,K),s(K,ar),s(B,or),m(e,Wn,p),P(rs,e,p),m(e,Xn,p),m(e,Ls,p),s(Ls,ir),m(e,Kn,p),P(as,e,p),m(e,Zn,p),m(e,Fe,p),s(Fe,ur),s(Fe,Fs),s(Fs,pr),s(Fe,cr),m(e,el,p),m(e,Ce,p),s(Ce,os),s(Ce,mr),s(Ce,is),m(e,sl,p),m(e,Os,p),s(Os,dr),m(e,tl,p),m(e,Ne,p),s(Ne,Oe),s(Oe,jt),P(us,jt,null),s(Ne,fr),s(Ne,Vs),s(Vs,hr),s(Vs,qt),s(qt,_r),m(e,nl,p),m(e,je,p),s(je,vr),s(je,wt),s(wt,br),s(je,$r),s(je,yt),s(yt,Er),s(je,gr),m(e,ll,p),m(e,qe,p),s(qe,ps),s(ps,kr),s(ps,xt),s(xt,jr),s(ps,qr),s(qe,wr),s(qe,cs),s(cs,yr),s(cs,Pt),s(Pt,xr),s(cs,Pr),s(qe,Tr),s(qe,Tt),s(Tt,Mr),m(e,rl,p),m(e,V,p),s(V,zr),s(V,ms),s(ms,Mt),s(Mt,Cr),s(V,Nr),s(V,zt),s(zt,Ir),s(V,Ar),s(V,Ct),s(Ct,Dr),s(V,Sr),s(V,Nt),s(Nt,Lr),s(V,Fr),s(V,It),s(It,Or),s(V,Vr),m(e,al,p),m(e,R,p),s(R,Gr),s(R,At),s(At,Hr),s(R,Jr),s(R,Dt),s(Dt,Ur),s(R,Br),s(R,St),s(St,Rr),s(R,Qr),s(R,ds),s(ds,Yr),s(R,Wr),m(e,ol,p),P(fs,e,p),m(e,il,p),m(e,Ve,p),s(Ve,Xr),s(Ve,Lt),s(Lt,Kr),s(Ve,Zr),m(e,ul,p),m(e,O,p),s(O,ea),s(O,Ft),s(Ft,sa),s(O,ta),s(O,Ot),s(Ot,na),s(O,la),s(O,Vt),s(Vt,ra),s(O,aa),s(O,Gt),s(Gt,oa),s(O,ia),s(O,Ht),s(Ht,ua),s(O,pa),s(O,Jt),s(Jt,ca),s(O,ma),m(e,pl,p),m(e,Ge,p),s(Ge,da),s(Ge,Ut),s(Ut,fa),s(Ge,ha),m(e,cl,p),Ps[ne].m(e,p),m(e,Gs,p),m(e,He,p),s(He,_a),s(He,Bt),s(Bt,va),s(He,ba),m(e,ml,p),Ts[re].m(e,p),m(e,Hs,p),m(e,G,p),s(G,$a),s(G,Rt),s(Rt,Ea),s(G,ga),s(G,Qt),s(Qt,ka),s(G,ja),s(G,Yt),s(Yt,qa),s(G,wa),s(G,Wt),s(Wt,ya),s(G,xa),s(G,Xt),s(Xt,Pa),s(G,Ta),m(e,dl,p),m(e,Ie,p),s(Ie,Je),s(Je,Kt),P(hs,Kt,null),s(Ie,Ma),s(Ie,Zt),s(Zt,za),m(e,fl,p),Ms[oe].m(e,p),m(e,Js,p),m(e,Ue,p),s(Ue,Ca),s(Ue,en),s(en,Na),s(Ue,Ia),m(e,hl,p),m(e,Q,p),s(Q,Aa),s(Q,sn),s(sn,Da),s(Q,Sa),s(Q,tn),s(tn,La),s(Q,Fa),s(Q,nn),s(nn,Oa),s(Q,Va),s(Q,Us),s(Us,Ga),s(Us,ln),s(ln,Ha),s(Q,Ja),m(e,_l,p),m(e,Bs,p),s(Bs,Ua),m(e,vl,p),m(e,we,p),s(we,Ba),s(we,rn),s(rn,Ra),s(we,Qa),s(we,Rs),s(Rs,Ya),s(we,Wa),m(e,bl,p),m(e,Ae,p),s(Ae,Be),s(Be,an),P(_s,an,null),s(Ae,Xa),s(Ae,on),s(on,Ka),m(e,$l,p),m(e,Re,p),s(Re,Za),s(Re,un),s(un,eo),s(Re,so),m(e,El,p),m(e,ye,p),s(ye,Qs),s(Qs,pn),s(pn,to),s(Qs,no),s(ye,lo),s(ye,Ys),s(Ys,cn),s(cn,ro),s(Ys,ao),s(ye,oo),s(ye,Ws),s(Ws,mn),s(mn,io),s(Ws,uo),m(e,gl,p),m(e,Xs,p),s(Xs,po),m(e,kl,p),m(e,Ks,p),s(Ks,co),m(e,jl,p),zs[ue].m(e,p),m(e,Zs,p),m(e,Y,p),s(Y,mo),s(Y,dn),s(dn,fo),s(Y,ho),s(Y,fn),s(fn,_o),s(Y,vo),s(Y,hn),s(hn,bo),s(Y,$o),s(Y,_n),s(_n,Eo),s(Y,go),m(e,ql,p),m(e,De,p),s(De,Qe),s(Qe,vn),P(vs,vn,null),s(De,ko),s(De,bn),s(bn,jo),m(e,wl,p),m(e,Se,p),s(Se,bs),s(Se,qo),s(Se,$s),m(e,yl,p),m(e,Z,p),s(Z,wo),s(Z,$n),s($n,yo),s(Z,xo),s(Z,En),s(En,Po),s(Z,To),s(Z,gn),s(gn,Mo),s(Z,zo),m(e,xl,p),m(e,F,p),s(F,et),s(et,kn),s(kn,Co),s(et,No),s(F,Io),s(F,jn),s(jn,qn),s(qn,Ao),s(F,Do),s(F,wn),s(wn,yn),s(yn,So),s(F,Lo),s(F,xn),s(xn,Pn),s(Pn,Fo),s(F,Oo),s(F,Tn),s(Tn,Mn),s(Mn,Vo),s(F,Go),s(F,zn),s(zn,Cn),s(Cn,Ho),s(F,Jo),s(F,Nn),s(Nn,In),s(In,Uo),s(F,Bo),s(F,An),s(An,Ro),m(e,Pl,p),Cs[ce].m(e,p),m(e,st,p),m(e,tt,p),s(tt,Qo),m(e,Tl,p),P(Es,e,p),m(e,Ml,p),Ns[de].m(e,p),m(e,nt,p),m(e,lt,p),s(lt,Yo),m(e,zl,p),m(e,Le,p),s(Le,Ye),s(Ye,Dn),P(gs,Dn,null),s(Le,Wo),s(Le,Sn),s(Sn,Xo),m(e,Cl,p),m(e,rt,p),s(rt,Ko),m(e,Nl,p),P(ks,e,p),m(e,Il,p),Is[he].m(e,p),m(e,at,p),m(e,H,p),s(H,Zo),s(H,Ln),s(Ln,ei),s(H,si),s(H,Fn),s(Fn,ti),s(H,ni),s(H,On),s(On,li),s(H,ri),s(H,js),s(js,ai),s(H,oi),s(H,Vn),s(Vn,ii),s(H,ui),m(e,Al,p),As[ve].m(e,p),m(e,ot,p),Ds[$e].m(e,p),m(e,it,p),m(e,xe,p),s(xe,pi),s(xe,Gn),s(Gn,ci),s(xe,mi),s(xe,Hn),s(Hn,di),s(xe,fi),m(e,Dl,p),m(e,We,p),s(We,hi),s(We,Jn),s(Jn,_i),s(We,vi),m(e,Sl,p),P(qs,e,p),m(e,Ll,p),P(ws,e,p),m(e,Fl,p),m(e,ut,p),s(ut,bi),m(e,Ol,p),m(e,Xe,p),s(Xe,Un),s(Un,$i),s(Xe,Ei),s(Xe,Bn),s(Bn,gi),m(e,Vl,p),m(e,Ke,p),s(Ke,ki),s(Ke,Rn),s(Rn,ji),s(Ke,qi),m(e,Gl,p),P(Ze,e,p),Hl=!0},p(e,[p]){const Ss={};p&1&&(Ss.fw=e[0]),l.$set(Ss);let pt=q;q=Di(e),q!==pt&&(ke(),b(ys[pt],1,1,()=>{ys[pt]=null}),ge(),A=ys[q],A||(A=ys[q]=Ai[q](e),A.c()),$(A,1),A.m(L.parentNode,L));const Qn={};p&2&&(Qn.$$scope={dirty:p,ctx:e}),S.$set(Qn);let ct=j;j=Li(e),j!==ct&&(ke(),b(xs[ct],1,1,()=>{xs[ct]=null}),ge(),w=xs[j],w||(w=xs[j]=Si[j](e),w.c()),$(w,1),w.m(X.parentNode,X));let es=ne;ne=Oi(e),ne!==es&&(ke(),b(Ps[es],1,1,()=>{Ps[es]=null}),ge(),le=Ps[ne],le||(le=Ps[ne]=Fi[ne](e),le.c()),$(le,1),le.m(Gs.parentNode,Gs));let mt=re;re=Gi(e),re!==mt&&(ke(),b(Ts[mt],1,1,()=>{Ts[mt]=null}),ge(),ae=Ts[re],ae||(ae=Ts[re]=Vi[re](e),ae.c()),$(ae,1),ae.m(Hs.parentNode,Hs));let dt=oe;oe=Ji(e),oe!==dt&&(ke(),b(Ms[dt],1,1,()=>{Ms[dt]=null}),ge(),ie=Ms[oe],ie||(ie=Ms[oe]=Hi[oe](e),ie.c()),$(ie,1),ie.m(Js.parentNode,Js));let ss=ue;ue=Bi(e),ue!==ss&&(ke(),b(zs[ss],1,1,()=>{zs[ss]=null}),ge(),pe=zs[ue],pe||(pe=zs[ue]=Ui[ue](e),pe.c()),$(pe,1),pe.m(Zs.parentNode,Zs));let ft=ce;ce=Qi(e),ce!==ft&&(ke(),b(Cs[ft],1,1,()=>{Cs[ft]=null}),ge(),me=Cs[ce],me||(me=Cs[ce]=Ri[ce](e),me.c()),$(me,1),me.m(st.parentNode,st));let ts=de;de=Wi(e),de!==ts&&(ke(),b(Ns[ts],1,1,()=>{Ns[ts]=null}),ge(),fe=Ns[de],fe||(fe=Ns[de]=Yi[de](e),fe.c()),$(fe,1),fe.m(nt.parentNode,nt));let ht=he;he=Ki(e),he!==ht&&(ke(),b(Is[ht],1,1,()=>{Is[ht]=null}),ge(),_e=Is[he],_e||(_e=Is[he]=Xi[he](e),_e.c()),$(_e,1),_e.m(at.parentNode,at));let ns=ve;ve=eu(e),ve!==ns&&(ke(),b(As[ns],1,1,()=>{As[ns]=null}),ge(),be=As[ve],be||(be=As[ve]=Zi[ve](e),be.c()),$(be,1),be.m(ot.parentNode,ot));let _t=$e;$e=tu(e),$e!==_t&&(ke(),b(Ds[_t],1,1,()=>{Ds[_t]=null}),ge(),Ee=Ds[$e],Ee||(Ee=Ds[$e]=su[$e](e),Ee.c()),$(Ee,1),Ee.m(it.parentNode,it));const Yn={};p&2&&(Yn.$$scope={dirty:p,ctx:e}),Ze.$set(Yn)},i(e){Hl||($(l.$$.fragment,e),$(N.$$.fragment,e),$(A),$(S.$$.fragment,e),$(w),$(rs.$$.fragment,e),$(as.$$.fragment,e),$(us.$$.fragment,e),$(fs.$$.fragment,e),$(le),$(ae),$(hs.$$.fragment,e),$(ie),$(_s.$$.fragment,e),$(pe),$(vs.$$.fragment,e),$(me),$(Es.$$.fragment,e),$(fe),$(gs.$$.fragment,e),$(ks.$$.fragment,e),$(_e),$(be),$(Ee),$(qs.$$.fragment,e),$(ws.$$.fragment,e),$(Ze.$$.fragment,e),Hl=!0)},o(e){b(l.$$.fragment,e),b(N.$$.fragment,e),b(A),b(S.$$.fragment,e),b(w),b(rs.$$.fragment,e),b(as.$$.fragment,e),b(us.$$.fragment,e),b(fs.$$.fragment,e),b(le),b(ae),b(hs.$$.fragment,e),b(ie),b(_s.$$.fragment,e),b(pe),b(vs.$$.fragment,e),b(me),b(Es.$$.fragment,e),b(fe),b(gs.$$.fragment,e),b(ks.$$.fragment,e),b(_e),b(be),b(Ee),b(qs.$$.fragment,e),b(ws.$$.fragment,e),b(Ze.$$.fragment,e),Hl=!1},d(e){t(n),e&&t(c),T(l,e),e&&t(h),e&&t(v),T(N),e&&t(g),ys[q].d(e),e&&t(L),T(S,e),e&&t(U),xs[j].d(e),e&&t(X),e&&t(B),e&&t(Wn),T(rs,e),e&&t(Xn),e&&t(Ls),e&&t(Kn),T(as,e),e&&t(Zn),e&&t(Fe),e&&t(el),e&&t(Ce),e&&t(sl),e&&t(Os),e&&t(tl),e&&t(Ne),T(us),e&&t(nl),e&&t(je),e&&t(ll),e&&t(qe),e&&t(rl),e&&t(V),e&&t(al),e&&t(R),e&&t(ol),T(fs,e),e&&t(il),e&&t(Ve),e&&t(ul),e&&t(O),e&&t(pl),e&&t(Ge),e&&t(cl),Ps[ne].d(e),e&&t(Gs),e&&t(He),e&&t(ml),Ts[re].d(e),e&&t(Hs),e&&t(G),e&&t(dl),e&&t(Ie),T(hs),e&&t(fl),Ms[oe].d(e),e&&t(Js),e&&t(Ue),e&&t(hl),e&&t(Q),e&&t(_l),e&&t(Bs),e&&t(vl),e&&t(we),e&&t(bl),e&&t(Ae),T(_s),e&&t($l),e&&t(Re),e&&t(El),e&&t(ye),e&&t(gl),e&&t(Xs),e&&t(kl),e&&t(Ks),e&&t(jl),zs[ue].d(e),e&&t(Zs),e&&t(Y),e&&t(ql),e&&t(De),T(vs),e&&t(wl),e&&t(Se),e&&t(yl),e&&t(Z),e&&t(xl),e&&t(F),e&&t(Pl),Cs[ce].d(e),e&&t(st),e&&t(tt),e&&t(Tl),T(Es,e),e&&t(Ml),Ns[de].d(e),e&&t(nt),e&&t(lt),e&&t(zl),e&&t(Le),T(gs),e&&t(Cl),e&&t(rt),e&&t(Nl),T(ks,e),e&&t(Il),Is[he].d(e),e&&t(at),e&&t(H),e&&t(Al),As[ve].d(e),e&&t(ot),Ds[$e].d(e),e&&t(it),e&&t(xe),e&&t(Dl),e&&t(We),e&&t(Sl),T(qs,e),e&&t(Ll),T(ws,e),e&&t(Fl),e&&t(ut),e&&t(Ol),e&&t(Xe),e&&t(Vl),e&&t(Ke),e&&t(Gl),T(Ze,e)}}}const gc={local:"derrire-le-pipeline",sections:[{local:"prtraitement-avec-un-itokenizeri",title:"Pr\xE9traitement avec un <i>tokenizer</i>"},{local:"passage-au-modle",sections:[{local:"un-vecteur-de-grande-dimension",title:"Un vecteur de grande dimension ?"},{local:"les-ttes-des-modles-donner-du-sens-aux-chiffres",title:"Les t\xEAtes des mod\xE8les : donner du sens aux chiffres"}],title:"Passage au mod\xE8le"},{local:"posttraitement-de-la-sortie",title:"Post-traitement de la sortie"}],title:"Derri\xE8re le pipeline"};function kc(E,n,c){let l="pt";return Qp(()=>{const h=new URLSearchParams(window.location.search);c(0,l=h.get("fw")||"pt")}),[l]}class Mc extends Jp{constructor(n){super();Up(this,n,kc,Ec,Bp,{})}}export{Mc as default,gc as metadata};
