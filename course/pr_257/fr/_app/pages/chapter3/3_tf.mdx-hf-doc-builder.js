import{S as Tn,i as Dn,s as Nn,e as o,k as d,w as q,t as a,M as Kn,c as l,d as t,m as c,x as b,a as i,h as n,b as $,G as s,g as u,y as E,q as g,o as j,B as w,v as Fn}from"../../chunks/vendor-hf-doc-builder.js";import{T as ht}from"../../chunks/Tip-hf-doc-builder.js";import{Y as $t}from"../../chunks/Youtube-hf-doc-builder.js";import{I as _t}from"../../chunks/IconCopyLink-hf-doc-builder.js";import{C as G}from"../../chunks/CodeBlock-hf-doc-builder.js";import{D as Ln}from"../../chunks/DocNotebookDropdown-hf-doc-builder.js";import{F as Un}from"../../chunks/FrameworkSwitchCourse-hf-doc-builder.js";function On(O){let p,k,m,z,_,f,y,x;return{c(){p=o("p"),k=a("Notez que les mod\xE8les \u{1F917} "),m=o("em"),z=a("Transformers"),_=a(" ont une capacit\xE9 sp\xE9ciale que la plupart des mod\xE8les Keras n\u2019ont pas. Ils peuvent automatiquement utiliser une perte appropri\xE9e qu\u2019ils calculent en interne. Ils utiliseront cette perte par d\xE9faut si vous ne d\xE9finissez pas un argument de perte dans "),f=o("code"),y=a("compile()"),x=a(". Notez que pour utiliser la perte interne, vous devrez passer vos labels comme faisant partie de l\u2019entr\xE9e, et non pas comme un label s\xE9par\xE9, ce qui est la fa\xE7on normale d\u2019utiliser les labels avec les mod\xE8les Keras. Vous verrez des exemples de cela dans la partie 2 du cours, o\xF9 la d\xE9finition de la fonction de perte correcte peut \xEAtre d\xE9licate. Pour la classification des s\xE9quences, cependant, une fonction de perte standard de Keras fonctionne bien, et c\u2019est donc ce que nous utiliserons ici.")},l(h){p=l(h,"P",{});var v=i(p);k=n(v,"Notez que les mod\xE8les \u{1F917} "),m=l(v,"EM",{});var A=i(m);z=n(A,"Transformers"),A.forEach(t),_=n(v," ont une capacit\xE9 sp\xE9ciale que la plupart des mod\xE8les Keras n\u2019ont pas. Ils peuvent automatiquement utiliser une perte appropri\xE9e qu\u2019ils calculent en interne. Ils utiliseront cette perte par d\xE9faut si vous ne d\xE9finissez pas un argument de perte dans "),f=l(v,"CODE",{});var C=i(f);y=n(C,"compile()"),C.forEach(t),x=n(v,". Notez que pour utiliser la perte interne, vous devrez passer vos labels comme faisant partie de l\u2019entr\xE9e, et non pas comme un label s\xE9par\xE9, ce qui est la fa\xE7on normale d\u2019utiliser les labels avec les mod\xE8les Keras. Vous verrez des exemples de cela dans la partie 2 du cours, o\xF9 la d\xE9finition de la fonction de perte correcte peut \xEAtre d\xE9licate. Pour la classification des s\xE9quences, cependant, une fonction de perte standard de Keras fonctionne bien, et c\u2019est donc ce que nous utiliserons ici."),v.forEach(t)},m(h,v){u(h,p,v),s(p,k),s(p,m),s(m,z),s(p,_),s(p,f),s(f,y),s(p,x)},d(h){h&&t(p)}}}function In(O){let p,k,m,z,_,f,y,x;return{c(){p=o("p"),k=a("Notez un pi\xE8ge tr\xE8s commun ici. Vous "),m=o("em"),z=a("pouvez"),_=a(" simplement passer le nom de la perte comme une cha\xEEne \xE0 Keras, mais par d\xE9faut Keras supposera que vous avez d\xE9j\xE0 appliqu\xE9 une fonction softmax \xE0 vos sorties. Cependant, de nombreux mod\xE8les produisent les valeurs juste avant l\u2019application de la softmax, que l\u2019on appelle aussi les "),f=o("em"),y=a("logits"),x=a(". Nous devons indiquer \xE0 la fonction de perte que c\u2019est ce que fait notre mod\xE8le, et la seule fa\xE7on de le faire est de l\u2019appeler directement, plut\xF4t que par son nom avec une cha\xEEne.")},l(h){p=l(h,"P",{});var v=i(p);k=n(v,"Notez un pi\xE8ge tr\xE8s commun ici. Vous "),m=l(v,"EM",{});var A=i(m);z=n(A,"pouvez"),A.forEach(t),_=n(v," simplement passer le nom de la perte comme une cha\xEEne \xE0 Keras, mais par d\xE9faut Keras supposera que vous avez d\xE9j\xE0 appliqu\xE9 une fonction softmax \xE0 vos sorties. Cependant, de nombreux mod\xE8les produisent les valeurs juste avant l\u2019application de la softmax, que l\u2019on appelle aussi les "),f=l(v,"EM",{});var C=i(f);y=n(C,"logits"),C.forEach(t),x=n(v,". Nous devons indiquer \xE0 la fonction de perte que c\u2019est ce que fait notre mod\xE8le, et la seule fa\xE7on de le faire est de l\u2019appeler directement, plut\xF4t que par son nom avec une cha\xEEne."),v.forEach(t)},m(h,v){u(h,p,v),s(p,k),s(p,m),s(m,z),s(p,_),s(p,f),s(f,y),s(p,x)},d(h){h&&t(p)}}}function Gn(O){let p,k,m,z,_,f,y,x,h,v,A;return{c(){p=o("p"),k=a("La biblioth\xE8que \u{1F917} "),m=o("em"),z=a("Transformers"),_=a(" poss\xE8de \xE9galement une fonction "),f=o("code"),y=a("create_optimizer()"),x=a(" qui cr\xE9era un optimiseur "),h=o("code"),v=a("AdamW"),A=a(" avec un taux d\u2019apprentissage d\xE9croissant. Il s\u2019agit d\u2019un raccourci pratique que vous verrez en d\xE9tail dans les prochaines sections du cours.")},l(C){p=l(C,"P",{});var M=i(p);k=n(M,"La biblioth\xE8que \u{1F917} "),m=l(M,"EM",{});var I=i(m);z=n(I,"Transformers"),I.forEach(t),_=n(M," poss\xE8de \xE9galement une fonction "),f=l(M,"CODE",{});var S=i(f);y=n(S,"create_optimizer()"),S.forEach(t),x=n(M," qui cr\xE9era un optimiseur "),h=l(M,"CODE",{});var P=i(h);v=n(P,"AdamW"),P.forEach(t),A=n(M," avec un taux d\u2019apprentissage d\xE9croissant. Il s\u2019agit d\u2019un raccourci pratique que vous verrez en d\xE9tail dans les prochaines sections du cours."),M.forEach(t)},m(C,M){u(C,p,M),s(p,k),s(p,m),s(m,z),s(p,_),s(p,f),s(f,y),s(p,x),s(p,h),s(h,v),s(p,A)},d(C){C&&t(p)}}}function Vn(O){let p,k,m,z,_,f,y,x,h,v,A,C,M,I;return{c(){p=o("p"),k=a("\u{1F4A1} Si vous voulez t\xE9l\xE9charger automatiquement votre mod\xE8le sur le "),m=o("em"),z=a("Hub"),_=a(" pendant l\u2019entra\xEEnement, vous pouvez passer un "),f=o("code"),y=a("PushToHubCallback"),x=a(" dans la m\xE9thode "),h=o("code"),v=a("model.fit()"),A=a(". Nous en apprendrons davantage \xE0 ce sujet au "),C=o("a"),M=a("chapitre 4"),I=a("."),this.h()},l(S){p=l(S,"P",{});var P=i(p);k=n(P,"\u{1F4A1} Si vous voulez t\xE9l\xE9charger automatiquement votre mod\xE8le sur le "),m=l(P,"EM",{});var N=i(m);z=n(N,"Hub"),N.forEach(t),_=n(P," pendant l\u2019entra\xEEnement, vous pouvez passer un "),f=l(P,"CODE",{});var Se=i(f);y=n(Se,"PushToHubCallback"),Se.forEach(t),x=n(P," dans la m\xE9thode "),h=l(P,"CODE",{});var Q=i(h);v=n(Q,"model.fit()"),Q.forEach(t),A=n(P,". Nous en apprendrons davantage \xE0 ce sujet au "),C=l(P,"A",{href:!0});var Te=i(C);M=n(Te,"chapitre 4"),Te.forEach(t),I=n(P,"."),P.forEach(t),this.h()},h(){$(C,"href","/course/fr/chapter4/3")},m(S,P){u(S,p,P),s(p,k),s(p,m),s(m,z),s(p,_),s(p,f),s(f,y),s(p,x),s(p,h),s(h,v),s(p,A),s(p,C),s(C,M),s(p,I)},d(S){S&&t(p)}}}function Hn(O){let p,k,m,z,_,f,y,x,h,v,A,C,M,I,S,P,N,Se,Q,Te,qt,ce,bt,Et,xs,De,gt,ks,me,zs,W,X,Re,fe,jt,Be,wt,Cs,Z,xt,We,kt,zt,ys,ve,Ps,Ne,Ct,As,he,Ms,V,yt,Ke,Pt,At,Ye,Mt,St,Ss,$e,Ts,ee,Tt,Fe,Dt,Nt,Ds,D,Kt,Je,Ft,Lt,Qe,Ut,Ot,Xe,It,Gt,Ze,Vt,Ht,Ns,se,Ks,_e,Fs,te,Ls,Y,ae,es,qe,Rt,ss,Bt,Us,be,Os,H,Wt,ts,Yt,Jt,as,Qt,Xt,Is,T,Zt,ns,ea,sa,rs,ta,aa,os,na,ra,ls,oa,la,is,ia,ua,Gs,Ee,Vs,ne,Hs,Le,pa,Rs,ge,Bs,re,da,us,ca,ma,Ws,je,Ys,oe,Js,J,le,ps,we,fa,ds,va,Qs,xe,Xs,R,ha,cs,$a,_a,ms,qa,ba,Zs,ke,et,ie,Ea,fs,ga,ja,st,ze,tt,Ce,at,K,wa,vs,xa,ka,hs,za,Ca,$s,ya,Pa,nt,ye,rt,Pe,ot,F,Aa,Ae,Ma,Sa,_s,Ta,Da,qs,Na,Ka,lt,L,Fa,bs,La,Ua,Ue,Oa,Ia,Es,Ga,Va,it;return m=new Un({props:{fw:O[0]}}),x=new _t({}),S=new Ln({props:{classNames:"absolute z-10 right-0 top-0",options:[{label:"Google Colab",value:"https://colab.research.google.com/github/huggingface/notebooks/blob/master/course/chapter3/section3_tf.ipynb"},{label:"Aws Studio",value:"https://studiolab.sagemaker.aws/import/github/huggingface/notebooks/blob/master/course/chapter3/section3_tf.ipynb"}]}}),me=new G({props:{code:`






`,highlighted:`<span class="hljs-keyword">from</span> datasets <span class="hljs-keyword">import</span> load_dataset
<span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> AutoTokenizer, DataCollatorWithPadding
<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np

raw_datasets = load_dataset(<span class="hljs-string">&quot;glue&quot;</span>, <span class="hljs-string">&quot;mrpc&quot;</span>)
checkpoint = <span class="hljs-string">&quot;bert-base-uncased&quot;</span>
tokenizer = AutoTokenizer.from_pretrained(checkpoint)


<span class="hljs-keyword">def</span> <span class="hljs-title function_">tokenize_function</span>(<span class="hljs-params">example</span>):
    <span class="hljs-keyword">return</span> tokenizer(example[<span class="hljs-string">&quot;sentence1&quot;</span>], example[<span class="hljs-string">&quot;sentence2&quot;</span>], truncation=<span class="hljs-literal">True</span>)


tokenized_datasets = raw_datasets.<span class="hljs-built_in">map</span>(tokenize_function, batched=<span class="hljs-literal">True</span>)

data_collator = DataCollatorWithPadding(tokenizer=tokenizer, return_tensors=<span class="hljs-string">&quot;tf&quot;</span>)

tf_train_dataset = tokenized_datasets[<span class="hljs-string">&quot;train&quot;</span>].to_tf_dataset(
    columns=[<span class="hljs-string">&quot;attention_mask&quot;</span>, <span class="hljs-string">&quot;input_ids&quot;</span>, <span class="hljs-string">&quot;token_type_ids&quot;</span>],
    label_cols=[<span class="hljs-string">&quot;labels&quot;</span>],
    shuffle=<span class="hljs-literal">True</span>,
    collate_fn=data_collator,
    batch_size=<span class="hljs-number">8</span>,
)

tf_validation_dataset = tokenized_datasets[<span class="hljs-string">&quot;validation&quot;</span>].to_tf_dataset(
    columns=[<span class="hljs-string">&quot;attention_mask&quot;</span>, <span class="hljs-string">&quot;input_ids&quot;</span>, <span class="hljs-string">&quot;token_type_ids&quot;</span>],
    label_cols=[<span class="hljs-string">&quot;labels&quot;</span>],
    shuffle=<span class="hljs-literal">False</span>,
    collate_fn=data_collator,
    batch_size=<span class="hljs-number">8</span>,
)`}}),fe=new _t({}),ve=new $t({props:{id:"rnTGBy2ax1c"}}),he=new $t({props:{id:"AUozVp78dhk"}}),$e=new G({props:{code:"",highlighted:`<span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> TFAutoModelForSequenceClassification

model = TFAutoModelForSequenceClassification.from_pretrained(checkpoint, num_labels=<span class="hljs-number">2</span>)`}}),se=new ht({props:{$$slots:{default:[On]},$$scope:{ctx:O}}}),_e=new G({props:{code:"",highlighted:`<span class="hljs-keyword">from</span> tensorflow.keras.losses <span class="hljs-keyword">import</span> SparseCategoricalCrossentropy

model.<span class="hljs-built_in">compile</span>(
    optimizer=<span class="hljs-string">&quot;adam&quot;</span>,
    loss=SparseCategoricalCrossentropy(from_logits=<span class="hljs-literal">True</span>),
    metrics=[<span class="hljs-string">&quot;accuracy&quot;</span>],
)
model.fit(
    tf_train_dataset,
    validation_data=tf_validation_dataset,
)`}}),te=new ht({props:{warning:!0,$$slots:{default:[In]},$$scope:{ctx:O}}}),qe=new _t({}),be=new $t({props:{id:"cpzq6ESSM5c"}}),Ee=new G({props:{code:`
`,highlighted:`<span class="hljs-keyword">from</span> tensorflow.keras.optimizers.schedules <span class="hljs-keyword">import</span> PolynomialDecay

batch_size = <span class="hljs-number">8</span>
num_epochs = <span class="hljs-number">3</span>
<span class="hljs-comment"># Le nombre d&#x27;\xE9tapes d&#x27;entra\xEEnement est le nombre d&#x27;\xE9chantillons dans l&#x27;ensemble de donn\xE9es, divis\xE9 par la taille du batch puis multipli\xE9</span>
<span class="hljs-comment"># par le nombre total d&#x27;\xE9poques. Notez que le jeu de donn\xE9es tf_train_dataset est ici un lot tf.data.Dataset</span>
<span class="hljs-comment"># et non le jeu de donn\xE9es original Hugging Face Dataset, donc son len() est d\xE9j\xE0 num_samples // batch_size.</span>
num_train_steps = <span class="hljs-built_in">len</span>(tf_train_dataset) * num_epochs
lr_scheduler = PolynomialDecay(
    initial_learning_rate=<span class="hljs-number">5e-5</span>, end_learning_rate=<span class="hljs-number">0.0</span>, decay_steps=num_train_steps
)
<span class="hljs-keyword">from</span> tensorflow.keras.optimizers <span class="hljs-keyword">import</span> Adam

opt = Adam(learning_rate=lr_scheduler)`}}),ne=new ht({props:{$$slots:{default:[Gn]},$$scope:{ctx:O}}}),ge=new G({props:{code:"",highlighted:`<span class="hljs-keyword">import</span> tensorflow <span class="hljs-keyword">as</span> tf

model = TFAutoModelForSequenceClassification.from_pretrained(checkpoint, num_labels=<span class="hljs-number">2</span>)
loss = tf.keras.losses.SparseCategoricalCrossentropy(from_logits=<span class="hljs-literal">True</span>)
model.<span class="hljs-built_in">compile</span>(optimizer=opt, loss=loss, metrics=[<span class="hljs-string">&quot;accuracy&quot;</span>])`}}),je=new G({props:{code:"model.fit(tf_train_dataset, validation_data=tf_validation_dataset, epochs=3)",highlighted:'model.fit(tf_train_dataset, validation_data=tf_validation_dataset, epochs=<span class="hljs-number">3</span>)'}}),oe=new ht({props:{$$slots:{default:[Vn]},$$scope:{ctx:O}}}),we=new _t({}),xe=new $t({props:{id:"nx10eh4CoOs"}}),ke=new G({props:{code:'preds = model.predict(tf_validation_dataset)["logits"]',highlighted:'preds = model.predict(tf_validation_dataset)[<span class="hljs-string">&quot;logits&quot;</span>]'}}),ze=new G({props:{code:`class_preds = np.argmax(preds, axis=1)
print(preds.shape, class_preds.shape)`,highlighted:`class_preds = np.argmax(preds, axis=<span class="hljs-number">1</span>)
<span class="hljs-built_in">print</span>(preds.shape, class_preds.shape)`}}),Ce=new G({props:{code:"(408, 2) (408,)",highlighted:'(<span class="hljs-number">408</span>, <span class="hljs-number">2</span>) (<span class="hljs-number">408</span>,)'}}),ye=new G({props:{code:"",highlighted:`<span class="hljs-keyword">from</span> datasets <span class="hljs-keyword">import</span> load_metric

metric = load_metric(<span class="hljs-string">&quot;glue&quot;</span>, <span class="hljs-string">&quot;mrpc&quot;</span>)
metric.compute(predictions=class_preds, references=raw_datasets[<span class="hljs-string">&quot;validation&quot;</span>][<span class="hljs-string">&quot;label&quot;</span>])`}}),Pe=new G({props:{code:"{'accuracy': 0.8578431372549019, 'f1': 0.8996539792387542}",highlighted:'{<span class="hljs-string">&#x27;accuracy&#x27;</span>: <span class="hljs-number">0.8578431372549019</span>, <span class="hljs-string">&#x27;f1&#x27;</span>: <span class="hljs-number">0.8996539792387542</span>}'}}),{c(){p=o("meta"),k=d(),q(m.$$.fragment),z=d(),_=o("h1"),f=o("a"),y=o("span"),q(x.$$.fragment),h=d(),v=o("span"),A=o("i"),C=a("Finetuner"),M=a(" un mod\xE8le avec Keras"),I=d(),q(S.$$.fragment),P=d(),N=o("p"),Se=a("Une fois que vous avez fait tout le travail de pr\xE9traitement des donn\xE9es dans la derni\xE8re section, il ne vous reste que quelques \xE9tapes pour entra\xEEner le mod\xE8le. Notez, cependant, que la commande "),Q=o("code"),Te=a("model.fit()"),qt=a(" s\u2019ex\xE9cutera tr\xE8s lentement sur un CPU. Si vous n\u2019avez pas de GPU, vous pouvez avoir acc\xE8s \xE0 des GPUs ou TPUs gratuits sur "),ce=o("a"),bt=a("Google Colab"),Et=a("."),xs=d(),De=o("p"),gt=a("Les exemples de code ci-dessous supposent que vous avez d\xE9j\xE0 ex\xE9cut\xE9 les exemples de la section pr\xE9c\xE9dente. Voici un bref r\xE9sum\xE9 de ce dont vous avez besoin :"),ks=d(),q(me.$$.fragment),zs=d(),W=o("h3"),X=o("a"),Re=o("span"),q(fe.$$.fragment),jt=d(),Be=o("span"),wt=a("Entra\xEEnement"),Cs=d(),Z=o("p"),xt=a("Les mod\xE8les TensorFlow import\xE9s depuis \u{1F917} "),We=o("em"),kt=a("Transformers"),zt=a(" sont d\xE9j\xE0 des mod\xE8les Keras. Voici une courte introduction \xE0 Keras."),ys=d(),q(ve.$$.fragment),Ps=d(),Ne=o("p"),Ct=a("Cela signifie qu\u2019une fois que nous disposons de nos donn\xE9es, tr\xE8s peu de travail est n\xE9cessaire pour commencer \xE0 entra\xEEner sur celles-ci."),As=d(),q(he.$$.fragment),Ms=d(),V=o("p"),yt=a("Comme dans le "),Ke=o("a"),Pt=a("chapitre pr\xE9c\xE9dent"),At=a(", nous allons utiliser la classe "),Ye=o("code"),Mt=a("TFAutoModelForSequenceClassification"),St=a(", avec deux \xE9tiquettes :"),Ss=d(),q($e.$$.fragment),Ts=d(),ee=o("p"),Tt=a("Vous remarquerez que, contrairement au "),Fe=o("a"),Dt=a("chapitre 2"),Nt=a(", vous obtenez un message d\u2019avertissement apr\xE8s l\u2019instanciation de ce mod\xE8le pr\xE9-entra\xEEn\xE9. Ceci est d\xFB au fait que BERT n\u2019a pas \xE9t\xE9 pr\xE9-entra\xEEn\xE9 \xE0 la classification de paires de phrases, donc la t\xEAte du mod\xE8le pr\xE9-entra\xEEn\xE9 a \xE9t\xE9 supprim\xE9e et une nouvelle t\xEAte adapt\xE9e \xE0 la classification de s\xE9quences a \xE9t\xE9 ins\xE9r\xE9e \xE0 la place. Les messages d\u2019avertissement indiquent que certains poids n\u2019ont pas \xE9t\xE9 utilis\xE9s (ceux correspondant \xE0 la t\xEAte de pr\xE9-entra\xEEnement abandonn\xE9e) et que d\u2019autres ont \xE9t\xE9 initialis\xE9s de mani\xE8re al\xE9atoire (ceux pour la nouvelle t\xEAte). Il conclut en vous encourageant \xE0 entra\xEEner le mod\xE8le, ce qui est exactement ce que nous allons faire maintenant."),Ds=d(),D=o("p"),Kt=a("Pour "),Je=o("em"),Ft=a("finetuner"),Lt=a(" le mod\xE8le sur notre jeu de donn\xE9es, nous devons simplement "),Qe=o("code"),Ut=a("compiler()"),Ot=a(" notre mod\xE8le et ensuite passer nos donn\xE9es \xE0 la m\xE9thode "),Xe=o("code"),It=a("fit()"),Gt=a(". Cela va d\xE9marrer le processus de "),Ze=o("em"),Vt=a("finetuning"),Ht=a(" (qui devrait prendre quelques minutes sur un GPU) et rapporter la perte d\u2019entra\xEEnement au fur et \xE0 mesure, plus la perte de validation \xE0 la fin de chaque \xE9poque."),Ns=d(),q(se.$$.fragment),Ks=d(),q(_e.$$.fragment),Fs=d(),q(te.$$.fragment),Ls=d(),Y=o("h3"),ae=o("a"),es=o("span"),q(qe.$$.fragment),Rt=d(),ss=o("span"),Bt=a("Am\xE9liorer les performances d'entra\xEEnement"),Us=d(),q(be.$$.fragment),Os=d(),H=o("p"),Wt=a("Si vous essayez le code ci-dessus, il fonctionne certainement, mais vous constaterez que la perte ne diminue que lentement ou sporadiquement. La cause principale est le "),ts=o("em"),Yt=a("taux d\u2019apprentissage"),Jt=a(". Comme pour la perte, lorsque nous transmettons \xE0 Keras le nom d\u2019un optimiseur sous forme de cha\xEEne de caract\xE8res, Keras initialise cet optimiseur avec des valeurs par d\xE9faut pour tous les param\xE8tres, y compris le taux d\u2019apprentissage. Cependant, nous savons depuis longtemps que les "),as=o("em"),Qt=a("transformers"),Xt=a(" b\xE9n\xE9ficient d\u2019un taux d\u2019apprentissage beaucoup plus faible que celui par d\xE9faut d\u2019Adam, qui est de 1e-3, \xE9galement \xE9crit comme 10 \xE0 la puissance -3, ou 0,001. 5e-5 (0,00005), qui est environ vingt fois inf\xE9rieur, est un bien meilleur point de d\xE9part."),Is=d(),T=o("p"),Zt=a("En plus de r\xE9duire le taux d\u2019apprentissage, nous avons une deuxi\xE8me astuce dans notre manche : nous pouvons r\xE9duire lentement le taux d\u2019apprentissage au cours de l\u2019entra\xEEnement. Dans la litt\xE9rature, on parle parfois de "),ns=o("em"),ea=a("d\xE9croissance"),sa=a(" ou d\u2019"),rs=o("em"),ta=a("annulation"),aa=a(" du taux d\u2019apprentissage.le taux d\u2019apprentissage. Dans Keras, la meilleure fa\xE7on de le faire est d\u2019utiliser un "),os=o("em"),na=a("planificateur du taux d\u2019apprentissage"),ra=a(". Un bon planificateur \xE0 utiliser est "),ls=o("code"),oa=a("PolynomialDecay"),la=a(". Malgr\xE9 son nom, avec les param\xE8tres par d\xE9faut, il diminue simplement de fa\xE7on lin\xE9aire le taux d\u2019apprentissage de la valeur initiale \xE0 la valeur finale au cours de l\u2019entra\xEEnement, ce qui est exactement ce que nous voulons. Afin d\u2019utiliser correctement un planificateur, nous devons lui dire combien de temps l\u2019entra\xEEnement va durer. Nous calculons cela comme "),is=o("code"),ia=a("num_train_steps"),ua=a(" ci-dessous."),Gs=d(),q(Ee.$$.fragment),Vs=d(),q(ne.$$.fragment),Hs=d(),Le=o("p"),pa=a("Nous avons maintenant notre tout nouvel optimiseur et nous pouvons essayer de nous entra\xEEner avec lui. Tout d\u2019abord, rechargeons le mod\xE8le pour r\xE9initialiser les modifications apport\xE9es aux poids lors de l\u2019entra\xEEnement que nous venons d\u2019effectuer, puis nous pouvons le compiler avec le nouvel optimiseur :"),Rs=d(),q(ge.$$.fragment),Bs=d(),re=o("p"),da=a("Maintenant, on "),us=o("em"),ca=a("fit"),ma=a(" :"),Ws=d(),q(je.$$.fragment),Ys=d(),q(oe.$$.fragment),Js=d(),J=o("h3"),le=o("a"),ps=o("span"),q(we.$$.fragment),fa=d(),ds=o("span"),va=a("Pr\xE9dictions du mod\xE8le"),Qs=d(),q(xe.$$.fragment),Xs=d(),R=o("p"),ha=a("Entra\xEEner et regarder la perte diminuer, c\u2019est tr\xE8s bien, mais que faire si l\u2019on veut r\xE9ellement obtenir des r\xE9sultats du mod\xE8le entra\xEEn\xE9, soit pour calculer des m\xE9triques, soit pour utiliser le mod\xE8le en production ? Pour ce faire, nous pouvons simplement utiliser la m\xE9thode "),cs=o("code"),$a=a("predict()"),_a=a(". Ceci retournera les "),ms=o("em"),qa=a("logits"),ba=a(" de la t\xEAte de sortie du mod\xE8le, un par classe."),Zs=d(),q(ke.$$.fragment),et=d(),ie=o("p"),Ea=a("Nous pouvons convertir ces logits en pr\xE9dictions de classe du mod\xE8le en utilisant "),fs=o("code"),ga=a("argmax"),ja=a(" pour trouver le logit le plus \xE9lev\xE9, qui correspond \xE0 la classe la plus probable :"),st=d(),q(ze.$$.fragment),tt=d(),q(Ce.$$.fragment),at=d(),K=o("p"),wa=a("Maintenant, utilisons ces "),vs=o("code"),xa=a("preds"),ka=a(" pour calculer des m\xE9triques ! Nous pouvons charger les m\xE9triques associ\xE9es au jeu de donn\xE9es MRPC aussi facilement que nous avons charg\xE9 le jeu de donn\xE9es, cette fois avec la fonction "),hs=o("code"),za=a("load_metric()"),Ca=a(". L\u2019objet retourn\xE9 a une m\xE9thode "),$s=o("code"),ya=a("compute()"),Pa=a(" que nous pouvons utiliser pour faire le calcul de la m\xE9trique :"),nt=d(),q(ye.$$.fragment),rt=d(),q(Pe.$$.fragment),ot=d(),F=o("p"),Aa=a("Les r\xE9sultats exacts que vous obtiendrez peuvent varier, car l\u2019initialisation al\xE9atoire de la t\xEAte du mod\xE8le peut modifier les m\xE9triques obtenues. Ici, nous pouvons voir que notre mod\xE8le a une pr\xE9cision de 85,78% sur l\u2019ensemble de validation et un score F1 de 89,97. Ce sont les deux m\xE9triques utilis\xE9es pour \xE9valuer les r\xE9sultats sur le jeu de donn\xE9es MRPC pour le benchmark GLUE. Le tableau du papier de "),Ae=o("a"),Ma=a("BERT"),Sa=a(" indique un score F1 de 88,9 pour le mod\xE8le de base. Il s\u2019agissait du mod\xE8le "),_s=o("code"),Ta=a("uncased"),Da=a(" alors que nous utilisons actuellement le mod\xE8le "),qs=o("code"),Na=a("cased"),Ka=a(", ce qui explique le meilleur r\xE9sultat."),lt=d(),L=o("p"),Fa=a("Ceci conclut l\u2019introduction \xE0 le "),bs=o("em"),La=a("finetuning"),Ua=a(" en utilisant l\u2019API Keras. Un exemple d\u2019application de cette m\xE9thode aux t\xE2ches les plus courantes du traitement automatique des langues sera pr\xE9sent\xE9 au "),Ue=o("a"),Oa=a("chapitre 7"),Ia=a(". Si vous souhaitez affiner vos connaissances de l\u2019API Keras, essayez "),Es=o("em"),Ga=a("finetuner"),Va=a(" un mod\xE8le sur le jeu de donn\xE9es GLUE SST-2, en utilisant le traitement des donn\xE9es que vous avez effectu\xE9 dans la section 2."),this.h()},l(e){const r=Kn('[data-svelte="svelte-1phssyn"]',document.head);p=l(r,"META",{name:!0,content:!0}),r.forEach(t),k=c(e),b(m.$$.fragment,e),z=c(e),_=l(e,"H1",{class:!0});var Me=i(_);f=l(Me,"A",{id:!0,class:!0,href:!0});var gs=i(f);y=l(gs,"SPAN",{});var js=i(y);b(x.$$.fragment,js),js.forEach(t),gs.forEach(t),h=c(Me),v=l(Me,"SPAN",{});var Oe=i(v);A=l(Oe,"I",{});var ws=i(A);C=n(ws,"Finetuner"),ws.forEach(t),M=n(Oe," un mod\xE8le avec Keras"),Oe.forEach(t),Me.forEach(t),I=c(e),b(S.$$.fragment,e),P=c(e),N=l(e,"P",{});var Ie=i(N);Se=n(Ie,"Une fois que vous avez fait tout le travail de pr\xE9traitement des donn\xE9es dans la derni\xE8re section, il ne vous reste que quelques \xE9tapes pour entra\xEEner le mod\xE8le. Notez, cependant, que la commande "),Q=l(Ie,"CODE",{});var Ha=i(Q);Te=n(Ha,"model.fit()"),Ha.forEach(t),qt=n(Ie," s\u2019ex\xE9cutera tr\xE8s lentement sur un CPU. Si vous n\u2019avez pas de GPU, vous pouvez avoir acc\xE8s \xE0 des GPUs ou TPUs gratuits sur "),ce=l(Ie,"A",{href:!0,rel:!0});var Ra=i(ce);bt=n(Ra,"Google Colab"),Ra.forEach(t),Et=n(Ie,"."),Ie.forEach(t),xs=c(e),De=l(e,"P",{});var Ba=i(De);gt=n(Ba,"Les exemples de code ci-dessous supposent que vous avez d\xE9j\xE0 ex\xE9cut\xE9 les exemples de la section pr\xE9c\xE9dente. Voici un bref r\xE9sum\xE9 de ce dont vous avez besoin :"),Ba.forEach(t),ks=c(e),b(me.$$.fragment,e),zs=c(e),W=l(e,"H3",{class:!0});var ut=i(W);X=l(ut,"A",{id:!0,class:!0,href:!0});var Wa=i(X);Re=l(Wa,"SPAN",{});var Ya=i(Re);b(fe.$$.fragment,Ya),Ya.forEach(t),Wa.forEach(t),jt=c(ut),Be=l(ut,"SPAN",{});var Ja=i(Be);wt=n(Ja,"Entra\xEEnement"),Ja.forEach(t),ut.forEach(t),Cs=c(e),Z=l(e,"P",{});var pt=i(Z);xt=n(pt,"Les mod\xE8les TensorFlow import\xE9s depuis \u{1F917} "),We=l(pt,"EM",{});var Qa=i(We);kt=n(Qa,"Transformers"),Qa.forEach(t),zt=n(pt," sont d\xE9j\xE0 des mod\xE8les Keras. Voici une courte introduction \xE0 Keras."),pt.forEach(t),ys=c(e),b(ve.$$.fragment,e),Ps=c(e),Ne=l(e,"P",{});var Xa=i(Ne);Ct=n(Xa,"Cela signifie qu\u2019une fois que nous disposons de nos donn\xE9es, tr\xE8s peu de travail est n\xE9cessaire pour commencer \xE0 entra\xEEner sur celles-ci."),Xa.forEach(t),As=c(e),b(he.$$.fragment,e),Ms=c(e),V=l(e,"P",{});var Ge=i(V);yt=n(Ge,"Comme dans le "),Ke=l(Ge,"A",{href:!0});var Za=i(Ke);Pt=n(Za,"chapitre pr\xE9c\xE9dent"),Za.forEach(t),At=n(Ge,", nous allons utiliser la classe "),Ye=l(Ge,"CODE",{});var en=i(Ye);Mt=n(en,"TFAutoModelForSequenceClassification"),en.forEach(t),St=n(Ge,", avec deux \xE9tiquettes :"),Ge.forEach(t),Ss=c(e),b($e.$$.fragment,e),Ts=c(e),ee=l(e,"P",{});var dt=i(ee);Tt=n(dt,"Vous remarquerez que, contrairement au "),Fe=l(dt,"A",{href:!0});var sn=i(Fe);Dt=n(sn,"chapitre 2"),sn.forEach(t),Nt=n(dt,", vous obtenez un message d\u2019avertissement apr\xE8s l\u2019instanciation de ce mod\xE8le pr\xE9-entra\xEEn\xE9. Ceci est d\xFB au fait que BERT n\u2019a pas \xE9t\xE9 pr\xE9-entra\xEEn\xE9 \xE0 la classification de paires de phrases, donc la t\xEAte du mod\xE8le pr\xE9-entra\xEEn\xE9 a \xE9t\xE9 supprim\xE9e et une nouvelle t\xEAte adapt\xE9e \xE0 la classification de s\xE9quences a \xE9t\xE9 ins\xE9r\xE9e \xE0 la place. Les messages d\u2019avertissement indiquent que certains poids n\u2019ont pas \xE9t\xE9 utilis\xE9s (ceux correspondant \xE0 la t\xEAte de pr\xE9-entra\xEEnement abandonn\xE9e) et que d\u2019autres ont \xE9t\xE9 initialis\xE9s de mani\xE8re al\xE9atoire (ceux pour la nouvelle t\xEAte). Il conclut en vous encourageant \xE0 entra\xEEner le mod\xE8le, ce qui est exactement ce que nous allons faire maintenant."),dt.forEach(t),Ds=c(e),D=l(e,"P",{});var B=i(D);Kt=n(B,"Pour "),Je=l(B,"EM",{});var tn=i(Je);Ft=n(tn,"finetuner"),tn.forEach(t),Lt=n(B," le mod\xE8le sur notre jeu de donn\xE9es, nous devons simplement "),Qe=l(B,"CODE",{});var an=i(Qe);Ut=n(an,"compiler()"),an.forEach(t),Ot=n(B," notre mod\xE8le et ensuite passer nos donn\xE9es \xE0 la m\xE9thode "),Xe=l(B,"CODE",{});var nn=i(Xe);It=n(nn,"fit()"),nn.forEach(t),Gt=n(B,". Cela va d\xE9marrer le processus de "),Ze=l(B,"EM",{});var rn=i(Ze);Vt=n(rn,"finetuning"),rn.forEach(t),Ht=n(B," (qui devrait prendre quelques minutes sur un GPU) et rapporter la perte d\u2019entra\xEEnement au fur et \xE0 mesure, plus la perte de validation \xE0 la fin de chaque \xE9poque."),B.forEach(t),Ns=c(e),b(se.$$.fragment,e),Ks=c(e),b(_e.$$.fragment,e),Fs=c(e),b(te.$$.fragment,e),Ls=c(e),Y=l(e,"H3",{class:!0});var ct=i(Y);ae=l(ct,"A",{id:!0,class:!0,href:!0});var on=i(ae);es=l(on,"SPAN",{});var ln=i(es);b(qe.$$.fragment,ln),ln.forEach(t),on.forEach(t),Rt=c(ct),ss=l(ct,"SPAN",{});var un=i(ss);Bt=n(un,"Am\xE9liorer les performances d'entra\xEEnement"),un.forEach(t),ct.forEach(t),Us=c(e),b(be.$$.fragment,e),Os=c(e),H=l(e,"P",{});var Ve=i(H);Wt=n(Ve,"Si vous essayez le code ci-dessus, il fonctionne certainement, mais vous constaterez que la perte ne diminue que lentement ou sporadiquement. La cause principale est le "),ts=l(Ve,"EM",{});var pn=i(ts);Yt=n(pn,"taux d\u2019apprentissage"),pn.forEach(t),Jt=n(Ve,". Comme pour la perte, lorsque nous transmettons \xE0 Keras le nom d\u2019un optimiseur sous forme de cha\xEEne de caract\xE8res, Keras initialise cet optimiseur avec des valeurs par d\xE9faut pour tous les param\xE8tres, y compris le taux d\u2019apprentissage. Cependant, nous savons depuis longtemps que les "),as=l(Ve,"EM",{});var dn=i(as);Qt=n(dn,"transformers"),dn.forEach(t),Xt=n(Ve," b\xE9n\xE9ficient d\u2019un taux d\u2019apprentissage beaucoup plus faible que celui par d\xE9faut d\u2019Adam, qui est de 1e-3, \xE9galement \xE9crit comme 10 \xE0 la puissance -3, ou 0,001. 5e-5 (0,00005), qui est environ vingt fois inf\xE9rieur, est un bien meilleur point de d\xE9part."),Ve.forEach(t),Is=c(e),T=l(e,"P",{});var U=i(T);Zt=n(U,"En plus de r\xE9duire le taux d\u2019apprentissage, nous avons une deuxi\xE8me astuce dans notre manche : nous pouvons r\xE9duire lentement le taux d\u2019apprentissage au cours de l\u2019entra\xEEnement. Dans la litt\xE9rature, on parle parfois de "),ns=l(U,"EM",{});var cn=i(ns);ea=n(cn,"d\xE9croissance"),cn.forEach(t),sa=n(U," ou d\u2019"),rs=l(U,"EM",{});var mn=i(rs);ta=n(mn,"annulation"),mn.forEach(t),aa=n(U," du taux d\u2019apprentissage.le taux d\u2019apprentissage. Dans Keras, la meilleure fa\xE7on de le faire est d\u2019utiliser un "),os=l(U,"EM",{});var fn=i(os);na=n(fn,"planificateur du taux d\u2019apprentissage"),fn.forEach(t),ra=n(U,". Un bon planificateur \xE0 utiliser est "),ls=l(U,"CODE",{});var vn=i(ls);oa=n(vn,"PolynomialDecay"),vn.forEach(t),la=n(U,". Malgr\xE9 son nom, avec les param\xE8tres par d\xE9faut, il diminue simplement de fa\xE7on lin\xE9aire le taux d\u2019apprentissage de la valeur initiale \xE0 la valeur finale au cours de l\u2019entra\xEEnement, ce qui est exactement ce que nous voulons. Afin d\u2019utiliser correctement un planificateur, nous devons lui dire combien de temps l\u2019entra\xEEnement va durer. Nous calculons cela comme "),is=l(U,"CODE",{});var hn=i(is);ia=n(hn,"num_train_steps"),hn.forEach(t),ua=n(U," ci-dessous."),U.forEach(t),Gs=c(e),b(Ee.$$.fragment,e),Vs=c(e),b(ne.$$.fragment,e),Hs=c(e),Le=l(e,"P",{});var $n=i(Le);pa=n($n,"Nous avons maintenant notre tout nouvel optimiseur et nous pouvons essayer de nous entra\xEEner avec lui. Tout d\u2019abord, rechargeons le mod\xE8le pour r\xE9initialiser les modifications apport\xE9es aux poids lors de l\u2019entra\xEEnement que nous venons d\u2019effectuer, puis nous pouvons le compiler avec le nouvel optimiseur :"),$n.forEach(t),Rs=c(e),b(ge.$$.fragment,e),Bs=c(e),re=l(e,"P",{});var mt=i(re);da=n(mt,"Maintenant, on "),us=l(mt,"EM",{});var _n=i(us);ca=n(_n,"fit"),_n.forEach(t),ma=n(mt," :"),mt.forEach(t),Ws=c(e),b(je.$$.fragment,e),Ys=c(e),b(oe.$$.fragment,e),Js=c(e),J=l(e,"H3",{class:!0});var ft=i(J);le=l(ft,"A",{id:!0,class:!0,href:!0});var qn=i(le);ps=l(qn,"SPAN",{});var bn=i(ps);b(we.$$.fragment,bn),bn.forEach(t),qn.forEach(t),fa=c(ft),ds=l(ft,"SPAN",{});var En=i(ds);va=n(En,"Pr\xE9dictions du mod\xE8le"),En.forEach(t),ft.forEach(t),Qs=c(e),b(xe.$$.fragment,e),Xs=c(e),R=l(e,"P",{});var He=i(R);ha=n(He,"Entra\xEEner et regarder la perte diminuer, c\u2019est tr\xE8s bien, mais que faire si l\u2019on veut r\xE9ellement obtenir des r\xE9sultats du mod\xE8le entra\xEEn\xE9, soit pour calculer des m\xE9triques, soit pour utiliser le mod\xE8le en production ? Pour ce faire, nous pouvons simplement utiliser la m\xE9thode "),cs=l(He,"CODE",{});var gn=i(cs);$a=n(gn,"predict()"),gn.forEach(t),_a=n(He,". Ceci retournera les "),ms=l(He,"EM",{});var jn=i(ms);qa=n(jn,"logits"),jn.forEach(t),ba=n(He," de la t\xEAte de sortie du mod\xE8le, un par classe."),He.forEach(t),Zs=c(e),b(ke.$$.fragment,e),et=c(e),ie=l(e,"P",{});var vt=i(ie);Ea=n(vt,"Nous pouvons convertir ces logits en pr\xE9dictions de classe du mod\xE8le en utilisant "),fs=l(vt,"CODE",{});var wn=i(fs);ga=n(wn,"argmax"),wn.forEach(t),ja=n(vt," pour trouver le logit le plus \xE9lev\xE9, qui correspond \xE0 la classe la plus probable :"),vt.forEach(t),st=c(e),b(ze.$$.fragment,e),tt=c(e),b(Ce.$$.fragment,e),at=c(e),K=l(e,"P",{});var ue=i(K);wa=n(ue,"Maintenant, utilisons ces "),vs=l(ue,"CODE",{});var xn=i(vs);xa=n(xn,"preds"),xn.forEach(t),ka=n(ue," pour calculer des m\xE9triques ! Nous pouvons charger les m\xE9triques associ\xE9es au jeu de donn\xE9es MRPC aussi facilement que nous avons charg\xE9 le jeu de donn\xE9es, cette fois avec la fonction "),hs=l(ue,"CODE",{});var kn=i(hs);za=n(kn,"load_metric()"),kn.forEach(t),Ca=n(ue,". L\u2019objet retourn\xE9 a une m\xE9thode "),$s=l(ue,"CODE",{});var zn=i($s);ya=n(zn,"compute()"),zn.forEach(t),Pa=n(ue," que nous pouvons utiliser pour faire le calcul de la m\xE9trique :"),ue.forEach(t),nt=c(e),b(ye.$$.fragment,e),rt=c(e),b(Pe.$$.fragment,e),ot=c(e),F=l(e,"P",{});var pe=i(F);Aa=n(pe,"Les r\xE9sultats exacts que vous obtiendrez peuvent varier, car l\u2019initialisation al\xE9atoire de la t\xEAte du mod\xE8le peut modifier les m\xE9triques obtenues. Ici, nous pouvons voir que notre mod\xE8le a une pr\xE9cision de 85,78% sur l\u2019ensemble de validation et un score F1 de 89,97. Ce sont les deux m\xE9triques utilis\xE9es pour \xE9valuer les r\xE9sultats sur le jeu de donn\xE9es MRPC pour le benchmark GLUE. Le tableau du papier de "),Ae=l(pe,"A",{href:!0,rel:!0});var Cn=i(Ae);Ma=n(Cn,"BERT"),Cn.forEach(t),Sa=n(pe," indique un score F1 de 88,9 pour le mod\xE8le de base. Il s\u2019agissait du mod\xE8le "),_s=l(pe,"CODE",{});var yn=i(_s);Ta=n(yn,"uncased"),yn.forEach(t),Da=n(pe," alors que nous utilisons actuellement le mod\xE8le "),qs=l(pe,"CODE",{});var Pn=i(qs);Na=n(Pn,"cased"),Pn.forEach(t),Ka=n(pe,", ce qui explique le meilleur r\xE9sultat."),pe.forEach(t),lt=c(e),L=l(e,"P",{});var de=i(L);Fa=n(de,"Ceci conclut l\u2019introduction \xE0 le "),bs=l(de,"EM",{});var An=i(bs);La=n(An,"finetuning"),An.forEach(t),Ua=n(de," en utilisant l\u2019API Keras. Un exemple d\u2019application de cette m\xE9thode aux t\xE2ches les plus courantes du traitement automatique des langues sera pr\xE9sent\xE9 au "),Ue=l(de,"A",{href:!0});var Mn=i(Ue);Oa=n(Mn,"chapitre 7"),Mn.forEach(t),Ia=n(de,". Si vous souhaitez affiner vos connaissances de l\u2019API Keras, essayez "),Es=l(de,"EM",{});var Sn=i(Es);Ga=n(Sn,"finetuner"),Sn.forEach(t),Va=n(de," un mod\xE8le sur le jeu de donn\xE9es GLUE SST-2, en utilisant le traitement des donn\xE9es que vous avez effectu\xE9 dans la section 2."),de.forEach(t),this.h()},h(){$(p,"name","hf:doc:metadata"),$(p,"content",JSON.stringify(Rn)),$(f,"id","ifinetuneri-un-modle-avec-keras"),$(f,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),$(f,"href","#ifinetuneri-un-modle-avec-keras"),$(_,"class","relative group"),$(ce,"href","https://colab.research.google.com/"),$(ce,"rel","nofollow"),$(X,"id","entranement"),$(X,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),$(X,"href","#entranement"),$(W,"class","relative group"),$(Ke,"href","/course/fr/chapter2"),$(Fe,"href","/course/fr/chapter2"),$(ae,"id","amliorer-les-performances-dentranement"),$(ae,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),$(ae,"href","#amliorer-les-performances-dentranement"),$(Y,"class","relative group"),$(le,"id","prdictions-du-modle"),$(le,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),$(le,"href","#prdictions-du-modle"),$(J,"class","relative group"),$(Ae,"href","https://arxiv.org/pdf/1810.04805.pdf"),$(Ae,"rel","nofollow"),$(Ue,"href","/course/fr/chapter7")},m(e,r){s(document.head,p),u(e,k,r),E(m,e,r),u(e,z,r),u(e,_,r),s(_,f),s(f,y),E(x,y,null),s(_,h),s(_,v),s(v,A),s(A,C),s(v,M),u(e,I,r),E(S,e,r),u(e,P,r),u(e,N,r),s(N,Se),s(N,Q),s(Q,Te),s(N,qt),s(N,ce),s(ce,bt),s(N,Et),u(e,xs,r),u(e,De,r),s(De,gt),u(e,ks,r),E(me,e,r),u(e,zs,r),u(e,W,r),s(W,X),s(X,Re),E(fe,Re,null),s(W,jt),s(W,Be),s(Be,wt),u(e,Cs,r),u(e,Z,r),s(Z,xt),s(Z,We),s(We,kt),s(Z,zt),u(e,ys,r),E(ve,e,r),u(e,Ps,r),u(e,Ne,r),s(Ne,Ct),u(e,As,r),E(he,e,r),u(e,Ms,r),u(e,V,r),s(V,yt),s(V,Ke),s(Ke,Pt),s(V,At),s(V,Ye),s(Ye,Mt),s(V,St),u(e,Ss,r),E($e,e,r),u(e,Ts,r),u(e,ee,r),s(ee,Tt),s(ee,Fe),s(Fe,Dt),s(ee,Nt),u(e,Ds,r),u(e,D,r),s(D,Kt),s(D,Je),s(Je,Ft),s(D,Lt),s(D,Qe),s(Qe,Ut),s(D,Ot),s(D,Xe),s(Xe,It),s(D,Gt),s(D,Ze),s(Ze,Vt),s(D,Ht),u(e,Ns,r),E(se,e,r),u(e,Ks,r),E(_e,e,r),u(e,Fs,r),E(te,e,r),u(e,Ls,r),u(e,Y,r),s(Y,ae),s(ae,es),E(qe,es,null),s(Y,Rt),s(Y,ss),s(ss,Bt),u(e,Us,r),E(be,e,r),u(e,Os,r),u(e,H,r),s(H,Wt),s(H,ts),s(ts,Yt),s(H,Jt),s(H,as),s(as,Qt),s(H,Xt),u(e,Is,r),u(e,T,r),s(T,Zt),s(T,ns),s(ns,ea),s(T,sa),s(T,rs),s(rs,ta),s(T,aa),s(T,os),s(os,na),s(T,ra),s(T,ls),s(ls,oa),s(T,la),s(T,is),s(is,ia),s(T,ua),u(e,Gs,r),E(Ee,e,r),u(e,Vs,r),E(ne,e,r),u(e,Hs,r),u(e,Le,r),s(Le,pa),u(e,Rs,r),E(ge,e,r),u(e,Bs,r),u(e,re,r),s(re,da),s(re,us),s(us,ca),s(re,ma),u(e,Ws,r),E(je,e,r),u(e,Ys,r),E(oe,e,r),u(e,Js,r),u(e,J,r),s(J,le),s(le,ps),E(we,ps,null),s(J,fa),s(J,ds),s(ds,va),u(e,Qs,r),E(xe,e,r),u(e,Xs,r),u(e,R,r),s(R,ha),s(R,cs),s(cs,$a),s(R,_a),s(R,ms),s(ms,qa),s(R,ba),u(e,Zs,r),E(ke,e,r),u(e,et,r),u(e,ie,r),s(ie,Ea),s(ie,fs),s(fs,ga),s(ie,ja),u(e,st,r),E(ze,e,r),u(e,tt,r),E(Ce,e,r),u(e,at,r),u(e,K,r),s(K,wa),s(K,vs),s(vs,xa),s(K,ka),s(K,hs),s(hs,za),s(K,Ca),s(K,$s),s($s,ya),s(K,Pa),u(e,nt,r),E(ye,e,r),u(e,rt,r),E(Pe,e,r),u(e,ot,r),u(e,F,r),s(F,Aa),s(F,Ae),s(Ae,Ma),s(F,Sa),s(F,_s),s(_s,Ta),s(F,Da),s(F,qs),s(qs,Na),s(F,Ka),u(e,lt,r),u(e,L,r),s(L,Fa),s(L,bs),s(bs,La),s(L,Ua),s(L,Ue),s(Ue,Oa),s(L,Ia),s(L,Es),s(Es,Ga),s(L,Va),it=!0},p(e,[r]){const Me={};r&1&&(Me.fw=e[0]),m.$set(Me);const gs={};r&2&&(gs.$$scope={dirty:r,ctx:e}),se.$set(gs);const js={};r&2&&(js.$$scope={dirty:r,ctx:e}),te.$set(js);const Oe={};r&2&&(Oe.$$scope={dirty:r,ctx:e}),ne.$set(Oe);const ws={};r&2&&(ws.$$scope={dirty:r,ctx:e}),oe.$set(ws)},i(e){it||(g(m.$$.fragment,e),g(x.$$.fragment,e),g(S.$$.fragment,e),g(me.$$.fragment,e),g(fe.$$.fragment,e),g(ve.$$.fragment,e),g(he.$$.fragment,e),g($e.$$.fragment,e),g(se.$$.fragment,e),g(_e.$$.fragment,e),g(te.$$.fragment,e),g(qe.$$.fragment,e),g(be.$$.fragment,e),g(Ee.$$.fragment,e),g(ne.$$.fragment,e),g(ge.$$.fragment,e),g(je.$$.fragment,e),g(oe.$$.fragment,e),g(we.$$.fragment,e),g(xe.$$.fragment,e),g(ke.$$.fragment,e),g(ze.$$.fragment,e),g(Ce.$$.fragment,e),g(ye.$$.fragment,e),g(Pe.$$.fragment,e),it=!0)},o(e){j(m.$$.fragment,e),j(x.$$.fragment,e),j(S.$$.fragment,e),j(me.$$.fragment,e),j(fe.$$.fragment,e),j(ve.$$.fragment,e),j(he.$$.fragment,e),j($e.$$.fragment,e),j(se.$$.fragment,e),j(_e.$$.fragment,e),j(te.$$.fragment,e),j(qe.$$.fragment,e),j(be.$$.fragment,e),j(Ee.$$.fragment,e),j(ne.$$.fragment,e),j(ge.$$.fragment,e),j(je.$$.fragment,e),j(oe.$$.fragment,e),j(we.$$.fragment,e),j(xe.$$.fragment,e),j(ke.$$.fragment,e),j(ze.$$.fragment,e),j(Ce.$$.fragment,e),j(ye.$$.fragment,e),j(Pe.$$.fragment,e),it=!1},d(e){t(p),e&&t(k),w(m,e),e&&t(z),e&&t(_),w(x),e&&t(I),w(S,e),e&&t(P),e&&t(N),e&&t(xs),e&&t(De),e&&t(ks),w(me,e),e&&t(zs),e&&t(W),w(fe),e&&t(Cs),e&&t(Z),e&&t(ys),w(ve,e),e&&t(Ps),e&&t(Ne),e&&t(As),w(he,e),e&&t(Ms),e&&t(V),e&&t(Ss),w($e,e),e&&t(Ts),e&&t(ee),e&&t(Ds),e&&t(D),e&&t(Ns),w(se,e),e&&t(Ks),w(_e,e),e&&t(Fs),w(te,e),e&&t(Ls),e&&t(Y),w(qe),e&&t(Us),w(be,e),e&&t(Os),e&&t(H),e&&t(Is),e&&t(T),e&&t(Gs),w(Ee,e),e&&t(Vs),w(ne,e),e&&t(Hs),e&&t(Le),e&&t(Rs),w(ge,e),e&&t(Bs),e&&t(re),e&&t(Ws),w(je,e),e&&t(Ys),w(oe,e),e&&t(Js),e&&t(J),w(we),e&&t(Qs),w(xe,e),e&&t(Xs),e&&t(R),e&&t(Zs),w(ke,e),e&&t(et),e&&t(ie),e&&t(st),w(ze,e),e&&t(tt),w(Ce,e),e&&t(at),e&&t(K),e&&t(nt),w(ye,e),e&&t(rt),w(Pe,e),e&&t(ot),e&&t(F),e&&t(lt),e&&t(L)}}}const Rn={local:"ifinetuneri-un-modle-avec-keras",sections:[{local:"entranement",title:"Entra\xEEnement"},{local:"amliorer-les-performances-dentranement",title:"Am\xE9liorer les performances d'entra\xEEnement"},{local:"prdictions-du-modle",title:"Pr\xE9dictions du mod\xE8le"}],title:"<i>Finetuner</i> un mod\xE8le avec Keras"};function Bn(O,p,k){let m="pt";return Fn(()=>{const z=new URLSearchParams(window.location.search);k(0,m=z.get("fw")||"pt")}),[m]}class sr extends Tn{constructor(p){super();Dn(this,p,Bn,Hn,Nn,{})}}export{sr as default,Rn as metadata};
