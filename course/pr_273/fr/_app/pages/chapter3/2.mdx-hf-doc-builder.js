import{S as Ud,i as Bd,s as Gd,e as l,t as n,k as m,w as x,c as o,a as r,h as a,d as t,m as f,x as z,g as c,G as s,y as w,q,o as j,B as y,l as Id,M as Wd,b as D,p as Us,v as Jd,n as Bs}from"../../chunks/vendor-hf-doc-builder.js";import{T as jp}from"../../chunks/Tip-hf-doc-builder.js";import{Y as qa}from"../../chunks/Youtube-hf-doc-builder.js";import{I as Tl}from"../../chunks/IconCopyLink-hf-doc-builder.js";import{C as T}from"../../chunks/CodeBlock-hf-doc-builder.js";import{D as Vd}from"../../chunks/DocNotebookDropdown-hf-doc-builder.js";import{F as Qd}from"../../chunks/FrameworkSwitchCourse-hf-doc-builder.js";function Kd(C){let i,d;return i=new Vd({props:{classNames:"absolute z-10 right-0 top-0",options:[{label:"Google Colab",value:"https://colab.research.google.com/github/huggingface/notebooks/blob/master/course/chapter3/section2_tf.ipynb"},{label:"Aws Studio",value:"https://studiolab.sagemaker.aws/import/github/huggingface/notebooks/blob/master/course/chapter3/section2_tf.ipynb"}]}}),{c(){x(i.$$.fragment)},l(u){z(i.$$.fragment,u)},m(u,v){w(i,u,v),d=!0},i(u){d||(q(i.$$.fragment,u),d=!0)},o(u){j(i.$$.fragment,u),d=!1},d(u){y(i,u)}}}function Yd(C){let i,d;return i=new Vd({props:{classNames:"absolute z-10 right-0 top-0",options:[{label:"Google Colab",value:"https://colab.research.google.com/github/huggingface/notebooks/blob/master/course/chapter3/section2_pt.ipynb"},{label:"Aws Studio",value:"https://studiolab.sagemaker.aws/import/github/huggingface/notebooks/blob/master/course/chapter3/section2_pt.ipynb"}]}}),{c(){x(i.$$.fragment)},l(u){z(i.$$.fragment,u)},m(u,v){w(i,u,v),d=!0},i(u){d||(q(i.$$.fragment,u),d=!0)},o(u){j(i.$$.fragment,u),d=!1},d(u){y(i,u)}}}function Zd(C){let i,d,u,v,E,_,b,k;return b=new T({props:{code:`
`,highlighted:`<span class="hljs-keyword">import</span> tensorflow <span class="hljs-keyword">as</span> tf
<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np
<span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> AutoTokenizer, TFAutoModelForSequenceClassification

<span class="hljs-comment"># M\xEAme chose que pr\xE9c\xE9demment</span>
checkpoint = <span class="hljs-string">&quot;bert-base-uncased&quot;</span>
tokenizer = AutoTokenizer.from_pretrained(checkpoint)
model = TFAutoModelForSequenceClassification.from_pretrained(checkpoint)
sequences = [
    <span class="hljs-string">&quot;I&#x27;ve been waiting for a HuggingFace course my whole life.&quot;</span>,
    <span class="hljs-comment"># J&#x27;ai attendu un cours de HuggingFace toute ma vie.</span>
    <span class="hljs-string">&quot;This course is amazing!&quot;</span>,  <span class="hljs-comment"># Ce cours est incroyable !</span>
]
batch = <span class="hljs-built_in">dict</span>(tokenizer(sequences, padding=<span class="hljs-literal">True</span>, truncation=<span class="hljs-literal">True</span>, return_tensors=<span class="hljs-string">&quot;tf&quot;</span>))

<span class="hljs-comment"># Ceci est nouveau</span>
model.<span class="hljs-built_in">compile</span>(optimizer=<span class="hljs-string">&quot;adam&quot;</span>, loss=<span class="hljs-string">&quot;sparse_categorical_crossentropy&quot;</span>)
labels = tf.convert_to_tensor([<span class="hljs-number">1</span>, <span class="hljs-number">1</span>])
model.train_on_batch(batch, labels)`}}),{c(){i=l("p"),d=n("En continuant avec l\u2019exemple du "),u=l("a"),v=n("chapitre pr\xE9c\xE9dent"),E=n(", voici comment entra\xEEner un classifieur de s\xE9quences sur un batch avec TensorFlow :"),_=m(),x(b.$$.fragment),this.h()},l(h){i=o(h,"P",{});var $=r(i);d=a($,"En continuant avec l\u2019exemple du "),u=o($,"A",{href:!0});var S=r(u);v=a(S,"chapitre pr\xE9c\xE9dent"),S.forEach(t),E=a($,", voici comment entra\xEEner un classifieur de s\xE9quences sur un batch avec TensorFlow :"),$.forEach(t),_=f(h),z(b.$$.fragment,h),this.h()},h(){D(u,"href","/course/fr/chapter2")},m(h,$){c(h,i,$),s(i,d),s(i,u),s(u,v),s(i,E),c(h,_,$),w(b,h,$),k=!0},i(h){k||(q(b.$$.fragment,h),k=!0)},o(h){j(b.$$.fragment,h),k=!1},d(h){h&&t(i),h&&t(_),y(b,h)}}}function Xd(C){let i,d,u,v,E,_,b,k;return b=new T({props:{code:`

`,highlighted:`<span class="hljs-keyword">import</span> torch
<span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> AdamW, AutoTokenizer, AutoModelForSequenceClassification

<span class="hljs-comment"># M\xEAme chose que pr\xE9c\xE9demment</span>
checkpoint = <span class="hljs-string">&quot;bert-base-uncased&quot;</span>
tokenizer = AutoTokenizer.from_pretrained(checkpoint)
model = AutoModelForSequenceClassification.from_pretrained(checkpoint)
sequences = [
    <span class="hljs-string">&quot;I&#x27;ve been waiting for a HuggingFace course my whole life.&quot;</span>,
    <span class="hljs-comment"># J&#x27;ai attendu un cours de HuggingFace toute ma vie.</span>
    <span class="hljs-string">&quot;This course is amazing!&quot;</span>,  <span class="hljs-comment"># Ce cours est incroyable !</span>
]
batch = tokenizer(sequences, padding=<span class="hljs-literal">True</span>, truncation=<span class="hljs-literal">True</span>, return_tensors=<span class="hljs-string">&quot;pt&quot;</span>)

<span class="hljs-comment"># Ceci est nouveau</span>
batch[<span class="hljs-string">&quot;labels&quot;</span>] = torch.tensor([<span class="hljs-number">1</span>, <span class="hljs-number">1</span>])

optimizer = AdamW(model.parameters())
loss = model(**batch).loss
loss.backward()
optimizer.step()`}}),{c(){i=l("p"),d=n("En continuant avec l\u2019exemple du "),u=l("a"),v=n("chapitre pr\xE9c\xE9dent"),E=n(", voici comment entra\xEEner un classifieur de s\xE9quences sur un batch avec PyTorch :"),_=m(),x(b.$$.fragment),this.h()},l(h){i=o(h,"P",{});var $=r(i);d=a($,"En continuant avec l\u2019exemple du "),u=o($,"A",{href:!0});var S=r(u);v=a(S,"chapitre pr\xE9c\xE9dent"),S.forEach(t),E=a($,", voici comment entra\xEEner un classifieur de s\xE9quences sur un batch avec PyTorch :"),$.forEach(t),_=f(h),z(b.$$.fragment,h),this.h()},h(){D(u,"href","/course/fr/chapter2")},m(h,$){c(h,i,$),s(i,d),s(i,u),s(u,v),s(i,E),c(h,_,$),w(b,h,$),k=!0},i(h){k||(q(b.$$.fragment,h),k=!0)},o(h){j(b.$$.fragment,h),k=!1},d(h){h&&t(i),h&&t(_),y(b,h)}}}function em(C){let i,d;return i=new qa({props:{id:"W_gMJF0xomE"}}),{c(){x(i.$$.fragment)},l(u){z(i.$$.fragment,u)},m(u,v){w(i,u,v),d=!0},i(u){d||(q(i.$$.fragment,u),d=!0)},o(u){j(i.$$.fragment,u),d=!1},d(u){y(i,u)}}}function sm(C){let i,d;return i=new qa({props:{id:"_BZearw7f0w"}}),{c(){x(i.$$.fragment)},l(u){z(i.$$.fragment,u)},m(u,v){w(i,u,v),d=!0},i(u){d||(q(i.$$.fragment,u),d=!0)},o(u){j(i.$$.fragment,u),d=!1},d(u){y(i,u)}}}function tm(C){let i,d,u,v,E;return{c(){i=l("p"),d=n("\u270F\uFE0F "),u=l("strong"),v=n("Essayez !"),E=n(" Regardez l\u2019\xE9l\xE9ment 15 de l\u2019ensemble d\u2019entra\xEEnement et l\u2019\xE9l\xE9ment 87 de l\u2019ensemble de validation. Quelles sont leurs \xE9tiquettes ?")},l(_){i=o(_,"P",{});var b=r(i);d=a(b,"\u270F\uFE0F "),u=o(b,"STRONG",{});var k=r(u);v=a(k,"Essayez !"),k.forEach(t),E=a(b," Regardez l\u2019\xE9l\xE9ment 15 de l\u2019ensemble d\u2019entra\xEEnement et l\u2019\xE9l\xE9ment 87 de l\u2019ensemble de validation. Quelles sont leurs \xE9tiquettes ?"),b.forEach(t)},m(_,b){c(_,i,b),s(i,d),s(i,u),s(u,v),s(i,E)},d(_){_&&t(i)}}}function nm(C){let i,d;return i=new qa({props:{id:"P-rZWqcB6CE"}}),{c(){x(i.$$.fragment)},l(u){z(i.$$.fragment,u)},m(u,v){w(i,u,v),d=!0},i(u){d||(q(i.$$.fragment,u),d=!0)},o(u){j(i.$$.fragment,u),d=!1},d(u){y(i,u)}}}function am(C){let i,d;return i=new qa({props:{id:"0u3ioSwev3s"}}),{c(){x(i.$$.fragment)},l(u){z(i.$$.fragment,u)},m(u,v){w(i,u,v),d=!0},i(u){d||(q(i.$$.fragment,u),d=!0)},o(u){j(i.$$.fragment,u),d=!1},d(u){y(i,u)}}}function lm(C){let i,d,u,v,E;return{c(){i=l("p"),d=n("\u270F\uFE0F "),u=l("strong"),v=n("Essayez !"),E=n(" Prenez l\u2019\xE9l\xE9ment 15 de l\u2019ensemble d\u2019entra\xEEnement et tokenisez les deux phrases s\xE9par\xE9ment et par paire. Quelle est la diff\xE9rence entre les deux r\xE9sultats ?")},l(_){i=o(_,"P",{});var b=r(i);d=a(b,"\u270F\uFE0F "),u=o(b,"STRONG",{});var k=r(u);v=a(k,"Essayez !"),k.forEach(t),E=a(b," Prenez l\u2019\xE9l\xE9ment 15 de l\u2019ensemble d\u2019entra\xEEnement et tokenisez les deux phrases s\xE9par\xE9ment et par paire. Quelle est la diff\xE9rence entre les deux r\xE9sultats ?"),b.forEach(t)},m(_,b){c(_,i,b),s(i,d),s(i,u),s(u,v),s(i,E)},d(_){_&&t(i)}}}function om(C){let i,d,u,v,E,_,b,k,h,$,S,F,A,L,N,R,H;return{c(){i=l("p"),d=n("La fonction qui est responsable de l\u2019assemblage des \xE9chantillons dans un batch est appel\xE9e "),u=l("em"),v=n("fonction de rassemblement"),E=n(". C\u2019est un argument que vous pouvez passer quand vous construisez un "),_=l("code"),b=n("DataLoader"),k=n(", la valeur par d\xE9faut \xE9tant une fonction qui va juste convertir vos \xE9chantillons en type tf.Tensor et les concat\xE9ner (r\xE9cursivement si les \xE9l\xE9ments sont des listes, des "),h=l("em"),$=n("tuples"),S=n(" ou des dictionnaires). Cela ne sera pas possible dans notre cas puisque les entr\xE9es que nous avons ne seront pas toutes de la m\xEAme taille. Nous avons d\xE9lib\xE9r\xE9ment report\xE9 le "),F=l("em"),A=n("padding"),L=n(", pour ne l\u2019appliquer que si n\xE9cessaire sur chaque batch et \xE9viter d\u2019avoir des entr\xE9es trop longues avec beaucoup de remplissage. Cela acc\xE9l\xE8re consid\xE9rablement l\u2019entra\xEEnement, mais notez que si vous vous entra\xEEnez sur un TPU, cela peut poser des probl\xE8mes. En effet, les TPU pr\xE9f\xE8rent les formes fixes, m\xEAme si cela n\xE9cessite un "),N=l("em"),R=n("padding"),H=n(" suppl\xE9mentaire.")},l(I){i=o(I,"P",{});var g=r(i);d=a(g,"La fonction qui est responsable de l\u2019assemblage des \xE9chantillons dans un batch est appel\xE9e "),u=o(g,"EM",{});var ae=r(u);v=a(ae,"fonction de rassemblement"),ae.forEach(t),E=a(g,". C\u2019est un argument que vous pouvez passer quand vous construisez un "),_=o(g,"CODE",{});var Q=r(_);b=a(Q,"DataLoader"),Q.forEach(t),k=a(g,", la valeur par d\xE9faut \xE9tant une fonction qui va juste convertir vos \xE9chantillons en type tf.Tensor et les concat\xE9ner (r\xE9cursivement si les \xE9l\xE9ments sont des listes, des "),h=o(g,"EM",{});var U=r(h);$=a(U,"tuples"),U.forEach(t),S=a(g," ou des dictionnaires). Cela ne sera pas possible dans notre cas puisque les entr\xE9es que nous avons ne seront pas toutes de la m\xEAme taille. Nous avons d\xE9lib\xE9r\xE9ment report\xE9 le "),F=o(g,"EM",{});var le=r(F);A=a(le,"padding"),le.forEach(t),L=a(g,", pour ne l\u2019appliquer que si n\xE9cessaire sur chaque batch et \xE9viter d\u2019avoir des entr\xE9es trop longues avec beaucoup de remplissage. Cela acc\xE9l\xE8re consid\xE9rablement l\u2019entra\xEEnement, mais notez que si vous vous entra\xEEnez sur un TPU, cela peut poser des probl\xE8mes. En effet, les TPU pr\xE9f\xE8rent les formes fixes, m\xEAme si cela n\xE9cessite un "),N=o(g,"EM",{});var P=r(N);R=a(P,"padding"),P.forEach(t),H=a(g," suppl\xE9mentaire."),g.forEach(t)},m(I,g){c(I,i,g),s(i,d),s(i,u),s(u,v),s(i,E),s(i,_),s(_,b),s(i,k),s(i,h),s(h,$),s(i,S),s(i,F),s(F,A),s(i,L),s(i,N),s(N,R),s(i,H)},d(I){I&&t(i)}}}function rm(C){let i,d,u,v,E,_,b,k,h,$,S,F,A,L,N,R,H;return{c(){i=l("p"),d=n("La fonction qui est responsable de l\u2019assemblage des \xE9chantillons dans un batch est appel\xE9e "),u=l("em"),v=n("fonction de rassemblement"),E=n(". C\u2019est un argument que vous pouvez passer quand vous construisez un "),_=l("code"),b=n("DataLoader"),k=n(", la valeur par d\xE9faut \xE9tant une fonction qui va juste convertir vos \xE9chantillons en tenseurs PyTorch et les concat\xE9ner (r\xE9cursivement si vos \xE9l\xE9ments sont des listes, des "),h=l("em"),$=n("tuples"),S=n(" ou des dictionnaires). Cela ne sera pas possible dans notre cas puisque les entr\xE9es que nous avons ne seront pas toutes de la m\xEAme taille. Nous avons d\xE9lib\xE9r\xE9ment report\xE9 le "),F=l("em"),A=n("padding"),L=n(", pour ne l\u2019appliquer que si n\xE9cessaire sur chaque batch et \xE9viter d\u2019avoir des entr\xE9es trop longues avec beaucoup de remplissage. Cela acc\xE9l\xE8re consid\xE9rablement l\u2019entra\xEEnement, mais notez que si vous vous entra\xEEnez sur un TPU, cela peut poser des probl\xE8mes. En effet, les TPU pr\xE9f\xE8rent les formes fixes, m\xEAme si cela n\xE9cessite un "),N=l("em"),R=n("padding"),H=n(" suppl\xE9mentaire.")},l(I){i=o(I,"P",{});var g=r(i);d=a(g,"La fonction qui est responsable de l\u2019assemblage des \xE9chantillons dans un batch est appel\xE9e "),u=o(g,"EM",{});var ae=r(u);v=a(ae,"fonction de rassemblement"),ae.forEach(t),E=a(g,". C\u2019est un argument que vous pouvez passer quand vous construisez un "),_=o(g,"CODE",{});var Q=r(_);b=a(Q,"DataLoader"),Q.forEach(t),k=a(g,", la valeur par d\xE9faut \xE9tant une fonction qui va juste convertir vos \xE9chantillons en tenseurs PyTorch et les concat\xE9ner (r\xE9cursivement si vos \xE9l\xE9ments sont des listes, des "),h=o(g,"EM",{});var U=r(h);$=a(U,"tuples"),U.forEach(t),S=a(g," ou des dictionnaires). Cela ne sera pas possible dans notre cas puisque les entr\xE9es que nous avons ne seront pas toutes de la m\xEAme taille. Nous avons d\xE9lib\xE9r\xE9ment report\xE9 le "),F=o(g,"EM",{});var le=r(F);A=a(le,"padding"),le.forEach(t),L=a(g,", pour ne l\u2019appliquer que si n\xE9cessaire sur chaque batch et \xE9viter d\u2019avoir des entr\xE9es trop longues avec beaucoup de remplissage. Cela acc\xE9l\xE8re consid\xE9rablement l\u2019entra\xEEnement, mais notez que si vous vous entra\xEEnez sur un TPU, cela peut poser des probl\xE8mes. En effet, les TPU pr\xE9f\xE8rent les formes fixes, m\xEAme si cela n\xE9cessite un "),N=o(g,"EM",{});var P=r(N);R=a(P,"padding"),P.forEach(t),H=a(g," suppl\xE9mentaire."),g.forEach(t)},m(I,g){c(I,i,g),s(i,d),s(i,u),s(u,v),s(i,E),s(i,_),s(_,b),s(i,k),s(i,h),s(h,$),s(i,S),s(i,F),s(F,A),s(i,L),s(i,N),s(N,R),s(i,H)},d(I){I&&t(i)}}}function im(C){let i,d;return i=new T({props:{code:"",highlighted:`<span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> DataCollatorWithPadding

data_collator = DataCollatorWithPadding(tokenizer=tokenizer, return_tensors=<span class="hljs-string">&quot;tf&quot;</span>)`}}),{c(){x(i.$$.fragment)},l(u){z(i.$$.fragment,u)},m(u,v){w(i,u,v),d=!0},i(u){d||(q(i.$$.fragment,u),d=!0)},o(u){j(i.$$.fragment,u),d=!1},d(u){y(i,u)}}}function um(C){let i,d;return i=new T({props:{code:"",highlighted:`<span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> DataCollatorWithPadding

data_collator = DataCollatorWithPadding(tokenizer=tokenizer)`}}),{c(){x(i.$$.fragment)},l(u){z(i.$$.fragment,u)},m(u,v){w(i,u,v),d=!0},i(u){d||(q(i.$$.fragment,u),d=!0)},o(u){j(i.$$.fragment,u),d=!1},d(u){y(i,u)}}}function pm(C){let i,d,u,v,E,_,b,k;return i=new T({props:{code:`{'attention_mask': torch.Size([8, 67]),
 'input_ids': torch.Size([8, 67]),
 'token_type_ids': torch.Size([8, 67]),
 'labels': torch.Size([8])}`,highlighted:`{<span class="hljs-string">&#x27;attention_mask&#x27;</span>: torch.Size([<span class="hljs-number">8</span>, <span class="hljs-number">67</span>]),
 <span class="hljs-string">&#x27;input_ids&#x27;</span>: torch.Size([<span class="hljs-number">8</span>, <span class="hljs-number">67</span>]),
 <span class="hljs-string">&#x27;token_type_ids&#x27;</span>: torch.Size([<span class="hljs-number">8</span>, <span class="hljs-number">67</span>]),
 <span class="hljs-string">&#x27;labels&#x27;</span>: torch.Size([<span class="hljs-number">8</span>])}`}}),{c(){x(i.$$.fragment),d=m(),u=l("p"),v=n("C\u2019est beau ! Maintenant que nous sommes pass\xE9s du texte brut \xE0 des batchs que notre mod\xE8le peut traiter, nous sommes pr\xEAts \xE0 le "),E=l("em"),_=n("finetuner"),b=n(" !")},l(h){z(i.$$.fragment,h),d=f(h),u=o(h,"P",{});var $=r(u);v=a($,"C\u2019est beau ! Maintenant que nous sommes pass\xE9s du texte brut \xE0 des batchs que notre mod\xE8le peut traiter, nous sommes pr\xEAts \xE0 le "),E=o($,"EM",{});var S=r(E);_=a(S,"finetuner"),S.forEach(t),b=a($," !"),$.forEach(t)},m(h,$){w(i,h,$),c(h,d,$),c(h,u,$),s(u,v),s(u,E),s(E,_),s(u,b),k=!0},i(h){k||(q(i.$$.fragment,h),k=!0)},o(h){j(i.$$.fragment,h),k=!1},d(h){y(i,h),h&&t(d),h&&t(u)}}}function cm(C){let i,d;return i=new T({props:{code:`{'attention_mask': TensorShape([8, 67]),
 'input_ids': TensorShape([8, 67]),
 'token_type_ids': TensorShape([8, 67]),
 'labels': TensorShape([8])}`,highlighted:`{<span class="hljs-string">&#x27;attention_mask&#x27;</span>: TensorShape([<span class="hljs-number">8</span>, <span class="hljs-number">67</span>]),
 <span class="hljs-string">&#x27;input_ids&#x27;</span>: TensorShape([<span class="hljs-number">8</span>, <span class="hljs-number">67</span>]),
 <span class="hljs-string">&#x27;token_type_ids&#x27;</span>: TensorShape([<span class="hljs-number">8</span>, <span class="hljs-number">67</span>]),
 <span class="hljs-string">&#x27;labels&#x27;</span>: TensorShape([<span class="hljs-number">8</span>])}`}}),{c(){x(i.$$.fragment)},l(u){z(i.$$.fragment,u)},m(u,v){w(i,u,v),d=!0},i(u){d||(q(i.$$.fragment,u),d=!0)},o(u){j(i.$$.fragment,u),d=!1},d(u){y(i,u)}}}function dm(C){let i,d,u,v,E;return{c(){i=l("p"),d=n("\u270F\uFE0F "),u=l("strong"),v=n("Essayez !"),E=n(" Reproduisez le pr\xE9traitement sur le jeu de donn\xE9es GLUE SST-2. C\u2019est un peu diff\xE9rent puisqu\u2019il est compos\xE9 de phrases simples au lieu de paires, mais le reste de ce que nous avons fait devrait \xEAtre identique. Pour un d\xE9fi plus difficile, essayez d\u2019\xE9crire une fonction de pr\xE9traitement qui fonctionne sur toutes les t\xE2ches GLUE.")},l(_){i=o(_,"P",{});var b=r(i);d=a(b,"\u270F\uFE0F "),u=o(b,"STRONG",{});var k=r(u);v=a(k,"Essayez !"),k.forEach(t),E=a(b," Reproduisez le pr\xE9traitement sur le jeu de donn\xE9es GLUE SST-2. C\u2019est un peu diff\xE9rent puisqu\u2019il est compos\xE9 de phrases simples au lieu de paires, mais le reste de ce que nous avons fait devrait \xEAtre identique. Pour un d\xE9fi plus difficile, essayez d\u2019\xE9crire une fonction de pr\xE9traitement qui fonctionne sur toutes les t\xE2ches GLUE."),b.forEach(t)},m(_,b){c(_,i,b),s(i,d),s(i,u),s(u,v),s(i,E)},d(_){_&&t(i)}}}function Fd(C){let i,d,u,v,E,_,b,k,h,$,S,F,A,L,N,R,H,I,g,ae,Q,U,le;return g=new T({props:{code:"",highlighted:`tf_train_dataset = tokenized_datasets[<span class="hljs-string">&quot;train&quot;</span>].to_tf_dataset(
    columns=[<span class="hljs-string">&quot;attention_mask&quot;</span>, <span class="hljs-string">&quot;input_ids&quot;</span>, <span class="hljs-string">&quot;token_type_ids&quot;</span>],
    label_cols=[<span class="hljs-string">&quot;labels&quot;</span>],
    shuffle=<span class="hljs-literal">True</span>,
    collate_fn=data_collator,
    batch_size=<span class="hljs-number">8</span>,
)

tf_validation_dataset = tokenized_datasets[<span class="hljs-string">&quot;validation&quot;</span>].to_tf_dataset(
    columns=[<span class="hljs-string">&quot;attention_mask&quot;</span>, <span class="hljs-string">&quot;input_ids&quot;</span>, <span class="hljs-string">&quot;token_type_ids&quot;</span>],
    label_cols=[<span class="hljs-string">&quot;labels&quot;</span>],
    shuffle=<span class="hljs-literal">False</span>,
    collate_fn=data_collator,
    batch_size=<span class="hljs-number">8</span>,
)`}}),{c(){i=l("p"),d=n("Maintenant que nous disposons de notre jeu de donn\xE9es et d\u2019un collecteur de donn\xE9es, nous devons les assembler. Nous pourrions charger manuellement des batchs et les assembler mais c\u2019est beaucoup de travail et probablement pas tr\xE8s performant non plus. A la place, il existe une m\xE9thode simple qui offre une solution performante \xE0 ce probl\xE8me : "),u=l("code"),v=n("to_tf_dataset()"),E=n(". Cela va envelopper un "),_=l("code"),b=n("tf.data.Dataset"),k=n(" autour de votre jeu de donn\xE9es, avec une fonction de collation optionnelle. "),h=l("code"),$=n("tf.data.Dataset"),S=n(" est un format natif de TensorFlow que Keras peut utiliser pour "),F=l("code"),A=n("model.fit()"),L=n(", donc cette seule m\xE9thode convertit imm\xE9diatement un "),N=l("em"),R=n("dataset"),H=n(" en un format pr\xEAt pour l\u2019entra\xEEnement. Voyons cela en action avec notre jeu de donn\xE9es !"),I=m(),x(g.$$.fragment),ae=m(),Q=l("p"),U=n("Et c\u2019est tout ! Nous pouvons utiliser ces jeux de donn\xE9es dans le prochain cours, o\xF9 l\u2019entra\xEEnement sera agr\xE9ablement simple apr\xE8s tout le dur travail de pr\xE9traitement des donn\xE9es.")},l(P){i=o(P,"P",{});var V=r(i);d=a(V,"Maintenant que nous disposons de notre jeu de donn\xE9es et d\u2019un collecteur de donn\xE9es, nous devons les assembler. Nous pourrions charger manuellement des batchs et les assembler mais c\u2019est beaucoup de travail et probablement pas tr\xE8s performant non plus. A la place, il existe une m\xE9thode simple qui offre une solution performante \xE0 ce probl\xE8me : "),u=o(V,"CODE",{});var Gs=r(u);v=a(Gs,"to_tf_dataset()"),Gs.forEach(t),E=a(V,". Cela va envelopper un "),_=o(V,"CODE",{});var Ce=r(_);b=a(Ce,"tf.data.Dataset"),Ce.forEach(t),k=a(V," autour de votre jeu de donn\xE9es, avec une fonction de collation optionnelle. "),h=o(V,"CODE",{});var Ws=r(h);$=a(Ws,"tf.data.Dataset"),Ws.forEach(t),S=a(V," est un format natif de TensorFlow que Keras peut utiliser pour "),F=o(V,"CODE",{});var Js=r(F);A=a(Js,"model.fit()"),Js.forEach(t),L=a(V,", donc cette seule m\xE9thode convertit imm\xE9diatement un "),N=o(V,"EM",{});var us=r(N);R=a(us,"dataset"),us.forEach(t),H=a(V," en un format pr\xEAt pour l\u2019entra\xEEnement. Voyons cela en action avec notre jeu de donn\xE9es !"),V.forEach(t),I=f(P),z(g.$$.fragment,P),ae=f(P),Q=o(P,"P",{});var pe=r(Q);U=a(pe,"Et c\u2019est tout ! Nous pouvons utiliser ces jeux de donn\xE9es dans le prochain cours, o\xF9 l\u2019entra\xEEnement sera agr\xE9ablement simple apr\xE8s tout le dur travail de pr\xE9traitement des donn\xE9es."),pe.forEach(t)},m(P,V){c(P,i,V),s(i,d),s(i,u),s(u,v),s(i,E),s(i,_),s(_,b),s(i,k),s(i,h),s(h,$),s(i,S),s(i,F),s(F,A),s(i,L),s(i,N),s(N,R),s(i,H),c(P,I,V),w(g,P,V),c(P,ae,V),c(P,Q,V),s(Q,U),le=!0},i(P){le||(q(g.$$.fragment,P),le=!0)},o(P){j(g.$$.fragment,P),le=!1},d(P){P&&t(i),P&&t(I),y(g,P),P&&t(ae),P&&t(Q)}}}function mm(C){let i,d,u,v,E,_,b,k,h,$,S,F,A,L,N,R,H,I,g,ae,Q,U,le,P,V,Gs,Ce,Ws,Js,us,pe,Ue,jt,ps,Sl,Qs,Nl,Et,Ol,ja,Ee,$e,Ks,K,Al,$t,Ll,Rl,cs,Hl,Il,ds,Fl,Vl,Be,gt,Ul,Bl,Gl,kt,Wl,Jl,Ea,De,Ql,xt,Kl,Yl,zt,Zl,Xl,$a,ms,ga,fs,ka,Y,eo,wt,so,to,yt,no,ao,Ct,lo,oo,Dt,ro,io,Pt,uo,po,xa,Pe,co,Mt,mo,fo,Tt,ho,vo,za,Ge,_o,St,bo,qo,wa,hs,ya,vs,Ca,Me,jo,Nt,Eo,$o,Ot,go,ko,Da,_s,Pa,bs,Ma,B,xo,At,zo,wo,Lt,yo,Co,Rt,Do,Po,Ht,Mo,To,It,So,No,Ft,Oo,Ao,Vt,Lo,Ro,Ta,We,Sa,Ie,Je,Ut,qs,Ho,Bt,Io,Na,ge,ke,Ys,ce,Fo,Zs,Vo,Uo,Gt,Bo,Go,Wt,Wo,Jo,Oa,js,Aa,Qe,Qo,Jt,Ko,Yo,La,Es,Ra,$s,Ha,oe,Zo,Qt,Xo,er,Kt,sr,tr,Xs,nr,ar,Yt,lr,or,Ia,Ke,Fa,Ye,rr,Zt,ir,ur,Va,gs,Ua,et,pr,Ba,ks,Ga,Te,cr,Xt,dr,mr,en,fr,hr,Wa,xs,Ja,J,vr,sn,_r,br,tn,qr,jr,nn,Er,$r,an,gr,kr,ln,xr,zr,on,wr,yr,Qa,Se,Cr,rn,Dr,Pr,un,Mr,Tr,Ka,de,Sr,pn,Nr,Or,st,Ar,Lr,cn,Rr,Hr,Ya,Ze,Ir,dn,Fr,Vr,Za,re,Ur,mn,Br,Gr,fn,Wr,Jr,hn,Qr,Kr,vn,Yr,Zr,Xa,ie,Xr,_n,ei,si,tt,ti,ni,bn,ai,li,nt,oi,ri,el,zs,sl,Z,ii,qn,ui,pi,jn,ci,di,En,mi,fi,$n,hi,vi,ws,_i,bi,tl,Ne,qi,ys,gn,ji,Ei,kn,$i,gi,nl,Cs,al,M,ki,xn,xi,zi,zn,wi,yi,wn,Ci,Di,yn,Pi,Mi,Cn,Ti,Si,Dn,Ni,Oi,Pn,Ai,Li,Mn,Ri,Hi,Tn,Ii,Fi,Xe,Vi,Sn,Ui,Bi,Nn,Gi,Wi,ll,me,Ji,On,Qi,Ki,An,Yi,Zi,Ln,Xi,eu,ol,Oe,su,Rn,tu,nu,Hn,au,lu,rl,Ds,il,es,ou,In,ru,iu,ul,Ps,pl,X,uu,Fn,pu,cu,Vn,du,mu,Un,fu,hu,Bn,vu,_u,Gn,bu,qu,cl,ee,ju,Wn,Eu,$u,Jn,gu,ku,Qn,xu,zu,Kn,wu,yu,Yn,Cu,Du,dl,ss,Pu,Zn,Mu,Tu,ml,Fe,ts,Xn,Ms,Su,at,ea,Nu,Ou,fl,Ts,hl,lt,G,Au,sa,Lu,Ru,ta,Hu,Iu,na,Fu,Vu,aa,Uu,Bu,la,Gu,Wu,oa,Ju,Qu,ra,Ku,Yu,vl,xe,ze,ot,se,Zu,ia,Xu,ep,ua,sp,tp,pa,np,ap,ca,lp,op,da,rp,ip,_l,Ss,bl,Ns,ql,fe,up,ma,pp,cp,fa,dp,mp,ha,fp,hp,jl,Os,El,we,ye,rt,ns,$l,it,gl;u=new Qd({props:{fw:C[0]}}),k=new Tl({});const Ep=[Yd,Kd],As=[];function $p(e,p){return e[0]==="pt"?0:1}A=$p(C),L=As[A]=Ep[A](C);const gp=[Xd,Zd],Ls=[];function kp(e,p){return e[0]==="pt"?0:1}R=kp(C),H=Ls[R]=gp[R](C),ps=new Tl({});const xp=[sm,em],Rs=[];function zp(e,p){return e[0]==="pt"?0:1}Ee=zp(C),$e=Rs[Ee]=xp[Ee](C),ms=new T({props:{code:"",highlighted:`<span class="hljs-keyword">from</span> datasets <span class="hljs-keyword">import</span> load_dataset

raw_datasets = load_dataset(<span class="hljs-string">&quot;glue&quot;</span>, <span class="hljs-string">&quot;mrpc&quot;</span>)
raw_datasets`}}),fs=new T({props:{code:`DatasetDict({
    train: Dataset({
        features: ['sentence1', 'sentence2', 'label', 'idx'],
        num_rows: 3668
    })
    validation: Dataset({
        features: ['sentence1', 'sentence2', 'label', 'idx'],
        num_rows: 408
    })
    test: Dataset({
        features: ['sentence1', 'sentence2', 'label', 'idx'],
        num_rows: 1725
    })
})`,highlighted:`DatasetDict({
    train: Dataset({
        features: [<span class="hljs-string">&#x27;sentence1&#x27;</span>, <span class="hljs-string">&#x27;sentence2&#x27;</span>, <span class="hljs-string">&#x27;label&#x27;</span>, <span class="hljs-string">&#x27;idx&#x27;</span>],
        num_rows: <span class="hljs-number">3668</span>
    })
    validation: Dataset({
        features: [<span class="hljs-string">&#x27;sentence1&#x27;</span>, <span class="hljs-string">&#x27;sentence2&#x27;</span>, <span class="hljs-string">&#x27;label&#x27;</span>, <span class="hljs-string">&#x27;idx&#x27;</span>],
        num_rows: <span class="hljs-number">408</span>
    })
    test: Dataset({
        features: [<span class="hljs-string">&#x27;sentence1&#x27;</span>, <span class="hljs-string">&#x27;sentence2&#x27;</span>, <span class="hljs-string">&#x27;label&#x27;</span>, <span class="hljs-string">&#x27;idx&#x27;</span>],
        num_rows: <span class="hljs-number">1725</span>
    })
})`}}),hs=new T({props:{code:`raw_train_dataset = raw_datasets["train"]
raw_train_dataset[0]`,highlighted:`raw_train_dataset = raw_datasets[<span class="hljs-string">&quot;train&quot;</span>]
raw_train_dataset[<span class="hljs-number">0</span>]`}}),vs=new T({props:{code:`{'idx': 0,
 'label': 1,
 'sentence1': 'Amrozi accused his brother , whom he called " the witness " , of deliberately distorting his evidence .', 
 # Amrozi a accus\xE9 son fr\xE8re, qu'il a appel\xE9 \xAB le t\xE9moin \xBB, de d\xE9former d\xE9lib\xE9r\xE9ment son t\xE9moignage.
 'sentence2': 'Referring to him as only " the witness " , Amrozi accused his brother of deliberately distorting his evidence .'} 
 # Se r\xE9f\xE9rant \xE0 lui uniquement comme \xAB le t\xE9moin \xBB, Amrozi a accus\xE9 son fr\xE8re de d\xE9former d\xE9lib\xE9r\xE9ment son t\xE9moignage.`,highlighted:`{<span class="hljs-string">&#x27;idx&#x27;</span>: <span class="hljs-number">0</span>,
 <span class="hljs-string">&#x27;label&#x27;</span>: <span class="hljs-number">1</span>,
 <span class="hljs-string">&#x27;sentence1&#x27;</span>: <span class="hljs-string">&#x27;Amrozi accused his brother , whom he called &quot; the witness &quot; , of deliberately distorting his evidence .&#x27;</span>, 
 <span class="hljs-comment"># Amrozi a accus\xE9 son fr\xE8re, qu&#x27;il a appel\xE9 \xAB le t\xE9moin \xBB, de d\xE9former d\xE9lib\xE9r\xE9ment son t\xE9moignage.</span>
 <span class="hljs-string">&#x27;sentence2&#x27;</span>: <span class="hljs-string">&#x27;Referring to him as only &quot; the witness &quot; , Amrozi accused his brother of deliberately distorting his evidence .&#x27;</span>} 
 <span class="hljs-comment"># Se r\xE9f\xE9rant \xE0 lui uniquement comme \xAB le t\xE9moin \xBB, Amrozi a accus\xE9 son fr\xE8re de d\xE9former d\xE9lib\xE9r\xE9ment son t\xE9moignage.</span>`}}),_s=new T({props:{code:"raw_train_dataset.features",highlighted:"raw_train_dataset.features"}}),bs=new T({props:{code:`{'sentence1': Value(dtype='string', id=None),
 'sentence2': Value(dtype='string', id=None),
 'label': ClassLabel(num_classes=2, names=['not_equivalent', 'equivalent'], names_file=None, id=None),
 'idx': Value(dtype='int32', id=None)}`,highlighted:`{<span class="hljs-string">&#x27;sentence1&#x27;</span>: Value(dtype=<span class="hljs-string">&#x27;string&#x27;</span>, <span class="hljs-built_in">id</span>=<span class="hljs-literal">None</span>),
 <span class="hljs-string">&#x27;sentence2&#x27;</span>: Value(dtype=<span class="hljs-string">&#x27;string&#x27;</span>, <span class="hljs-built_in">id</span>=<span class="hljs-literal">None</span>),
 <span class="hljs-string">&#x27;label&#x27;</span>: ClassLabel(num_classes=<span class="hljs-number">2</span>, names=[<span class="hljs-string">&#x27;not_equivalent&#x27;</span>, <span class="hljs-string">&#x27;equivalent&#x27;</span>], names_file=<span class="hljs-literal">None</span>, <span class="hljs-built_in">id</span>=<span class="hljs-literal">None</span>),
 <span class="hljs-string">&#x27;idx&#x27;</span>: Value(dtype=<span class="hljs-string">&#x27;int32&#x27;</span>, <span class="hljs-built_in">id</span>=<span class="hljs-literal">None</span>)}`}}),We=new jp({props:{$$slots:{default:[tm]},$$scope:{ctx:C}}}),qs=new Tl({});const wp=[am,nm],Hs=[];function yp(e,p){return e[0]==="pt"?0:1}ge=yp(C),ke=Hs[ge]=wp[ge](C),js=new T({props:{code:"",highlighted:`<span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> AutoTokenizer

checkpoint = <span class="hljs-string">&quot;bert-base-uncased&quot;</span>
tokenizer = AutoTokenizer.from_pretrained(checkpoint)
tokenized_sentences_1 = tokenizer(raw_datasets[<span class="hljs-string">&quot;train&quot;</span>][<span class="hljs-string">&quot;sentence1&quot;</span>])
tokenized_sentences_2 = tokenizer(raw_datasets[<span class="hljs-string">&quot;train&quot;</span>][<span class="hljs-string">&quot;sentence2&quot;</span>])`}}),Es=new T({props:{code:`inputs = tokenizer(
    "This is the first sentence.", "This is the second one."
)  # "C'est la premi\xE8re phrase.", "C'est la deuxi\xE8me."
inputs`,highlighted:`inputs = tokenizer(
    <span class="hljs-string">&quot;This is the first sentence.&quot;</span>, <span class="hljs-string">&quot;This is the second one.&quot;</span>
)  <span class="hljs-comment"># &quot;C&#x27;est la premi\xE8re phrase.&quot;, &quot;C&#x27;est la deuxi\xE8me.&quot;</span>
inputs`}}),$s=new T({props:{code:`{ 
  'input_ids': [101, 2023, 2003, 1996, 2034, 6251, 1012, 102, 2023, 2003, 1996, 2117, 2028, 1012, 102],
  'token_type_ids': [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1],
  'attention_mask': [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
}`,highlighted:`{ 
  <span class="hljs-string">&#x27;input_ids&#x27;</span>: [<span class="hljs-number">101</span>, <span class="hljs-number">2023</span>, <span class="hljs-number">2003</span>, <span class="hljs-number">1996</span>, <span class="hljs-number">2034</span>, <span class="hljs-number">6251</span>, <span class="hljs-number">1012</span>, <span class="hljs-number">102</span>, <span class="hljs-number">2023</span>, <span class="hljs-number">2003</span>, <span class="hljs-number">1996</span>, <span class="hljs-number">2117</span>, <span class="hljs-number">2028</span>, <span class="hljs-number">1012</span>, <span class="hljs-number">102</span>],
  <span class="hljs-string">&#x27;token_type_ids&#x27;</span>: [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>],
  <span class="hljs-string">&#x27;attention_mask&#x27;</span>: [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>]
}`}}),Ke=new jp({props:{$$slots:{default:[lm]},$$scope:{ctx:C}}}),gs=new T({props:{code:'tokenizer.convert_ids_to_tokens(inputs["input_ids"])',highlighted:'tokenizer.convert_ids_to_tokens(inputs[<span class="hljs-string">&quot;input_ids&quot;</span>])'}}),ks=new T({props:{code:"['[CLS]', 'this', 'is', 'the', 'first', 'sentence', '.', '[SEP]', 'this', 'is', 'the', 'second', 'one', '.', '[SEP]']",highlighted:'[<span class="hljs-string">&#x27;[CLS]&#x27;</span>, <span class="hljs-string">&#x27;this&#x27;</span>, <span class="hljs-string">&#x27;is&#x27;</span>, <span class="hljs-string">&#x27;the&#x27;</span>, <span class="hljs-string">&#x27;first&#x27;</span>, <span class="hljs-string">&#x27;sentence&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;[SEP]&#x27;</span>, <span class="hljs-string">&#x27;this&#x27;</span>, <span class="hljs-string">&#x27;is&#x27;</span>, <span class="hljs-string">&#x27;the&#x27;</span>, <span class="hljs-string">&#x27;second&#x27;</span>, <span class="hljs-string">&#x27;one&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;[SEP]&#x27;</span>]'}}),xs=new T({props:{code:`['[CLS]', 'this', 'is', 'the', 'first', 'sentence', '.', '[SEP]', 'this', 'is', 'the', 'second', 'one', '.', '[SEP]']
[      0,      0,    0,     0,       0,          0,   0,       0,      1,    1,     1,        1,     1,   1,       1]`,highlighted:`[<span class="hljs-string">&#x27;[CLS]&#x27;</span>, <span class="hljs-string">&#x27;this&#x27;</span>, <span class="hljs-string">&#x27;is&#x27;</span>, <span class="hljs-string">&#x27;the&#x27;</span>, <span class="hljs-string">&#x27;first&#x27;</span>, <span class="hljs-string">&#x27;sentence&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;[SEP]&#x27;</span>, <span class="hljs-string">&#x27;this&#x27;</span>, <span class="hljs-string">&#x27;is&#x27;</span>, <span class="hljs-string">&#x27;the&#x27;</span>, <span class="hljs-string">&#x27;second&#x27;</span>, <span class="hljs-string">&#x27;one&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;[SEP]&#x27;</span>]
[      <span class="hljs-number">0</span>,      <span class="hljs-number">0</span>,    <span class="hljs-number">0</span>,     <span class="hljs-number">0</span>,       <span class="hljs-number">0</span>,          <span class="hljs-number">0</span>,   <span class="hljs-number">0</span>,       <span class="hljs-number">0</span>,      <span class="hljs-number">1</span>,    <span class="hljs-number">1</span>,     <span class="hljs-number">1</span>,        <span class="hljs-number">1</span>,     <span class="hljs-number">1</span>,   <span class="hljs-number">1</span>,       <span class="hljs-number">1</span>]`}}),zs=new T({props:{code:`tokenized_dataset = tokenizer(
    raw_datasets["train"]["sentence1"],
    raw_datasets["train"]["sentence2"],
    padding=True,
    truncation=True,
)`,highlighted:`tokenized_dataset = tokenizer(
    raw_datasets[<span class="hljs-string">&quot;train&quot;</span>][<span class="hljs-string">&quot;sentence1&quot;</span>],
    raw_datasets[<span class="hljs-string">&quot;train&quot;</span>][<span class="hljs-string">&quot;sentence2&quot;</span>],
    padding=<span class="hljs-literal">True</span>,
    truncation=<span class="hljs-literal">True</span>,
)`}}),Cs=new T({props:{code:`def tokenize_function(example):
    return tokenizer(example["sentence1"], example["sentence2"], truncation=True)`,highlighted:`<span class="hljs-keyword">def</span> <span class="hljs-title function_">tokenize_function</span>(<span class="hljs-params">example</span>):
    <span class="hljs-keyword">return</span> tokenizer(example[<span class="hljs-string">&quot;sentence1&quot;</span>], example[<span class="hljs-string">&quot;sentence2&quot;</span>], truncation=<span class="hljs-literal">True</span>)`}}),Ds=new T({props:{code:`tokenized_datasets = raw_datasets.map(tokenize_function, batched=True)
tokenized_datasets`,highlighted:`tokenized_datasets = raw_datasets.<span class="hljs-built_in">map</span>(tokenize_function, batched=<span class="hljs-literal">True</span>)
tokenized_datasets`}}),Ps=new T({props:{code:`DatasetDict({
    train: Dataset({
        features: ['attention_mask', 'idx', 'input_ids', 'label', 'sentence1', 'sentence2', 'token_type_ids'],
        num_rows: 3668
    })
    validation: Dataset({
        features: ['attention_mask', 'idx', 'input_ids', 'label', 'sentence1', 'sentence2', 'token_type_ids'],
        num_rows: 408
    })
    test: Dataset({
        features: ['attention_mask', 'idx', 'input_ids', 'label', 'sentence1', 'sentence2', 'token_type_ids'],
        num_rows: 1725
    })
})`,highlighted:`DatasetDict({
    train: Dataset({
        features: [<span class="hljs-string">&#x27;attention_mask&#x27;</span>, <span class="hljs-string">&#x27;idx&#x27;</span>, <span class="hljs-string">&#x27;input_ids&#x27;</span>, <span class="hljs-string">&#x27;label&#x27;</span>, <span class="hljs-string">&#x27;sentence1&#x27;</span>, <span class="hljs-string">&#x27;sentence2&#x27;</span>, <span class="hljs-string">&#x27;token_type_ids&#x27;</span>],
        num_rows: <span class="hljs-number">3668</span>
    })
    validation: Dataset({
        features: [<span class="hljs-string">&#x27;attention_mask&#x27;</span>, <span class="hljs-string">&#x27;idx&#x27;</span>, <span class="hljs-string">&#x27;input_ids&#x27;</span>, <span class="hljs-string">&#x27;label&#x27;</span>, <span class="hljs-string">&#x27;sentence1&#x27;</span>, <span class="hljs-string">&#x27;sentence2&#x27;</span>, <span class="hljs-string">&#x27;token_type_ids&#x27;</span>],
        num_rows: <span class="hljs-number">408</span>
    })
    test: Dataset({
        features: [<span class="hljs-string">&#x27;attention_mask&#x27;</span>, <span class="hljs-string">&#x27;idx&#x27;</span>, <span class="hljs-string">&#x27;input_ids&#x27;</span>, <span class="hljs-string">&#x27;label&#x27;</span>, <span class="hljs-string">&#x27;sentence1&#x27;</span>, <span class="hljs-string">&#x27;sentence2&#x27;</span>, <span class="hljs-string">&#x27;token_type_ids&#x27;</span>],
        num_rows: <span class="hljs-number">1725</span>
    })
})`}}),Ms=new Tl({}),Ts=new qa({props:{id:"7q5NyFT8REg"}});function Cp(e,p){return e[0]==="pt"?rm:om}let kl=Cp(C),Ve=kl(C);const Dp=[um,im],Is=[];function Pp(e,p){return e[0]==="pt"?0:1}xe=Pp(C),ze=Is[xe]=Dp[xe](C),Ss=new T({props:{code:`samples = tokenized_datasets["train"][:8]
samples = {k: v for k, v in samples.items() if k not in ["idx", "sentence1", "sentence2"]}
[len(x) for x in samples["input_ids"]]`,highlighted:`samples = tokenized_datasets[<span class="hljs-string">&quot;train&quot;</span>][:<span class="hljs-number">8</span>]
samples = {k: v <span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span> samples.items() <span class="hljs-keyword">if</span> k <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> [<span class="hljs-string">&quot;idx&quot;</span>, <span class="hljs-string">&quot;sentence1&quot;</span>, <span class="hljs-string">&quot;sentence2&quot;</span>]}
[<span class="hljs-built_in">len</span>(x) <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> samples[<span class="hljs-string">&quot;input_ids&quot;</span>]]`}}),Ns=new T({props:{code:"[50, 59, 47, 67, 59, 50, 62, 32]",highlighted:'[<span class="hljs-number">50</span>, <span class="hljs-number">59</span>, <span class="hljs-number">47</span>, <span class="hljs-number">67</span>, <span class="hljs-number">59</span>, <span class="hljs-number">50</span>, <span class="hljs-number">62</span>, <span class="hljs-number">32</span>]'}}),Os=new T({props:{code:`batch = data_collator(samples)
{k: v.shape for k, v in batch.items()}`,highlighted:`batch = data_collator(samples)
{k: v.shape <span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span> batch.items()}`}});const Mp=[cm,pm],Fs=[];function Tp(e,p){return e[0]==="tf"?0:1}we=Tp(C),ye=Fs[we]=Mp[we](C),ns=new jp({props:{$$slots:{default:[dm]},$$scope:{ctx:C}}});let W=C[0]==="tf"&&Fd();return{c(){i=l("meta"),d=m(),x(u.$$.fragment),v=m(),E=l("h1"),_=l("a"),b=l("span"),x(k.$$.fragment),h=m(),$=l("span"),S=n("Pr\xE9parer les donn\xE9es"),F=m(),L.c(),N=m(),H.c(),I=m(),g=l("p"),ae=n("Evidemment, entra\xEEner un mod\xE8le avec seulement deux phrases ne va pas donner de bons r\xE9sultats. Pour obtenir de meilleurs r\xE9sultats, vous allez avoir \xE0 pr\xE9parer un plus grand jeu de donn\xE9es."),Q=m(),U=l("p"),le=n("Dans cette section, nous allons utiliser comme exemple le jeu de donn\xE9es MRPC ("),P=l("em"),V=n("Microsoft Research Paraphrase Corpus"),Gs=n(") pr\xE9sent\xE9 dans un "),Ce=l("a"),Ws=n("papier"),Js=n(" par William B. Dolan et Chris Brockett. Ce jeu de donn\xE9es contient 5801 paires de phrases avec un label indiquant si ces paires sont des paraphrases ou non (i.e. si elles ont la m\xEAme signification). Nous l\u2019avons choisi pour ce chapitre parce que c\u2019est un petit jeu de donn\xE9es et cela rend donc simples les exp\xE9riences d\u2019entra\xEEnement sur ce jeu de donn\xE9es."),us=m(),pe=l("h3"),Ue=l("a"),jt=l("span"),x(ps.$$.fragment),Sl=m(),Qs=l("span"),Nl=n("Charger un jeu de donn\xE9es depuis le "),Et=l("i"),Ol=n("Hub"),ja=m(),$e.c(),Ks=m(),K=l("p"),Al=n("Le "),$t=l("em"),Ll=n("Hub"),Rl=n(" ne contient pas seulement des mod\xE8les mais aussi plusieurs jeux de donn\xE9es dans un tas de langues diff\xE9rentes. Vous pouvez explorer les jeux de donn\xE9es "),cs=l("a"),Hl=n("ici"),Il=n(" et nous vous conseillons d\u2019essayer de charger un nouveau jeu de donn\xE9es une fois que vous avez \xE9tudi\xE9 cette section (voir la documentation g\xE9n\xE9rale "),ds=l("a"),Fl=n("ici"),Vl=n("). Mais pour l\u2019instant, concentrons-nous sur le jeu de donn\xE9es MRPC ! Il s\u2019agit de l\u2019un des 10 jeux de donn\xE9es qui constituent le "),Be=l("a"),gt=l("em"),Ul=n("benchmark"),Bl=n(" GLUE"),Gl=n(" qui est un "),kt=l("em"),Wl=n("benchmark"),Jl=n(" acad\xE9mique utilis\xE9 pour mesurer les performances des mod\xE8les d\u2019apprentissage automatique sur 10 diff\xE9rentes t\xE2ches de classification de textes."),Ea=m(),De=l("p"),Ql=n("La biblioth\xE8que \u{1F917} "),xt=l("em"),Kl=n("Datasets"),Yl=n(" propose une commande tr\xE8s simple pour t\xE9l\xE9charger et mettre en cache un jeu de donn\xE9es \xE0 partir du "),zt=l("em"),Zl=n("Hub"),Xl=n(". On peut t\xE9l\xE9charger le jeu de donn\xE9es MRPC comme ceci :"),$a=m(),x(ms.$$.fragment),ga=m(),x(fs.$$.fragment),ka=m(),Y=l("p"),eo=n("Comme vous le voyez, on obtient un objet de type "),wt=l("code"),so=n("DatasetDict"),to=n(" qui contient le jeu de donn\xE9es d\u2019entra\xEEnement, celui de validation et celui de test. Chacun d\u2019eux contient plusieurs colonnes ("),yt=l("code"),no=n("sentence1"),ao=n(", "),Ct=l("code"),lo=n("sentence2"),oo=n(", "),Dt=l("code"),ro=n("label"),io=n(" et "),Pt=l("code"),uo=n("idx"),po=n(") et une variable nombre de lignes qui contient le nombre d\u2019\xE9l\xE9ments dans chaque jeu de donn\xE9es (il y a donc 3.668 paires de phrases dans le jeu d\u2019entra\xEEnement, 408 dans celui de validation et 1.725 dans celui de test)."),xa=m(),Pe=l("p"),co=n("Cette commande t\xE9l\xE9charge et met en cache le jeu de donn\xE9es dans "),Mt=l("em"),mo=n("~/.cache/huggingface/dataset"),fo=n(". Rappelez-vous que comme vu au chapitre 2, vous pouvez personnaliser votre dossier cache en modifiant la variable d\u2019environnement "),Tt=l("code"),ho=n("HF_HOME"),vo=n("."),za=m(),Ge=l("p"),_o=n("Nous pouvons acc\xE9der \xE0 chaque paire de phrase de notre objet "),St=l("code"),bo=n("raw_datasets"),qo=n(" par les indices, comme avec un dictionnaire :"),wa=m(),x(hs.$$.fragment),ya=m(),x(vs.$$.fragment),Ca=m(),Me=l("p"),jo=n("Nous pouvons voir que les \xE9tiquettes sont d\xE9j\xE0 des entiers, donc nous n\u2019aurons pas \xE0 faire de pr\xE9traitement ici. Pour savoir quel entier correspond \xE0 quel label, nous pouvons inspecter les "),Nt=l("code"),Eo=n("features"),$o=n(" de notre "),Ot=l("code"),go=n("raw_train_dataset"),ko=n(". Cela nous indiquera le type de chaque colonne :"),Da=m(),x(_s.$$.fragment),Pa=m(),x(bs.$$.fragment),Ma=m(),B=l("p"),xo=n("En r\xE9alit\xE9, "),At=l("code"),zo=n("label"),wo=n(" est de type "),Lt=l("code"),yo=n("ClassLabel"),Co=n(" et la correspondance des entiers aux noms des labels est enregistr\xE9e le dossier "),Rt=l("em"),Do=n("names"),Po=n(". "),Ht=l("code"),Mo=n("0"),To=n(" correspond \xE0  "),It=l("code"),So=n("not_equivalent"),No=n(" et "),Ft=l("code"),Oo=n("1"),Ao=n(" correspond \xE0 "),Vt=l("code"),Lo=n("equivalent"),Ro=n("."),Ta=m(),x(We.$$.fragment),Sa=m(),Ie=l("h3"),Je=l("a"),Ut=l("span"),x(qs.$$.fragment),Ho=m(),Bt=l("span"),Io=n("Pr\xE9traitement d'un jeu de donn\xE9es"),Na=m(),ke.c(),Ys=m(),ce=l("p"),Fo=n("Pour pr\xE9traiter le jeu de donn\xE9es, nous devons convertir le texte en chiffres compr\xE9hensibles par le mod\xE8le. Comme vous l\u2019avez vu dans le "),Zs=l("a"),Vo=n("chapitre pr\xE9c\xE9dent"),Uo=n(", cette conversion est effectu\xE9e par un "),Gt=l("em"),Bo=n("tokenizer"),Go=n(". Nous pouvons fournir au "),Wt=l("em"),Wo=n("tokenizer"),Jo=n(" une phrase ou une liste de phrases, de sorte que nous pouvons directement tokeniser toutes les premi\xE8res phrases et toutes les secondes phrases de chaque paire comme ceci :"),Oa=m(),x(js.$$.fragment),Aa=m(),Qe=l("p"),Qo=n("Cependant, nous ne pouvons pas simplement passer deux s\xE9quences au mod\xE8le et obtenir une pr\xE9diction pour savoir si les deux phrases sont des paraphrases ou non. Nous devons traiter les deux s\xE9quences comme une paire, et appliquer le pr\xE9traitement appropri\xE9. Heureusement, le "),Jt=l("em"),Ko=n("tokenizer"),Yo=n(" peut \xE9galement prendre une paire de s\xE9quences et la pr\xE9parer de la mani\xE8re attendue par notre mod\xE8le BERT :"),La=m(),x(Es.$$.fragment),Ra=m(),x($s.$$.fragment),Ha=m(),oe=l("p"),Zo=n("Nous avons discut\xE9 des cl\xE9s "),Qt=l("code"),Xo=n("input_ids"),er=n(" et "),Kt=l("code"),sr=n("attention_mask"),tr=n(" dans le "),Xs=l("a"),nr=n("chapitre 2"),ar=n(", mais nous avons laiss\xE9 de c\xF4t\xE9 les "),Yt=l("code"),lr=n("token_type_ids"),or=n(". Dans cet exemple, c\u2019est ce qui indique au mod\xE8le quelle partie de l\u2019entr\xE9e est la premi\xE8re phrase et quelle partie est la deuxi\xE8me phrase."),Ia=m(),x(Ke.$$.fragment),Fa=m(),Ye=l("p"),rr=n("Si on d\xE9code les IDs dans "),Zt=l("code"),ir=n("input_ids"),ur=n(" en mots :"),Va=m(),x(gs.$$.fragment),Ua=m(),et=l("p"),pr=n("nous aurons :"),Ba=m(),x(ks.$$.fragment),Ga=m(),Te=l("p"),cr=n("Nous voyons donc que le mod\xE8le s\u2019attend \xE0 ce que les entr\xE9es soient de la forme "),Xt=l("code"),dr=n("[CLS] phrase1 [SEP] phrase2 [SEP]"),mr=n(" lorsqu\u2019il y a deux phrases. En alignant cela avec les "),en=l("code"),fr=n("token_type_ids"),hr=n(", on obtient :"),Wa=m(),x(xs.$$.fragment),Ja=m(),J=l("p"),vr=n("Comme vous pouvez le voir, les parties de l\u2019entr\xE9e correspondant \xE0 "),sn=l("code"),_r=n("[CLS] sentence1 [SEP]"),br=n(" ont toutes un "),tn=l("em"),qr=n("token"),jr=n(" de type ID de "),nn=l("code"),Er=n("0"),$r=n(", tandis que les autres parties, correspondant \xE0 "),an=l("code"),gr=n("sentence2 [SEP]"),kr=n(", ont toutes un "),ln=l("em"),xr=n("token"),zr=n(" de type ID de "),on=l("code"),wr=n("1"),yr=n("."),Qa=m(),Se=l("p"),Cr=n("Notez que si vous choisissez un autre "),rn=l("em"),Dr=n("checkpoint"),Pr=n(", vous n\u2019aurez pas n\xE9cessairement les "),un=l("code"),Mr=n("token_type_ids"),Tr=n(" dans vos entr\xE9es tokenis\xE9es (par exemple, ils ne sont pas retourn\xE9s si vous utilisez un mod\xE8le DistilBERT). Ils ne sont retourn\xE9s que lorsque le mod\xE8le sait quoi faire avec eux, parce qu\u2019il les a vus pendant son pr\xE9-entra\xEEnement."),Ka=m(),de=l("p"),Sr=n("Ici, BERT est pr\xE9-entra\xEEn\xE9 avec les "),pn=l("em"),Nr=n("tokens"),Or=n(" de type ID et en plus de l\u2019objectif de mod\xE9lisation du langage masqu\xE9 dont nous avons abord\xE9 dans "),st=l("a"),Ar=n("chapitre 1"),Lr=n(", il a un objectif suppl\xE9mentaire appel\xE9 "),cn=l("em"),Rr=n("pr\xE9diction de la phrase suivante"),Hr=n(". Le but de cette t\xE2che est de mod\xE9liser la relation entre des paires de phrases."),Ya=m(),Ze=l("p"),Ir=n("Avec la pr\xE9diction de la phrase suivante, on fournit au mod\xE8le des paires de phrases (avec des "),dn=l("em"),Fr=n("tokens"),Vr=n(" masqu\xE9s de mani\xE8re al\xE9atoire) et on lui demande de pr\xE9dire si la deuxi\xE8me phrase suit la premi\xE8re. Pour rendre la t\xE2che non triviale, la moiti\xE9 du temps, les phrases se suivent dans le document d\u2019origine dont elles ont \xE9t\xE9 extraites, et l\u2019autre moiti\xE9 du temps, les deux phrases proviennent de deux documents diff\xE9rents."),Za=m(),re=l("p"),Ur=n("En g\xE9n\xE9ral, vous n\u2019avez pas besoin de vous inqui\xE9ter de savoir s\u2019il y a ou non des "),mn=l("code"),Br=n("token_type_ids"),Gr=n(" dans vos entr\xE9es tokenis\xE9es : tant que vous utilisez le m\xEAme "),fn=l("em"),Wr=n("checkpoint"),Jr=n(" pour le "),hn=l("em"),Qr=n("tokenizer"),Kr=n(" et le mod\xE8le, tout ira bien puisque le "),vn=l("em"),Yr=n("tokenizer"),Zr=n(" sait quoi fournir \xE0 son mod\xE8le."),Xa=m(),ie=l("p"),Xr=n("Maintenant que nous avons vu comment notre "),_n=l("em"),ei=n("tokenizer"),si=n(" peut traiter une paire de phrases, nous pouvons l\u2019utiliser pour tokeniser l\u2019ensemble de notre jeu de donn\xE9es : comme dans le "),tt=l("a"),ti=n("chapitre pr\xE9c\xE9dent"),ni=n(", nous pouvons fournir au "),bn=l("em"),ai=n("tokenizer"),li=n(" une liste de paires de phrases en lui donnant la liste des premi\xE8res phrases, puis la liste des secondes phrases. Ceci est \xE9galement compatible avec les options de remplissage et de troncature que nous avons vues dans le "),nt=l("a"),oi=n("chapitre 2"),ri=n(". Voici donc une fa\xE7on de pr\xE9traiter le jeu de donn\xE9es d\u2019entra\xEEnement :"),el=m(),x(zs.$$.fragment),sl=m(),Z=l("p"),ii=n("Cela fonctionne bien, mais a l\u2019inconv\xE9nient de retourner un dictionnaire (avec nos cl\xE9s, "),qn=l("code"),ui=n("input_ids"),pi=n(", "),jn=l("code"),ci=n("attention_mask"),di=n(", et "),En=l("code"),mi=n("token_type_ids"),fi=n(", et des valeurs qui sont des listes de listes). Cela ne fonctionnera \xE9galement que si vous avez assez de RAM pour stocker l\u2019ensemble de votre jeu de donn\xE9es pendant la tokenisation (alors que les jeux de donn\xE9es de la biblioth\xE8que \u{1F917} "),$n=l("em"),hi=n("Datasets"),vi=n(" sont des fichiers "),ws=l("a"),_i=n("Apache Arrow"),bi=n(" stock\xE9s sur le disque, vous ne gardez donc en m\xE9moire que les \xE9chantillons que vous demandez)."),tl=m(),Ne=l("p"),qi=n("Pour conserver les donn\xE9es sous forme de jeu de donn\xE9es, nous utiliserons la m\xE9thode "),ys=l("a"),gn=l("code"),ji=n("Dataset.map()"),Ei=n(". Cela nous permet \xE9galement une certaine flexibilit\xE9, si nous avons besoin d\u2019un pr\xE9traitement plus pouss\xE9 que la simple tokenisation. La m\xE9thode "),kn=l("code"),$i=n("map()"),gi=n(" fonctionne en appliquant une fonction sur chaque \xE9l\xE9ment de l\u2019ensemble de donn\xE9es, donc d\xE9finissons une fonction qui tokenise nos entr\xE9es :"),nl=m(),x(Cs.$$.fragment),al=m(),M=l("p"),ki=n("Cette fonction prend un dictionnaire (comme les \xE9l\xE9ments de notre jeu de donn\xE9es) et retourne un nouveau dictionnaire avec les cl\xE9s "),xn=l("code"),xi=n("input_ids"),zi=n(", "),zn=l("code"),wi=n("attention_mask"),yi=n(", et "),wn=l("code"),Ci=n("token_type_ids"),Di=n(". Notez que cela fonctionne \xE9galement si le dictionnaire "),yn=l("code"),Pi=n("example"),Mi=n(" contient plusieurs \xE9chantillons (chaque cl\xE9 \xE9tant une liste de phrases) puisque le "),Cn=l("code"),Ti=n("tokenizer"),Si=n(" travaille sur des listes de paires de phrases, comme vu pr\xE9c\xE9demment. Cela nous permettra d\u2019utiliser l\u2019option "),Dn=l("code"),Ni=n("batched=True"),Oi=n(" dans notre appel \xE0 "),Pn=l("code"),Ai=n("map()"),Li=n(", ce qui acc\xE9l\xE9rera grandement la tok\xE9nisation. Le "),Mn=l("code"),Ri=n("tokenizer"),Hi=n(" est soutenu par un "),Tn=l("em"),Ii=n("tokenizer"),Fi=n(" \xE9crit en Rust \xE0 partir de la biblioth\xE8que "),Xe=l("a"),Vi=n("\u{1F917} "),Sn=l("em"),Ui=n("Tokenizers"),Bi=n(". Ce "),Nn=l("em"),Gi=n("tokenizer"),Wi=n(" peut \xEAtre tr\xE8s rapide, mais seulement si on lui donne beaucoup d\u2019entr\xE9es en m\xEAme temps."),ll=m(),me=l("p"),Ji=n("Notez que nous avons laiss\xE9 l\u2019argument "),On=l("code"),Qi=n("padding"),Ki=n(" hors de notre fonction de "),An=l("em"),Yi=n("tokenizer"),Zi=n(" pour le moment. C\u2019est parce que le "),Ln=l("em"),Xi=n("padding"),eu=n(" de tous les \xE9chantillons \xE0 la longueur maximale n\u2019est pas efficace : il est pr\xE9f\xE9rable de remplir les \xE9chantillons lorsque nous construisons un batch, car alors nous avons seulement besoin de remplir \xE0 la longueur maximale dans ce batch, et non la longueur maximale dans l\u2019ensemble des donn\xE9es. Cela peut permettre de gagner beaucoup de temps et de puissance de traitement lorsque les entr\xE9es ont des longueurs tr\xE8s variables !"),ol=m(),Oe=l("p"),su=n("Voici comment nous appliquons la fonction de tokenization sur tous nos jeux de donn\xE9es en m\xEAme temps. Nous utilisons "),Rn=l("code"),tu=n("batched=True"),nu=n(" dans notre appel \xE0 "),Hn=l("code"),au=n("map"),lu=n(" pour que la fonction soit appliqu\xE9e \xE0 plusieurs \xE9l\xE9ments de notre jeu de donn\xE9es en une fois, et non \xE0 chaque \xE9l\xE9ment s\xE9par\xE9ment. Cela permet un pr\xE9traitement plus rapide."),rl=m(),x(Ds.$$.fragment),il=m(),es=l("p"),ou=n("La fa\xE7on dont la biblioth\xE8que \u{1F917} "),In=l("em"),ru=n("Datasets"),iu=n(" applique ce traitement consiste \xE0 ajouter de nouveaux champs aux jeux de donn\xE9es, un pour chaque cl\xE9 du dictionnaire renvoy\xE9 par la fonction de pr\xE9traitement :"),ul=m(),x(Ps.$$.fragment),pl=m(),X=l("p"),uu=n("Vous pouvez m\xEAme utiliser le multitraitement lorsque vous appliquez votre fonction de pr\xE9traitement avec "),Fn=l("code"),pu=n("map()"),cu=n(" en passant un argument "),Vn=l("code"),du=n("num_proc"),mu=n(". Nous ne l\u2019avons pas fait ici parce que la biblioth\xE8que \u{1F917} "),Un=l("em"),fu=n("Tokenizers"),hu=n(" utilise d\xE9j\xE0 plusieurs "),Bn=l("em"),vu=n("threads"),_u=n(" pour tokeniser nos \xE9chantillons plus rapidement, mais si vous n\u2019utilisez pas un "),Gn=l("em"),bu=n("tokenizer"),qu=n(" rapide soutenu par cette biblioth\xE8que, cela pourrait acc\xE9l\xE9rer votre pr\xE9traitement."),cl=m(),ee=l("p"),ju=n("Notre "),Wn=l("code"),Eu=n("tokenize_function"),$u=n(" retourne un dictionnaire avec les cl\xE9s "),Jn=l("code"),gu=n("input_ids"),ku=n(", "),Qn=l("code"),xu=n("attention_mask"),zu=n(", et "),Kn=l("code"),wu=n("token_type_ids"),yu=n(", donc ces trois champs sont ajout\xE9s \xE0 toutes les divisions de notre jeu de donn\xE9es. Notez que nous aurions \xE9galement pu modifier des champs existants si notre fonction de pr\xE9traitement avait retourn\xE9 une nouvelle valeur pour une cl\xE9 existante dans l\u2019ensemble de donn\xE9es auquel nous avons appliqu\xE9 "),Yn=l("code"),Cu=n("map()"),Du=n("."),dl=m(),ss=l("p"),Pu=n("La derni\xE8re chose que nous devrons faire est de remplir tous les exemples \xE0 la longueur de l\u2019\xE9l\xE9ment le plus long lorsque nous regroupons les \xE9l\xE9ments, une technique que nous appelons le "),Zn=l("em"),Mu=n("padding dynamique"),Tu=n("."),ml=m(),Fe=l("h3"),ts=l("a"),Xn=l("span"),x(Ms.$$.fragment),Su=m(),at=l("span"),ea=l("i"),Nu=n("Padding"),Ou=n(" dynamique"),fl=m(),x(Ts.$$.fragment),hl=m(),Ve.c(),lt=m(),G=l("p"),Au=n("Pour faire cela en pratique, nous devons d\xE9finir une fonction de rassemblement qui appliquera la bonne quantit\xE9 de "),sa=l("em"),Lu=n("padding"),Ru=n(" aux \xE9l\xE9ments du jeu de donn\xE9es que nous voulons regrouper. Heureusement, la biblioth\xE8que \u{1F917} "),ta=l("em"),Hu=n("Transformers"),Iu=n(" nous fournit une telle fonction via "),na=l("code"),Fu=n("DataCollatorWithPadding"),Vu=n(". Elle prend un "),aa=l("em"),Uu=n("tokenizer"),Bu=n(" lorsque vous l\u2019instanciez (pour savoir quel "),la=l("em"),Gu=n("token"),Wu=n(" de "),oa=l("em"),Ju=n("padding"),Qu=n(" utiliser et si le mod\xE8le s\u2019attend \xE0 ce que le "),ra=l("em"),Ku=n("padding"),Yu=n(" soit \xE0 gauche ou \xE0 droite des entr\xE9es) et fera tout ce dont vous avez besoin :"),vl=m(),ze.c(),ot=m(),se=l("p"),Zu=n("Pour tester notre nouveau jouet, prenons quelques \xE9l\xE9ments de notre jeu d\u2019entra\xEEnement avec lesquels nous allons former un batch. Ici, on supprime les colonnes "),ia=l("code"),Xu=n("idx"),ep=n(", "),ua=l("code"),sp=n("sentence1"),tp=n(" et "),pa=l("code"),np=n("sentence2"),ap=n(" puisque nous n\u2019en aurons pas besoin et qu\u2019elles contiennent des "),ca=l("em"),lp=n("strings"),op=n(" (et nous ne pouvons pas cr\xE9er des tenseurs avec des "),da=l("em"),rp=n("strings"),ip=n(") et on regarde la longueur de chaque entr\xE9e du batch :"),_l=m(),x(Ss.$$.fragment),bl=m(),x(Ns.$$.fragment),ql=m(),fe=l("p"),up=n("Sans surprise, nous obtenons des \xE9chantillons de longueur variable, de 32 \xE0 67. Le "),ma=l("em"),pp=n("padding"),cp=n(" dynamique signifie que les \xE9chantillons de ce batch doivent tous \xEAtre rembourr\xE9s \xE0 une longueur de 67, la longueur maximale dans le batch. Sans le "),fa=l("em"),dp=n("padding"),mp=n(" dynamique, tous les \xE9chantillons devraient \xEAtre rembourr\xE9s \xE0 la longueur maximale du jeu de donn\xE9es entier, ou \xE0 la longueur maximale que le mod\xE8le peut accepter. V\xE9rifions \xE0 nouveau que notre "),ha=l("code"),fp=n("data_collator"),hp=n(" rembourre dynamiquement le batch correctement :"),jl=m(),x(Os.$$.fragment),El=m(),ye.c(),rt=m(),x(ns.$$.fragment),$l=m(),W&&W.c(),it=Id(),this.h()},l(e){const p=Wd('[data-svelte="svelte-1phssyn"]',document.head);i=o(p,"META",{name:!0,content:!0}),p.forEach(t),d=f(e),z(u.$$.fragment,e),v=f(e),E=o(e,"H1",{class:!0});var Vs=r(E);_=o(Vs,"A",{id:!0,class:!0,href:!0});var ut=r(_);b=o(ut,"SPAN",{});var pt=r(b);z(k.$$.fragment,pt),pt.forEach(t),ut.forEach(t),h=f(Vs),$=o(Vs,"SPAN",{});var ct=r($);S=a(ct,"Pr\xE9parer les donn\xE9es"),ct.forEach(t),Vs.forEach(t),F=f(e),L.l(e),N=f(e),H.l(e),I=f(e),g=o(e,"P",{});var va=r(g);ae=a(va,"Evidemment, entra\xEEner un mod\xE8le avec seulement deux phrases ne va pas donner de bons r\xE9sultats. Pour obtenir de meilleurs r\xE9sultats, vous allez avoir \xE0 pr\xE9parer un plus grand jeu de donn\xE9es."),va.forEach(t),Q=f(e),U=o(e,"P",{});var Ae=r(U);le=a(Ae,"Dans cette section, nous allons utiliser comme exemple le jeu de donn\xE9es MRPC ("),P=o(Ae,"EM",{});var _a=r(P);V=a(_a,"Microsoft Research Paraphrase Corpus"),_a.forEach(t),Gs=a(Ae,") pr\xE9sent\xE9 dans un "),Ce=o(Ae,"A",{href:!0,rel:!0});var dt=r(Ce);Ws=a(dt,"papier"),dt.forEach(t),Js=a(Ae," par William B. Dolan et Chris Brockett. Ce jeu de donn\xE9es contient 5801 paires de phrases avec un label indiquant si ces paires sont des paraphrases ou non (i.e. si elles ont la m\xEAme signification). Nous l\u2019avons choisi pour ce chapitre parce que c\u2019est un petit jeu de donn\xE9es et cela rend donc simples les exp\xE9riences d\u2019entra\xEEnement sur ce jeu de donn\xE9es."),Ae.forEach(t),us=f(e),pe=o(e,"H3",{class:!0});var as=r(pe);Ue=o(as,"A",{id:!0,class:!0,href:!0});var ba=r(Ue);jt=o(ba,"SPAN",{});var Sp=r(jt);z(ps.$$.fragment,Sp),Sp.forEach(t),ba.forEach(t),Sl=f(as),Qs=o(as,"SPAN",{});var vp=r(Qs);Nl=a(vp,"Charger un jeu de donn\xE9es depuis le "),Et=o(vp,"I",{});var Np=r(Et);Ol=a(Np,"Hub"),Np.forEach(t),vp.forEach(t),as.forEach(t),ja=f(e),$e.l(e),Ks=f(e),K=o(e,"P",{});var he=r(K);Al=a(he,"Le "),$t=o(he,"EM",{});var Op=r($t);Ll=a(Op,"Hub"),Op.forEach(t),Rl=a(he," ne contient pas seulement des mod\xE8les mais aussi plusieurs jeux de donn\xE9es dans un tas de langues diff\xE9rentes. Vous pouvez explorer les jeux de donn\xE9es "),cs=o(he,"A",{href:!0,rel:!0});var Ap=r(cs);Hl=a(Ap,"ici"),Ap.forEach(t),Il=a(he," et nous vous conseillons d\u2019essayer de charger un nouveau jeu de donn\xE9es une fois que vous avez \xE9tudi\xE9 cette section (voir la documentation g\xE9n\xE9rale "),ds=o(he,"A",{href:!0,rel:!0});var Lp=r(ds);Fl=a(Lp,"ici"),Lp.forEach(t),Vl=a(he,"). Mais pour l\u2019instant, concentrons-nous sur le jeu de donn\xE9es MRPC ! Il s\u2019agit de l\u2019un des 10 jeux de donn\xE9es qui constituent le "),Be=o(he,"A",{href:!0,rel:!0});var _p=r(Be);gt=o(_p,"EM",{});var Rp=r(gt);Ul=a(Rp,"benchmark"),Rp.forEach(t),Bl=a(_p," GLUE"),_p.forEach(t),Gl=a(he," qui est un "),kt=o(he,"EM",{});var Hp=r(kt);Wl=a(Hp,"benchmark"),Hp.forEach(t),Jl=a(he," acad\xE9mique utilis\xE9 pour mesurer les performances des mod\xE8les d\u2019apprentissage automatique sur 10 diff\xE9rentes t\xE2ches de classification de textes."),he.forEach(t),Ea=f(e),De=o(e,"P",{});var mt=r(De);Ql=a(mt,"La biblioth\xE8que \u{1F917} "),xt=o(mt,"EM",{});var Ip=r(xt);Kl=a(Ip,"Datasets"),Ip.forEach(t),Yl=a(mt," propose une commande tr\xE8s simple pour t\xE9l\xE9charger et mettre en cache un jeu de donn\xE9es \xE0 partir du "),zt=o(mt,"EM",{});var Fp=r(zt);Zl=a(Fp,"Hub"),Fp.forEach(t),Xl=a(mt,". On peut t\xE9l\xE9charger le jeu de donn\xE9es MRPC comme ceci :"),mt.forEach(t),$a=f(e),z(ms.$$.fragment,e),ga=f(e),z(fs.$$.fragment,e),ka=f(e),Y=o(e,"P",{});var ve=r(Y);eo=a(ve,"Comme vous le voyez, on obtient un objet de type "),wt=o(ve,"CODE",{});var Vp=r(wt);so=a(Vp,"DatasetDict"),Vp.forEach(t),to=a(ve," qui contient le jeu de donn\xE9es d\u2019entra\xEEnement, celui de validation et celui de test. Chacun d\u2019eux contient plusieurs colonnes ("),yt=o(ve,"CODE",{});var Up=r(yt);no=a(Up,"sentence1"),Up.forEach(t),ao=a(ve,", "),Ct=o(ve,"CODE",{});var Bp=r(Ct);lo=a(Bp,"sentence2"),Bp.forEach(t),oo=a(ve,", "),Dt=o(ve,"CODE",{});var Gp=r(Dt);ro=a(Gp,"label"),Gp.forEach(t),io=a(ve," et "),Pt=o(ve,"CODE",{});var Wp=r(Pt);uo=a(Wp,"idx"),Wp.forEach(t),po=a(ve,") et une variable nombre de lignes qui contient le nombre d\u2019\xE9l\xE9ments dans chaque jeu de donn\xE9es (il y a donc 3.668 paires de phrases dans le jeu d\u2019entra\xEEnement, 408 dans celui de validation et 1.725 dans celui de test)."),ve.forEach(t),xa=f(e),Pe=o(e,"P",{});var ft=r(Pe);co=a(ft,"Cette commande t\xE9l\xE9charge et met en cache le jeu de donn\xE9es dans "),Mt=o(ft,"EM",{});var Jp=r(Mt);mo=a(Jp,"~/.cache/huggingface/dataset"),Jp.forEach(t),fo=a(ft,". Rappelez-vous que comme vu au chapitre 2, vous pouvez personnaliser votre dossier cache en modifiant la variable d\u2019environnement "),Tt=o(ft,"CODE",{});var Qp=r(Tt);ho=a(Qp,"HF_HOME"),Qp.forEach(t),vo=a(ft,"."),ft.forEach(t),za=f(e),Ge=o(e,"P",{});var xl=r(Ge);_o=a(xl,"Nous pouvons acc\xE9der \xE0 chaque paire de phrase de notre objet "),St=o(xl,"CODE",{});var Kp=r(St);bo=a(Kp,"raw_datasets"),Kp.forEach(t),qo=a(xl," par les indices, comme avec un dictionnaire :"),xl.forEach(t),wa=f(e),z(hs.$$.fragment,e),ya=f(e),z(vs.$$.fragment,e),Ca=f(e),Me=o(e,"P",{});var ht=r(Me);jo=a(ht,"Nous pouvons voir que les \xE9tiquettes sont d\xE9j\xE0 des entiers, donc nous n\u2019aurons pas \xE0 faire de pr\xE9traitement ici. Pour savoir quel entier correspond \xE0 quel label, nous pouvons inspecter les "),Nt=o(ht,"CODE",{});var Yp=r(Nt);Eo=a(Yp,"features"),Yp.forEach(t),$o=a(ht," de notre "),Ot=o(ht,"CODE",{});var Zp=r(Ot);go=a(Zp,"raw_train_dataset"),Zp.forEach(t),ko=a(ht,". Cela nous indiquera le type de chaque colonne :"),ht.forEach(t),Da=f(e),z(_s.$$.fragment,e),Pa=f(e),z(bs.$$.fragment,e),Ma=f(e),B=o(e,"P",{});var te=r(B);xo=a(te,"En r\xE9alit\xE9, "),At=o(te,"CODE",{});var Xp=r(At);zo=a(Xp,"label"),Xp.forEach(t),wo=a(te," est de type "),Lt=o(te,"CODE",{});var ec=r(Lt);yo=a(ec,"ClassLabel"),ec.forEach(t),Co=a(te," et la correspondance des entiers aux noms des labels est enregistr\xE9e le dossier "),Rt=o(te,"EM",{});var sc=r(Rt);Do=a(sc,"names"),sc.forEach(t),Po=a(te,". "),Ht=o(te,"CODE",{});var tc=r(Ht);Mo=a(tc,"0"),tc.forEach(t),To=a(te," correspond \xE0  "),It=o(te,"CODE",{});var nc=r(It);So=a(nc,"not_equivalent"),nc.forEach(t),No=a(te," et "),Ft=o(te,"CODE",{});var ac=r(Ft);Oo=a(ac,"1"),ac.forEach(t),Ao=a(te," correspond \xE0 "),Vt=o(te,"CODE",{});var lc=r(Vt);Lo=a(lc,"equivalent"),lc.forEach(t),Ro=a(te,"."),te.forEach(t),Ta=f(e),z(We.$$.fragment,e),Sa=f(e),Ie=o(e,"H3",{class:!0});var zl=r(Ie);Je=o(zl,"A",{id:!0,class:!0,href:!0});var oc=r(Je);Ut=o(oc,"SPAN",{});var rc=r(Ut);z(qs.$$.fragment,rc),rc.forEach(t),oc.forEach(t),Ho=f(zl),Bt=o(zl,"SPAN",{});var ic=r(Bt);Io=a(ic,"Pr\xE9traitement d'un jeu de donn\xE9es"),ic.forEach(t),zl.forEach(t),Na=f(e),ke.l(e),Ys=f(e),ce=o(e,"P",{});var ls=r(ce);Fo=a(ls,"Pour pr\xE9traiter le jeu de donn\xE9es, nous devons convertir le texte en chiffres compr\xE9hensibles par le mod\xE8le. Comme vous l\u2019avez vu dans le "),Zs=o(ls,"A",{href:!0});var uc=r(Zs);Vo=a(uc,"chapitre pr\xE9c\xE9dent"),uc.forEach(t),Uo=a(ls,", cette conversion est effectu\xE9e par un "),Gt=o(ls,"EM",{});var pc=r(Gt);Bo=a(pc,"tokenizer"),pc.forEach(t),Go=a(ls,". Nous pouvons fournir au "),Wt=o(ls,"EM",{});var cc=r(Wt);Wo=a(cc,"tokenizer"),cc.forEach(t),Jo=a(ls," une phrase ou une liste de phrases, de sorte que nous pouvons directement tokeniser toutes les premi\xE8res phrases et toutes les secondes phrases de chaque paire comme ceci :"),ls.forEach(t),Oa=f(e),z(js.$$.fragment,e),Aa=f(e),Qe=o(e,"P",{});var wl=r(Qe);Qo=a(wl,"Cependant, nous ne pouvons pas simplement passer deux s\xE9quences au mod\xE8le et obtenir une pr\xE9diction pour savoir si les deux phrases sont des paraphrases ou non. Nous devons traiter les deux s\xE9quences comme une paire, et appliquer le pr\xE9traitement appropri\xE9. Heureusement, le "),Jt=o(wl,"EM",{});var dc=r(Jt);Ko=a(dc,"tokenizer"),dc.forEach(t),Yo=a(wl," peut \xE9galement prendre une paire de s\xE9quences et la pr\xE9parer de la mani\xE8re attendue par notre mod\xE8le BERT :"),wl.forEach(t),La=f(e),z(Es.$$.fragment,e),Ra=f(e),z($s.$$.fragment,e),Ha=f(e),oe=o(e,"P",{});var Le=r(oe);Zo=a(Le,"Nous avons discut\xE9 des cl\xE9s "),Qt=o(Le,"CODE",{});var mc=r(Qt);Xo=a(mc,"input_ids"),mc.forEach(t),er=a(Le," et "),Kt=o(Le,"CODE",{});var fc=r(Kt);sr=a(fc,"attention_mask"),fc.forEach(t),tr=a(Le," dans le "),Xs=o(Le,"A",{href:!0});var hc=r(Xs);nr=a(hc,"chapitre 2"),hc.forEach(t),ar=a(Le,", mais nous avons laiss\xE9 de c\xF4t\xE9 les "),Yt=o(Le,"CODE",{});var vc=r(Yt);lr=a(vc,"token_type_ids"),vc.forEach(t),or=a(Le,". Dans cet exemple, c\u2019est ce qui indique au mod\xE8le quelle partie de l\u2019entr\xE9e est la premi\xE8re phrase et quelle partie est la deuxi\xE8me phrase."),Le.forEach(t),Ia=f(e),z(Ke.$$.fragment,e),Fa=f(e),Ye=o(e,"P",{});var yl=r(Ye);rr=a(yl,"Si on d\xE9code les IDs dans "),Zt=o(yl,"CODE",{});var _c=r(Zt);ir=a(_c,"input_ids"),_c.forEach(t),ur=a(yl," en mots :"),yl.forEach(t),Va=f(e),z(gs.$$.fragment,e),Ua=f(e),et=o(e,"P",{});var bc=r(et);pr=a(bc,"nous aurons :"),bc.forEach(t),Ba=f(e),z(ks.$$.fragment,e),Ga=f(e),Te=o(e,"P",{});var vt=r(Te);cr=a(vt,"Nous voyons donc que le mod\xE8le s\u2019attend \xE0 ce que les entr\xE9es soient de la forme "),Xt=o(vt,"CODE",{});var qc=r(Xt);dr=a(qc,"[CLS] phrase1 [SEP] phrase2 [SEP]"),qc.forEach(t),mr=a(vt," lorsqu\u2019il y a deux phrases. En alignant cela avec les "),en=o(vt,"CODE",{});var jc=r(en);fr=a(jc,"token_type_ids"),jc.forEach(t),hr=a(vt,", on obtient :"),vt.forEach(t),Wa=f(e),z(xs.$$.fragment,e),Ja=f(e),J=o(e,"P",{});var ue=r(J);vr=a(ue,"Comme vous pouvez le voir, les parties de l\u2019entr\xE9e correspondant \xE0 "),sn=o(ue,"CODE",{});var Ec=r(sn);_r=a(Ec,"[CLS] sentence1 [SEP]"),Ec.forEach(t),br=a(ue," ont toutes un "),tn=o(ue,"EM",{});var $c=r(tn);qr=a($c,"token"),$c.forEach(t),jr=a(ue," de type ID de "),nn=o(ue,"CODE",{});var gc=r(nn);Er=a(gc,"0"),gc.forEach(t),$r=a(ue,", tandis que les autres parties, correspondant \xE0 "),an=o(ue,"CODE",{});var kc=r(an);gr=a(kc,"sentence2 [SEP]"),kc.forEach(t),kr=a(ue,", ont toutes un "),ln=o(ue,"EM",{});var xc=r(ln);xr=a(xc,"token"),xc.forEach(t),zr=a(ue," de type ID de "),on=o(ue,"CODE",{});var zc=r(on);wr=a(zc,"1"),zc.forEach(t),yr=a(ue,"."),ue.forEach(t),Qa=f(e),Se=o(e,"P",{});var _t=r(Se);Cr=a(_t,"Notez que si vous choisissez un autre "),rn=o(_t,"EM",{});var wc=r(rn);Dr=a(wc,"checkpoint"),wc.forEach(t),Pr=a(_t,", vous n\u2019aurez pas n\xE9cessairement les "),un=o(_t,"CODE",{});var yc=r(un);Mr=a(yc,"token_type_ids"),yc.forEach(t),Tr=a(_t," dans vos entr\xE9es tokenis\xE9es (par exemple, ils ne sont pas retourn\xE9s si vous utilisez un mod\xE8le DistilBERT). Ils ne sont retourn\xE9s que lorsque le mod\xE8le sait quoi faire avec eux, parce qu\u2019il les a vus pendant son pr\xE9-entra\xEEnement."),_t.forEach(t),Ka=f(e),de=o(e,"P",{});var os=r(de);Sr=a(os,"Ici, BERT est pr\xE9-entra\xEEn\xE9 avec les "),pn=o(os,"EM",{});var Cc=r(pn);Nr=a(Cc,"tokens"),Cc.forEach(t),Or=a(os," de type ID et en plus de l\u2019objectif de mod\xE9lisation du langage masqu\xE9 dont nous avons abord\xE9 dans "),st=o(os,"A",{href:!0});var Dc=r(st);Ar=a(Dc,"chapitre 1"),Dc.forEach(t),Lr=a(os,", il a un objectif suppl\xE9mentaire appel\xE9 "),cn=o(os,"EM",{});var Pc=r(cn);Rr=a(Pc,"pr\xE9diction de la phrase suivante"),Pc.forEach(t),Hr=a(os,". Le but de cette t\xE2che est de mod\xE9liser la relation entre des paires de phrases."),os.forEach(t),Ya=f(e),Ze=o(e,"P",{});var Cl=r(Ze);Ir=a(Cl,"Avec la pr\xE9diction de la phrase suivante, on fournit au mod\xE8le des paires de phrases (avec des "),dn=o(Cl,"EM",{});var Mc=r(dn);Fr=a(Mc,"tokens"),Mc.forEach(t),Vr=a(Cl," masqu\xE9s de mani\xE8re al\xE9atoire) et on lui demande de pr\xE9dire si la deuxi\xE8me phrase suit la premi\xE8re. Pour rendre la t\xE2che non triviale, la moiti\xE9 du temps, les phrases se suivent dans le document d\u2019origine dont elles ont \xE9t\xE9 extraites, et l\u2019autre moiti\xE9 du temps, les deux phrases proviennent de deux documents diff\xE9rents."),Cl.forEach(t),Za=f(e),re=o(e,"P",{});var Re=r(re);Ur=a(Re,"En g\xE9n\xE9ral, vous n\u2019avez pas besoin de vous inqui\xE9ter de savoir s\u2019il y a ou non des "),mn=o(Re,"CODE",{});var Tc=r(mn);Br=a(Tc,"token_type_ids"),Tc.forEach(t),Gr=a(Re," dans vos entr\xE9es tokenis\xE9es : tant que vous utilisez le m\xEAme "),fn=o(Re,"EM",{});var Sc=r(fn);Wr=a(Sc,"checkpoint"),Sc.forEach(t),Jr=a(Re," pour le "),hn=o(Re,"EM",{});var Nc=r(hn);Qr=a(Nc,"tokenizer"),Nc.forEach(t),Kr=a(Re," et le mod\xE8le, tout ira bien puisque le "),vn=o(Re,"EM",{});var Oc=r(vn);Yr=a(Oc,"tokenizer"),Oc.forEach(t),Zr=a(Re," sait quoi fournir \xE0 son mod\xE8le."),Re.forEach(t),Xa=f(e),ie=o(e,"P",{});var He=r(ie);Xr=a(He,"Maintenant que nous avons vu comment notre "),_n=o(He,"EM",{});var Ac=r(_n);ei=a(Ac,"tokenizer"),Ac.forEach(t),si=a(He," peut traiter une paire de phrases, nous pouvons l\u2019utiliser pour tokeniser l\u2019ensemble de notre jeu de donn\xE9es : comme dans le "),tt=o(He,"A",{href:!0});var Lc=r(tt);ti=a(Lc,"chapitre pr\xE9c\xE9dent"),Lc.forEach(t),ni=a(He,", nous pouvons fournir au "),bn=o(He,"EM",{});var Rc=r(bn);ai=a(Rc,"tokenizer"),Rc.forEach(t),li=a(He," une liste de paires de phrases en lui donnant la liste des premi\xE8res phrases, puis la liste des secondes phrases. Ceci est \xE9galement compatible avec les options de remplissage et de troncature que nous avons vues dans le "),nt=o(He,"A",{href:!0});var Hc=r(nt);oi=a(Hc,"chapitre 2"),Hc.forEach(t),ri=a(He,". Voici donc une fa\xE7on de pr\xE9traiter le jeu de donn\xE9es d\u2019entra\xEEnement :"),He.forEach(t),el=f(e),z(zs.$$.fragment,e),sl=f(e),Z=o(e,"P",{});var _e=r(Z);ii=a(_e,"Cela fonctionne bien, mais a l\u2019inconv\xE9nient de retourner un dictionnaire (avec nos cl\xE9s, "),qn=o(_e,"CODE",{});var Ic=r(qn);ui=a(Ic,"input_ids"),Ic.forEach(t),pi=a(_e,", "),jn=o(_e,"CODE",{});var Fc=r(jn);ci=a(Fc,"attention_mask"),Fc.forEach(t),di=a(_e,", et "),En=o(_e,"CODE",{});var Vc=r(En);mi=a(Vc,"token_type_ids"),Vc.forEach(t),fi=a(_e,", et des valeurs qui sont des listes de listes). Cela ne fonctionnera \xE9galement que si vous avez assez de RAM pour stocker l\u2019ensemble de votre jeu de donn\xE9es pendant la tokenisation (alors que les jeux de donn\xE9es de la biblioth\xE8que \u{1F917} "),$n=o(_e,"EM",{});var Uc=r($n);hi=a(Uc,"Datasets"),Uc.forEach(t),vi=a(_e," sont des fichiers "),ws=o(_e,"A",{href:!0,rel:!0});var Bc=r(ws);_i=a(Bc,"Apache Arrow"),Bc.forEach(t),bi=a(_e," stock\xE9s sur le disque, vous ne gardez donc en m\xE9moire que les \xE9chantillons que vous demandez)."),_e.forEach(t),tl=f(e),Ne=o(e,"P",{});var bt=r(Ne);qi=a(bt,"Pour conserver les donn\xE9es sous forme de jeu de donn\xE9es, nous utiliserons la m\xE9thode "),ys=o(bt,"A",{href:!0,rel:!0});var Gc=r(ys);gn=o(Gc,"CODE",{});var Wc=r(gn);ji=a(Wc,"Dataset.map()"),Wc.forEach(t),Gc.forEach(t),Ei=a(bt,". Cela nous permet \xE9galement une certaine flexibilit\xE9, si nous avons besoin d\u2019un pr\xE9traitement plus pouss\xE9 que la simple tokenisation. La m\xE9thode "),kn=o(bt,"CODE",{});var Jc=r(kn);$i=a(Jc,"map()"),Jc.forEach(t),gi=a(bt," fonctionne en appliquant une fonction sur chaque \xE9l\xE9ment de l\u2019ensemble de donn\xE9es, donc d\xE9finissons une fonction qui tokenise nos entr\xE9es :"),bt.forEach(t),nl=f(e),z(Cs.$$.fragment,e),al=f(e),M=o(e,"P",{});var O=r(M);ki=a(O,"Cette fonction prend un dictionnaire (comme les \xE9l\xE9ments de notre jeu de donn\xE9es) et retourne un nouveau dictionnaire avec les cl\xE9s "),xn=o(O,"CODE",{});var Qc=r(xn);xi=a(Qc,"input_ids"),Qc.forEach(t),zi=a(O,", "),zn=o(O,"CODE",{});var Kc=r(zn);wi=a(Kc,"attention_mask"),Kc.forEach(t),yi=a(O,", et "),wn=o(O,"CODE",{});var Yc=r(wn);Ci=a(Yc,"token_type_ids"),Yc.forEach(t),Di=a(O,". Notez que cela fonctionne \xE9galement si le dictionnaire "),yn=o(O,"CODE",{});var Zc=r(yn);Pi=a(Zc,"example"),Zc.forEach(t),Mi=a(O," contient plusieurs \xE9chantillons (chaque cl\xE9 \xE9tant une liste de phrases) puisque le "),Cn=o(O,"CODE",{});var Xc=r(Cn);Ti=a(Xc,"tokenizer"),Xc.forEach(t),Si=a(O," travaille sur des listes de paires de phrases, comme vu pr\xE9c\xE9demment. Cela nous permettra d\u2019utiliser l\u2019option "),Dn=o(O,"CODE",{});var ed=r(Dn);Ni=a(ed,"batched=True"),ed.forEach(t),Oi=a(O," dans notre appel \xE0 "),Pn=o(O,"CODE",{});var sd=r(Pn);Ai=a(sd,"map()"),sd.forEach(t),Li=a(O,", ce qui acc\xE9l\xE9rera grandement la tok\xE9nisation. Le "),Mn=o(O,"CODE",{});var td=r(Mn);Ri=a(td,"tokenizer"),td.forEach(t),Hi=a(O," est soutenu par un "),Tn=o(O,"EM",{});var nd=r(Tn);Ii=a(nd,"tokenizer"),nd.forEach(t),Fi=a(O," \xE9crit en Rust \xE0 partir de la biblioth\xE8que "),Xe=o(O,"A",{href:!0,rel:!0});var bp=r(Xe);Vi=a(bp,"\u{1F917} "),Sn=o(bp,"EM",{});var ad=r(Sn);Ui=a(ad,"Tokenizers"),ad.forEach(t),bp.forEach(t),Bi=a(O,". Ce "),Nn=o(O,"EM",{});var ld=r(Nn);Gi=a(ld,"tokenizer"),ld.forEach(t),Wi=a(O," peut \xEAtre tr\xE8s rapide, mais seulement si on lui donne beaucoup d\u2019entr\xE9es en m\xEAme temps."),O.forEach(t),ll=f(e),me=o(e,"P",{});var rs=r(me);Ji=a(rs,"Notez que nous avons laiss\xE9 l\u2019argument "),On=o(rs,"CODE",{});var od=r(On);Qi=a(od,"padding"),od.forEach(t),Ki=a(rs," hors de notre fonction de "),An=o(rs,"EM",{});var rd=r(An);Yi=a(rd,"tokenizer"),rd.forEach(t),Zi=a(rs," pour le moment. C\u2019est parce que le "),Ln=o(rs,"EM",{});var id=r(Ln);Xi=a(id,"padding"),id.forEach(t),eu=a(rs," de tous les \xE9chantillons \xE0 la longueur maximale n\u2019est pas efficace : il est pr\xE9f\xE9rable de remplir les \xE9chantillons lorsque nous construisons un batch, car alors nous avons seulement besoin de remplir \xE0 la longueur maximale dans ce batch, et non la longueur maximale dans l\u2019ensemble des donn\xE9es. Cela peut permettre de gagner beaucoup de temps et de puissance de traitement lorsque les entr\xE9es ont des longueurs tr\xE8s variables !"),rs.forEach(t),ol=f(e),Oe=o(e,"P",{});var qt=r(Oe);su=a(qt,"Voici comment nous appliquons la fonction de tokenization sur tous nos jeux de donn\xE9es en m\xEAme temps. Nous utilisons "),Rn=o(qt,"CODE",{});var ud=r(Rn);tu=a(ud,"batched=True"),ud.forEach(t),nu=a(qt," dans notre appel \xE0 "),Hn=o(qt,"CODE",{});var pd=r(Hn);au=a(pd,"map"),pd.forEach(t),lu=a(qt," pour que la fonction soit appliqu\xE9e \xE0 plusieurs \xE9l\xE9ments de notre jeu de donn\xE9es en une fois, et non \xE0 chaque \xE9l\xE9ment s\xE9par\xE9ment. Cela permet un pr\xE9traitement plus rapide."),qt.forEach(t),rl=f(e),z(Ds.$$.fragment,e),il=f(e),es=o(e,"P",{});var Dl=r(es);ou=a(Dl,"La fa\xE7on dont la biblioth\xE8que \u{1F917} "),In=o(Dl,"EM",{});var cd=r(In);ru=a(cd,"Datasets"),cd.forEach(t),iu=a(Dl," applique ce traitement consiste \xE0 ajouter de nouveaux champs aux jeux de donn\xE9es, un pour chaque cl\xE9 du dictionnaire renvoy\xE9 par la fonction de pr\xE9traitement :"),Dl.forEach(t),ul=f(e),z(Ps.$$.fragment,e),pl=f(e),X=o(e,"P",{});var be=r(X);uu=a(be,"Vous pouvez m\xEAme utiliser le multitraitement lorsque vous appliquez votre fonction de pr\xE9traitement avec "),Fn=o(be,"CODE",{});var dd=r(Fn);pu=a(dd,"map()"),dd.forEach(t),cu=a(be," en passant un argument "),Vn=o(be,"CODE",{});var md=r(Vn);du=a(md,"num_proc"),md.forEach(t),mu=a(be,". Nous ne l\u2019avons pas fait ici parce que la biblioth\xE8que \u{1F917} "),Un=o(be,"EM",{});var fd=r(Un);fu=a(fd,"Tokenizers"),fd.forEach(t),hu=a(be," utilise d\xE9j\xE0 plusieurs "),Bn=o(be,"EM",{});var hd=r(Bn);vu=a(hd,"threads"),hd.forEach(t),_u=a(be," pour tokeniser nos \xE9chantillons plus rapidement, mais si vous n\u2019utilisez pas un "),Gn=o(be,"EM",{});var vd=r(Gn);bu=a(vd,"tokenizer"),vd.forEach(t),qu=a(be," rapide soutenu par cette biblioth\xE8que, cela pourrait acc\xE9l\xE9rer votre pr\xE9traitement."),be.forEach(t),cl=f(e),ee=o(e,"P",{});var qe=r(ee);ju=a(qe,"Notre "),Wn=o(qe,"CODE",{});var _d=r(Wn);Eu=a(_d,"tokenize_function"),_d.forEach(t),$u=a(qe," retourne un dictionnaire avec les cl\xE9s "),Jn=o(qe,"CODE",{});var bd=r(Jn);gu=a(bd,"input_ids"),bd.forEach(t),ku=a(qe,", "),Qn=o(qe,"CODE",{});var qd=r(Qn);xu=a(qd,"attention_mask"),qd.forEach(t),zu=a(qe,", et "),Kn=o(qe,"CODE",{});var jd=r(Kn);wu=a(jd,"token_type_ids"),jd.forEach(t),yu=a(qe,", donc ces trois champs sont ajout\xE9s \xE0 toutes les divisions de notre jeu de donn\xE9es. Notez que nous aurions \xE9galement pu modifier des champs existants si notre fonction de pr\xE9traitement avait retourn\xE9 une nouvelle valeur pour une cl\xE9 existante dans l\u2019ensemble de donn\xE9es auquel nous avons appliqu\xE9 "),Yn=o(qe,"CODE",{});var Ed=r(Yn);Cu=a(Ed,"map()"),Ed.forEach(t),Du=a(qe,"."),qe.forEach(t),dl=f(e),ss=o(e,"P",{});var Pl=r(ss);Pu=a(Pl,"La derni\xE8re chose que nous devrons faire est de remplir tous les exemples \xE0 la longueur de l\u2019\xE9l\xE9ment le plus long lorsque nous regroupons les \xE9l\xE9ments, une technique que nous appelons le "),Zn=o(Pl,"EM",{});var $d=r(Zn);Mu=a($d,"padding dynamique"),$d.forEach(t),Tu=a(Pl,"."),Pl.forEach(t),ml=f(e),Fe=o(e,"H3",{class:!0});var Ml=r(Fe);ts=o(Ml,"A",{id:!0,class:!0,href:!0});var gd=r(ts);Xn=o(gd,"SPAN",{});var kd=r(Xn);z(Ms.$$.fragment,kd),kd.forEach(t),gd.forEach(t),Su=f(Ml),at=o(Ml,"SPAN",{});var qp=r(at);ea=o(qp,"I",{});var xd=r(ea);Nu=a(xd,"Padding"),xd.forEach(t),Ou=a(qp," dynamique"),qp.forEach(t),Ml.forEach(t),fl=f(e),z(Ts.$$.fragment,e),hl=f(e),Ve.l(e),lt=f(e),G=o(e,"P",{});var ne=r(G);Au=a(ne,"Pour faire cela en pratique, nous devons d\xE9finir une fonction de rassemblement qui appliquera la bonne quantit\xE9 de "),sa=o(ne,"EM",{});var zd=r(sa);Lu=a(zd,"padding"),zd.forEach(t),Ru=a(ne," aux \xE9l\xE9ments du jeu de donn\xE9es que nous voulons regrouper. Heureusement, la biblioth\xE8que \u{1F917} "),ta=o(ne,"EM",{});var wd=r(ta);Hu=a(wd,"Transformers"),wd.forEach(t),Iu=a(ne," nous fournit une telle fonction via "),na=o(ne,"CODE",{});var yd=r(na);Fu=a(yd,"DataCollatorWithPadding"),yd.forEach(t),Vu=a(ne,". Elle prend un "),aa=o(ne,"EM",{});var Cd=r(aa);Uu=a(Cd,"tokenizer"),Cd.forEach(t),Bu=a(ne," lorsque vous l\u2019instanciez (pour savoir quel "),la=o(ne,"EM",{});var Dd=r(la);Gu=a(Dd,"token"),Dd.forEach(t),Wu=a(ne," de "),oa=o(ne,"EM",{});var Pd=r(oa);Ju=a(Pd,"padding"),Pd.forEach(t),Qu=a(ne," utiliser et si le mod\xE8le s\u2019attend \xE0 ce que le "),ra=o(ne,"EM",{});var Md=r(ra);Ku=a(Md,"padding"),Md.forEach(t),Yu=a(ne," soit \xE0 gauche ou \xE0 droite des entr\xE9es) et fera tout ce dont vous avez besoin :"),ne.forEach(t),vl=f(e),ze.l(e),ot=f(e),se=o(e,"P",{});var je=r(se);Zu=a(je,"Pour tester notre nouveau jouet, prenons quelques \xE9l\xE9ments de notre jeu d\u2019entra\xEEnement avec lesquels nous allons former un batch. Ici, on supprime les colonnes "),ia=o(je,"CODE",{});var Td=r(ia);Xu=a(Td,"idx"),Td.forEach(t),ep=a(je,", "),ua=o(je,"CODE",{});var Sd=r(ua);sp=a(Sd,"sentence1"),Sd.forEach(t),tp=a(je," et "),pa=o(je,"CODE",{});var Nd=r(pa);np=a(Nd,"sentence2"),Nd.forEach(t),ap=a(je," puisque nous n\u2019en aurons pas besoin et qu\u2019elles contiennent des "),ca=o(je,"EM",{});var Od=r(ca);lp=a(Od,"strings"),Od.forEach(t),op=a(je," (et nous ne pouvons pas cr\xE9er des tenseurs avec des "),da=o(je,"EM",{});var Ad=r(da);rp=a(Ad,"strings"),Ad.forEach(t),ip=a(je,") et on regarde la longueur de chaque entr\xE9e du batch :"),je.forEach(t),_l=f(e),z(Ss.$$.fragment,e),bl=f(e),z(Ns.$$.fragment,e),ql=f(e),fe=o(e,"P",{});var is=r(fe);up=a(is,"Sans surprise, nous obtenons des \xE9chantillons de longueur variable, de 32 \xE0 67. Le "),ma=o(is,"EM",{});var Ld=r(ma);pp=a(Ld,"padding"),Ld.forEach(t),cp=a(is," dynamique signifie que les \xE9chantillons de ce batch doivent tous \xEAtre rembourr\xE9s \xE0 une longueur de 67, la longueur maximale dans le batch. Sans le "),fa=o(is,"EM",{});var Rd=r(fa);dp=a(Rd,"padding"),Rd.forEach(t),mp=a(is," dynamique, tous les \xE9chantillons devraient \xEAtre rembourr\xE9s \xE0 la longueur maximale du jeu de donn\xE9es entier, ou \xE0 la longueur maximale que le mod\xE8le peut accepter. V\xE9rifions \xE0 nouveau que notre "),ha=o(is,"CODE",{});var Hd=r(ha);fp=a(Hd,"data_collator"),Hd.forEach(t),hp=a(is," rembourre dynamiquement le batch correctement :"),is.forEach(t),jl=f(e),z(Os.$$.fragment,e),El=f(e),ye.l(e),rt=f(e),z(ns.$$.fragment,e),$l=f(e),W&&W.l(e),it=Id(),this.h()},h(){D(i,"name","hf:doc:metadata"),D(i,"content",JSON.stringify(fm)),D(_,"id","prparer-les-donnes"),D(_,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),D(_,"href","#prparer-les-donnes"),D(E,"class","relative group"),D(Ce,"href","https://www.aclweb.org/anthology/I05-5002.pdf"),D(Ce,"rel","nofollow"),D(Ue,"id","charger-un-jeu-de-donnes-depuis-le-ihubi"),D(Ue,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),D(Ue,"href","#charger-un-jeu-de-donnes-depuis-le-ihubi"),D(pe,"class","relative group"),D(cs,"href","https://huggingface.co/datasets"),D(cs,"rel","nofollow"),D(ds,"href","https://huggingface.co/docs/datasets/loading_datasets.html#from-the-huggingface-hub"),D(ds,"rel","nofollow"),D(Be,"href","https://gluebenchmark.com/"),D(Be,"rel","nofollow"),D(Je,"id","prtraitement-dun-jeu-de-donnes"),D(Je,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),D(Je,"href","#prtraitement-dun-jeu-de-donnes"),D(Ie,"class","relative group"),D(Zs,"href","/course/fr/chapter2"),D(Xs,"href","/course/fr/chapter2"),D(st,"href","/course/fr/chapter1"),D(tt,"href","/course/fr/chapter2"),D(nt,"href","/course/fr/chapter2"),D(ws,"href","https://arrow.apache.org/"),D(ws,"rel","nofollow"),D(ys,"href","https://huggingface.co/docs/datasets/package_reference/main_classes.html#datasets.Dataset.map"),D(ys,"rel","nofollow"),D(Xe,"href","https://github.com/huggingface/tokenizers"),D(Xe,"rel","nofollow"),D(ts,"id","ipaddingi-dynamique"),D(ts,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),D(ts,"href","#ipaddingi-dynamique"),D(Fe,"class","relative group")},m(e,p){s(document.head,i),c(e,d,p),w(u,e,p),c(e,v,p),c(e,E,p),s(E,_),s(_,b),w(k,b,null),s(E,h),s(E,$),s($,S),c(e,F,p),As[A].m(e,p),c(e,N,p),Ls[R].m(e,p),c(e,I,p),c(e,g,p),s(g,ae),c(e,Q,p),c(e,U,p),s(U,le),s(U,P),s(P,V),s(U,Gs),s(U,Ce),s(Ce,Ws),s(U,Js),c(e,us,p),c(e,pe,p),s(pe,Ue),s(Ue,jt),w(ps,jt,null),s(pe,Sl),s(pe,Qs),s(Qs,Nl),s(Qs,Et),s(Et,Ol),c(e,ja,p),Rs[Ee].m(e,p),c(e,Ks,p),c(e,K,p),s(K,Al),s(K,$t),s($t,Ll),s(K,Rl),s(K,cs),s(cs,Hl),s(K,Il),s(K,ds),s(ds,Fl),s(K,Vl),s(K,Be),s(Be,gt),s(gt,Ul),s(Be,Bl),s(K,Gl),s(K,kt),s(kt,Wl),s(K,Jl),c(e,Ea,p),c(e,De,p),s(De,Ql),s(De,xt),s(xt,Kl),s(De,Yl),s(De,zt),s(zt,Zl),s(De,Xl),c(e,$a,p),w(ms,e,p),c(e,ga,p),w(fs,e,p),c(e,ka,p),c(e,Y,p),s(Y,eo),s(Y,wt),s(wt,so),s(Y,to),s(Y,yt),s(yt,no),s(Y,ao),s(Y,Ct),s(Ct,lo),s(Y,oo),s(Y,Dt),s(Dt,ro),s(Y,io),s(Y,Pt),s(Pt,uo),s(Y,po),c(e,xa,p),c(e,Pe,p),s(Pe,co),s(Pe,Mt),s(Mt,mo),s(Pe,fo),s(Pe,Tt),s(Tt,ho),s(Pe,vo),c(e,za,p),c(e,Ge,p),s(Ge,_o),s(Ge,St),s(St,bo),s(Ge,qo),c(e,wa,p),w(hs,e,p),c(e,ya,p),w(vs,e,p),c(e,Ca,p),c(e,Me,p),s(Me,jo),s(Me,Nt),s(Nt,Eo),s(Me,$o),s(Me,Ot),s(Ot,go),s(Me,ko),c(e,Da,p),w(_s,e,p),c(e,Pa,p),w(bs,e,p),c(e,Ma,p),c(e,B,p),s(B,xo),s(B,At),s(At,zo),s(B,wo),s(B,Lt),s(Lt,yo),s(B,Co),s(B,Rt),s(Rt,Do),s(B,Po),s(B,Ht),s(Ht,Mo),s(B,To),s(B,It),s(It,So),s(B,No),s(B,Ft),s(Ft,Oo),s(B,Ao),s(B,Vt),s(Vt,Lo),s(B,Ro),c(e,Ta,p),w(We,e,p),c(e,Sa,p),c(e,Ie,p),s(Ie,Je),s(Je,Ut),w(qs,Ut,null),s(Ie,Ho),s(Ie,Bt),s(Bt,Io),c(e,Na,p),Hs[ge].m(e,p),c(e,Ys,p),c(e,ce,p),s(ce,Fo),s(ce,Zs),s(Zs,Vo),s(ce,Uo),s(ce,Gt),s(Gt,Bo),s(ce,Go),s(ce,Wt),s(Wt,Wo),s(ce,Jo),c(e,Oa,p),w(js,e,p),c(e,Aa,p),c(e,Qe,p),s(Qe,Qo),s(Qe,Jt),s(Jt,Ko),s(Qe,Yo),c(e,La,p),w(Es,e,p),c(e,Ra,p),w($s,e,p),c(e,Ha,p),c(e,oe,p),s(oe,Zo),s(oe,Qt),s(Qt,Xo),s(oe,er),s(oe,Kt),s(Kt,sr),s(oe,tr),s(oe,Xs),s(Xs,nr),s(oe,ar),s(oe,Yt),s(Yt,lr),s(oe,or),c(e,Ia,p),w(Ke,e,p),c(e,Fa,p),c(e,Ye,p),s(Ye,rr),s(Ye,Zt),s(Zt,ir),s(Ye,ur),c(e,Va,p),w(gs,e,p),c(e,Ua,p),c(e,et,p),s(et,pr),c(e,Ba,p),w(ks,e,p),c(e,Ga,p),c(e,Te,p),s(Te,cr),s(Te,Xt),s(Xt,dr),s(Te,mr),s(Te,en),s(en,fr),s(Te,hr),c(e,Wa,p),w(xs,e,p),c(e,Ja,p),c(e,J,p),s(J,vr),s(J,sn),s(sn,_r),s(J,br),s(J,tn),s(tn,qr),s(J,jr),s(J,nn),s(nn,Er),s(J,$r),s(J,an),s(an,gr),s(J,kr),s(J,ln),s(ln,xr),s(J,zr),s(J,on),s(on,wr),s(J,yr),c(e,Qa,p),c(e,Se,p),s(Se,Cr),s(Se,rn),s(rn,Dr),s(Se,Pr),s(Se,un),s(un,Mr),s(Se,Tr),c(e,Ka,p),c(e,de,p),s(de,Sr),s(de,pn),s(pn,Nr),s(de,Or),s(de,st),s(st,Ar),s(de,Lr),s(de,cn),s(cn,Rr),s(de,Hr),c(e,Ya,p),c(e,Ze,p),s(Ze,Ir),s(Ze,dn),s(dn,Fr),s(Ze,Vr),c(e,Za,p),c(e,re,p),s(re,Ur),s(re,mn),s(mn,Br),s(re,Gr),s(re,fn),s(fn,Wr),s(re,Jr),s(re,hn),s(hn,Qr),s(re,Kr),s(re,vn),s(vn,Yr),s(re,Zr),c(e,Xa,p),c(e,ie,p),s(ie,Xr),s(ie,_n),s(_n,ei),s(ie,si),s(ie,tt),s(tt,ti),s(ie,ni),s(ie,bn),s(bn,ai),s(ie,li),s(ie,nt),s(nt,oi),s(ie,ri),c(e,el,p),w(zs,e,p),c(e,sl,p),c(e,Z,p),s(Z,ii),s(Z,qn),s(qn,ui),s(Z,pi),s(Z,jn),s(jn,ci),s(Z,di),s(Z,En),s(En,mi),s(Z,fi),s(Z,$n),s($n,hi),s(Z,vi),s(Z,ws),s(ws,_i),s(Z,bi),c(e,tl,p),c(e,Ne,p),s(Ne,qi),s(Ne,ys),s(ys,gn),s(gn,ji),s(Ne,Ei),s(Ne,kn),s(kn,$i),s(Ne,gi),c(e,nl,p),w(Cs,e,p),c(e,al,p),c(e,M,p),s(M,ki),s(M,xn),s(xn,xi),s(M,zi),s(M,zn),s(zn,wi),s(M,yi),s(M,wn),s(wn,Ci),s(M,Di),s(M,yn),s(yn,Pi),s(M,Mi),s(M,Cn),s(Cn,Ti),s(M,Si),s(M,Dn),s(Dn,Ni),s(M,Oi),s(M,Pn),s(Pn,Ai),s(M,Li),s(M,Mn),s(Mn,Ri),s(M,Hi),s(M,Tn),s(Tn,Ii),s(M,Fi),s(M,Xe),s(Xe,Vi),s(Xe,Sn),s(Sn,Ui),s(M,Bi),s(M,Nn),s(Nn,Gi),s(M,Wi),c(e,ll,p),c(e,me,p),s(me,Ji),s(me,On),s(On,Qi),s(me,Ki),s(me,An),s(An,Yi),s(me,Zi),s(me,Ln),s(Ln,Xi),s(me,eu),c(e,ol,p),c(e,Oe,p),s(Oe,su),s(Oe,Rn),s(Rn,tu),s(Oe,nu),s(Oe,Hn),s(Hn,au),s(Oe,lu),c(e,rl,p),w(Ds,e,p),c(e,il,p),c(e,es,p),s(es,ou),s(es,In),s(In,ru),s(es,iu),c(e,ul,p),w(Ps,e,p),c(e,pl,p),c(e,X,p),s(X,uu),s(X,Fn),s(Fn,pu),s(X,cu),s(X,Vn),s(Vn,du),s(X,mu),s(X,Un),s(Un,fu),s(X,hu),s(X,Bn),s(Bn,vu),s(X,_u),s(X,Gn),s(Gn,bu),s(X,qu),c(e,cl,p),c(e,ee,p),s(ee,ju),s(ee,Wn),s(Wn,Eu),s(ee,$u),s(ee,Jn),s(Jn,gu),s(ee,ku),s(ee,Qn),s(Qn,xu),s(ee,zu),s(ee,Kn),s(Kn,wu),s(ee,yu),s(ee,Yn),s(Yn,Cu),s(ee,Du),c(e,dl,p),c(e,ss,p),s(ss,Pu),s(ss,Zn),s(Zn,Mu),s(ss,Tu),c(e,ml,p),c(e,Fe,p),s(Fe,ts),s(ts,Xn),w(Ms,Xn,null),s(Fe,Su),s(Fe,at),s(at,ea),s(ea,Nu),s(at,Ou),c(e,fl,p),w(Ts,e,p),c(e,hl,p),Ve.m(e,p),c(e,lt,p),c(e,G,p),s(G,Au),s(G,sa),s(sa,Lu),s(G,Ru),s(G,ta),s(ta,Hu),s(G,Iu),s(G,na),s(na,Fu),s(G,Vu),s(G,aa),s(aa,Uu),s(G,Bu),s(G,la),s(la,Gu),s(G,Wu),s(G,oa),s(oa,Ju),s(G,Qu),s(G,ra),s(ra,Ku),s(G,Yu),c(e,vl,p),Is[xe].m(e,p),c(e,ot,p),c(e,se,p),s(se,Zu),s(se,ia),s(ia,Xu),s(se,ep),s(se,ua),s(ua,sp),s(se,tp),s(se,pa),s(pa,np),s(se,ap),s(se,ca),s(ca,lp),s(se,op),s(se,da),s(da,rp),s(se,ip),c(e,_l,p),w(Ss,e,p),c(e,bl,p),w(Ns,e,p),c(e,ql,p),c(e,fe,p),s(fe,up),s(fe,ma),s(ma,pp),s(fe,cp),s(fe,fa),s(fa,dp),s(fe,mp),s(fe,ha),s(ha,fp),s(fe,hp),c(e,jl,p),w(Os,e,p),c(e,El,p),Fs[we].m(e,p),c(e,rt,p),w(ns,e,p),c(e,$l,p),W&&W.m(e,p),c(e,it,p),gl=!0},p(e,[p]){const Vs={};p&1&&(Vs.fw=e[0]),u.$set(Vs);let ut=A;A=$p(e),A!==ut&&(Bs(),j(As[ut],1,1,()=>{As[ut]=null}),Us(),L=As[A],L||(L=As[A]=Ep[A](e),L.c()),q(L,1),L.m(N.parentNode,N));let pt=R;R=kp(e),R!==pt&&(Bs(),j(Ls[pt],1,1,()=>{Ls[pt]=null}),Us(),H=Ls[R],H||(H=Ls[R]=gp[R](e),H.c()),q(H,1),H.m(I.parentNode,I));let ct=Ee;Ee=zp(e),Ee!==ct&&(Bs(),j(Rs[ct],1,1,()=>{Rs[ct]=null}),Us(),$e=Rs[Ee],$e||($e=Rs[Ee]=xp[Ee](e),$e.c()),q($e,1),$e.m(Ks.parentNode,Ks));const va={};p&2&&(va.$$scope={dirty:p,ctx:e}),We.$set(va);let Ae=ge;ge=yp(e),ge!==Ae&&(Bs(),j(Hs[Ae],1,1,()=>{Hs[Ae]=null}),Us(),ke=Hs[ge],ke||(ke=Hs[ge]=wp[ge](e),ke.c()),q(ke,1),ke.m(Ys.parentNode,Ys));const _a={};p&2&&(_a.$$scope={dirty:p,ctx:e}),Ke.$set(_a),kl!==(kl=Cp(e))&&(Ve.d(1),Ve=kl(e),Ve&&(Ve.c(),Ve.m(lt.parentNode,lt)));let dt=xe;xe=Pp(e),xe!==dt&&(Bs(),j(Is[dt],1,1,()=>{Is[dt]=null}),Us(),ze=Is[xe],ze||(ze=Is[xe]=Dp[xe](e),ze.c()),q(ze,1),ze.m(ot.parentNode,ot));let as=we;we=Tp(e),we!==as&&(Bs(),j(Fs[as],1,1,()=>{Fs[as]=null}),Us(),ye=Fs[we],ye||(ye=Fs[we]=Mp[we](e),ye.c()),q(ye,1),ye.m(rt.parentNode,rt));const ba={};p&2&&(ba.$$scope={dirty:p,ctx:e}),ns.$set(ba),e[0]==="tf"?W?p&1&&q(W,1):(W=Fd(),W.c(),q(W,1),W.m(it.parentNode,it)):W&&(Bs(),j(W,1,1,()=>{W=null}),Us())},i(e){gl||(q(u.$$.fragment,e),q(k.$$.fragment,e),q(L),q(H),q(ps.$$.fragment,e),q($e),q(ms.$$.fragment,e),q(fs.$$.fragment,e),q(hs.$$.fragment,e),q(vs.$$.fragment,e),q(_s.$$.fragment,e),q(bs.$$.fragment,e),q(We.$$.fragment,e),q(qs.$$.fragment,e),q(ke),q(js.$$.fragment,e),q(Es.$$.fragment,e),q($s.$$.fragment,e),q(Ke.$$.fragment,e),q(gs.$$.fragment,e),q(ks.$$.fragment,e),q(xs.$$.fragment,e),q(zs.$$.fragment,e),q(Cs.$$.fragment,e),q(Ds.$$.fragment,e),q(Ps.$$.fragment,e),q(Ms.$$.fragment,e),q(Ts.$$.fragment,e),q(ze),q(Ss.$$.fragment,e),q(Ns.$$.fragment,e),q(Os.$$.fragment,e),q(ye),q(ns.$$.fragment,e),q(W),gl=!0)},o(e){j(u.$$.fragment,e),j(k.$$.fragment,e),j(L),j(H),j(ps.$$.fragment,e),j($e),j(ms.$$.fragment,e),j(fs.$$.fragment,e),j(hs.$$.fragment,e),j(vs.$$.fragment,e),j(_s.$$.fragment,e),j(bs.$$.fragment,e),j(We.$$.fragment,e),j(qs.$$.fragment,e),j(ke),j(js.$$.fragment,e),j(Es.$$.fragment,e),j($s.$$.fragment,e),j(Ke.$$.fragment,e),j(gs.$$.fragment,e),j(ks.$$.fragment,e),j(xs.$$.fragment,e),j(zs.$$.fragment,e),j(Cs.$$.fragment,e),j(Ds.$$.fragment,e),j(Ps.$$.fragment,e),j(Ms.$$.fragment,e),j(Ts.$$.fragment,e),j(ze),j(Ss.$$.fragment,e),j(Ns.$$.fragment,e),j(Os.$$.fragment,e),j(ye),j(ns.$$.fragment,e),j(W),gl=!1},d(e){t(i),e&&t(d),y(u,e),e&&t(v),e&&t(E),y(k),e&&t(F),As[A].d(e),e&&t(N),Ls[R].d(e),e&&t(I),e&&t(g),e&&t(Q),e&&t(U),e&&t(us),e&&t(pe),y(ps),e&&t(ja),Rs[Ee].d(e),e&&t(Ks),e&&t(K),e&&t(Ea),e&&t(De),e&&t($a),y(ms,e),e&&t(ga),y(fs,e),e&&t(ka),e&&t(Y),e&&t(xa),e&&t(Pe),e&&t(za),e&&t(Ge),e&&t(wa),y(hs,e),e&&t(ya),y(vs,e),e&&t(Ca),e&&t(Me),e&&t(Da),y(_s,e),e&&t(Pa),y(bs,e),e&&t(Ma),e&&t(B),e&&t(Ta),y(We,e),e&&t(Sa),e&&t(Ie),y(qs),e&&t(Na),Hs[ge].d(e),e&&t(Ys),e&&t(ce),e&&t(Oa),y(js,e),e&&t(Aa),e&&t(Qe),e&&t(La),y(Es,e),e&&t(Ra),y($s,e),e&&t(Ha),e&&t(oe),e&&t(Ia),y(Ke,e),e&&t(Fa),e&&t(Ye),e&&t(Va),y(gs,e),e&&t(Ua),e&&t(et),e&&t(Ba),y(ks,e),e&&t(Ga),e&&t(Te),e&&t(Wa),y(xs,e),e&&t(Ja),e&&t(J),e&&t(Qa),e&&t(Se),e&&t(Ka),e&&t(de),e&&t(Ya),e&&t(Ze),e&&t(Za),e&&t(re),e&&t(Xa),e&&t(ie),e&&t(el),y(zs,e),e&&t(sl),e&&t(Z),e&&t(tl),e&&t(Ne),e&&t(nl),y(Cs,e),e&&t(al),e&&t(M),e&&t(ll),e&&t(me),e&&t(ol),e&&t(Oe),e&&t(rl),y(Ds,e),e&&t(il),e&&t(es),e&&t(ul),y(Ps,e),e&&t(pl),e&&t(X),e&&t(cl),e&&t(ee),e&&t(dl),e&&t(ss),e&&t(ml),e&&t(Fe),y(Ms),e&&t(fl),y(Ts,e),e&&t(hl),Ve.d(e),e&&t(lt),e&&t(G),e&&t(vl),Is[xe].d(e),e&&t(ot),e&&t(se),e&&t(_l),y(Ss,e),e&&t(bl),y(Ns,e),e&&t(ql),e&&t(fe),e&&t(jl),y(Os,e),e&&t(El),Fs[we].d(e),e&&t(rt),y(ns,e),e&&t($l),W&&W.d(e),e&&t(it)}}}const fm={local:"prparer-les-donnes",sections:[{local:"charger-un-jeu-de-donnes-depuis-le-ihubi",title:"Charger un jeu de donn\xE9es depuis le <i>Hub</i>"},{local:"prtraitement-dun-jeu-de-donnes",title:"Pr\xE9traitement d'un jeu de donn\xE9es"},{local:"ipaddingi-dynamique",title:"<i>Padding</i> dynamique"}],title:"Pr\xE9parer les donn\xE9es"};function hm(C,i,d){let u="pt";return Jd(()=>{const v=new URLSearchParams(window.location.search);d(0,u=v.get("fw")||"pt")}),[u]}class gm extends Ud{constructor(i){super();Bd(this,i,hm,mm,Gd,{})}}export{gm as default,fm as metadata};
