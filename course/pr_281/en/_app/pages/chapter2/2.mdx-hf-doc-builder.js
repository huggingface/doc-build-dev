import{S as fp,i as mp,s as dp,e as i,k as f,w as E,t as o,M as bp,c as p,d as t,m,x as T,a as c,h as r,b as y,N as Sa,G as s,g as u,y as x,o as k,p as ce,q as $,B as A,v as _p,n as ue}from"../../chunks/vendor-hf-doc-builder.js";import{T as cp}from"../../chunks/Tip-hf-doc-builder.js";import{Y as up}from"../../chunks/Youtube-hf-doc-builder.js";import{I as _s}from"../../chunks/IconCopyLink-hf-doc-builder.js";import{C as M}from"../../chunks/CodeBlock-hf-doc-builder.js";import{D as hp}from"../../chunks/DocNotebookDropdown-hf-doc-builder.js";import{F as wp}from"../../chunks/FrameworkSwitchCourse-hf-doc-builder.js";function kp(v){let n,h;return n=new hp({props:{classNames:"absolute z-10 right-0 top-0",options:[{label:"Google Colab",value:"https://colab.research.google.com/github/huggingface/notebooks/blob/master/course/chapter2/section2_tf.ipynb"},{label:"Aws Studio",value:"https://studiolab.sagemaker.aws/import/github/huggingface/notebooks/blob/master/course/chapter2/section2_tf.ipynb"}]}}),{c(){E(n.$$.fragment)},l(a){T(n.$$.fragment,a)},m(a,d){x(n,a,d),h=!0},i(a){h||($(n.$$.fragment,a),h=!0)},o(a){k(n.$$.fragment,a),h=!1},d(a){A(n,a)}}}function $p(v){let n,h;return n=new hp({props:{classNames:"absolute z-10 right-0 top-0",options:[{label:"Google Colab",value:"https://colab.research.google.com/github/huggingface/notebooks/blob/master/course/chapter2/section2_pt.ipynb"},{label:"Aws Studio",value:"https://studiolab.sagemaker.aws/import/github/huggingface/notebooks/blob/master/course/chapter2/section2_pt.ipynb"}]}}),{c(){E(n.$$.fragment)},l(a){T(n.$$.fragment,a)},m(a,d){x(n,a,d),h=!0},i(a){h||($(n.$$.fragment,a),h=!0)},o(a){k(n.$$.fragment,a),h=!1},d(a){A(n,a)}}}function gp(v){let n;return{c(){n=o("This is the first section where the content is slightly different depending on whether you use PyTorch or TensorFlow. Toggle the switch on top of the title to select the platform you prefer!")},l(h){n=r(h,"This is the first section where the content is slightly different depending on whether you use PyTorch or TensorFlow. Toggle the switch on top of the title to select the platform you prefer!")},m(h,a){u(h,n,a)},d(h){h&&t(n)}}}function vp(v){let n,h;return n=new up({props:{id:"wVN12smEvqg"}}),{c(){E(n.$$.fragment)},l(a){T(n.$$.fragment,a)},m(a,d){x(n,a,d),h=!0},i(a){h||($(n.$$.fragment,a),h=!0)},o(a){k(n.$$.fragment,a),h=!1},d(a){A(n,a)}}}function yp(v){let n,h;return n=new up({props:{id:"1pedAIvTWXk"}}),{c(){E(n.$$.fragment)},l(a){T(n.$$.fragment,a)},m(a,d){x(n,a,d),h=!0},i(a){h||($(n.$$.fragment,a),h=!0)},o(a){k(n.$$.fragment,a),h=!1},d(a){A(n,a)}}}function jp(v){let n,h;return n=new M({props:{code:`raw_inputs = [
    "I've been waiting for a HuggingFace course my whole life.",
    "I hate this so much!",
]
inputs = tokenizer(raw_inputs, padding=True, truncation=True, return_tensors="tf")
print(inputs)`,highlighted:`raw_inputs = [
    <span class="hljs-string">&quot;I&#x27;ve been waiting for a HuggingFace course my whole life.&quot;</span>,
    <span class="hljs-string">&quot;I hate this so much!&quot;</span>,
]
inputs = tokenizer(raw_inputs, padding=<span class="hljs-literal">True</span>, truncation=<span class="hljs-literal">True</span>, return_tensors=<span class="hljs-string">&quot;tf&quot;</span>)
<span class="hljs-built_in">print</span>(inputs)`}}),{c(){E(n.$$.fragment)},l(a){T(n.$$.fragment,a)},m(a,d){x(n,a,d),h=!0},i(a){h||($(n.$$.fragment,a),h=!0)},o(a){k(n.$$.fragment,a),h=!1},d(a){A(n,a)}}}function Ep(v){let n,h;return n=new M({props:{code:`raw_inputs = [
    "I've been waiting for a HuggingFace course my whole life.",
    "I hate this so much!",
]
inputs = tokenizer(raw_inputs, padding=True, truncation=True, return_tensors="pt")
print(inputs)`,highlighted:`raw_inputs = [
    <span class="hljs-string">&quot;I&#x27;ve been waiting for a HuggingFace course my whole life.&quot;</span>,
    <span class="hljs-string">&quot;I hate this so much!&quot;</span>,
]
inputs = tokenizer(raw_inputs, padding=<span class="hljs-literal">True</span>, truncation=<span class="hljs-literal">True</span>, return_tensors=<span class="hljs-string">&quot;pt&quot;</span>)
<span class="hljs-built_in">print</span>(inputs)`}}),{c(){E(n.$$.fragment)},l(a){T(n.$$.fragment,a)},m(a,d){x(n,a,d),h=!0},i(a){h||($(n.$$.fragment,a),h=!0)},o(a){k(n.$$.fragment,a),h=!1},d(a){A(n,a)}}}function Tp(v){let n,h,a,d,_;return d=new M({props:{code:`{
    'input_ids': <tf.Tensor: shape=(2, 16), dtype=int32, numpy=
        array([
            [  101,  1045,  1005,  2310,  2042,  3403,  2005,  1037, 17662, 12172,  2607,  2026,  2878,  2166,  1012,   102],
            [  101,  1045,  5223,  2023,  2061,  2172,   999,   102,     0,     0,     0,     0,     0,     0,     0,     0]
        ], dtype=int32)>, 
    'attention_mask': <tf.Tensor: shape=(2, 16), dtype=int32, numpy=
        array([
            [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
            [1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0]
        ], dtype=int32)>
}`,highlighted:`{
    <span class="hljs-string">&#x27;input_ids&#x27;</span>: &lt;tf.Tensor: shape=(<span class="hljs-number">2</span>, <span class="hljs-number">16</span>), dtype=int32, numpy=
        array([
            [  <span class="hljs-number">101</span>,  <span class="hljs-number">1045</span>,  <span class="hljs-number">1005</span>,  <span class="hljs-number">2310</span>,  <span class="hljs-number">2042</span>,  <span class="hljs-number">3403</span>,  <span class="hljs-number">2005</span>,  <span class="hljs-number">1037</span>, <span class="hljs-number">17662</span>, <span class="hljs-number">12172</span>,  <span class="hljs-number">2607</span>,  <span class="hljs-number">2026</span>,  <span class="hljs-number">2878</span>,  <span class="hljs-number">2166</span>,  <span class="hljs-number">1012</span>,   <span class="hljs-number">102</span>],
            [  <span class="hljs-number">101</span>,  <span class="hljs-number">1045</span>,  <span class="hljs-number">5223</span>,  <span class="hljs-number">2023</span>,  <span class="hljs-number">2061</span>,  <span class="hljs-number">2172</span>,   <span class="hljs-number">999</span>,   <span class="hljs-number">102</span>,     <span class="hljs-number">0</span>,     <span class="hljs-number">0</span>,     <span class="hljs-number">0</span>,     <span class="hljs-number">0</span>,     <span class="hljs-number">0</span>,     <span class="hljs-number">0</span>,     <span class="hljs-number">0</span>,     <span class="hljs-number">0</span>]
        ], dtype=int32)&gt;, 
    <span class="hljs-string">&#x27;attention_mask&#x27;</span>: &lt;tf.Tensor: shape=(<span class="hljs-number">2</span>, <span class="hljs-number">16</span>), dtype=int32, numpy=
        array([
            [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>],
            [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>]
        ], dtype=int32)&gt;
}`}}),{c(){n=i("p"),h=o("Here\u2019s what the results look like as TensorFlow tensors:"),a=f(),E(d.$$.fragment)},l(b){n=p(b,"P",{});var P=c(n);h=r(P,"Here\u2019s what the results look like as TensorFlow tensors:"),P.forEach(t),a=m(b),T(d.$$.fragment,b)},m(b,P){u(b,n,P),s(n,h),u(b,a,P),x(d,b,P),_=!0},i(b){_||($(d.$$.fragment,b),_=!0)},o(b){k(d.$$.fragment,b),_=!1},d(b){b&&t(n),b&&t(a),A(d,b)}}}function xp(v){let n,h,a,d,_;return d=new M({props:{code:`{
    'input_ids': tensor([
        [  101,  1045,  1005,  2310,  2042,  3403,  2005,  1037, 17662, 12172, 2607,  2026,  2878,  2166,  1012,   102],
        [  101,  1045,  5223,  2023,  2061,  2172,   999,   102,     0,     0,     0,     0,     0,     0,     0,     0]
    ]), 
    'attention_mask': tensor([
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
        [1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0]
    ])
}`,highlighted:`{
    <span class="hljs-string">&#x27;input_ids&#x27;</span>: tensor([
        [  <span class="hljs-number">101</span>,  <span class="hljs-number">1045</span>,  <span class="hljs-number">1005</span>,  <span class="hljs-number">2310</span>,  <span class="hljs-number">2042</span>,  <span class="hljs-number">3403</span>,  <span class="hljs-number">2005</span>,  <span class="hljs-number">1037</span>, <span class="hljs-number">17662</span>, <span class="hljs-number">12172</span>, <span class="hljs-number">2607</span>,  <span class="hljs-number">2026</span>,  <span class="hljs-number">2878</span>,  <span class="hljs-number">2166</span>,  <span class="hljs-number">1012</span>,   <span class="hljs-number">102</span>],
        [  <span class="hljs-number">101</span>,  <span class="hljs-number">1045</span>,  <span class="hljs-number">5223</span>,  <span class="hljs-number">2023</span>,  <span class="hljs-number">2061</span>,  <span class="hljs-number">2172</span>,   <span class="hljs-number">999</span>,   <span class="hljs-number">102</span>,     <span class="hljs-number">0</span>,     <span class="hljs-number">0</span>,     <span class="hljs-number">0</span>,     <span class="hljs-number">0</span>,     <span class="hljs-number">0</span>,     <span class="hljs-number">0</span>,     <span class="hljs-number">0</span>,     <span class="hljs-number">0</span>]
    ]), 
    <span class="hljs-string">&#x27;attention_mask&#x27;</span>: tensor([
        [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>],
        [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>]
    ])
}`}}),{c(){n=i("p"),h=o("Here\u2019s what the results look like as PyTorch tensors:"),a=f(),E(d.$$.fragment)},l(b){n=p(b,"P",{});var P=c(n);h=r(P,"Here\u2019s what the results look like as PyTorch tensors:"),P.forEach(t),a=m(b),T(d.$$.fragment,b)},m(b,P){u(b,n,P),s(n,h),u(b,a,P),x(d,b,P),_=!0},i(b){_||($(d.$$.fragment,b),_=!0)},o(b){k(d.$$.fragment,b),_=!1},d(b){b&&t(n),b&&t(a),A(d,b)}}}function Ap(v){let n,h,a,d,_,b,P,S,I,j,C;return j=new M({props:{code:`from transformers import TFAutoModel

checkpoint = "distilbert-base-uncased-finetuned-sst-2-english"
model = TFAutoModel.from_pretrained(checkpoint)`,highlighted:`<span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> TFAutoModel

checkpoint = <span class="hljs-string">&quot;distilbert-base-uncased-finetuned-sst-2-english&quot;</span>
model = TFAutoModel.from_pretrained(checkpoint)`}}),{c(){n=i("p"),h=o("We can download our pretrained model the same way we did with our tokenizer. \u{1F917} Transformers provides an "),a=i("code"),d=o("TFAutoModel"),_=o(" class which also has a "),b=i("code"),P=o("from_pretrained"),S=o(" method:"),I=f(),E(j.$$.fragment)},l(w){n=p(w,"P",{});var g=c(n);h=r(g,"We can download our pretrained model the same way we did with our tokenizer. \u{1F917} Transformers provides an "),a=p(g,"CODE",{});var q=c(a);d=r(q,"TFAutoModel"),q.forEach(t),_=r(g," class which also has a "),b=p(g,"CODE",{});var N=c(b);P=r(N,"from_pretrained"),N.forEach(t),S=r(g," method:"),g.forEach(t),I=m(w),T(j.$$.fragment,w)},m(w,g){u(w,n,g),s(n,h),s(n,a),s(a,d),s(n,_),s(n,b),s(b,P),s(n,S),u(w,I,g),x(j,w,g),C=!0},i(w){C||($(j.$$.fragment,w),C=!0)},o(w){k(j.$$.fragment,w),C=!1},d(w){w&&t(n),w&&t(I),A(j,w)}}}function Pp(v){let n,h,a,d,_,b,P,S,I,j,C;return j=new M({props:{code:`from transformers import AutoModel

checkpoint = "distilbert-base-uncased-finetuned-sst-2-english"
model = AutoModel.from_pretrained(checkpoint)`,highlighted:`<span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> AutoModel

checkpoint = <span class="hljs-string">&quot;distilbert-base-uncased-finetuned-sst-2-english&quot;</span>
model = AutoModel.from_pretrained(checkpoint)`}}),{c(){n=i("p"),h=o("We can download our pretrained model the same way we did with our tokenizer. \u{1F917} Transformers provides an "),a=i("code"),d=o("AutoModel"),_=o(" class which also has a "),b=i("code"),P=o("from_pretrained()"),S=o(" method:"),I=f(),E(j.$$.fragment)},l(w){n=p(w,"P",{});var g=c(n);h=r(g,"We can download our pretrained model the same way we did with our tokenizer. \u{1F917} Transformers provides an "),a=p(g,"CODE",{});var q=c(a);d=r(q,"AutoModel"),q.forEach(t),_=r(g," class which also has a "),b=p(g,"CODE",{});var N=c(b);P=r(N,"from_pretrained()"),N.forEach(t),S=r(g," method:"),g.forEach(t),I=m(w),T(j.$$.fragment,w)},m(w,g){u(w,n,g),s(n,h),s(n,a),s(a,d),s(n,_),s(n,b),s(b,P),s(n,S),u(w,I,g),x(j,w,g),C=!0},i(w){C||($(j.$$.fragment,w),C=!0)},o(w){k(j.$$.fragment,w),C=!1},d(w){w&&t(n),w&&t(I),A(j,w)}}}function Ip(v){let n,h,a,d;return n=new M({props:{code:`outputs = model(inputs)
print(outputs.last_hidden_state.shape)`,highlighted:`outputs = model(inputs)
<span class="hljs-built_in">print</span>(outputs.last_hidden_state.shape)`}}),a=new M({props:{code:"(2, 16, 768)",highlighted:'(<span class="hljs-number">2</span>, <span class="hljs-number">16</span>, <span class="hljs-number">768</span>)'}}),{c(){E(n.$$.fragment),h=f(),E(a.$$.fragment)},l(_){T(n.$$.fragment,_),h=m(_),T(a.$$.fragment,_)},m(_,b){x(n,_,b),u(_,h,b),x(a,_,b),d=!0},i(_){d||($(n.$$.fragment,_),$(a.$$.fragment,_),d=!0)},o(_){k(n.$$.fragment,_),k(a.$$.fragment,_),d=!1},d(_){A(n,_),_&&t(h),A(a,_)}}}function Sp(v){let n,h,a,d;return n=new M({props:{code:`outputs = model(**inputs)
print(outputs.last_hidden_state.shape)`,highlighted:`outputs = model(**inputs)
<span class="hljs-built_in">print</span>(outputs.last_hidden_state.shape)`}}),a=new M({props:{code:"torch.Size([2, 16, 768])",highlighted:'torch.Size([<span class="hljs-number">2</span>, <span class="hljs-number">16</span>, <span class="hljs-number">768</span>])'}}),{c(){E(n.$$.fragment),h=f(),E(a.$$.fragment)},l(_){T(n.$$.fragment,_),h=m(_),T(a.$$.fragment,_)},m(_,b){x(n,_,b),u(_,h,b),x(a,_,b),d=!0},i(_){d||($(n.$$.fragment,_),$(a.$$.fragment,_),d=!0)},o(_){k(n.$$.fragment,_),k(a.$$.fragment,_),d=!1},d(_){A(n,_),_&&t(h),A(a,_)}}}function Mp(v){let n,h,a,d,_,b,P,S,I,j,C;return j=new M({props:{code:`from transformers import TFAutoModelForSequenceClassification

checkpoint = "distilbert-base-uncased-finetuned-sst-2-english"
model = TFAutoModelForSequenceClassification.from_pretrained(checkpoint)
outputs = model(inputs)`,highlighted:`<span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> TFAutoModelForSequenceClassification

checkpoint = <span class="hljs-string">&quot;distilbert-base-uncased-finetuned-sst-2-english&quot;</span>
model = TFAutoModelForSequenceClassification.from_pretrained(checkpoint)
outputs = model(inputs)`}}),{c(){n=i("p"),h=o("For our example, we will need a model with a sequence classification head (to be able to classify the sentences as positive or negative). So, we won\u2019t actually use the "),a=i("code"),d=o("TFAutoModel"),_=o(" class, but "),b=i("code"),P=o("TFAutoModelForSequenceClassification"),S=o(":"),I=f(),E(j.$$.fragment)},l(w){n=p(w,"P",{});var g=c(n);h=r(g,"For our example, we will need a model with a sequence classification head (to be able to classify the sentences as positive or negative). So, we won\u2019t actually use the "),a=p(g,"CODE",{});var q=c(a);d=r(q,"TFAutoModel"),q.forEach(t),_=r(g," class, but "),b=p(g,"CODE",{});var N=c(b);P=r(N,"TFAutoModelForSequenceClassification"),N.forEach(t),S=r(g,":"),g.forEach(t),I=m(w),T(j.$$.fragment,w)},m(w,g){u(w,n,g),s(n,h),s(n,a),s(a,d),s(n,_),s(n,b),s(b,P),s(n,S),u(w,I,g),x(j,w,g),C=!0},i(w){C||($(j.$$.fragment,w),C=!0)},o(w){k(j.$$.fragment,w),C=!1},d(w){w&&t(n),w&&t(I),A(j,w)}}}function Cp(v){let n,h,a,d,_,b,P,S,I,j,C;return j=new M({props:{code:`from transformers import AutoModelForSequenceClassification

checkpoint = "distilbert-base-uncased-finetuned-sst-2-english"
model = AutoModelForSequenceClassification.from_pretrained(checkpoint)
outputs = model(**inputs)`,highlighted:`<span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> AutoModelForSequenceClassification

checkpoint = <span class="hljs-string">&quot;distilbert-base-uncased-finetuned-sst-2-english&quot;</span>
model = AutoModelForSequenceClassification.from_pretrained(checkpoint)
outputs = model(**inputs)`}}),{c(){n=i("p"),h=o("For our example, we will need a model with a sequence classification head (to be able to classify the sentences as positive or negative). So, we won\u2019t actually use the "),a=i("code"),d=o("AutoModel"),_=o(" class, but "),b=i("code"),P=o("AutoModelForSequenceClassification"),S=o(":"),I=f(),E(j.$$.fragment)},l(w){n=p(w,"P",{});var g=c(n);h=r(g,"For our example, we will need a model with a sequence classification head (to be able to classify the sentences as positive or negative). So, we won\u2019t actually use the "),a=p(g,"CODE",{});var q=c(a);d=r(q,"AutoModel"),q.forEach(t),_=r(g," class, but "),b=p(g,"CODE",{});var N=c(b);P=r(N,"AutoModelForSequenceClassification"),N.forEach(t),S=r(g,":"),g.forEach(t),I=m(w),T(j.$$.fragment,w)},m(w,g){u(w,n,g),s(n,h),s(n,a),s(a,d),s(n,_),s(n,b),s(b,P),s(n,S),u(w,I,g),x(j,w,g),C=!0},i(w){C||($(j.$$.fragment,w),C=!0)},o(w){k(j.$$.fragment,w),C=!1},d(w){w&&t(n),w&&t(I),A(j,w)}}}function qp(v){let n,h;return n=new M({props:{code:"(2, 2)",highlighted:'(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>)'}}),{c(){E(n.$$.fragment)},l(a){T(n.$$.fragment,a)},m(a,d){x(n,a,d),h=!0},i(a){h||($(n.$$.fragment,a),h=!0)},o(a){k(n.$$.fragment,a),h=!1},d(a){A(n,a)}}}function Fp(v){let n,h;return n=new M({props:{code:"torch.Size([2, 2])",highlighted:'torch.Size([<span class="hljs-number">2</span>, <span class="hljs-number">2</span>])'}}),{c(){E(n.$$.fragment)},l(a){T(n.$$.fragment,a)},m(a,d){x(n,a,d),h=!0},i(a){h||($(n.$$.fragment,a),h=!0)},o(a){k(n.$$.fragment,a),h=!1},d(a){A(n,a)}}}function Np(v){let n,h;return n=new M({props:{code:`<tf.Tensor: shape=(2, 2), dtype=float32, numpy=
    array([[-1.5606991,  1.6122842],
           [ 4.169231 , -3.3464472]], dtype=float32)>`,highlighted:`&lt;tf.Tensor: shape=(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>), dtype=float32, numpy=
    array([[-<span class="hljs-number">1.5606991</span>,  <span class="hljs-number">1.6122842</span>],
           [ <span class="hljs-number">4.169231</span> , -<span class="hljs-number">3.3464472</span>]], dtype=float32)&gt;`}}),{c(){E(n.$$.fragment)},l(a){T(n.$$.fragment,a)},m(a,d){x(n,a,d),h=!0},i(a){h||($(n.$$.fragment,a),h=!0)},o(a){k(n.$$.fragment,a),h=!1},d(a){A(n,a)}}}function Dp(v){let n,h;return n=new M({props:{code:`tensor([[-1.5607,  1.6123],
        [ 4.1692, -3.3464]], grad_fn=<AddmmBackward>)`,highlighted:`tensor([[-<span class="hljs-number">1.5607</span>,  <span class="hljs-number">1.6123</span>],
        [ <span class="hljs-number">4.1692</span>, -<span class="hljs-number">3.3464</span>]], grad_fn=&lt;AddmmBackward&gt;)`}}),{c(){E(n.$$.fragment)},l(a){T(n.$$.fragment,a)},m(a,d){x(n,a,d),h=!0},i(a){h||($(n.$$.fragment,a),h=!0)},o(a){k(n.$$.fragment,a),h=!1},d(a){A(n,a)}}}function Op(v){let n,h;return n=new M({props:{code:`import tensorflow as tf

predictions = tf.math.softmax(outputs.logits, axis=-1)
print(predictions)`,highlighted:`<span class="hljs-keyword">import</span> tensorflow <span class="hljs-keyword">as</span> tf

predictions = tf.math.softmax(outputs.logits, axis=-<span class="hljs-number">1</span>)
<span class="hljs-built_in">print</span>(predictions)`}}),{c(){E(n.$$.fragment)},l(a){T(n.$$.fragment,a)},m(a,d){x(n,a,d),h=!0},i(a){h||($(n.$$.fragment,a),h=!0)},o(a){k(n.$$.fragment,a),h=!1},d(a){A(n,a)}}}function zp(v){let n,h;return n=new M({props:{code:`import torch

predictions = torch.nn.functional.softmax(outputs.logits, dim=-1)
print(predictions)`,highlighted:`<span class="hljs-keyword">import</span> torch

predictions = torch.nn.functional.softmax(outputs.logits, dim=-<span class="hljs-number">1</span>)
<span class="hljs-built_in">print</span>(predictions)`}}),{c(){E(n.$$.fragment)},l(a){T(n.$$.fragment,a)},m(a,d){x(n,a,d),h=!0},i(a){h||($(n.$$.fragment,a),h=!0)},o(a){k(n.$$.fragment,a),h=!1},d(a){A(n,a)}}}function Lp(v){let n,h;return n=new M({props:{code:`tf.Tensor(
[[4.01951671e-02 9.59804833e-01]
 [9.9945587e-01 5.4418424e-04]], shape=(2, 2), dtype=float32)`,highlighted:`tf.Tensor(
[[<span class="hljs-number">4.01951671e-02</span> <span class="hljs-number">9.59804833e-01</span>]
 [<span class="hljs-number">9.9945587e-01</span> <span class="hljs-number">5.4418424e-04</span>]], shape=(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>), dtype=float32)`}}),{c(){E(n.$$.fragment)},l(a){T(n.$$.fragment,a)},m(a,d){x(n,a,d),h=!0},i(a){h||($(n.$$.fragment,a),h=!0)},o(a){k(n.$$.fragment,a),h=!1},d(a){A(n,a)}}}function Hp(v){let n,h;return n=new M({props:{code:`tensor([[4.0195e-02, 9.5980e-01],
        [9.9946e-01, 5.4418e-04]], grad_fn=<SoftmaxBackward>)`,highlighted:`tensor([[<span class="hljs-number">4.0195e-02</span>, <span class="hljs-number">9.5980e-01</span>],
        [<span class="hljs-number">9.9946e-01</span>, <span class="hljs-number">5.4418e-04</span>]], grad_fn=&lt;SoftmaxBackward&gt;)`}}),{c(){E(n.$$.fragment)},l(a){T(n.$$.fragment,a)},m(a,d){x(n,a,d),h=!0},i(a){h||($(n.$$.fragment,a),h=!0)},o(a){k(n.$$.fragment,a),h=!1},d(a){A(n,a)}}}function Gp(v){let n,h,a,d,_,b,P,S;return{c(){n=i("p"),h=o("\u270F\uFE0F "),a=i("strong"),d=o("Try it out!"),_=o(" Choose two (or more) texts of your own and run them through the "),b=i("code"),P=o("sentiment-analysis"),S=o(" pipeline. Then replicate the steps you saw here yourself and check that you obtain the same results!")},l(I){n=p(I,"P",{});var j=c(n);h=r(j,"\u270F\uFE0F "),a=p(j,"STRONG",{});var C=c(a);d=r(C,"Try it out!"),C.forEach(t),_=r(j," Choose two (or more) texts of your own and run them through the "),b=p(j,"CODE",{});var w=c(b);P=r(w,"sentiment-analysis"),w.forEach(t),S=r(j," pipeline. Then replicate the steps you saw here yourself and check that you obtain the same results!"),j.forEach(t)},m(I,j){u(I,n,j),s(n,h),s(n,a),s(a,d),s(n,_),s(n,b),s(b,P),s(n,S)},d(I){I&&t(n)}}}function Vp(v){let n,h,a,d,_,b,P,S,I,j,C,w,g,q,N,Ee,yn,W,B,jt,Te,Ma,Et,Ca,qa,jn,Re,En,Tt,Fa,Tn,Ye,xn,xe,Na,xt,Da,Oa,An,we,Qe,fr,za,Je,mr,Pn,At,La,In,ke,Ae,ws,Xe,Ha,ks,Ga,Sn,Pe,Va,$s,Wa,Ba,Mn,he,Pt,Ua,gs,Ra,Ya,vs,Qa,Ja,ys,Xa,Cn,L,Ka,Ke,Za,el,js,tl,sl,Es,nl,al,qn,H,ll,Ts,ol,rl,xs,il,pl,Ze,cl,ul,Fn,et,Nn,It,hl,Dn,Ie,fl,As,ml,dl,On,Se,bl,Ps,_l,wl,zn,U,R,St,Mt,kl,Ln,Y,Q,Ct,O,$l,Is,gl,vl,Ss,yl,jl,Ms,El,Tl,Cs,xl,Al,Hn,$e,Me,qs,tt,Pl,Fs,Il,Gn,J,X,qt,Ft,Sl,Vn,G,Ml,Ns,Cl,ql,Ds,Fl,Nl,Os,Dl,Ol,Wn,Nt,zl,Bn,fe,Ll,zs,Hl,Gl,Dt,Vl,Wl,Un,ge,Ce,Ls,st,Bl,Hs,Ul,Rn,Ot,Rl,Yn,me,zt,Gs,Yl,Ql,Jl,Lt,Vs,Xl,Kl,Zl,Ht,Ws,eo,to,Qn,Gt,so,Jn,Vt,no,Xn,K,Z,Wt,V,ao,Bs,lo,oo,Us,ro,io,Rs,po,co,Kn,ve,qe,Ys,nt,uo,Qs,ho,Zn,Bt,fo,ea,ye,at,dr,mo,lt,br,ta,Ut,bo,sa,Rt,_o,na,Yt,wo,aa,F,Qt,Js,ko,$o,go,Xs,Ks,vo,yo,Zs,en,jo,Eo,tn,sn,To,xo,nn,an,Ao,Po,ln,on,Io,So,rn,pn,Mo,Co,cn,qo,la,ee,te,Jt,Xt,Fo,oa,ot,ra,se,ne,Kt,Zt,No,ia,je,Fe,un,rt,Do,hn,Oo,pa,es,zo,ca,it,ua,ae,le,ts,z,Lo,fn,Ho,Go,mn,Vo,Wo,dn,Bo,Uo,pt,Ro,Yo,ha,oe,re,ss,ie,pe,ns,de,Qo,bn,Jo,Xo,_n,Ko,Zo,fa,Ne,er,wn,tr,sr,ma,ct,da,ut,ba,as,nr,_a,De,kn,ar,lr,$n,or,wa,ls,rr,ka,Oe,$a;a=new wp({props:{fw:v[0]}}),S=new _s({});const _r=[$p,kp],ht=[];function wr(e,l){return e[0]==="pt"?0:1}g=wr(v),q=ht[g]=_r[g](v),Ee=new cp({props:{$$slots:{default:[gp]},$$scope:{ctx:v}}});const kr=[yp,vp],ft=[];function $r(e,l){return e[0]==="pt"?0:1}W=$r(v),B=ft[W]=kr[W](v),Re=new M({props:{code:`from transformers import pipeline

classifier = pipeline("sentiment-analysis")
classifier(
    ["I've been waiting for a HuggingFace course my whole life.", "I hate this so much!",]
)`,highlighted:`<span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> pipeline

classifier = pipeline(<span class="hljs-string">&quot;sentiment-analysis&quot;</span>)
classifier(
    [<span class="hljs-string">&quot;I&#x27;ve been waiting for a HuggingFace course my whole life.&quot;</span>, <span class="hljs-string">&quot;I hate this so much!&quot;</span>,]
)`}}),Ye=new M({props:{code:`[{'label': 'POSITIVE', 'score': 0.9598047137260437},
 {'label': 'NEGATIVE', 'score': 0.9994558095932007}]`,highlighted:`[{<span class="hljs-string">&#x27;label&#x27;</span>: <span class="hljs-string">&#x27;POSITIVE&#x27;</span>, <span class="hljs-string">&#x27;score&#x27;</span>: <span class="hljs-number">0.9598047137260437</span>},
 {<span class="hljs-string">&#x27;label&#x27;</span>: <span class="hljs-string">&#x27;NEGATIVE&#x27;</span>, <span class="hljs-string">&#x27;score&#x27;</span>: <span class="hljs-number">0.9994558095932007</span>}]`}}),Xe=new _s({}),et=new M({props:{code:`from transformers import AutoTokenizer

checkpoint = "distilbert-base-uncased-finetuned-sst-2-english"
tokenizer = AutoTokenizer.from_pretrained(checkpoint)`,highlighted:`<span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> AutoTokenizer

checkpoint = <span class="hljs-string">&quot;distilbert-base-uncased-finetuned-sst-2-english&quot;</span>
tokenizer = AutoTokenizer.from_pretrained(checkpoint)`}});const gr=[Ep,jp],mt=[];function vr(e,l){return e[0]==="pt"?0:1}U=vr(v),R=mt[U]=gr[U](v);const yr=[xp,Tp],dt=[];function jr(e,l){return e[0]==="pt"?0:1}Y=jr(v),Q=dt[Y]=yr[Y](v),tt=new _s({});const Er=[Pp,Ap],bt=[];function Tr(e,l){return e[0]==="pt"?0:1}J=Tr(v),X=bt[J]=Er[J](v),st=new _s({});const xr=[Sp,Ip],_t=[];function Ar(e,l){return e[0]==="pt"?0:1}K=Ar(v),Z=_t[K]=xr[K](v),nt=new _s({});const Pr=[Cp,Mp],wt=[];function Ir(e,l){return e[0]==="pt"?0:1}ee=Ir(v),te=wt[ee]=Pr[ee](v),ot=new M({props:{code:"print(outputs.logits.shape)",highlighted:'<span class="hljs-built_in">print</span>(outputs.logits.shape)'}});const Sr=[Fp,qp],kt=[];function Mr(e,l){return e[0]==="pt"?0:1}se=Mr(v),ne=kt[se]=Sr[se](v),rt=new _s({}),it=new M({props:{code:"print(outputs.logits)",highlighted:'<span class="hljs-built_in">print</span>(outputs.logits)'}});const Cr=[Dp,Np],$t=[];function qr(e,l){return e[0]==="pt"?0:1}ae=qr(v),le=$t[ae]=Cr[ae](v);const Fr=[zp,Op],gt=[];function Nr(e,l){return e[0]==="pt"?0:1}oe=Nr(v),re=gt[oe]=Fr[oe](v);const Dr=[Hp,Lp],vt=[];function Or(e,l){return e[0]==="pt"?0:1}return ie=Or(v),pe=vt[ie]=Dr[ie](v),ct=new M({props:{code:"model.config.id2label",highlighted:"model.config.id2label"}}),ut=new M({props:{code:"{0: 'NEGATIVE', 1: 'POSITIVE'}",highlighted:'{<span class="hljs-number">0</span>: <span class="hljs-string">&#x27;NEGATIVE&#x27;</span>, <span class="hljs-number">1</span>: <span class="hljs-string">&#x27;POSITIVE&#x27;</span>}'}}),Oe=new cp({props:{$$slots:{default:[Gp]},$$scope:{ctx:v}}}),{c(){n=i("meta"),h=f(),E(a.$$.fragment),d=f(),_=i("h1"),b=i("a"),P=i("span"),E(S.$$.fragment),I=f(),j=i("span"),C=o("Behind the pipeline"),w=f(),q.c(),N=f(),E(Ee.$$.fragment),yn=f(),B.c(),jt=f(),Te=i("p"),Ma=o("Let\u2019s start with a complete example, taking a look at what happened behind the scenes when we executed the following code in "),Et=i("a"),Ca=o("Chapter 1"),qa=o(":"),jn=f(),E(Re.$$.fragment),En=f(),Tt=i("p"),Fa=o("and obtained:"),Tn=f(),E(Ye.$$.fragment),xn=f(),xe=i("p"),Na=o("As we saw in "),xt=i("a"),Da=o("Chapter 1"),Oa=o(", this pipeline groups together three steps: preprocessing, passing the inputs through the model, and postprocessing:"),An=f(),we=i("div"),Qe=i("img"),za=f(),Je=i("img"),Pn=f(),At=i("p"),La=o("Let\u2019s quickly go over each of these."),In=f(),ke=i("h2"),Ae=i("a"),ws=i("span"),E(Xe.$$.fragment),Ha=f(),ks=i("span"),Ga=o("Preprocessing with a tokenizer"),Sn=f(),Pe=i("p"),Va=o("Like other neural networks, Transformer models can\u2019t process raw text directly, so the first step of our pipeline is to convert the text inputs into numbers that the model can make sense of. To do this we use a "),$s=i("em"),Wa=o("tokenizer"),Ba=o(", which will be responsible for:"),Mn=f(),he=i("ul"),Pt=i("li"),Ua=o("Splitting the input into words, subwords, or symbols (like punctuation) that are called "),gs=i("em"),Ra=o("tokens"),Ya=f(),vs=i("li"),Qa=o("Mapping each token to an integer"),Ja=f(),ys=i("li"),Xa=o("Adding additional inputs that may be useful to the model"),Cn=f(),L=i("p"),Ka=o("All this preprocessing needs to be done in exactly the same way as when the model was pretrained, so we first need to download that information from the "),Ke=i("a"),Za=o("Model Hub"),el=o(". To do this, we use the "),js=i("code"),tl=o("AutoTokenizer"),sl=o(" class and its "),Es=i("code"),nl=o("from_pretrained()"),al=o(" method. Using the checkpoint name of our model, it will automatically fetch the data associated with the model\u2019s tokenizer and cache it (so it\u2019s only downloaded the first time you run the code below)."),qn=f(),H=i("p"),ll=o("Since the default checkpoint of the "),Ts=i("code"),ol=o("sentiment-analysis"),rl=o(" pipeline is "),xs=i("code"),il=o("distilbert-base-uncased-finetuned-sst-2-english"),pl=o(" (you can see its model card "),Ze=i("a"),cl=o("here"),ul=o("), we run the following:"),Fn=f(),E(et.$$.fragment),Nn=f(),It=i("p"),hl=o("Once we have the tokenizer, we can directly pass our sentences to it and we\u2019ll get back a dictionary that\u2019s ready to feed to our model! The only thing left to do is to convert the list of input IDs to tensors."),Dn=f(),Ie=i("p"),fl=o("You can use \u{1F917} Transformers without having to worry about which ML framework is used as a backend; it might be PyTorch or TensorFlow, or Flax for some models. However, Transformer models only accept "),As=i("em"),ml=o("tensors"),dl=o(" as input. If this is your first time hearing about tensors, you can think of them as NumPy arrays instead. A NumPy array can be a scalar (0D), a vector (1D), a matrix (2D), or have more dimensions. It\u2019s effectively a tensor; other ML frameworks\u2019 tensors behave similarly, and are usually as simple to instantiate as NumPy arrays."),On=f(),Se=i("p"),bl=o("To specify the type of tensors we want to get back (PyTorch, TensorFlow, or plain NumPy), we use the "),Ps=i("code"),_l=o("return_tensors"),wl=o(" argument:"),zn=f(),R.c(),St=f(),Mt=i("p"),kl=o("Don\u2019t worry about padding and truncation just yet; we\u2019ll explain those later. The main things to remember here are that you can pass one sentence or a list of sentences, as well as specifying the type of tensors you want to get back (if no type is passed, you will get a list of lists as a result)."),Ln=f(),Q.c(),Ct=f(),O=i("p"),$l=o("The output itself is a dictionary containing two keys, "),Is=i("code"),gl=o("input_ids"),vl=o(" and "),Ss=i("code"),yl=o("attention_mask"),jl=o(". "),Ms=i("code"),El=o("input_ids"),Tl=o(" contains two rows of integers (one for each sentence) that are the unique identifiers of the tokens in each sentence. We\u2019ll explain what the "),Cs=i("code"),xl=o("attention_mask"),Al=o(" is later in this chapter."),Hn=f(),$e=i("h2"),Me=i("a"),qs=i("span"),E(tt.$$.fragment),Pl=f(),Fs=i("span"),Il=o("Going through the model"),Gn=f(),X.c(),qt=f(),Ft=i("p"),Sl=o("In this code snippet, we have downloaded the same checkpoint we used in our pipeline before (it should actually have been cached already) and instantiated a model with it."),Vn=f(),G=i("p"),Ml=o("This architecture contains only the base Transformer module: given some inputs, it outputs what we\u2019ll call "),Ns=i("em"),Cl=o("hidden states"),ql=o(", also known as "),Ds=i("em"),Fl=o("features"),Nl=o(". For each model input, we\u2019ll retrieve a high-dimensional vector representing the "),Os=i("strong"),Dl=o("contextual understanding of that input by the Transformer model"),Ol=o("."),Wn=f(),Nt=i("p"),zl=o("If this doesn\u2019t make sense, don\u2019t worry about it. We\u2019ll explain it all later."),Bn=f(),fe=i("p"),Ll=o("While these hidden states can be useful on their own, they\u2019re usually inputs to another part of the model, known as the "),zs=i("em"),Hl=o("head"),Gl=o(". In "),Dt=i("a"),Vl=o("Chapter 1"),Wl=o(", the different tasks could have been performed with the same architecture, but each of these tasks will have a different head associated with it."),Un=f(),ge=i("h3"),Ce=i("a"),Ls=i("span"),E(st.$$.fragment),Bl=f(),Hs=i("span"),Ul=o("A high-dimensional vector?"),Rn=f(),Ot=i("p"),Rl=o("The vector output by the Transformer module is usually large. It generally has three dimensions:"),Yn=f(),me=i("ul"),zt=i("li"),Gs=i("strong"),Yl=o("Batch size"),Ql=o(": The number of sequences processed at a time (2 in our example)."),Jl=f(),Lt=i("li"),Vs=i("strong"),Xl=o("Sequence length"),Kl=o(": The length of the numerical representation of the sequence (16 in our example)."),Zl=f(),Ht=i("li"),Ws=i("strong"),eo=o("Hidden size"),to=o(": The vector dimension of each model input."),Qn=f(),Gt=i("p"),so=o("It is said to be \u201Chigh dimensional\u201D because of the last value. The hidden size can be very large (768 is common for smaller models, and in larger models this can reach 3072 or more)."),Jn=f(),Vt=i("p"),no=o("We can see this if we feed the inputs we preprocessed to our model:"),Xn=f(),Z.c(),Wt=f(),V=i("p"),ao=o("Note that the outputs of \u{1F917} Transformers models behave like "),Bs=i("code"),lo=o("namedtuple"),oo=o("s or dictionaries. You can access the elements by attributes (like we did) or by key ("),Us=i("code"),ro=o('outputs["last_hidden_state"]'),io=o("), or even by index if you know exactly where the thing you are looking for is ("),Rs=i("code"),po=o("outputs[0]"),co=o(")."),Kn=f(),ve=i("h3"),qe=i("a"),Ys=i("span"),E(nt.$$.fragment),uo=f(),Qs=i("span"),ho=o("Model heads: Making sense out of numbers"),Zn=f(),Bt=i("p"),fo=o("The model heads take the high-dimensional vector of hidden states as input and project them onto a different dimension. They are usually composed of one or a few linear layers:"),ea=f(),ye=i("div"),at=i("img"),mo=f(),lt=i("img"),ta=f(),Ut=i("p"),bo=o("The output of the Transformer model is sent directly to the model head to be processed."),sa=f(),Rt=i("p"),_o=o("In this diagram, the model is represented by its embeddings layer and the subsequent layers. The embeddings layer converts each input ID in the tokenized input into a vector that represents the associated token. The subsequent layers manipulate those vectors using the attention mechanism to produce the final representation of the sentences."),na=f(),Yt=i("p"),wo=o("There are many different architectures available in \u{1F917} Transformers, with each one designed around tackling a specific task. Here is a non-exhaustive list:"),aa=f(),F=i("ul"),Qt=i("li"),Js=i("code"),ko=o("*Model"),$o=o(" (retrieve the hidden states)"),go=f(),Xs=i("li"),Ks=i("code"),vo=o("*ForCausalLM"),yo=f(),Zs=i("li"),en=i("code"),jo=o("*ForMaskedLM"),Eo=f(),tn=i("li"),sn=i("code"),To=o("*ForMultipleChoice"),xo=f(),nn=i("li"),an=i("code"),Ao=o("*ForQuestionAnswering"),Po=f(),ln=i("li"),on=i("code"),Io=o("*ForSequenceClassification"),So=f(),rn=i("li"),pn=i("code"),Mo=o("*ForTokenClassification"),Co=f(),cn=i("li"),qo=o("and others \u{1F917}"),la=f(),te.c(),Jt=f(),Xt=i("p"),Fo=o("Now if we look at the shape of our inputs, the dimensionality will be much lower: the model head takes as input the high-dimensional vectors we saw before, and outputs vectors containing two values (one per label):"),oa=f(),E(ot.$$.fragment),ra=f(),ne.c(),Kt=f(),Zt=i("p"),No=o("Since we have just two sentences and two labels, the result we get from our model is of shape 2 x 2."),ia=f(),je=i("h2"),Fe=i("a"),un=i("span"),E(rt.$$.fragment),Do=f(),hn=i("span"),Oo=o("Postprocessing the output"),pa=f(),es=i("p"),zo=o("The values we get as output from our model don\u2019t necessarily make sense by themselves. Let\u2019s take a look:"),ca=f(),E(it.$$.fragment),ua=f(),le.c(),ts=f(),z=i("p"),Lo=o("Our model predicted "),fn=i("code"),Ho=o("[-1.5607, 1.6123]"),Go=o(" for the first sentence and "),mn=i("code"),Vo=o("[ 4.1692, -3.3464]"),Wo=o(" for the second one. Those are not probabilities but "),dn=i("em"),Bo=o("logits"),Uo=o(", the raw, unnormalized scores outputted by the last layer of the model. To be converted to probabilities, they need to go through a "),pt=i("a"),Ro=o("SoftMax"),Yo=o(" layer (all \u{1F917} Transformers models output the logits, as the loss function for training will generally fuse the last activation function, such as SoftMax, with the actual loss function, such as cross entropy):"),ha=f(),re.c(),ss=f(),pe.c(),ns=f(),de=i("p"),Qo=o("Now we can see that the model predicted "),bn=i("code"),Jo=o("[0.0402, 0.9598]"),Xo=o(" for the first sentence and "),_n=i("code"),Ko=o("[0.9995, 0.0005]"),Zo=o(" for the second one. These are recognizable probability scores."),fa=f(),Ne=i("p"),er=o("To get the labels corresponding to each position, we can inspect the "),wn=i("code"),tr=o("id2label"),sr=o(" attribute of the model config (more on this in the next section):"),ma=f(),E(ct.$$.fragment),da=f(),E(ut.$$.fragment),ba=f(),as=i("p"),nr=o("Now we can conclude that the model predicted the following:"),_a=f(),De=i("ul"),kn=i("li"),ar=o("First sentence: NEGATIVE: 0.0402, POSITIVE: 0.9598"),lr=f(),$n=i("li"),or=o("Second sentence: NEGATIVE: 0.9995, POSITIVE: 0.0005"),wa=f(),ls=i("p"),rr=o("We have successfully reproduced the three steps of the pipeline: preprocessing with tokenizers, passing the inputs through the model, and postprocessing! Now let\u2019s take some time to dive deeper into each of those steps."),ka=f(),E(Oe.$$.fragment),this.h()},l(e){const l=bp('[data-svelte="svelte-1phssyn"]',document.head);n=p(l,"META",{name:!0,content:!0}),l.forEach(t),h=m(e),T(a.$$.fragment,e),d=m(e),_=p(e,"H1",{class:!0});var yt=c(_);b=p(yt,"A",{id:!0,class:!0,href:!0});var os=c(b);P=p(os,"SPAN",{});var gn=c(P);T(S.$$.fragment,gn),gn.forEach(t),os.forEach(t),I=m(yt),j=p(yt,"SPAN",{});var rs=c(j);C=r(rs,"Behind the pipeline"),rs.forEach(t),yt.forEach(t),w=m(e),q.l(e),N=m(e),T(Ee.$$.fragment,e),yn=m(e),B.l(e),jt=m(e),Te=p(e,"P",{});var ze=c(Te);Ma=r(ze,"Let\u2019s start with a complete example, taking a look at what happened behind the scenes when we executed the following code in "),Et=p(ze,"A",{href:!0});var is=c(Et);Ca=r(is,"Chapter 1"),is.forEach(t),qa=r(ze,":"),ze.forEach(t),jn=m(e),T(Re.$$.fragment,e),En=m(e),Tt=p(e,"P",{});var ps=c(Tt);Fa=r(ps,"and obtained:"),ps.forEach(t),Tn=m(e),T(Ye.$$.fragment,e),xn=m(e),xe=p(e,"P",{});var Le=c(xe);Na=r(Le,"As we saw in "),xt=p(Le,"A",{href:!0});var cs=c(xt);Da=r(cs,"Chapter 1"),cs.forEach(t),Oa=r(Le,", this pipeline groups together three steps: preprocessing, passing the inputs through the model, and postprocessing:"),Le.forEach(t),An=m(e),we=p(e,"DIV",{class:!0});var He=c(we);Qe=p(He,"IMG",{class:!0,src:!0,alt:!0}),za=m(He),Je=p(He,"IMG",{class:!0,src:!0,alt:!0}),He.forEach(t),Pn=m(e),At=p(e,"P",{});var us=c(At);La=r(us,"Let\u2019s quickly go over each of these."),us.forEach(t),In=m(e),ke=p(e,"H2",{class:!0});var Ge=c(ke);Ae=p(Ge,"A",{id:!0,class:!0,href:!0});var hs=c(Ae);ws=p(hs,"SPAN",{});var vn=c(ws);T(Xe.$$.fragment,vn),vn.forEach(t),hs.forEach(t),Ha=m(Ge),ks=p(Ge,"SPAN",{});var zr=c(ks);Ga=r(zr,"Preprocessing with a tokenizer"),zr.forEach(t),Ge.forEach(t),Sn=m(e),Pe=p(e,"P",{});var ga=c(Pe);Va=r(ga,"Like other neural networks, Transformer models can\u2019t process raw text directly, so the first step of our pipeline is to convert the text inputs into numbers that the model can make sense of. To do this we use a "),$s=p(ga,"EM",{});var Lr=c($s);Wa=r(Lr,"tokenizer"),Lr.forEach(t),Ba=r(ga,", which will be responsible for:"),ga.forEach(t),Mn=m(e),he=p(e,"UL",{});var fs=c(he);Pt=p(fs,"LI",{});var ir=c(Pt);Ua=r(ir,"Splitting the input into words, subwords, or symbols (like punctuation) that are called "),gs=p(ir,"EM",{});var Hr=c(gs);Ra=r(Hr,"tokens"),Hr.forEach(t),ir.forEach(t),Ya=m(fs),vs=p(fs,"LI",{});var Gr=c(vs);Qa=r(Gr,"Mapping each token to an integer"),Gr.forEach(t),Ja=m(fs),ys=p(fs,"LI",{});var Vr=c(ys);Xa=r(Vr,"Adding additional inputs that may be useful to the model"),Vr.forEach(t),fs.forEach(t),Cn=m(e),L=p(e,"P",{});var Ve=c(L);Ka=r(Ve,"All this preprocessing needs to be done in exactly the same way as when the model was pretrained, so we first need to download that information from the "),Ke=p(Ve,"A",{href:!0,rel:!0});var Wr=c(Ke);Za=r(Wr,"Model Hub"),Wr.forEach(t),el=r(Ve,". To do this, we use the "),js=p(Ve,"CODE",{});var Br=c(js);tl=r(Br,"AutoTokenizer"),Br.forEach(t),sl=r(Ve," class and its "),Es=p(Ve,"CODE",{});var Ur=c(Es);nl=r(Ur,"from_pretrained()"),Ur.forEach(t),al=r(Ve," method. Using the checkpoint name of our model, it will automatically fetch the data associated with the model\u2019s tokenizer and cache it (so it\u2019s only downloaded the first time you run the code below)."),Ve.forEach(t),qn=m(e),H=p(e,"P",{});var We=c(H);ll=r(We,"Since the default checkpoint of the "),Ts=p(We,"CODE",{});var Rr=c(Ts);ol=r(Rr,"sentiment-analysis"),Rr.forEach(t),rl=r(We," pipeline is "),xs=p(We,"CODE",{});var Yr=c(xs);il=r(Yr,"distilbert-base-uncased-finetuned-sst-2-english"),Yr.forEach(t),pl=r(We," (you can see its model card "),Ze=p(We,"A",{href:!0,rel:!0});var Qr=c(Ze);cl=r(Qr,"here"),Qr.forEach(t),ul=r(We,"), we run the following:"),We.forEach(t),Fn=m(e),T(et.$$.fragment,e),Nn=m(e),It=p(e,"P",{});var Jr=c(It);hl=r(Jr,"Once we have the tokenizer, we can directly pass our sentences to it and we\u2019ll get back a dictionary that\u2019s ready to feed to our model! The only thing left to do is to convert the list of input IDs to tensors."),Jr.forEach(t),Dn=m(e),Ie=p(e,"P",{});var va=c(Ie);fl=r(va,"You can use \u{1F917} Transformers without having to worry about which ML framework is used as a backend; it might be PyTorch or TensorFlow, or Flax for some models. However, Transformer models only accept "),As=p(va,"EM",{});var Xr=c(As);ml=r(Xr,"tensors"),Xr.forEach(t),dl=r(va," as input. If this is your first time hearing about tensors, you can think of them as NumPy arrays instead. A NumPy array can be a scalar (0D), a vector (1D), a matrix (2D), or have more dimensions. It\u2019s effectively a tensor; other ML frameworks\u2019 tensors behave similarly, and are usually as simple to instantiate as NumPy arrays."),va.forEach(t),On=m(e),Se=p(e,"P",{});var ya=c(Se);bl=r(ya,"To specify the type of tensors we want to get back (PyTorch, TensorFlow, or plain NumPy), we use the "),Ps=p(ya,"CODE",{});var Kr=c(Ps);_l=r(Kr,"return_tensors"),Kr.forEach(t),wl=r(ya," argument:"),ya.forEach(t),zn=m(e),R.l(e),St=m(e),Mt=p(e,"P",{});var Zr=c(Mt);kl=r(Zr,"Don\u2019t worry about padding and truncation just yet; we\u2019ll explain those later. The main things to remember here are that you can pass one sentence or a list of sentences, as well as specifying the type of tensors you want to get back (if no type is passed, you will get a list of lists as a result)."),Zr.forEach(t),Ln=m(e),Q.l(e),Ct=m(e),O=p(e,"P",{});var be=c(O);$l=r(be,"The output itself is a dictionary containing two keys, "),Is=p(be,"CODE",{});var ei=c(Is);gl=r(ei,"input_ids"),ei.forEach(t),vl=r(be," and "),Ss=p(be,"CODE",{});var ti=c(Ss);yl=r(ti,"attention_mask"),ti.forEach(t),jl=r(be,". "),Ms=p(be,"CODE",{});var si=c(Ms);El=r(si,"input_ids"),si.forEach(t),Tl=r(be," contains two rows of integers (one for each sentence) that are the unique identifiers of the tokens in each sentence. We\u2019ll explain what the "),Cs=p(be,"CODE",{});var ni=c(Cs);xl=r(ni,"attention_mask"),ni.forEach(t),Al=r(be," is later in this chapter."),be.forEach(t),Hn=m(e),$e=p(e,"H2",{class:!0});var ja=c($e);Me=p(ja,"A",{id:!0,class:!0,href:!0});var ai=c(Me);qs=p(ai,"SPAN",{});var li=c(qs);T(tt.$$.fragment,li),li.forEach(t),ai.forEach(t),Pl=m(ja),Fs=p(ja,"SPAN",{});var oi=c(Fs);Il=r(oi,"Going through the model"),oi.forEach(t),ja.forEach(t),Gn=m(e),X.l(e),qt=m(e),Ft=p(e,"P",{});var ri=c(Ft);Sl=r(ri,"In this code snippet, we have downloaded the same checkpoint we used in our pipeline before (it should actually have been cached already) and instantiated a model with it."),ri.forEach(t),Vn=m(e),G=p(e,"P",{});var Be=c(G);Ml=r(Be,"This architecture contains only the base Transformer module: given some inputs, it outputs what we\u2019ll call "),Ns=p(Be,"EM",{});var ii=c(Ns);Cl=r(ii,"hidden states"),ii.forEach(t),ql=r(Be,", also known as "),Ds=p(Be,"EM",{});var pi=c(Ds);Fl=r(pi,"features"),pi.forEach(t),Nl=r(Be,". For each model input, we\u2019ll retrieve a high-dimensional vector representing the "),Os=p(Be,"STRONG",{});var ci=c(Os);Dl=r(ci,"contextual understanding of that input by the Transformer model"),ci.forEach(t),Ol=r(Be,"."),Be.forEach(t),Wn=m(e),Nt=p(e,"P",{});var ui=c(Nt);zl=r(ui,"If this doesn\u2019t make sense, don\u2019t worry about it. We\u2019ll explain it all later."),ui.forEach(t),Bn=m(e),fe=p(e,"P",{});var ms=c(fe);Ll=r(ms,"While these hidden states can be useful on their own, they\u2019re usually inputs to another part of the model, known as the "),zs=p(ms,"EM",{});var hi=c(zs);Hl=r(hi,"head"),hi.forEach(t),Gl=r(ms,". In "),Dt=p(ms,"A",{href:!0});var fi=c(Dt);Vl=r(fi,"Chapter 1"),fi.forEach(t),Wl=r(ms,", the different tasks could have been performed with the same architecture, but each of these tasks will have a different head associated with it."),ms.forEach(t),Un=m(e),ge=p(e,"H3",{class:!0});var Ea=c(ge);Ce=p(Ea,"A",{id:!0,class:!0,href:!0});var mi=c(Ce);Ls=p(mi,"SPAN",{});var di=c(Ls);T(st.$$.fragment,di),di.forEach(t),mi.forEach(t),Bl=m(Ea),Hs=p(Ea,"SPAN",{});var bi=c(Hs);Ul=r(bi,"A high-dimensional vector?"),bi.forEach(t),Ea.forEach(t),Rn=m(e),Ot=p(e,"P",{});var _i=c(Ot);Rl=r(_i,"The vector output by the Transformer module is usually large. It generally has three dimensions:"),_i.forEach(t),Yn=m(e),me=p(e,"UL",{});var ds=c(me);zt=p(ds,"LI",{});var pr=c(zt);Gs=p(pr,"STRONG",{});var wi=c(Gs);Yl=r(wi,"Batch size"),wi.forEach(t),Ql=r(pr,": The number of sequences processed at a time (2 in our example)."),pr.forEach(t),Jl=m(ds),Lt=p(ds,"LI",{});var cr=c(Lt);Vs=p(cr,"STRONG",{});var ki=c(Vs);Xl=r(ki,"Sequence length"),ki.forEach(t),Kl=r(cr,": The length of the numerical representation of the sequence (16 in our example)."),cr.forEach(t),Zl=m(ds),Ht=p(ds,"LI",{});var ur=c(Ht);Ws=p(ur,"STRONG",{});var $i=c(Ws);eo=r($i,"Hidden size"),$i.forEach(t),to=r(ur,": The vector dimension of each model input."),ur.forEach(t),ds.forEach(t),Qn=m(e),Gt=p(e,"P",{});var gi=c(Gt);so=r(gi,"It is said to be \u201Chigh dimensional\u201D because of the last value. The hidden size can be very large (768 is common for smaller models, and in larger models this can reach 3072 or more)."),gi.forEach(t),Jn=m(e),Vt=p(e,"P",{});var vi=c(Vt);no=r(vi,"We can see this if we feed the inputs we preprocessed to our model:"),vi.forEach(t),Xn=m(e),Z.l(e),Wt=m(e),V=p(e,"P",{});var Ue=c(V);ao=r(Ue,"Note that the outputs of \u{1F917} Transformers models behave like "),Bs=p(Ue,"CODE",{});var yi=c(Bs);lo=r(yi,"namedtuple"),yi.forEach(t),oo=r(Ue,"s or dictionaries. You can access the elements by attributes (like we did) or by key ("),Us=p(Ue,"CODE",{});var ji=c(Us);ro=r(ji,'outputs["last_hidden_state"]'),ji.forEach(t),io=r(Ue,"), or even by index if you know exactly where the thing you are looking for is ("),Rs=p(Ue,"CODE",{});var Ei=c(Rs);po=r(Ei,"outputs[0]"),Ei.forEach(t),co=r(Ue,")."),Ue.forEach(t),Kn=m(e),ve=p(e,"H3",{class:!0});var Ta=c(ve);qe=p(Ta,"A",{id:!0,class:!0,href:!0});var Ti=c(qe);Ys=p(Ti,"SPAN",{});var xi=c(Ys);T(nt.$$.fragment,xi),xi.forEach(t),Ti.forEach(t),uo=m(Ta),Qs=p(Ta,"SPAN",{});var Ai=c(Qs);ho=r(Ai,"Model heads: Making sense out of numbers"),Ai.forEach(t),Ta.forEach(t),Zn=m(e),Bt=p(e,"P",{});var Pi=c(Bt);fo=r(Pi,"The model heads take the high-dimensional vector of hidden states as input and project them onto a different dimension. They are usually composed of one or a few linear layers:"),Pi.forEach(t),ea=m(e),ye=p(e,"DIV",{class:!0});var xa=c(ye);at=p(xa,"IMG",{class:!0,src:!0,alt:!0}),mo=m(xa),lt=p(xa,"IMG",{class:!0,src:!0,alt:!0}),xa.forEach(t),ta=m(e),Ut=p(e,"P",{});var Ii=c(Ut);bo=r(Ii,"The output of the Transformer model is sent directly to the model head to be processed."),Ii.forEach(t),sa=m(e),Rt=p(e,"P",{});var Si=c(Rt);_o=r(Si,"In this diagram, the model is represented by its embeddings layer and the subsequent layers. The embeddings layer converts each input ID in the tokenized input into a vector that represents the associated token. The subsequent layers manipulate those vectors using the attention mechanism to produce the final representation of the sentences."),Si.forEach(t),na=m(e),Yt=p(e,"P",{});var Mi=c(Yt);wo=r(Mi,"There are many different architectures available in \u{1F917} Transformers, with each one designed around tackling a specific task. Here is a non-exhaustive list:"),Mi.forEach(t),aa=m(e),F=p(e,"UL",{});var D=c(F);Qt=p(D,"LI",{});var hr=c(Qt);Js=p(hr,"CODE",{});var Ci=c(Js);ko=r(Ci,"*Model"),Ci.forEach(t),$o=r(hr," (retrieve the hidden states)"),hr.forEach(t),go=m(D),Xs=p(D,"LI",{});var qi=c(Xs);Ks=p(qi,"CODE",{});var Fi=c(Ks);vo=r(Fi,"*ForCausalLM"),Fi.forEach(t),qi.forEach(t),yo=m(D),Zs=p(D,"LI",{});var Ni=c(Zs);en=p(Ni,"CODE",{});var Di=c(en);jo=r(Di,"*ForMaskedLM"),Di.forEach(t),Ni.forEach(t),Eo=m(D),tn=p(D,"LI",{});var Oi=c(tn);sn=p(Oi,"CODE",{});var zi=c(sn);To=r(zi,"*ForMultipleChoice"),zi.forEach(t),Oi.forEach(t),xo=m(D),nn=p(D,"LI",{});var Li=c(nn);an=p(Li,"CODE",{});var Hi=c(an);Ao=r(Hi,"*ForQuestionAnswering"),Hi.forEach(t),Li.forEach(t),Po=m(D),ln=p(D,"LI",{});var Gi=c(ln);on=p(Gi,"CODE",{});var Vi=c(on);Io=r(Vi,"*ForSequenceClassification"),Vi.forEach(t),Gi.forEach(t),So=m(D),rn=p(D,"LI",{});var Wi=c(rn);pn=p(Wi,"CODE",{});var Bi=c(pn);Mo=r(Bi,"*ForTokenClassification"),Bi.forEach(t),Wi.forEach(t),Co=m(D),cn=p(D,"LI",{});var Ui=c(cn);qo=r(Ui,"and others \u{1F917}"),Ui.forEach(t),D.forEach(t),la=m(e),te.l(e),Jt=m(e),Xt=p(e,"P",{});var Ri=c(Xt);Fo=r(Ri,"Now if we look at the shape of our inputs, the dimensionality will be much lower: the model head takes as input the high-dimensional vectors we saw before, and outputs vectors containing two values (one per label):"),Ri.forEach(t),oa=m(e),T(ot.$$.fragment,e),ra=m(e),ne.l(e),Kt=m(e),Zt=p(e,"P",{});var Yi=c(Zt);No=r(Yi,"Since we have just two sentences and two labels, the result we get from our model is of shape 2 x 2."),Yi.forEach(t),ia=m(e),je=p(e,"H2",{class:!0});var Aa=c(je);Fe=p(Aa,"A",{id:!0,class:!0,href:!0});var Qi=c(Fe);un=p(Qi,"SPAN",{});var Ji=c(un);T(rt.$$.fragment,Ji),Ji.forEach(t),Qi.forEach(t),Do=m(Aa),hn=p(Aa,"SPAN",{});var Xi=c(hn);Oo=r(Xi,"Postprocessing the output"),Xi.forEach(t),Aa.forEach(t),pa=m(e),es=p(e,"P",{});var Ki=c(es);zo=r(Ki,"The values we get as output from our model don\u2019t necessarily make sense by themselves. Let\u2019s take a look:"),Ki.forEach(t),ca=m(e),T(it.$$.fragment,e),ua=m(e),le.l(e),ts=m(e),z=p(e,"P",{});var _e=c(z);Lo=r(_e,"Our model predicted "),fn=p(_e,"CODE",{});var Zi=c(fn);Ho=r(Zi,"[-1.5607, 1.6123]"),Zi.forEach(t),Go=r(_e," for the first sentence and "),mn=p(_e,"CODE",{});var ep=c(mn);Vo=r(ep,"[ 4.1692, -3.3464]"),ep.forEach(t),Wo=r(_e," for the second one. Those are not probabilities but "),dn=p(_e,"EM",{});var tp=c(dn);Bo=r(tp,"logits"),tp.forEach(t),Uo=r(_e,", the raw, unnormalized scores outputted by the last layer of the model. To be converted to probabilities, they need to go through a "),pt=p(_e,"A",{href:!0,rel:!0});var sp=c(pt);Ro=r(sp,"SoftMax"),sp.forEach(t),Yo=r(_e," layer (all \u{1F917} Transformers models output the logits, as the loss function for training will generally fuse the last activation function, such as SoftMax, with the actual loss function, such as cross entropy):"),_e.forEach(t),ha=m(e),re.l(e),ss=m(e),pe.l(e),ns=m(e),de=p(e,"P",{});var bs=c(de);Qo=r(bs,"Now we can see that the model predicted "),bn=p(bs,"CODE",{});var np=c(bn);Jo=r(np,"[0.0402, 0.9598]"),np.forEach(t),Xo=r(bs," for the first sentence and "),_n=p(bs,"CODE",{});var ap=c(_n);Ko=r(ap,"[0.9995, 0.0005]"),ap.forEach(t),Zo=r(bs," for the second one. These are recognizable probability scores."),bs.forEach(t),fa=m(e),Ne=p(e,"P",{});var Pa=c(Ne);er=r(Pa,"To get the labels corresponding to each position, we can inspect the "),wn=p(Pa,"CODE",{});var lp=c(wn);tr=r(lp,"id2label"),lp.forEach(t),sr=r(Pa," attribute of the model config (more on this in the next section):"),Pa.forEach(t),ma=m(e),T(ct.$$.fragment,e),da=m(e),T(ut.$$.fragment,e),ba=m(e),as=p(e,"P",{});var op=c(as);nr=r(op,"Now we can conclude that the model predicted the following:"),op.forEach(t),_a=m(e),De=p(e,"UL",{});var Ia=c(De);kn=p(Ia,"LI",{});var rp=c(kn);ar=r(rp,"First sentence: NEGATIVE: 0.0402, POSITIVE: 0.9598"),rp.forEach(t),lr=m(Ia),$n=p(Ia,"LI",{});var ip=c($n);or=r(ip,"Second sentence: NEGATIVE: 0.9995, POSITIVE: 0.0005"),ip.forEach(t),Ia.forEach(t),wa=m(e),ls=p(e,"P",{});var pp=c(ls);rr=r(pp,"We have successfully reproduced the three steps of the pipeline: preprocessing with tokenizers, passing the inputs through the model, and postprocessing! Now let\u2019s take some time to dive deeper into each of those steps."),pp.forEach(t),ka=m(e),T(Oe.$$.fragment,e),this.h()},h(){y(n,"name","hf:doc:metadata"),y(n,"content",JSON.stringify(Wp)),y(b,"id","behind-the-pipeline"),y(b,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),y(b,"href","#behind-the-pipeline"),y(_,"class","relative group"),y(Et,"href","/course/chapter1"),y(xt,"href","/course/chapter1"),y(Qe,"class","block dark:hidden"),Sa(Qe.src,fr="https://huggingface.co/datasets/huggingface-course/documentation-images/resolve/main/en/chapter2/full_nlp_pipeline.svg")||y(Qe,"src",fr),y(Qe,"alt","The full NLP pipeline: tokenization of text, conversion to IDs, and inference through the Transformer model and the model head."),y(Je,"class","hidden dark:block"),Sa(Je.src,mr="https://huggingface.co/datasets/huggingface-course/documentation-images/resolve/main/en/chapter2/full_nlp_pipeline-dark.svg")||y(Je,"src",mr),y(Je,"alt","The full NLP pipeline: tokenization of text, conversion to IDs, and inference through the Transformer model and the model head."),y(we,"class","flex justify-center"),y(Ae,"id","preprocessing-with-a-tokenizer"),y(Ae,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),y(Ae,"href","#preprocessing-with-a-tokenizer"),y(ke,"class","relative group"),y(Ke,"href","https://huggingface.co/models"),y(Ke,"rel","nofollow"),y(Ze,"href","https://huggingface.co/distilbert-base-uncased-finetuned-sst-2-english"),y(Ze,"rel","nofollow"),y(Me,"id","going-through-the-model"),y(Me,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),y(Me,"href","#going-through-the-model"),y($e,"class","relative group"),y(Dt,"href","/course/chapter1"),y(Ce,"id","a-highdimensional-vector"),y(Ce,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),y(Ce,"href","#a-highdimensional-vector"),y(ge,"class","relative group"),y(qe,"id","model-heads-making-sense-out-of-numbers"),y(qe,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),y(qe,"href","#model-heads-making-sense-out-of-numbers"),y(ve,"class","relative group"),y(at,"class","block dark:hidden"),Sa(at.src,dr="https://huggingface.co/datasets/huggingface-course/documentation-images/resolve/main/en/chapter2/transformer_and_head.svg")||y(at,"src",dr),y(at,"alt","A Transformer network alongside its head."),y(lt,"class","hidden dark:block"),Sa(lt.src,br="https://huggingface.co/datasets/huggingface-course/documentation-images/resolve/main/en/chapter2/transformer_and_head-dark.svg")||y(lt,"src",br),y(lt,"alt","A Transformer network alongside its head."),y(ye,"class","flex justify-center"),y(Fe,"id","postprocessing-the-output"),y(Fe,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),y(Fe,"href","#postprocessing-the-output"),y(je,"class","relative group"),y(pt,"href","https://en.wikipedia.org/wiki/Softmax_function"),y(pt,"rel","nofollow")},m(e,l){s(document.head,n),u(e,h,l),x(a,e,l),u(e,d,l),u(e,_,l),s(_,b),s(b,P),x(S,P,null),s(_,I),s(_,j),s(j,C),u(e,w,l),ht[g].m(e,l),u(e,N,l),x(Ee,e,l),u(e,yn,l),ft[W].m(e,l),u(e,jt,l),u(e,Te,l),s(Te,Ma),s(Te,Et),s(Et,Ca),s(Te,qa),u(e,jn,l),x(Re,e,l),u(e,En,l),u(e,Tt,l),s(Tt,Fa),u(e,Tn,l),x(Ye,e,l),u(e,xn,l),u(e,xe,l),s(xe,Na),s(xe,xt),s(xt,Da),s(xe,Oa),u(e,An,l),u(e,we,l),s(we,Qe),s(we,za),s(we,Je),u(e,Pn,l),u(e,At,l),s(At,La),u(e,In,l),u(e,ke,l),s(ke,Ae),s(Ae,ws),x(Xe,ws,null),s(ke,Ha),s(ke,ks),s(ks,Ga),u(e,Sn,l),u(e,Pe,l),s(Pe,Va),s(Pe,$s),s($s,Wa),s(Pe,Ba),u(e,Mn,l),u(e,he,l),s(he,Pt),s(Pt,Ua),s(Pt,gs),s(gs,Ra),s(he,Ya),s(he,vs),s(vs,Qa),s(he,Ja),s(he,ys),s(ys,Xa),u(e,Cn,l),u(e,L,l),s(L,Ka),s(L,Ke),s(Ke,Za),s(L,el),s(L,js),s(js,tl),s(L,sl),s(L,Es),s(Es,nl),s(L,al),u(e,qn,l),u(e,H,l),s(H,ll),s(H,Ts),s(Ts,ol),s(H,rl),s(H,xs),s(xs,il),s(H,pl),s(H,Ze),s(Ze,cl),s(H,ul),u(e,Fn,l),x(et,e,l),u(e,Nn,l),u(e,It,l),s(It,hl),u(e,Dn,l),u(e,Ie,l),s(Ie,fl),s(Ie,As),s(As,ml),s(Ie,dl),u(e,On,l),u(e,Se,l),s(Se,bl),s(Se,Ps),s(Ps,_l),s(Se,wl),u(e,zn,l),mt[U].m(e,l),u(e,St,l),u(e,Mt,l),s(Mt,kl),u(e,Ln,l),dt[Y].m(e,l),u(e,Ct,l),u(e,O,l),s(O,$l),s(O,Is),s(Is,gl),s(O,vl),s(O,Ss),s(Ss,yl),s(O,jl),s(O,Ms),s(Ms,El),s(O,Tl),s(O,Cs),s(Cs,xl),s(O,Al),u(e,Hn,l),u(e,$e,l),s($e,Me),s(Me,qs),x(tt,qs,null),s($e,Pl),s($e,Fs),s(Fs,Il),u(e,Gn,l),bt[J].m(e,l),u(e,qt,l),u(e,Ft,l),s(Ft,Sl),u(e,Vn,l),u(e,G,l),s(G,Ml),s(G,Ns),s(Ns,Cl),s(G,ql),s(G,Ds),s(Ds,Fl),s(G,Nl),s(G,Os),s(Os,Dl),s(G,Ol),u(e,Wn,l),u(e,Nt,l),s(Nt,zl),u(e,Bn,l),u(e,fe,l),s(fe,Ll),s(fe,zs),s(zs,Hl),s(fe,Gl),s(fe,Dt),s(Dt,Vl),s(fe,Wl),u(e,Un,l),u(e,ge,l),s(ge,Ce),s(Ce,Ls),x(st,Ls,null),s(ge,Bl),s(ge,Hs),s(Hs,Ul),u(e,Rn,l),u(e,Ot,l),s(Ot,Rl),u(e,Yn,l),u(e,me,l),s(me,zt),s(zt,Gs),s(Gs,Yl),s(zt,Ql),s(me,Jl),s(me,Lt),s(Lt,Vs),s(Vs,Xl),s(Lt,Kl),s(me,Zl),s(me,Ht),s(Ht,Ws),s(Ws,eo),s(Ht,to),u(e,Qn,l),u(e,Gt,l),s(Gt,so),u(e,Jn,l),u(e,Vt,l),s(Vt,no),u(e,Xn,l),_t[K].m(e,l),u(e,Wt,l),u(e,V,l),s(V,ao),s(V,Bs),s(Bs,lo),s(V,oo),s(V,Us),s(Us,ro),s(V,io),s(V,Rs),s(Rs,po),s(V,co),u(e,Kn,l),u(e,ve,l),s(ve,qe),s(qe,Ys),x(nt,Ys,null),s(ve,uo),s(ve,Qs),s(Qs,ho),u(e,Zn,l),u(e,Bt,l),s(Bt,fo),u(e,ea,l),u(e,ye,l),s(ye,at),s(ye,mo),s(ye,lt),u(e,ta,l),u(e,Ut,l),s(Ut,bo),u(e,sa,l),u(e,Rt,l),s(Rt,_o),u(e,na,l),u(e,Yt,l),s(Yt,wo),u(e,aa,l),u(e,F,l),s(F,Qt),s(Qt,Js),s(Js,ko),s(Qt,$o),s(F,go),s(F,Xs),s(Xs,Ks),s(Ks,vo),s(F,yo),s(F,Zs),s(Zs,en),s(en,jo),s(F,Eo),s(F,tn),s(tn,sn),s(sn,To),s(F,xo),s(F,nn),s(nn,an),s(an,Ao),s(F,Po),s(F,ln),s(ln,on),s(on,Io),s(F,So),s(F,rn),s(rn,pn),s(pn,Mo),s(F,Co),s(F,cn),s(cn,qo),u(e,la,l),wt[ee].m(e,l),u(e,Jt,l),u(e,Xt,l),s(Xt,Fo),u(e,oa,l),x(ot,e,l),u(e,ra,l),kt[se].m(e,l),u(e,Kt,l),u(e,Zt,l),s(Zt,No),u(e,ia,l),u(e,je,l),s(je,Fe),s(Fe,un),x(rt,un,null),s(je,Do),s(je,hn),s(hn,Oo),u(e,pa,l),u(e,es,l),s(es,zo),u(e,ca,l),x(it,e,l),u(e,ua,l),$t[ae].m(e,l),u(e,ts,l),u(e,z,l),s(z,Lo),s(z,fn),s(fn,Ho),s(z,Go),s(z,mn),s(mn,Vo),s(z,Wo),s(z,dn),s(dn,Bo),s(z,Uo),s(z,pt),s(pt,Ro),s(z,Yo),u(e,ha,l),gt[oe].m(e,l),u(e,ss,l),vt[ie].m(e,l),u(e,ns,l),u(e,de,l),s(de,Qo),s(de,bn),s(bn,Jo),s(de,Xo),s(de,_n),s(_n,Ko),s(de,Zo),u(e,fa,l),u(e,Ne,l),s(Ne,er),s(Ne,wn),s(wn,tr),s(Ne,sr),u(e,ma,l),x(ct,e,l),u(e,da,l),x(ut,e,l),u(e,ba,l),u(e,as,l),s(as,nr),u(e,_a,l),u(e,De,l),s(De,kn),s(kn,ar),s(De,lr),s(De,$n),s($n,or),u(e,wa,l),u(e,ls,l),s(ls,rr),u(e,ka,l),x(Oe,e,l),$a=!0},p(e,[l]){const yt={};l&1&&(yt.fw=e[0]),a.$set(yt);let os=g;g=wr(e),g!==os&&(ue(),k(ht[os],1,1,()=>{ht[os]=null}),ce(),q=ht[g],q||(q=ht[g]=_r[g](e),q.c()),$(q,1),q.m(N.parentNode,N));const gn={};l&2&&(gn.$$scope={dirty:l,ctx:e}),Ee.$set(gn);let rs=W;W=$r(e),W!==rs&&(ue(),k(ft[rs],1,1,()=>{ft[rs]=null}),ce(),B=ft[W],B||(B=ft[W]=kr[W](e),B.c()),$(B,1),B.m(jt.parentNode,jt));let ze=U;U=vr(e),U!==ze&&(ue(),k(mt[ze],1,1,()=>{mt[ze]=null}),ce(),R=mt[U],R||(R=mt[U]=gr[U](e),R.c()),$(R,1),R.m(St.parentNode,St));let is=Y;Y=jr(e),Y!==is&&(ue(),k(dt[is],1,1,()=>{dt[is]=null}),ce(),Q=dt[Y],Q||(Q=dt[Y]=yr[Y](e),Q.c()),$(Q,1),Q.m(Ct.parentNode,Ct));let ps=J;J=Tr(e),J!==ps&&(ue(),k(bt[ps],1,1,()=>{bt[ps]=null}),ce(),X=bt[J],X||(X=bt[J]=Er[J](e),X.c()),$(X,1),X.m(qt.parentNode,qt));let Le=K;K=Ar(e),K!==Le&&(ue(),k(_t[Le],1,1,()=>{_t[Le]=null}),ce(),Z=_t[K],Z||(Z=_t[K]=xr[K](e),Z.c()),$(Z,1),Z.m(Wt.parentNode,Wt));let cs=ee;ee=Ir(e),ee!==cs&&(ue(),k(wt[cs],1,1,()=>{wt[cs]=null}),ce(),te=wt[ee],te||(te=wt[ee]=Pr[ee](e),te.c()),$(te,1),te.m(Jt.parentNode,Jt));let He=se;se=Mr(e),se!==He&&(ue(),k(kt[He],1,1,()=>{kt[He]=null}),ce(),ne=kt[se],ne||(ne=kt[se]=Sr[se](e),ne.c()),$(ne,1),ne.m(Kt.parentNode,Kt));let us=ae;ae=qr(e),ae!==us&&(ue(),k($t[us],1,1,()=>{$t[us]=null}),ce(),le=$t[ae],le||(le=$t[ae]=Cr[ae](e),le.c()),$(le,1),le.m(ts.parentNode,ts));let Ge=oe;oe=Nr(e),oe!==Ge&&(ue(),k(gt[Ge],1,1,()=>{gt[Ge]=null}),ce(),re=gt[oe],re||(re=gt[oe]=Fr[oe](e),re.c()),$(re,1),re.m(ss.parentNode,ss));let hs=ie;ie=Or(e),ie!==hs&&(ue(),k(vt[hs],1,1,()=>{vt[hs]=null}),ce(),pe=vt[ie],pe||(pe=vt[ie]=Dr[ie](e),pe.c()),$(pe,1),pe.m(ns.parentNode,ns));const vn={};l&2&&(vn.$$scope={dirty:l,ctx:e}),Oe.$set(vn)},i(e){$a||($(a.$$.fragment,e),$(S.$$.fragment,e),$(q),$(Ee.$$.fragment,e),$(B),$(Re.$$.fragment,e),$(Ye.$$.fragment,e),$(Xe.$$.fragment,e),$(et.$$.fragment,e),$(R),$(Q),$(tt.$$.fragment,e),$(X),$(st.$$.fragment,e),$(Z),$(nt.$$.fragment,e),$(te),$(ot.$$.fragment,e),$(ne),$(rt.$$.fragment,e),$(it.$$.fragment,e),$(le),$(re),$(pe),$(ct.$$.fragment,e),$(ut.$$.fragment,e),$(Oe.$$.fragment,e),$a=!0)},o(e){k(a.$$.fragment,e),k(S.$$.fragment,e),k(q),k(Ee.$$.fragment,e),k(B),k(Re.$$.fragment,e),k(Ye.$$.fragment,e),k(Xe.$$.fragment,e),k(et.$$.fragment,e),k(R),k(Q),k(tt.$$.fragment,e),k(X),k(st.$$.fragment,e),k(Z),k(nt.$$.fragment,e),k(te),k(ot.$$.fragment,e),k(ne),k(rt.$$.fragment,e),k(it.$$.fragment,e),k(le),k(re),k(pe),k(ct.$$.fragment,e),k(ut.$$.fragment,e),k(Oe.$$.fragment,e),$a=!1},d(e){t(n),e&&t(h),A(a,e),e&&t(d),e&&t(_),A(S),e&&t(w),ht[g].d(e),e&&t(N),A(Ee,e),e&&t(yn),ft[W].d(e),e&&t(jt),e&&t(Te),e&&t(jn),A(Re,e),e&&t(En),e&&t(Tt),e&&t(Tn),A(Ye,e),e&&t(xn),e&&t(xe),e&&t(An),e&&t(we),e&&t(Pn),e&&t(At),e&&t(In),e&&t(ke),A(Xe),e&&t(Sn),e&&t(Pe),e&&t(Mn),e&&t(he),e&&t(Cn),e&&t(L),e&&t(qn),e&&t(H),e&&t(Fn),A(et,e),e&&t(Nn),e&&t(It),e&&t(Dn),e&&t(Ie),e&&t(On),e&&t(Se),e&&t(zn),mt[U].d(e),e&&t(St),e&&t(Mt),e&&t(Ln),dt[Y].d(e),e&&t(Ct),e&&t(O),e&&t(Hn),e&&t($e),A(tt),e&&t(Gn),bt[J].d(e),e&&t(qt),e&&t(Ft),e&&t(Vn),e&&t(G),e&&t(Wn),e&&t(Nt),e&&t(Bn),e&&t(fe),e&&t(Un),e&&t(ge),A(st),e&&t(Rn),e&&t(Ot),e&&t(Yn),e&&t(me),e&&t(Qn),e&&t(Gt),e&&t(Jn),e&&t(Vt),e&&t(Xn),_t[K].d(e),e&&t(Wt),e&&t(V),e&&t(Kn),e&&t(ve),A(nt),e&&t(Zn),e&&t(Bt),e&&t(ea),e&&t(ye),e&&t(ta),e&&t(Ut),e&&t(sa),e&&t(Rt),e&&t(na),e&&t(Yt),e&&t(aa),e&&t(F),e&&t(la),wt[ee].d(e),e&&t(Jt),e&&t(Xt),e&&t(oa),A(ot,e),e&&t(ra),kt[se].d(e),e&&t(Kt),e&&t(Zt),e&&t(ia),e&&t(je),A(rt),e&&t(pa),e&&t(es),e&&t(ca),A(it,e),e&&t(ua),$t[ae].d(e),e&&t(ts),e&&t(z),e&&t(ha),gt[oe].d(e),e&&t(ss),vt[ie].d(e),e&&t(ns),e&&t(de),e&&t(fa),e&&t(Ne),e&&t(ma),A(ct,e),e&&t(da),A(ut,e),e&&t(ba),e&&t(as),e&&t(_a),e&&t(De),e&&t(wa),e&&t(ls),e&&t(ka),A(Oe,e)}}}const Wp={local:"behind-the-pipeline",sections:[{local:"preprocessing-with-a-tokenizer",title:"Preprocessing with a tokenizer"},{local:"going-through-the-model",sections:[{local:"a-highdimensional-vector",title:"A high-dimensional vector?"},{local:"model-heads-making-sense-out-of-numbers",title:"Model heads: Making sense out of numbers"}],title:"Going through the model"},{local:"postprocessing-the-output",title:"Postprocessing the output"}],title:"Behind the pipeline"};function Bp(v,n,h){let a="pt";return _p(()=>{const d=new URLSearchParams(window.location.search);h(0,a=d.get("fw")||"pt")}),[a]}class Zp extends fp{constructor(n){super();mp(this,n,Bp,Vp,dp,{})}}export{Zp as default,Wp as metadata};
