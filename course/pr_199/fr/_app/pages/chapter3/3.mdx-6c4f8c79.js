import{S as si,i as oi,s as ai,e as n,k as d,w as _,t as o,M as ni,c as r,d as s,m as c,x as E,a as l,h as a,b as v,F as t,g as u,y as q,q as $,o as b,B as g,v as ri}from"../../chunks/vendor-1e8b365d.js";import{T as ti}from"../../chunks/Tip-62b14c6e.js";import{Y as li}from"../../chunks/Youtube-c2a8cc39.js";import{I as jr}from"../../chunks/IconCopyLink-483c28ba.js";import{C as V}from"../../chunks/CodeBlock-e5764662.js";import{D as ii}from"../../chunks/DocNotebookDropdown-37d928d3.js";import{F as ui}from"../../chunks/FrameworkSwitchCourse-7f8f0f31.js";function di(ge){let p,S,f,M,T,C,G,A,L,j,W,R,Ce,ue;return{c(){p=n("p"),S=o("\u{1F4A1} Si vous voulez t\xE9l\xE9charger automatiquement votre mod\xE8le sur le "),f=n("em"),M=o("Hub"),T=o(" pendant l\u2019entra\xEEnement, passez "),C=n("code"),G=o("push_to_hub=True"),A=o(" dans le "),L=n("code"),j=o("TrainingArguments"),W=o(". Nous en apprendrons plus \xE0 ce sujet au "),R=n("a"),Ce=o("chapitre 4"),ue=o("."),this.h()},l(B){p=r(B,"P",{});var w=l(p);S=a(w,"\u{1F4A1} Si vous voulez t\xE9l\xE9charger automatiquement votre mod\xE8le sur le "),f=r(w,"EM",{});var te=l(f);M=a(te,"Hub"),te.forEach(s),T=a(w," pendant l\u2019entra\xEEnement, passez "),C=r(w,"CODE",{});var ke=l(C);G=a(ke,"push_to_hub=True"),ke.forEach(s),A=a(w," dans le "),L=r(w,"CODE",{});var h=l(L);j=a(h,"TrainingArguments"),h.forEach(s),W=a(w,". Nous en apprendrons plus \xE0 ce sujet au "),R=r(w,"A",{href:!0});var Re=l(R);Ce=a(Re,"chapitre 4"),Re.forEach(s),ue=a(w,"."),w.forEach(s),this.h()},h(){v(R,"href","/course/fr/chapter4/3")},m(B,w){u(B,p,w),t(p,S),t(p,f),t(f,M),t(p,T),t(p,C),t(C,G),t(p,A),t(p,L),t(L,j),t(p,W),t(p,R),t(R,Ce),t(p,ue)},d(B){B&&s(p)}}}function ci(ge){let p,S,f,M,T,C,G,A;return{c(){p=n("p"),S=o("\u270F\uFE0F "),f=n("strong"),M=o("Essayez !"),T=d(),C=n("em"),G=o("Finetunez"),A=o(" un mod\xE8le sur le jeu de donn\xE9es GLUE SST-2, en utilisant le traitement des donn\xE9es que vous avez fait dans la section 2.")},l(L){p=r(L,"P",{});var j=l(p);S=a(j,"\u270F\uFE0F "),f=r(j,"STRONG",{});var W=l(f);M=a(W,"Essayez !"),W.forEach(s),T=c(j),C=r(j,"EM",{});var R=l(C);G=a(R,"Finetunez"),R.forEach(s),A=a(j," un mod\xE8le sur le jeu de donn\xE9es GLUE SST-2, en utilisant le traitement des donn\xE9es que vous avez fait dans la section 2."),j.forEach(s)},m(L,j){u(L,p,j),t(p,S),t(p,f),t(f,M),t(p,T),t(p,C),t(C,G),t(p,A)},d(L){L&&s(p)}}}function pi(ge){let p,S,f,M,T,C,G,A,L,j,W,R,Ce,ue,B,w,te,ke,h,Re,et,co,po,tt,mo,fo,st,vo,ho,ot,_o,Eo,at,qo,$o,je,bo,go,$s,Be,Co,bs,ze,gs,re,de,nt,Te,ko,rt,jo,Cs,D,zo,lt,To,wo,it,Po,Do,ut,xo,Oo,dt,yo,Ao,ct,Lo,So,ks,we,js,ce,zs,se,Mo,Ve,Uo,No,pt,Fo,Io,Ts,Pe,ws,pe,Go,We,Ro,Bo,Ps,x,Vo,mt,Wo,Ho,ft,Yo,Jo,vt,Xo,Ko,ht,Qo,Zo,_t,ea,ta,Ds,De,xs,O,sa,Et,oa,aa,qt,na,ra,$t,la,ia,bt,ua,da,gt,ca,pa,Os,H,ma,Ct,fa,va,kt,ha,_a,jt,Ea,qa,ys,xe,As,me,$a,zt,ba,ga,Ls,fe,P,Ca,Tt,ka,ja,wt,za,Ta,Pt,wa,Pa,Dt,Da,xa,xt,Oa,ya,Ot,Aa,La,Sa,le,Ma,yt,Ua,Na,At,Fa,Ia,Ss,ie,ve,Lt,Oe,Ga,St,Ra,Ms,z,Ba,Mt,Va,Wa,Ut,Ha,Ya,Nt,Ja,Xa,Ft,Ka,Qa,It,Za,en,Gt,tn,sn,Us,ye,Ns,Ae,Fs,m,on,Rt,an,nn,Bt,rn,ln,Vt,un,dn,Wt,cn,pn,Ht,mn,fn,Yt,vn,hn,Jt,_n,En,Xt,qn,$n,Kt,bn,gn,Is,U,Cn,Qt,kn,jn,Zt,zn,Tn,He,wn,Pn,es,Dn,xn,Gs,Le,Rs,y,On,ts,yn,An,ss,Ln,Sn,os,Mn,Un,as,Nn,Fn,ns,In,Gn,Bs,Se,Vs,Me,Ws,Y,Rn,Ue,Bn,Vn,rs,Wn,Hn,ls,Yn,Jn,Hs,he,Xn,is,Kn,Qn,Ys,Ne,Js,oe,Zn,us,er,tr,ds,sr,or,Xs,Fe,Ks,J,ar,cs,nr,rr,ps,lr,ir,ms,ur,dr,Qs,Ie,Zs,Ye,cr,eo,ae,pr,fs,mr,fr,vs,vr,hr,to,X,_r,hs,Er,qr,_s,$r,br,Je,gr,Cr,so,_e,oo;return f=new ui({props:{fw:ge[0]}}),A=new jr({}),B=new ii({props:{classNames:"absolute z-10 right-0 top-0",options:[{label:"Google Colab",value:"https://colab.research.google.com/github/huggingface/notebooks/blob/master/course/chapter3/section3.ipynb"},{label:"Aws Studio",value:"https://studiolab.sagemaker.aws/import/github/huggingface/notebooks/blob/master/course/chapter3/section3.ipynb"}]}}),te=new li({props:{id:"nvBXf7s7vTI"}}),ze=new V({props:{code:`from datasets import load_dataset
from transformers import AutoTokenizer, DataCollatorWithPadding

raw_datasets = load_dataset("glue", "mrpc")
checkpoint = "bert-base-uncased"
tokenizer = AutoTokenizer.from_pretrained(checkpoint)


def tokenize_function(example):
    return tokenizer(example["sentence1"], example["sentence2"], truncation=True)


tokenized_datasets = raw_datasets.map(tokenize_function, batched=True)
data_collator = DataCollatorWithPadding(tokenizer=tokenizer)`,highlighted:`<span class="hljs-keyword">from</span> datasets <span class="hljs-keyword">import</span> load_dataset
<span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> AutoTokenizer, DataCollatorWithPadding

raw_datasets = load_dataset(<span class="hljs-string">&quot;glue&quot;</span>, <span class="hljs-string">&quot;mrpc&quot;</span>)
checkpoint = <span class="hljs-string">&quot;bert-base-uncased&quot;</span>
tokenizer = AutoTokenizer.from_pretrained(checkpoint)


<span class="hljs-keyword">def</span> <span class="hljs-title function_">tokenize_function</span>(<span class="hljs-params">example</span>):
    <span class="hljs-keyword">return</span> tokenizer(example[<span class="hljs-string">&quot;sentence1&quot;</span>], example[<span class="hljs-string">&quot;sentence2&quot;</span>], truncation=<span class="hljs-literal">True</span>)


tokenized_datasets = raw_datasets.<span class="hljs-built_in">map</span>(tokenize_function, batched=<span class="hljs-literal">True</span>)
data_collator = DataCollatorWithPadding(tokenizer=tokenizer)`}}),Te=new jr({}),we=new V({props:{code:`from transformers import TrainingArguments

training_args = TrainingArguments("test-trainer")`,highlighted:`<span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> TrainingArguments

training_args = TrainingArguments(<span class="hljs-string">&quot;test-trainer&quot;</span>)`}}),ce=new ti({props:{$$slots:{default:[di]},$$scope:{ctx:ge}}}),Pe=new V({props:{code:`from transformers import AutoModelForSequenceClassification

model = AutoModelForSequenceClassification.from_pretrained(checkpoint, num_labels=2)`,highlighted:`<span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> AutoModelForSequenceClassification

model = AutoModelForSequenceClassification.from_pretrained(checkpoint, num_labels=<span class="hljs-number">2</span>)`}}),De=new V({props:{code:`from transformers import Trainer

trainer = Trainer(
    model,
    training_args,
    train_dataset=tokenized_datasets["train"],
    eval_dataset=tokenized_datasets["validation"],
    data_collator=data_collator,
    tokenizer=tokenizer,
)`,highlighted:`<span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> Trainer

trainer = Trainer(
    model,
    training_args,
    train_dataset=tokenized_datasets[<span class="hljs-string">&quot;train&quot;</span>],
    eval_dataset=tokenized_datasets[<span class="hljs-string">&quot;validation&quot;</span>],
    data_collator=data_collator,
    tokenizer=tokenizer,
)`}}),xe=new V({props:{code:"trainer.train()",highlighted:"trainer.train()"}}),Oe=new jr({}),ye=new V({props:{code:`predictions = trainer.predict(tokenized_datasets["validation"])
print(predictions.predictions.shape, predictions.label_ids.shape)`,highlighted:`predictions = trainer.predict(tokenized_datasets[<span class="hljs-string">&quot;validation&quot;</span>])
<span class="hljs-built_in">print</span>(predictions.predictions.shape, predictions.label_ids.shape)`}}),Ae=new V({props:{code:"(408, 2) (408,)",highlighted:'(<span class="hljs-number">408</span>, <span class="hljs-number">2</span>) (<span class="hljs-number">408</span>,)'}}),Le=new V({props:{code:`import numpy as np

preds = np.argmax(predictions.predictions, axis=-1)`,highlighted:`<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np

preds = np.argmax(predictions.predictions, axis=-<span class="hljs-number">1</span>)`}}),Se=new V({props:{code:`from datasets import load_metric

metric = load_metric("glue", "mrpc")
metric.compute(predictions=preds, references=predictions.label_ids)`,highlighted:`<span class="hljs-keyword">from</span> datasets <span class="hljs-keyword">import</span> load_metric

metric = load_metric(<span class="hljs-string">&quot;glue&quot;</span>, <span class="hljs-string">&quot;mrpc&quot;</span>)
metric.compute(predictions=preds, references=predictions.label_ids)`}}),Me=new V({props:{code:"{'accuracy': 0.8578431372549019, 'f1': 0.8996539792387542}",highlighted:'{<span class="hljs-string">&#x27;accuracy&#x27;</span>: <span class="hljs-number">0.8578431372549019</span>, <span class="hljs-string">&#x27;f1&#x27;</span>: <span class="hljs-number">0.8996539792387542</span>}'}}),Ne=new V({props:{code:`def compute_metrics(eval_preds):
    metric = load_metric("glue", "mrpc")
    logits, labels = eval_preds
    predictions = np.argmax(logits, axis=-1)
    return metric.compute(predictions=predictions, references=labels)`,highlighted:`<span class="hljs-keyword">def</span> <span class="hljs-title function_">compute_metrics</span>(<span class="hljs-params">eval_preds</span>):
    metric = load_metric(<span class="hljs-string">&quot;glue&quot;</span>, <span class="hljs-string">&quot;mrpc&quot;</span>)
    logits, labels = eval_preds
    predictions = np.argmax(logits, axis=-<span class="hljs-number">1</span>)
    <span class="hljs-keyword">return</span> metric.compute(predictions=predictions, references=labels)`}}),Fe=new V({props:{code:`training_args = TrainingArguments("test-trainer", evaluation_strategy="epoch")
model = AutoModelForSequenceClassification.from_pretrained(checkpoint, num_labels=2)

trainer = Trainer(
    model,
    training_args,
    train_dataset=tokenized_datasets["train"],
    eval_dataset=tokenized_datasets["validation"],
    data_collator=data_collator,
    tokenizer=tokenizer,
    compute_metrics=compute_metrics,
)`,highlighted:`training_args = TrainingArguments(<span class="hljs-string">&quot;test-trainer&quot;</span>, evaluation_strategy=<span class="hljs-string">&quot;epoch&quot;</span>)
model = AutoModelForSequenceClassification.from_pretrained(checkpoint, num_labels=<span class="hljs-number">2</span>)

trainer = Trainer(
    model,
    training_args,
    train_dataset=tokenized_datasets[<span class="hljs-string">&quot;train&quot;</span>],
    eval_dataset=tokenized_datasets[<span class="hljs-string">&quot;validation&quot;</span>],
    data_collator=data_collator,
    tokenizer=tokenizer,
    compute_metrics=compute_metrics,
)`}}),Ie=new V({props:{code:"trainer.train()",highlighted:'trainer.trai<span class="hljs-meta">n</span>()'}}),_e=new ti({props:{$$slots:{default:[ci]},$$scope:{ctx:ge}}}),{c(){p=n("meta"),S=d(),_(f.$$.fragment),M=d(),T=n("h1"),C=n("a"),G=n("span"),_(A.$$.fragment),L=d(),j=n("span"),W=n("i"),R=o("Finetuner"),Ce=o(" un mod\xE8le avec l'API Trainer"),ue=d(),_(B.$$.fragment),w=d(),_(te.$$.fragment),ke=d(),h=n("p"),Re=o("La biblioth\xE8que \u{1F917} "),et=n("em"),co=o("Transformers"),po=o(" fournit une classe "),tt=n("code"),mo=o("Trainer"),fo=o(" pour vous aider \xE0 "),st=n("em"),vo=o("finetuner"),ho=o(" n\u2019importe lequel des mod\xE8les pr\xE9-entra\xEEn\xE9s qu\u2019elle met \xE0 disposition sur votre jeu de donn\xE9es. Une fois que vous avez fait tout le travail de pr\xE9traitement des donn\xE9es dans la derni\xE8re section, il ne vous reste que quelques \xE9tapes pour d\xE9finir le "),ot=n("code"),_o=o("Trainer"),Eo=o(". La partie la plus difficile sera probablement de pr\xE9parer l\u2019environnement pour ex\xE9cuter "),at=n("code"),qo=o("Trainer.train()"),$o=o(", car elle fonctionnera tr\xE8s lentement sur un CPU. Si vous n\u2019avez pas de GPU, vous pouvez avoir acc\xE8s \xE0 des GPUs ou TPUs gratuits sur "),je=n("a"),bo=o("Google Colab"),go=o("."),$s=d(),Be=n("p"),Co=o("Les exemples de code ci-dessous supposent que vous avez d\xE9j\xE0 ex\xE9cut\xE9 les exemples de la section pr\xE9c\xE9dente. Voici un bref r\xE9sum\xE9 de ce dont vous avez besoin :"),bs=d(),_(ze.$$.fragment),gs=d(),re=n("h3"),de=n("a"),nt=n("span"),_(Te.$$.fragment),ko=d(),rt=n("span"),jo=o("Entra\xEEnement"),Cs=d(),D=n("p"),zo=o("La premi\xE8re \xE9tape avant de pouvoir d\xE9finir notre "),lt=n("code"),To=o("Trainer"),wo=o(" est de d\xE9finir une classe "),it=n("code"),Po=o("TrainingArguments"),Do=o(" qui contiendra tous les hyperparam\xE8tres que le "),ut=n("code"),xo=o("Trainer"),Oo=o(" utilisera pour l\u2019entra\xEEnement et l\u2019\xE9valuation. Le seul argument que vous devez fournir est un r\xE9pertoire o\xF9 le mod\xE8le entra\xEEn\xE9 sera sauvegard\xE9, ainsi que les "),dt=n("em"),yo=o("checkpoints"),Ao=o(". Pour tout le reste, vous pouvez laisser les valeurs par d\xE9faut, qui devraient fonctionner assez bien pour un "),ct=n("em"),Lo=o("finetuning"),So=o(" de base."),ks=d(),_(we.$$.fragment),js=d(),_(ce.$$.fragment),zs=d(),se=n("p"),Mo=o("La deuxi\xE8me \xE9tape consiste \xE0 d\xE9finir notre mod\xE8le. Comme dans le "),Ve=n("a"),Uo=o("chapitre pr\xE9c\xE9dent"),No=o(", nous utiliserons la classe "),pt=n("code"),Fo=o("AutoModelForSequenceClassification"),Io=o(", avec deux labels :"),Ts=d(),_(Pe.$$.fragment),ws=d(),pe=n("p"),Go=o("Vous remarquerez que contrairement au "),We=n("a"),Ro=o("chapitre 2"),Bo=o(", vous obtenez un message d\u2019avertissement apr\xE8s l\u2019instanciation de ce mod\xE8le pr\xE9-entra\xEEn\xE9. C\u2019est parce que BERT n\u2019a pas \xE9t\xE9 pr\xE9-entra\xEEn\xE9 \xE0 la classification de paires de phrases, donc la t\xEAte du mod\xE8le pr\xE9-entra\xEEn\xE9 a \xE9t\xE9 supprim\xE9e et une nouvelle t\xEAte adapt\xE9e \xE0 la classification de s\xE9quences a \xE9t\xE9 ajout\xE9e \xE0 la place. Les messages d\u2019avertissement indiquent que certains poids n\u2019ont pas \xE9t\xE9 utilis\xE9s (ceux correspondant \xE0 la t\xEAte de pr\xE9-entra\xEEnement abandonn\xE9e) et que d\u2019autres ont \xE9t\xE9 initialis\xE9s de mani\xE8re al\xE9atoire (ceux pour la nouvelle t\xEAte). Il conclut en vous encourageant \xE0 entra\xEEner le mod\xE8le, ce qui est exactement ce que nous allons faire maintenant."),Ps=d(),x=n("p"),Vo=o("Une fois que nous avons notre mod\xE8le, nous pouvons d\xE9finir un "),mt=n("code"),Wo=o("Trainer"),Ho=o(" en lui passant tous les objets construits jusqu\u2019\xE0 pr\xE9sent : le "),ft=n("code"),Yo=o("model"),Jo=o(", le "),vt=n("code"),Xo=o("training_args"),Ko=o(", les jeux de donn\xE9es d\u2019entra\xEEnement et de validation, notre "),ht=n("code"),Qo=o("data_collator"),Zo=o(", et notre "),_t=n("code"),ea=o("tokenizer"),ta=o(" :"),Ds=d(),_(De.$$.fragment),xs=d(),O=n("p"),sa=o("Notez que lorsque vous passez le "),Et=n("code"),oa=o("tokenizer"),aa=o(" comme nous l\u2019avons fait ici, le "),qt=n("code"),na=o("data_collator"),ra=o(" par d\xE9faut utilis\xE9 par le "),$t=n("code"),la=o("Trainer"),ia=o(" sera un "),bt=n("code"),ua=o("DataCollatorWithPadding"),da=o(" comme d\xE9fini pr\xE9c\xE9demment. Ainsi, vous pouvez sauter la ligne "),gt=n("code"),ca=o("data_collator=data_collator"),pa=o(" dans cet appel. Il \xE9tait quand m\xEAme important de vous montrer cette partie du traitement dans la section 2 !"),Os=d(),H=n("p"),ma=o("Pour "),Ct=n("em"),fa=o("finetuner"),va=o(" le mod\xE8le sur notre jeu de donn\xE9es, il suffit d\u2019appeler la m\xE9thode "),kt=n("code"),ha=o("train()"),_a=o(" de notre "),jt=n("code"),Ea=o("Trainer"),qa=o(" :"),ys=d(),_(xe.$$.fragment),As=d(),me=n("p"),$a=o("Cela lancera le "),zt=n("em"),ba=o("finetuning"),ga=o(" (qui devrait prendre quelques minutes sur un GPU) et indiquera la perte d\u2019entra\xEEnement tous les 500 pas. Cependant, elle ne vous dira pas si votre mod\xE8le fonctionne bien (ou mal). Ceci est d\xFB au fait que :"),Ls=d(),fe=n("ol"),P=n("li"),Ca=o("nous n\u2019avons pas dit au "),Tt=n("code"),ka=o("Trainer"),ja=o(" d\u2019\xE9valuer pendant l\u2019entra\xEEnement en r\xE9glant "),wt=n("code"),za=o("evaluation_strategy"),Ta=o(" \xE0 soit "),Pt=n("code"),wa=o('"steps"'),Pa=o(" (\xE9valuer chaque "),Dt=n("code"),Da=o("eval_steps"),xa=o(") ou "),xt=n("code"),Oa=o('"epoch"'),ya=o(" (\xE9valuer \xE0 la fin de chaque "),Ot=n("em"),Aa=o("epoch"),La=o(")."),Sa=d(),le=n("li"),Ma=o("nous n\u2019avons pas fourni au "),yt=n("code"),Ua=o("Trainer"),Na=o(" une fonction "),At=n("code"),Fa=o("compute_metrics()"),Ia=o(" pour calculer une m\xE9trique pendant ladite \xE9valuation (sinon l\u2019\xE9valuation aurait juste affich\xE9 la perte, qui n\u2019est pas un nombre tr\xE8s intuitif)."),Ss=d(),ie=n("h3"),ve=n("a"),Lt=n("span"),_(Oe.$$.fragment),Ga=d(),St=n("span"),Ra=o("Evaluation"),Ms=d(),z=n("p"),Ba=o("Voyons comment nous pouvons construire une fonction "),Mt=n("code"),Va=o("compute_metrics()"),Wa=o(" utile et l\u2019utiliser la prochaine fois que nous entra\xEEnons. La fonction doit prendre un objet "),Ut=n("code"),Ha=o("EvalPrediction"),Ya=o(" (qui est un "),Nt=n("em"),Ja=o("tuple"),Xa=o(" nomm\xE9 avec un champ "),Ft=n("code"),Ka=o("predictions"),Qa=o(" et un champ "),It=n("code"),Za=o("label_ids"),en=o(") et retournera un dictionnaire de cha\xEEnes de caract\xE8res vers des flottants (les cha\xEEnes de caract\xE8res \xE9tant les noms des m\xE9triques retourn\xE9es, et les flottants leurs valeurs). Pour obtenir des pr\xE9dictions de notre mod\xE8le, nous pouvons utiliser la commande "),Gt=n("code"),tn=o("Trainer.predict()"),sn=o(" :"),Us=d(),_(ye.$$.fragment),Ns=d(),_(Ae.$$.fragment),Fs=d(),m=n("p"),on=o("La sortie de la m\xE9thode "),Rt=n("code"),an=o("predict()"),nn=o(" est un autre "),Bt=n("em"),rn=o("tuple"),ln=o(" nomm\xE9 avec trois champs : "),Vt=n("code"),un=o("predictions"),dn=o(", "),Wt=n("code"),cn=o("label_ids"),pn=o(", et "),Ht=n("code"),mn=o("metrics"),fn=o(". Le champ "),Yt=n("code"),vn=o("metrics"),hn=o(" contiendra juste la perte sur le jeu de donn\xE9es pass\xE9, ainsi que quelques mesures de temps (combien de temps il a fallu pour pr\xE9dire, au total et en moyenne). Une fois que nous aurons compl\xE9t\xE9 notre fonction "),Jt=n("code"),_n=o("compute_metrics()"),En=o(" et que nous l\u2019aurons pass\xE9 au "),Xt=n("code"),qn=o("Trainer"),$n=o(", ce champ contiendra \xE9galement les m\xE9triques retourn\xE9es par "),Kt=n("code"),bn=o("compute_metrics()"),gn=o("."),Is=d(),U=n("p"),Cn=o("Comme vous pouvez le voir, "),Qt=n("code"),kn=o("predictions"),jn=o(" est un tableau bidimensionnel de forme 408 x 2 (408 \xE9tant le nombre d\u2019\xE9l\xE9ments dans le jeu de donn\xE9es que nous avons utilis\xE9). Ce sont les logits pour chaque \xE9l\xE9ment du jeu de donn\xE9es que nous avons pass\xE9 \xE0 "),Zt=n("code"),zn=o("predict()"),Tn=o(" (comme vous l\u2019avez vu dans le "),He=n("a"),wn=o("chapitre pr\xE9c\xE9dent"),Pn=o(", tous les "),es=n("em"),Dn=o("transformers"),xn=o(" retournent des logits). Pour les transformer en pr\xE9dictions que nous pouvons comparer \xE0 nos \xE9tiquettes, nous devons prendre l\u2019indice avec la valeur maximale sur le second axe :"),Gs=d(),_(Le.$$.fragment),Rs=d(),y=n("p"),On=o("Nous pouvons maintenant comparer ces "),ts=n("code"),yn=o("preds"),An=o(" aux \xE9tiquettes. Pour construire notre fonction "),ss=n("code"),Ln=o("compute_metric()"),Sn=o(", nous allons nous appuyer sur les m\xE9triques de la biblioth\xE8que \u{1F917} "),os=n("em"),Mn=o("Datasets"),Un=o(". Nous pouvons charger les m\xE9triques associ\xE9es au jeu de donn\xE9es MRPC aussi facilement que nous avons charg\xE9 le jeu de donn\xE9es, cette fois avec la fonction "),as=n("code"),Nn=o("load_metric()"),Fn=o(". L\u2019objet retourn\xE9 poss\xE8de une m\xE9thode "),ns=n("code"),In=o("compute()"),Gn=o(" que nous pouvons utiliser pour effectuer le calcul de la m\xE9trique :"),Bs=d(),_(Se.$$.fragment),Vs=d(),_(Me.$$.fragment),Ws=d(),Y=n("p"),Rn=o("Les r\xE9sultats exacts que vous obtiendrez peuvent varier, car l\u2019initialisation al\xE9atoire de la t\xEAte du mod\xE8le peut modifier les m\xE9triques obtenues. Ici, nous pouvons voir que notre mod\xE8le a une pr\xE9cision de 85,78% sur l\u2019ensemble de validation et un score F1 de 89,97. Ce sont les deux m\xE9triques utilis\xE9es pour \xE9valuer les r\xE9sultats sur le jeu de donn\xE9es MRPC pour le benchmark GLUE. Le tableau du papier de "),Ue=n("a"),Bn=o("BERT"),Vn=o(" indique un score F1 de 88,9 pour le mod\xE8le de base. Il s\u2019agissait du mod\xE8le "),rs=n("code"),Wn=o("uncased"),Hn=o(" alors que nous utilisons actuellement le mod\xE8le "),ls=n("code"),Yn=o("cased"),Jn=o(", ce qui explique le meilleur r\xE9sultat."),Hs=d(),he=n("p"),Xn=o("En regroupant le tout, nous obtenons notre fonction "),is=n("code"),Kn=o("compute_metrics()"),Qn=o(" :"),Ys=d(),_(Ne.$$.fragment),Js=d(),oe=n("p"),Zn=o("Et pour le voir utilis\xE9 en action pour rapporter les m\xE9triques \xE0 la fin de chaque \xE9poque, voici comment nous d\xE9finissons un nouveau "),us=n("code"),er=o("Trainer"),tr=o(" avec cette fonction "),ds=n("code"),sr=o("compute_metrics()"),or=o(" :"),Xs=d(),_(Fe.$$.fragment),Ks=d(),J=n("p"),ar=o("Notez que nous cr\xE9ons un nouveau "),cs=n("code"),nr=o("TrainingArguments"),rr=o(" avec sa "),ps=n("code"),lr=o("evaluation_strategy"),ir=o(" d\xE9finie sur "),ms=n("code"),ur=o('"epoch"'),dr=o(" et un nouveau mod\xE8le. Sinon, nous ne ferions que continuer l\u2019entra\xEEnement du mod\xE8le que nous avons d\xE9j\xE0 entra\xEEn\xE9. Pour lancer un nouveau cycle d\u2019entra\xEEnement, nous ex\xE9cutons :"),Qs=d(),_(Ie.$$.fragment),Zs=d(),Ye=n("p"),cr=o("Cette fois, il indiquera la perte et les mesures de validation \xE0 la fin de chaque \xE9poque, en plus de la perte d\u2019entra\xEEnement. Encore une fois, le score exact de pr\xE9cision/F1 que vous atteignez peut \xEAtre un peu diff\xE9rent de ce que nous avons trouv\xE9, en raison de l\u2019initialisation al\xE9atoire de la t\xEAte du mod\xE8le, mais il devrait \xEAtre dans la m\xEAme fourchette."),eo=d(),ae=n("p"),pr=o("Le "),fs=n("code"),mr=o("Trainer"),fr=o(" fonctionnera sur plusieurs GPUs ou TPUs et fournit beaucoup d\u2019options, comme l\u2019entra\xEEnement en pr\xE9cision mixte (utilisez "),vs=n("code"),vr=o("fp16 = True"),hr=o(" dans vos arguments d\u2019entra\xEEnement). Nous passerons en revue tout ce qu\u2019il supporte dans le chapitre 10."),to=d(),X=n("p"),_r=o("Ceci conclut l\u2019introduction au "),hs=n("em"),Er=o("fine-tuning"),qr=o(" en utilisant l\u2019API "),_s=n("code"),$r=o("Trainer"),br=o(". Un exemple d\u2019utilisation pour les t\xE2ches de NLP les plus communes es donn\xE9 dans le "),Je=n("a"),gr=o("chapitre 7"),Cr=o(", mais pour l\u2019instant regardons comment faire la m\xEAme chose en PyTorch pur."),so=d(),_(_e.$$.fragment),this.h()},l(e){const i=ni('[data-svelte="svelte-1phssyn"]',document.head);p=r(i,"META",{name:!0,content:!0}),i.forEach(s),S=c(e),E(f.$$.fragment,e),M=c(e),T=r(e,"H1",{class:!0});var Ge=l(T);C=r(Ge,"A",{id:!0,class:!0,href:!0});var Es=l(C);G=r(Es,"SPAN",{});var qs=l(G);E(A.$$.fragment,qs),qs.forEach(s),Es.forEach(s),L=c(Ge),j=r(Ge,"SPAN",{});var kr=l(j);W=r(kr,"I",{});var zr=l(W);R=a(zr,"Finetuner"),zr.forEach(s),Ce=a(kr," un mod\xE8le avec l'API Trainer"),kr.forEach(s),Ge.forEach(s),ue=c(e),E(B.$$.fragment,e),w=c(e),E(te.$$.fragment,e),ke=c(e),h=r(e,"P",{});var N=l(h);Re=a(N,"La biblioth\xE8que \u{1F917} "),et=r(N,"EM",{});var Tr=l(et);co=a(Tr,"Transformers"),Tr.forEach(s),po=a(N," fournit une classe "),tt=r(N,"CODE",{});var wr=l(tt);mo=a(wr,"Trainer"),wr.forEach(s),fo=a(N," pour vous aider \xE0 "),st=r(N,"EM",{});var Pr=l(st);vo=a(Pr,"finetuner"),Pr.forEach(s),ho=a(N," n\u2019importe lequel des mod\xE8les pr\xE9-entra\xEEn\xE9s qu\u2019elle met \xE0 disposition sur votre jeu de donn\xE9es. Une fois que vous avez fait tout le travail de pr\xE9traitement des donn\xE9es dans la derni\xE8re section, il ne vous reste que quelques \xE9tapes pour d\xE9finir le "),ot=r(N,"CODE",{});var Dr=l(ot);_o=a(Dr,"Trainer"),Dr.forEach(s),Eo=a(N,". La partie la plus difficile sera probablement de pr\xE9parer l\u2019environnement pour ex\xE9cuter "),at=r(N,"CODE",{});var xr=l(at);qo=a(xr,"Trainer.train()"),xr.forEach(s),$o=a(N,", car elle fonctionnera tr\xE8s lentement sur un CPU. Si vous n\u2019avez pas de GPU, vous pouvez avoir acc\xE8s \xE0 des GPUs ou TPUs gratuits sur "),je=r(N,"A",{href:!0,rel:!0});var Or=l(je);bo=a(Or,"Google Colab"),Or.forEach(s),go=a(N,"."),N.forEach(s),$s=c(e),Be=r(e,"P",{});var yr=l(Be);Co=a(yr,"Les exemples de code ci-dessous supposent que vous avez d\xE9j\xE0 ex\xE9cut\xE9 les exemples de la section pr\xE9c\xE9dente. Voici un bref r\xE9sum\xE9 de ce dont vous avez besoin :"),yr.forEach(s),bs=c(e),E(ze.$$.fragment,e),gs=c(e),re=r(e,"H3",{class:!0});var ao=l(re);de=r(ao,"A",{id:!0,class:!0,href:!0});var Ar=l(de);nt=r(Ar,"SPAN",{});var Lr=l(nt);E(Te.$$.fragment,Lr),Lr.forEach(s),Ar.forEach(s),ko=c(ao),rt=r(ao,"SPAN",{});var Sr=l(rt);jo=a(Sr,"Entra\xEEnement"),Sr.forEach(s),ao.forEach(s),Cs=c(e),D=r(e,"P",{});var K=l(D);zo=a(K,"La premi\xE8re \xE9tape avant de pouvoir d\xE9finir notre "),lt=r(K,"CODE",{});var Mr=l(lt);To=a(Mr,"Trainer"),Mr.forEach(s),wo=a(K," est de d\xE9finir une classe "),it=r(K,"CODE",{});var Ur=l(it);Po=a(Ur,"TrainingArguments"),Ur.forEach(s),Do=a(K," qui contiendra tous les hyperparam\xE8tres que le "),ut=r(K,"CODE",{});var Nr=l(ut);xo=a(Nr,"Trainer"),Nr.forEach(s),Oo=a(K," utilisera pour l\u2019entra\xEEnement et l\u2019\xE9valuation. Le seul argument que vous devez fournir est un r\xE9pertoire o\xF9 le mod\xE8le entra\xEEn\xE9 sera sauvegard\xE9, ainsi que les "),dt=r(K,"EM",{});var Fr=l(dt);yo=a(Fr,"checkpoints"),Fr.forEach(s),Ao=a(K,". Pour tout le reste, vous pouvez laisser les valeurs par d\xE9faut, qui devraient fonctionner assez bien pour un "),ct=r(K,"EM",{});var Ir=l(ct);Lo=a(Ir,"finetuning"),Ir.forEach(s),So=a(K," de base."),K.forEach(s),ks=c(e),E(we.$$.fragment,e),js=c(e),E(ce.$$.fragment,e),zs=c(e),se=r(e,"P",{});var Xe=l(se);Mo=a(Xe,"La deuxi\xE8me \xE9tape consiste \xE0 d\xE9finir notre mod\xE8le. Comme dans le "),Ve=r(Xe,"A",{href:!0});var Gr=l(Ve);Uo=a(Gr,"chapitre pr\xE9c\xE9dent"),Gr.forEach(s),No=a(Xe,", nous utiliserons la classe "),pt=r(Xe,"CODE",{});var Rr=l(pt);Fo=a(Rr,"AutoModelForSequenceClassification"),Rr.forEach(s),Io=a(Xe,", avec deux labels :"),Xe.forEach(s),Ts=c(e),E(Pe.$$.fragment,e),ws=c(e),pe=r(e,"P",{});var no=l(pe);Go=a(no,"Vous remarquerez que contrairement au "),We=r(no,"A",{href:!0});var Br=l(We);Ro=a(Br,"chapitre 2"),Br.forEach(s),Bo=a(no,", vous obtenez un message d\u2019avertissement apr\xE8s l\u2019instanciation de ce mod\xE8le pr\xE9-entra\xEEn\xE9. C\u2019est parce que BERT n\u2019a pas \xE9t\xE9 pr\xE9-entra\xEEn\xE9 \xE0 la classification de paires de phrases, donc la t\xEAte du mod\xE8le pr\xE9-entra\xEEn\xE9 a \xE9t\xE9 supprim\xE9e et une nouvelle t\xEAte adapt\xE9e \xE0 la classification de s\xE9quences a \xE9t\xE9 ajout\xE9e \xE0 la place. Les messages d\u2019avertissement indiquent que certains poids n\u2019ont pas \xE9t\xE9 utilis\xE9s (ceux correspondant \xE0 la t\xEAte de pr\xE9-entra\xEEnement abandonn\xE9e) et que d\u2019autres ont \xE9t\xE9 initialis\xE9s de mani\xE8re al\xE9atoire (ceux pour la nouvelle t\xEAte). Il conclut en vous encourageant \xE0 entra\xEEner le mod\xE8le, ce qui est exactement ce que nous allons faire maintenant."),no.forEach(s),Ps=c(e),x=r(e,"P",{});var Q=l(x);Vo=a(Q,"Une fois que nous avons notre mod\xE8le, nous pouvons d\xE9finir un "),mt=r(Q,"CODE",{});var Vr=l(mt);Wo=a(Vr,"Trainer"),Vr.forEach(s),Ho=a(Q," en lui passant tous les objets construits jusqu\u2019\xE0 pr\xE9sent : le "),ft=r(Q,"CODE",{});var Wr=l(ft);Yo=a(Wr,"model"),Wr.forEach(s),Jo=a(Q,", le "),vt=r(Q,"CODE",{});var Hr=l(vt);Xo=a(Hr,"training_args"),Hr.forEach(s),Ko=a(Q,", les jeux de donn\xE9es d\u2019entra\xEEnement et de validation, notre "),ht=r(Q,"CODE",{});var Yr=l(ht);Qo=a(Yr,"data_collator"),Yr.forEach(s),Zo=a(Q,", et notre "),_t=r(Q,"CODE",{});var Jr=l(_t);ea=a(Jr,"tokenizer"),Jr.forEach(s),ta=a(Q," :"),Q.forEach(s),Ds=c(e),E(De.$$.fragment,e),xs=c(e),O=r(e,"P",{});var Z=l(O);sa=a(Z,"Notez que lorsque vous passez le "),Et=r(Z,"CODE",{});var Xr=l(Et);oa=a(Xr,"tokenizer"),Xr.forEach(s),aa=a(Z," comme nous l\u2019avons fait ici, le "),qt=r(Z,"CODE",{});var Kr=l(qt);na=a(Kr,"data_collator"),Kr.forEach(s),ra=a(Z," par d\xE9faut utilis\xE9 par le "),$t=r(Z,"CODE",{});var Qr=l($t);la=a(Qr,"Trainer"),Qr.forEach(s),ia=a(Z," sera un "),bt=r(Z,"CODE",{});var Zr=l(bt);ua=a(Zr,"DataCollatorWithPadding"),Zr.forEach(s),da=a(Z," comme d\xE9fini pr\xE9c\xE9demment. Ainsi, vous pouvez sauter la ligne "),gt=r(Z,"CODE",{});var el=l(gt);ca=a(el,"data_collator=data_collator"),el.forEach(s),pa=a(Z," dans cet appel. Il \xE9tait quand m\xEAme important de vous montrer cette partie du traitement dans la section 2 !"),Z.forEach(s),Os=c(e),H=r(e,"P",{});var Ee=l(H);ma=a(Ee,"Pour "),Ct=r(Ee,"EM",{});var tl=l(Ct);fa=a(tl,"finetuner"),tl.forEach(s),va=a(Ee," le mod\xE8le sur notre jeu de donn\xE9es, il suffit d\u2019appeler la m\xE9thode "),kt=r(Ee,"CODE",{});var sl=l(kt);ha=a(sl,"train()"),sl.forEach(s),_a=a(Ee," de notre "),jt=r(Ee,"CODE",{});var ol=l(jt);Ea=a(ol,"Trainer"),ol.forEach(s),qa=a(Ee," :"),Ee.forEach(s),ys=c(e),E(xe.$$.fragment,e),As=c(e),me=r(e,"P",{});var ro=l(me);$a=a(ro,"Cela lancera le "),zt=r(ro,"EM",{});var al=l(zt);ba=a(al,"finetuning"),al.forEach(s),ga=a(ro," (qui devrait prendre quelques minutes sur un GPU) et indiquera la perte d\u2019entra\xEEnement tous les 500 pas. Cependant, elle ne vous dira pas si votre mod\xE8le fonctionne bien (ou mal). Ceci est d\xFB au fait que :"),ro.forEach(s),Ls=c(e),fe=r(e,"OL",{});var lo=l(fe);P=r(lo,"LI",{});var F=l(P);Ca=a(F,"nous n\u2019avons pas dit au "),Tt=r(F,"CODE",{});var nl=l(Tt);ka=a(nl,"Trainer"),nl.forEach(s),ja=a(F," d\u2019\xE9valuer pendant l\u2019entra\xEEnement en r\xE9glant "),wt=r(F,"CODE",{});var rl=l(wt);za=a(rl,"evaluation_strategy"),rl.forEach(s),Ta=a(F," \xE0 soit "),Pt=r(F,"CODE",{});var ll=l(Pt);wa=a(ll,'"steps"'),ll.forEach(s),Pa=a(F," (\xE9valuer chaque "),Dt=r(F,"CODE",{});var il=l(Dt);Da=a(il,"eval_steps"),il.forEach(s),xa=a(F,") ou "),xt=r(F,"CODE",{});var ul=l(xt);Oa=a(ul,'"epoch"'),ul.forEach(s),ya=a(F," (\xE9valuer \xE0 la fin de chaque "),Ot=r(F,"EM",{});var dl=l(Ot);Aa=a(dl,"epoch"),dl.forEach(s),La=a(F,")."),F.forEach(s),Sa=c(lo),le=r(lo,"LI",{});var Ke=l(le);Ma=a(Ke,"nous n\u2019avons pas fourni au "),yt=r(Ke,"CODE",{});var cl=l(yt);Ua=a(cl,"Trainer"),cl.forEach(s),Na=a(Ke," une fonction "),At=r(Ke,"CODE",{});var pl=l(At);Fa=a(pl,"compute_metrics()"),pl.forEach(s),Ia=a(Ke," pour calculer une m\xE9trique pendant ladite \xE9valuation (sinon l\u2019\xE9valuation aurait juste affich\xE9 la perte, qui n\u2019est pas un nombre tr\xE8s intuitif)."),Ke.forEach(s),lo.forEach(s),Ss=c(e),ie=r(e,"H3",{class:!0});var io=l(ie);ve=r(io,"A",{id:!0,class:!0,href:!0});var ml=l(ve);Lt=r(ml,"SPAN",{});var fl=l(Lt);E(Oe.$$.fragment,fl),fl.forEach(s),ml.forEach(s),Ga=c(io),St=r(io,"SPAN",{});var vl=l(St);Ra=a(vl,"Evaluation"),vl.forEach(s),io.forEach(s),Ms=c(e),z=r(e,"P",{});var I=l(z);Ba=a(I,"Voyons comment nous pouvons construire une fonction "),Mt=r(I,"CODE",{});var hl=l(Mt);Va=a(hl,"compute_metrics()"),hl.forEach(s),Wa=a(I," utile et l\u2019utiliser la prochaine fois que nous entra\xEEnons. La fonction doit prendre un objet "),Ut=r(I,"CODE",{});var _l=l(Ut);Ha=a(_l,"EvalPrediction"),_l.forEach(s),Ya=a(I," (qui est un "),Nt=r(I,"EM",{});var El=l(Nt);Ja=a(El,"tuple"),El.forEach(s),Xa=a(I," nomm\xE9 avec un champ "),Ft=r(I,"CODE",{});var ql=l(Ft);Ka=a(ql,"predictions"),ql.forEach(s),Qa=a(I," et un champ "),It=r(I,"CODE",{});var $l=l(It);Za=a($l,"label_ids"),$l.forEach(s),en=a(I,") et retournera un dictionnaire de cha\xEEnes de caract\xE8res vers des flottants (les cha\xEEnes de caract\xE8res \xE9tant les noms des m\xE9triques retourn\xE9es, et les flottants leurs valeurs). Pour obtenir des pr\xE9dictions de notre mod\xE8le, nous pouvons utiliser la commande "),Gt=r(I,"CODE",{});var bl=l(Gt);tn=a(bl,"Trainer.predict()"),bl.forEach(s),sn=a(I," :"),I.forEach(s),Us=c(e),E(ye.$$.fragment,e),Ns=c(e),E(Ae.$$.fragment,e),Fs=c(e),m=r(e,"P",{});var k=l(m);on=a(k,"La sortie de la m\xE9thode "),Rt=r(k,"CODE",{});var gl=l(Rt);an=a(gl,"predict()"),gl.forEach(s),nn=a(k," est un autre "),Bt=r(k,"EM",{});var Cl=l(Bt);rn=a(Cl,"tuple"),Cl.forEach(s),ln=a(k," nomm\xE9 avec trois champs : "),Vt=r(k,"CODE",{});var kl=l(Vt);un=a(kl,"predictions"),kl.forEach(s),dn=a(k,", "),Wt=r(k,"CODE",{});var jl=l(Wt);cn=a(jl,"label_ids"),jl.forEach(s),pn=a(k,", et "),Ht=r(k,"CODE",{});var zl=l(Ht);mn=a(zl,"metrics"),zl.forEach(s),fn=a(k,". Le champ "),Yt=r(k,"CODE",{});var Tl=l(Yt);vn=a(Tl,"metrics"),Tl.forEach(s),hn=a(k," contiendra juste la perte sur le jeu de donn\xE9es pass\xE9, ainsi que quelques mesures de temps (combien de temps il a fallu pour pr\xE9dire, au total et en moyenne). Une fois que nous aurons compl\xE9t\xE9 notre fonction "),Jt=r(k,"CODE",{});var wl=l(Jt);_n=a(wl,"compute_metrics()"),wl.forEach(s),En=a(k," et que nous l\u2019aurons pass\xE9 au "),Xt=r(k,"CODE",{});var Pl=l(Xt);qn=a(Pl,"Trainer"),Pl.forEach(s),$n=a(k,", ce champ contiendra \xE9galement les m\xE9triques retourn\xE9es par "),Kt=r(k,"CODE",{});var Dl=l(Kt);bn=a(Dl,"compute_metrics()"),Dl.forEach(s),gn=a(k,"."),k.forEach(s),Is=c(e),U=r(e,"P",{});var ne=l(U);Cn=a(ne,"Comme vous pouvez le voir, "),Qt=r(ne,"CODE",{});var xl=l(Qt);kn=a(xl,"predictions"),xl.forEach(s),jn=a(ne," est un tableau bidimensionnel de forme 408 x 2 (408 \xE9tant le nombre d\u2019\xE9l\xE9ments dans le jeu de donn\xE9es que nous avons utilis\xE9). Ce sont les logits pour chaque \xE9l\xE9ment du jeu de donn\xE9es que nous avons pass\xE9 \xE0 "),Zt=r(ne,"CODE",{});var Ol=l(Zt);zn=a(Ol,"predict()"),Ol.forEach(s),Tn=a(ne," (comme vous l\u2019avez vu dans le "),He=r(ne,"A",{href:!0});var yl=l(He);wn=a(yl,"chapitre pr\xE9c\xE9dent"),yl.forEach(s),Pn=a(ne,", tous les "),es=r(ne,"EM",{});var Al=l(es);Dn=a(Al,"transformers"),Al.forEach(s),xn=a(ne," retournent des logits). Pour les transformer en pr\xE9dictions que nous pouvons comparer \xE0 nos \xE9tiquettes, nous devons prendre l\u2019indice avec la valeur maximale sur le second axe :"),ne.forEach(s),Gs=c(e),E(Le.$$.fragment,e),Rs=c(e),y=r(e,"P",{});var ee=l(y);On=a(ee,"Nous pouvons maintenant comparer ces "),ts=r(ee,"CODE",{});var Ll=l(ts);yn=a(Ll,"preds"),Ll.forEach(s),An=a(ee," aux \xE9tiquettes. Pour construire notre fonction "),ss=r(ee,"CODE",{});var Sl=l(ss);Ln=a(Sl,"compute_metric()"),Sl.forEach(s),Sn=a(ee,", nous allons nous appuyer sur les m\xE9triques de la biblioth\xE8que \u{1F917} "),os=r(ee,"EM",{});var Ml=l(os);Mn=a(Ml,"Datasets"),Ml.forEach(s),Un=a(ee,". Nous pouvons charger les m\xE9triques associ\xE9es au jeu de donn\xE9es MRPC aussi facilement que nous avons charg\xE9 le jeu de donn\xE9es, cette fois avec la fonction "),as=r(ee,"CODE",{});var Ul=l(as);Nn=a(Ul,"load_metric()"),Ul.forEach(s),Fn=a(ee,". L\u2019objet retourn\xE9 poss\xE8de une m\xE9thode "),ns=r(ee,"CODE",{});var Nl=l(ns);In=a(Nl,"compute()"),Nl.forEach(s),Gn=a(ee," que nous pouvons utiliser pour effectuer le calcul de la m\xE9trique :"),ee.forEach(s),Bs=c(e),E(Se.$$.fragment,e),Vs=c(e),E(Me.$$.fragment,e),Ws=c(e),Y=r(e,"P",{});var qe=l(Y);Rn=a(qe,"Les r\xE9sultats exacts que vous obtiendrez peuvent varier, car l\u2019initialisation al\xE9atoire de la t\xEAte du mod\xE8le peut modifier les m\xE9triques obtenues. Ici, nous pouvons voir que notre mod\xE8le a une pr\xE9cision de 85,78% sur l\u2019ensemble de validation et un score F1 de 89,97. Ce sont les deux m\xE9triques utilis\xE9es pour \xE9valuer les r\xE9sultats sur le jeu de donn\xE9es MRPC pour le benchmark GLUE. Le tableau du papier de "),Ue=r(qe,"A",{href:!0,rel:!0});var Fl=l(Ue);Bn=a(Fl,"BERT"),Fl.forEach(s),Vn=a(qe," indique un score F1 de 88,9 pour le mod\xE8le de base. Il s\u2019agissait du mod\xE8le "),rs=r(qe,"CODE",{});var Il=l(rs);Wn=a(Il,"uncased"),Il.forEach(s),Hn=a(qe," alors que nous utilisons actuellement le mod\xE8le "),ls=r(qe,"CODE",{});var Gl=l(ls);Yn=a(Gl,"cased"),Gl.forEach(s),Jn=a(qe,", ce qui explique le meilleur r\xE9sultat."),qe.forEach(s),Hs=c(e),he=r(e,"P",{});var uo=l(he);Xn=a(uo,"En regroupant le tout, nous obtenons notre fonction "),is=r(uo,"CODE",{});var Rl=l(is);Kn=a(Rl,"compute_metrics()"),Rl.forEach(s),Qn=a(uo," :"),uo.forEach(s),Ys=c(e),E(Ne.$$.fragment,e),Js=c(e),oe=r(e,"P",{});var Qe=l(oe);Zn=a(Qe,"Et pour le voir utilis\xE9 en action pour rapporter les m\xE9triques \xE0 la fin de chaque \xE9poque, voici comment nous d\xE9finissons un nouveau "),us=r(Qe,"CODE",{});var Bl=l(us);er=a(Bl,"Trainer"),Bl.forEach(s),tr=a(Qe," avec cette fonction "),ds=r(Qe,"CODE",{});var Vl=l(ds);sr=a(Vl,"compute_metrics()"),Vl.forEach(s),or=a(Qe," :"),Qe.forEach(s),Xs=c(e),E(Fe.$$.fragment,e),Ks=c(e),J=r(e,"P",{});var $e=l(J);ar=a($e,"Notez que nous cr\xE9ons un nouveau "),cs=r($e,"CODE",{});var Wl=l(cs);nr=a(Wl,"TrainingArguments"),Wl.forEach(s),rr=a($e," avec sa "),ps=r($e,"CODE",{});var Hl=l(ps);lr=a(Hl,"evaluation_strategy"),Hl.forEach(s),ir=a($e," d\xE9finie sur "),ms=r($e,"CODE",{});var Yl=l(ms);ur=a(Yl,'"epoch"'),Yl.forEach(s),dr=a($e," et un nouveau mod\xE8le. Sinon, nous ne ferions que continuer l\u2019entra\xEEnement du mod\xE8le que nous avons d\xE9j\xE0 entra\xEEn\xE9. Pour lancer un nouveau cycle d\u2019entra\xEEnement, nous ex\xE9cutons :"),$e.forEach(s),Qs=c(e),E(Ie.$$.fragment,e),Zs=c(e),Ye=r(e,"P",{});var Jl=l(Ye);cr=a(Jl,"Cette fois, il indiquera la perte et les mesures de validation \xE0 la fin de chaque \xE9poque, en plus de la perte d\u2019entra\xEEnement. Encore une fois, le score exact de pr\xE9cision/F1 que vous atteignez peut \xEAtre un peu diff\xE9rent de ce que nous avons trouv\xE9, en raison de l\u2019initialisation al\xE9atoire de la t\xEAte du mod\xE8le, mais il devrait \xEAtre dans la m\xEAme fourchette."),Jl.forEach(s),eo=c(e),ae=r(e,"P",{});var Ze=l(ae);pr=a(Ze,"Le "),fs=r(Ze,"CODE",{});var Xl=l(fs);mr=a(Xl,"Trainer"),Xl.forEach(s),fr=a(Ze," fonctionnera sur plusieurs GPUs ou TPUs et fournit beaucoup d\u2019options, comme l\u2019entra\xEEnement en pr\xE9cision mixte (utilisez "),vs=r(Ze,"CODE",{});var Kl=l(vs);vr=a(Kl,"fp16 = True"),Kl.forEach(s),hr=a(Ze," dans vos arguments d\u2019entra\xEEnement). Nous passerons en revue tout ce qu\u2019il supporte dans le chapitre 10."),Ze.forEach(s),to=c(e),X=r(e,"P",{});var be=l(X);_r=a(be,"Ceci conclut l\u2019introduction au "),hs=r(be,"EM",{});var Ql=l(hs);Er=a(Ql,"fine-tuning"),Ql.forEach(s),qr=a(be," en utilisant l\u2019API "),_s=r(be,"CODE",{});var Zl=l(_s);$r=a(Zl,"Trainer"),Zl.forEach(s),br=a(be,". Un exemple d\u2019utilisation pour les t\xE2ches de NLP les plus communes es donn\xE9 dans le "),Je=r(be,"A",{href:!0});var ei=l(Je);gr=a(ei,"chapitre 7"),ei.forEach(s),Cr=a(be,", mais pour l\u2019instant regardons comment faire la m\xEAme chose en PyTorch pur."),be.forEach(s),so=c(e),E(_e.$$.fragment,e),this.h()},h(){v(p,"name","hf:doc:metadata"),v(p,"content",JSON.stringify(mi)),v(C,"id","ifinetuneri-un-modle-avec-lapi-trainer"),v(C,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),v(C,"href","#ifinetuneri-un-modle-avec-lapi-trainer"),v(T,"class","relative group"),v(je,"href","https://colab.research.google.com/"),v(je,"rel","nofollow"),v(de,"id","entranement"),v(de,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),v(de,"href","#entranement"),v(re,"class","relative group"),v(Ve,"href","/course/fr/chapter2"),v(We,"href","/course/fr/chapter2"),v(ve,"id","evaluation"),v(ve,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),v(ve,"href","#evaluation"),v(ie,"class","relative group"),v(He,"href","/course/fr/chapter2"),v(Ue,"href","https://arxiv.org/pdf/1810.04805.pdf"),v(Ue,"rel","nofollow"),v(Je,"href","/course/fr/chapter7")},m(e,i){t(document.head,p),u(e,S,i),q(f,e,i),u(e,M,i),u(e,T,i),t(T,C),t(C,G),q(A,G,null),t(T,L),t(T,j),t(j,W),t(W,R),t(j,Ce),u(e,ue,i),q(B,e,i),u(e,w,i),q(te,e,i),u(e,ke,i),u(e,h,i),t(h,Re),t(h,et),t(et,co),t(h,po),t(h,tt),t(tt,mo),t(h,fo),t(h,st),t(st,vo),t(h,ho),t(h,ot),t(ot,_o),t(h,Eo),t(h,at),t(at,qo),t(h,$o),t(h,je),t(je,bo),t(h,go),u(e,$s,i),u(e,Be,i),t(Be,Co),u(e,bs,i),q(ze,e,i),u(e,gs,i),u(e,re,i),t(re,de),t(de,nt),q(Te,nt,null),t(re,ko),t(re,rt),t(rt,jo),u(e,Cs,i),u(e,D,i),t(D,zo),t(D,lt),t(lt,To),t(D,wo),t(D,it),t(it,Po),t(D,Do),t(D,ut),t(ut,xo),t(D,Oo),t(D,dt),t(dt,yo),t(D,Ao),t(D,ct),t(ct,Lo),t(D,So),u(e,ks,i),q(we,e,i),u(e,js,i),q(ce,e,i),u(e,zs,i),u(e,se,i),t(se,Mo),t(se,Ve),t(Ve,Uo),t(se,No),t(se,pt),t(pt,Fo),t(se,Io),u(e,Ts,i),q(Pe,e,i),u(e,ws,i),u(e,pe,i),t(pe,Go),t(pe,We),t(We,Ro),t(pe,Bo),u(e,Ps,i),u(e,x,i),t(x,Vo),t(x,mt),t(mt,Wo),t(x,Ho),t(x,ft),t(ft,Yo),t(x,Jo),t(x,vt),t(vt,Xo),t(x,Ko),t(x,ht),t(ht,Qo),t(x,Zo),t(x,_t),t(_t,ea),t(x,ta),u(e,Ds,i),q(De,e,i),u(e,xs,i),u(e,O,i),t(O,sa),t(O,Et),t(Et,oa),t(O,aa),t(O,qt),t(qt,na),t(O,ra),t(O,$t),t($t,la),t(O,ia),t(O,bt),t(bt,ua),t(O,da),t(O,gt),t(gt,ca),t(O,pa),u(e,Os,i),u(e,H,i),t(H,ma),t(H,Ct),t(Ct,fa),t(H,va),t(H,kt),t(kt,ha),t(H,_a),t(H,jt),t(jt,Ea),t(H,qa),u(e,ys,i),q(xe,e,i),u(e,As,i),u(e,me,i),t(me,$a),t(me,zt),t(zt,ba),t(me,ga),u(e,Ls,i),u(e,fe,i),t(fe,P),t(P,Ca),t(P,Tt),t(Tt,ka),t(P,ja),t(P,wt),t(wt,za),t(P,Ta),t(P,Pt),t(Pt,wa),t(P,Pa),t(P,Dt),t(Dt,Da),t(P,xa),t(P,xt),t(xt,Oa),t(P,ya),t(P,Ot),t(Ot,Aa),t(P,La),t(fe,Sa),t(fe,le),t(le,Ma),t(le,yt),t(yt,Ua),t(le,Na),t(le,At),t(At,Fa),t(le,Ia),u(e,Ss,i),u(e,ie,i),t(ie,ve),t(ve,Lt),q(Oe,Lt,null),t(ie,Ga),t(ie,St),t(St,Ra),u(e,Ms,i),u(e,z,i),t(z,Ba),t(z,Mt),t(Mt,Va),t(z,Wa),t(z,Ut),t(Ut,Ha),t(z,Ya),t(z,Nt),t(Nt,Ja),t(z,Xa),t(z,Ft),t(Ft,Ka),t(z,Qa),t(z,It),t(It,Za),t(z,en),t(z,Gt),t(Gt,tn),t(z,sn),u(e,Us,i),q(ye,e,i),u(e,Ns,i),q(Ae,e,i),u(e,Fs,i),u(e,m,i),t(m,on),t(m,Rt),t(Rt,an),t(m,nn),t(m,Bt),t(Bt,rn),t(m,ln),t(m,Vt),t(Vt,un),t(m,dn),t(m,Wt),t(Wt,cn),t(m,pn),t(m,Ht),t(Ht,mn),t(m,fn),t(m,Yt),t(Yt,vn),t(m,hn),t(m,Jt),t(Jt,_n),t(m,En),t(m,Xt),t(Xt,qn),t(m,$n),t(m,Kt),t(Kt,bn),t(m,gn),u(e,Is,i),u(e,U,i),t(U,Cn),t(U,Qt),t(Qt,kn),t(U,jn),t(U,Zt),t(Zt,zn),t(U,Tn),t(U,He),t(He,wn),t(U,Pn),t(U,es),t(es,Dn),t(U,xn),u(e,Gs,i),q(Le,e,i),u(e,Rs,i),u(e,y,i),t(y,On),t(y,ts),t(ts,yn),t(y,An),t(y,ss),t(ss,Ln),t(y,Sn),t(y,os),t(os,Mn),t(y,Un),t(y,as),t(as,Nn),t(y,Fn),t(y,ns),t(ns,In),t(y,Gn),u(e,Bs,i),q(Se,e,i),u(e,Vs,i),q(Me,e,i),u(e,Ws,i),u(e,Y,i),t(Y,Rn),t(Y,Ue),t(Ue,Bn),t(Y,Vn),t(Y,rs),t(rs,Wn),t(Y,Hn),t(Y,ls),t(ls,Yn),t(Y,Jn),u(e,Hs,i),u(e,he,i),t(he,Xn),t(he,is),t(is,Kn),t(he,Qn),u(e,Ys,i),q(Ne,e,i),u(e,Js,i),u(e,oe,i),t(oe,Zn),t(oe,us),t(us,er),t(oe,tr),t(oe,ds),t(ds,sr),t(oe,or),u(e,Xs,i),q(Fe,e,i),u(e,Ks,i),u(e,J,i),t(J,ar),t(J,cs),t(cs,nr),t(J,rr),t(J,ps),t(ps,lr),t(J,ir),t(J,ms),t(ms,ur),t(J,dr),u(e,Qs,i),q(Ie,e,i),u(e,Zs,i),u(e,Ye,i),t(Ye,cr),u(e,eo,i),u(e,ae,i),t(ae,pr),t(ae,fs),t(fs,mr),t(ae,fr),t(ae,vs),t(vs,vr),t(ae,hr),u(e,to,i),u(e,X,i),t(X,_r),t(X,hs),t(hs,Er),t(X,qr),t(X,_s),t(_s,$r),t(X,br),t(X,Je),t(Je,gr),t(X,Cr),u(e,so,i),q(_e,e,i),oo=!0},p(e,[i]){const Ge={};i&1&&(Ge.fw=e[0]),f.$set(Ge);const Es={};i&2&&(Es.$$scope={dirty:i,ctx:e}),ce.$set(Es);const qs={};i&2&&(qs.$$scope={dirty:i,ctx:e}),_e.$set(qs)},i(e){oo||($(f.$$.fragment,e),$(A.$$.fragment,e),$(B.$$.fragment,e),$(te.$$.fragment,e),$(ze.$$.fragment,e),$(Te.$$.fragment,e),$(we.$$.fragment,e),$(ce.$$.fragment,e),$(Pe.$$.fragment,e),$(De.$$.fragment,e),$(xe.$$.fragment,e),$(Oe.$$.fragment,e),$(ye.$$.fragment,e),$(Ae.$$.fragment,e),$(Le.$$.fragment,e),$(Se.$$.fragment,e),$(Me.$$.fragment,e),$(Ne.$$.fragment,e),$(Fe.$$.fragment,e),$(Ie.$$.fragment,e),$(_e.$$.fragment,e),oo=!0)},o(e){b(f.$$.fragment,e),b(A.$$.fragment,e),b(B.$$.fragment,e),b(te.$$.fragment,e),b(ze.$$.fragment,e),b(Te.$$.fragment,e),b(we.$$.fragment,e),b(ce.$$.fragment,e),b(Pe.$$.fragment,e),b(De.$$.fragment,e),b(xe.$$.fragment,e),b(Oe.$$.fragment,e),b(ye.$$.fragment,e),b(Ae.$$.fragment,e),b(Le.$$.fragment,e),b(Se.$$.fragment,e),b(Me.$$.fragment,e),b(Ne.$$.fragment,e),b(Fe.$$.fragment,e),b(Ie.$$.fragment,e),b(_e.$$.fragment,e),oo=!1},d(e){s(p),e&&s(S),g(f,e),e&&s(M),e&&s(T),g(A),e&&s(ue),g(B,e),e&&s(w),g(te,e),e&&s(ke),e&&s(h),e&&s($s),e&&s(Be),e&&s(bs),g(ze,e),e&&s(gs),e&&s(re),g(Te),e&&s(Cs),e&&s(D),e&&s(ks),g(we,e),e&&s(js),g(ce,e),e&&s(zs),e&&s(se),e&&s(Ts),g(Pe,e),e&&s(ws),e&&s(pe),e&&s(Ps),e&&s(x),e&&s(Ds),g(De,e),e&&s(xs),e&&s(O),e&&s(Os),e&&s(H),e&&s(ys),g(xe,e),e&&s(As),e&&s(me),e&&s(Ls),e&&s(fe),e&&s(Ss),e&&s(ie),g(Oe),e&&s(Ms),e&&s(z),e&&s(Us),g(ye,e),e&&s(Ns),g(Ae,e),e&&s(Fs),e&&s(m),e&&s(Is),e&&s(U),e&&s(Gs),g(Le,e),e&&s(Rs),e&&s(y),e&&s(Bs),g(Se,e),e&&s(Vs),g(Me,e),e&&s(Ws),e&&s(Y),e&&s(Hs),e&&s(he),e&&s(Ys),g(Ne,e),e&&s(Js),e&&s(oe),e&&s(Xs),g(Fe,e),e&&s(Ks),e&&s(J),e&&s(Qs),g(Ie,e),e&&s(Zs),e&&s(Ye),e&&s(eo),e&&s(ae),e&&s(to),e&&s(X),e&&s(so),g(_e,e)}}}const mi={local:"ifinetuneri-un-modle-avec-lapi-trainer",sections:[{local:"entranement",title:"Entra\xEEnement"},{local:"evaluation",title:"Evaluation"}],title:"<i>Finetuner</i> un mod\xE8le avec l'API Trainer"};function fi(ge,p,S){let f="pt";return ri(()=>{const M=new URLSearchParams(window.location.search);S(0,f=M.get("fw")||"pt")}),[f]}class gi extends si{constructor(p){super();oi(this,p,fi,pi,ai,{})}}export{gi as default,mi as metadata};
