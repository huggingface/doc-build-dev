import{S as Io,i as qo,s as Po,e as n,k as p,w as ne,t as l,M as Ao,c as t,d as o,m as u,a,x as te,h as s,b as x,F as e,g as k,y as ae,q as re,o as ie,B as le,v as Uo,L as Co}from"../../chunks/vendor-a09ded63.js";import{T as Se}from"../../chunks/Tip-27a54654.js";import{D as je}from"../../chunks/Docstring-3f63de13.js";import{C as Ro}from"../../chunks/CodeBlock-879da7fe.js";import{I as Fo}from"../../chunks/IconCopyLink-3f5556be.js";import{E as So}from"../../chunks/ExampleCodeBlock-7aff195a.js";function jo(X){let h,O,_,i,f,d,m,I,A,y,b,N,R,E,c,v,U,S,C,w,T,q,V,j;return{c(){h=n("p"),O=l("Raises the following errors:"),_=p(),i=n("ul"),f=n("li"),d=n("a"),m=n("code"),I=l("EnvironmentError"),A=l(`
if `),y=n("code"),b=l("use_auth_token=True"),N=l(" and the token cannot be found."),R=p(),E=n("li"),c=n("a"),v=n("code"),U=l("OSError"),S=l(`
if ETag cannot be determined.`),C=p(),w=n("li"),T=n("a"),q=n("code"),V=l("ValueError"),j=l(`
if some parameter value is invalid`),this.h()},l(g){h=t(g,"P",{});var $=a(h);O=s($,"Raises the following errors:"),$.forEach(o),_=u(g),i=t(g,"UL",{});var D=a(i);f=t(D,"LI",{});var P=a(f);d=t(P,"A",{href:!0,rel:!0});var Y=a(d);m=t(Y,"CODE",{});var z=a(m);I=s(z,"EnvironmentError"),z.forEach(o),Y.forEach(o),A=s(P,`
if `),y=t(P,"CODE",{});var Z=a(y);b=s(Z,"use_auth_token=True"),Z.forEach(o),N=s(P," and the token cannot be found."),P.forEach(o),R=u(D),E=t(D,"LI",{});var M=a(E);c=t(M,"A",{href:!0,rel:!0});var G=a(c);v=t(G,"CODE",{});var ee=a(v);U=s(ee,"OSError"),ee.forEach(o),G.forEach(o),S=s(M,`
if ETag cannot be determined.`),M.forEach(o),C=u(D),w=t(D,"LI",{});var B=a(w);T=t(B,"A",{href:!0,rel:!0});var K=a(T);q=t(K,"CODE",{});var oe=a(q);V=s(oe,"ValueError"),oe.forEach(o),K.forEach(o),j=s(B,`
if some parameter value is invalid`),B.forEach(o),D.forEach(o),this.h()},h(){x(d,"href","https://docs.python.org/3/library/exceptions.html#EnvironmentError"),x(d,"rel","nofollow"),x(c,"href","https://docs.python.org/3/library/exceptions.html#OSError"),x(c,"rel","nofollow"),x(T,"href","https://docs.python.org/3/library/exceptions.html#ValueError"),x(T,"rel","nofollow")},m(g,$){k(g,h,$),e(h,O),k(g,_,$),k(g,i,$),e(i,f),e(f,d),e(d,m),e(m,I),e(f,A),e(f,y),e(y,b),e(f,N),e(i,R),e(i,E),e(E,c),e(c,v),e(v,U),e(E,S),e(i,C),e(i,w),e(w,T),e(T,q),e(q,V),e(w,j)},d(g){g&&o(h),g&&o(_),g&&o(i)}}}function Vo(X){let h,O,_,i,f,d,m,I,A,y,b,N,R,E,c,v,U,S,C,w,T,q,V,j;return{c(){h=n("p"),O=l("Raises the following errors:"),_=p(),i=n("ul"),f=n("li"),d=n("a"),m=n("code"),I=l("EnvironmentError"),A=l(`
if `),y=n("code"),b=l("use_auth_token=True"),N=l(" and the token cannot be found."),R=p(),E=n("li"),c=n("a"),v=n("code"),U=l("OSError"),S=l(` if
ETag cannot be determined.`),C=p(),w=n("li"),T=n("a"),q=n("code"),V=l("ValueError"),j=l(`
if some parameter value is invalid`),this.h()},l(g){h=t(g,"P",{});var $=a(h);O=s($,"Raises the following errors:"),$.forEach(o),_=u(g),i=t(g,"UL",{});var D=a(i);f=t(D,"LI",{});var P=a(f);d=t(P,"A",{href:!0,rel:!0});var Y=a(d);m=t(Y,"CODE",{});var z=a(m);I=s(z,"EnvironmentError"),z.forEach(o),Y.forEach(o),A=s(P,`
if `),y=t(P,"CODE",{});var Z=a(y);b=s(Z,"use_auth_token=True"),Z.forEach(o),N=s(P," and the token cannot be found."),P.forEach(o),R=u(D),E=t(D,"LI",{});var M=a(E);c=t(M,"A",{href:!0,rel:!0});var G=a(c);v=t(G,"CODE",{});var ee=a(v);U=s(ee,"OSError"),ee.forEach(o),G.forEach(o),S=s(M,` if
ETag cannot be determined.`),M.forEach(o),C=u(D),w=t(D,"LI",{});var B=a(w);T=t(B,"A",{href:!0,rel:!0});var K=a(T);q=t(K,"CODE",{});var oe=a(q);V=s(oe,"ValueError"),oe.forEach(o),K.forEach(o),j=s(B,`
if some parameter value is invalid`),B.forEach(o),D.forEach(o),this.h()},h(){x(d,"href","https://docs.python.org/3/library/exceptions.html#EnvironmentError"),x(d,"rel","nofollow"),x(c,"href","https://docs.python.org/3/library/exceptions.html#OSError"),x(c,"rel","nofollow"),x(T,"href","https://docs.python.org/3/library/exceptions.html#ValueError"),x(T,"rel","nofollow")},m(g,$){k(g,h,$),e(h,O),k(g,_,$),k(g,i,$),e(i,f),e(f,d),e(d,m),e(m,I),e(f,A),e(f,y),e(y,b),e(f,N),e(i,R),e(i,E),e(E,c),e(c,v),e(v,U),e(E,S),e(i,C),e(i,w),e(w,T),e(T,q),e(q,V),e(w,j)},d(g){g&&o(h),g&&o(_),g&&o(i)}}}function Mo(X){let h,O,_,i,f,d,m,I,A,y,b,N,R,E,c,v,U,S,C,w,T,q,V,j;return{c(){h=n("p"),O=l("Raises the following errors:"),_=p(),i=n("ul"),f=n("li"),d=n("a"),m=n("code"),I=l("EnvironmentError"),A=l(`
if `),y=n("code"),b=l("use_auth_token=True"),N=l(" and the token cannot be found."),R=p(),E=n("li"),c=n("a"),v=n("code"),U=l("OSError"),S=l(`
if ETag cannot be determined.`),C=p(),w=n("li"),T=n("a"),q=n("code"),V=l("ValueError"),j=l(`
if some parameter value is invalid`),this.h()},l(g){h=t(g,"P",{});var $=a(h);O=s($,"Raises the following errors:"),$.forEach(o),_=u(g),i=t(g,"UL",{});var D=a(i);f=t(D,"LI",{});var P=a(f);d=t(P,"A",{href:!0,rel:!0});var Y=a(d);m=t(Y,"CODE",{});var z=a(m);I=s(z,"EnvironmentError"),z.forEach(o),Y.forEach(o),A=s(P,`
if `),y=t(P,"CODE",{});var Z=a(y);b=s(Z,"use_auth_token=True"),Z.forEach(o),N=s(P," and the token cannot be found."),P.forEach(o),R=u(D),E=t(D,"LI",{});var M=a(E);c=t(M,"A",{href:!0,rel:!0});var G=a(c);v=t(G,"CODE",{});var ee=a(v);U=s(ee,"OSError"),ee.forEach(o),G.forEach(o),S=s(M,`
if ETag cannot be determined.`),M.forEach(o),C=u(D),w=t(D,"LI",{});var B=a(w);T=t(B,"A",{href:!0,rel:!0});var K=a(T);q=t(K,"CODE",{});var oe=a(q);V=s(oe,"ValueError"),oe.forEach(o),K.forEach(o),j=s(B,`
if some parameter value is invalid`),B.forEach(o),D.forEach(o),this.h()},h(){x(d,"href","https://docs.python.org/3/library/exceptions.html#EnvironmentError"),x(d,"rel","nofollow"),x(c,"href","https://docs.python.org/3/library/exceptions.html#OSError"),x(c,"rel","nofollow"),x(T,"href","https://docs.python.org/3/library/exceptions.html#ValueError"),x(T,"rel","nofollow")},m(g,$){k(g,h,$),e(h,O),k(g,_,$),k(g,i,$),e(i,f),e(f,d),e(d,m),e(m,I),e(f,A),e(f,y),e(y,b),e(f,N),e(i,R),e(i,E),e(E,c),e(c,v),e(v,U),e(E,S),e(i,C),e(i,w),e(w,T),e(T,q),e(q,V),e(w,j)},d(g){g&&o(h),g&&o(_),g&&o(i)}}}function Bo(X){let h,O,_,i,f;return i=new Ro({props:{code:`from huggingface_hub import hf_hub_url

hf_hub_url(
    repo_id="julien-c/EsperBERTo-small", filename="pytorch_model.bin"
)`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> huggingface_hub <span class="hljs-keyword">import</span> hf_hub_url

<span class="hljs-meta">&gt;&gt;&gt; </span>hf_hub_url(
<span class="hljs-meta">... </span>    repo_id=<span class="hljs-string">&quot;julien-c/EsperBERTo-small&quot;</span>, filename=<span class="hljs-string">&quot;pytorch_model.bin&quot;</span>
<span class="hljs-meta">... </span>)
<span class="hljs-string">&#x27;https://huggingface.co/julien-c/EsperBERTo-small/resolve/main/pytorch_model.bin&#x27;</span>`}}),{c(){h=n("p"),O=l("Example:"),_=p(),ne(i.$$.fragment)},l(d){h=t(d,"P",{});var m=a(h);O=s(m,"Example:"),m.forEach(o),_=u(d),te(i.$$.fragment,d)},m(d,m){k(d,h,m),e(h,O),k(d,_,m),ae(i,d,m),f=!0},p:Co,i(d){f||(re(i.$$.fragment,d),f=!0)},o(d){ie(i.$$.fragment,d),f=!1},d(d){d&&o(h),d&&o(_),le(i,d)}}}function Ho(X){let h,O,_,i,f,d,m,I,A,y,b,N,R,E;return{c(){h=n("p"),O=l("Notes:"),_=p(),i=n("p"),f=l(`Cloudfront is replicated over the globe so downloads are way faster for
the end user (and it also lowers our bandwidth costs).`),d=p(),m=n("p"),I=l(`Cloudfront aggressively caches files by default (default TTL is 24
hours), however this is not an issue here because we implement a
git-based versioning system on huggingface.co, which means that we store
the files on S3/Cloudfront in a content-addressable way (i.e., the file
name is its hash). Using content-addressable filenames means cache can\u2019t
ever be stale.`),A=p(),y=n("p"),b=l(`In terms of client-side caching from this library, we base our caching
on the objects\u2019 entity tag (`),N=n("code"),R=l("ETag"),E=l(`), which is an identifier of a
specific version of a resource [1]_. An object\u2019s ETag is: its git-sha1
if stored in git, or its sha256 if stored in git-lfs.`)},l(c){h=t(c,"P",{});var v=a(h);O=s(v,"Notes:"),v.forEach(o),_=u(c),i=t(c,"P",{});var U=a(i);f=s(U,`Cloudfront is replicated over the globe so downloads are way faster for
the end user (and it also lowers our bandwidth costs).`),U.forEach(o),d=u(c),m=t(c,"P",{});var S=a(m);I=s(S,`Cloudfront aggressively caches files by default (default TTL is 24
hours), however this is not an issue here because we implement a
git-based versioning system on huggingface.co, which means that we store
the files on S3/Cloudfront in a content-addressable way (i.e., the file
name is its hash). Using content-addressable filenames means cache can\u2019t
ever be stale.`),S.forEach(o),A=u(c),y=t(c,"P",{});var C=a(y);b=s(C,`In terms of client-side caching from this library, we base our caching
on the objects\u2019 entity tag (`),N=t(C,"CODE",{});var w=a(N);R=s(w,"ETag"),w.forEach(o),E=s(C,`), which is an identifier of a
specific version of a resource [1]_. An object\u2019s ETag is: its git-sha1
if stored in git, or its sha256 if stored in git-lfs.`),C.forEach(o)},m(c,v){k(c,h,v),e(h,O),k(c,_,v),k(c,i,v),e(i,f),k(c,d,v),k(c,m,v),e(m,I),k(c,A,v),k(c,y,v),e(y,b),e(y,N),e(N,R),e(y,E)},d(c){c&&o(h),c&&o(_),c&&o(i),c&&o(d),c&&o(m),c&&o(A),c&&o(y)}}}function Wo(X){let h,O,_,i,f,d,m,I,A,y,b,N,R,E,c,v,U,S,C,w,T,q,V,j,g,$,D,P,Y,z,Z,M,G,ee,B,K,oe,Ve,de,Ae,H,ge,Me,Ee,Be,He,$e,We,ze,xe,Ge,Ke,ce,Ue,Q,me,Je,Te,Qe,Xe,ke,Ye,Ze,he,Ce,F,_e,eo,De,oo,no,Ne,to,ao,fe,ro,pe,io,Oe,lo,so,Le,ye,co,be,ho,Re;return d=new Fo({}),N=new je({props:{name:"huggingface_hub.hf_hub_download",anchor:"huggingface_hub.hf_hub_download",parameters:[{name:"repo_id",val:": str"},{name:"filename",val:": str"},{name:"subfolder",val:": typing.Optional[str] = None"},{name:"repo_type",val:": typing.Optional[str] = None"},{name:"revision",val:": typing.Optional[str] = None"},{name:"library_name",val:": typing.Optional[str] = None"},{name:"library_version",val:": typing.Optional[str] = None"},{name:"cache_dir",val:": typing.Union[str, pathlib.Path, NoneType] = None"},{name:"user_agent",val:": typing.Union[typing.Dict, str, NoneType] = None"},{name:"force_download",val:": typing.Optional[bool] = False"},{name:"proxies",val:": typing.Optional[typing.Dict] = None"},{name:"etag_timeout",val:": typing.Optional[float] = 10"},{name:"resume_download",val:": typing.Optional[bool] = False"},{name:"use_auth_token",val:": typing.Union[bool, str, NoneType] = None"},{name:"local_files_only",val:": typing.Optional[bool] = False"},{name:"legacy_cache_layout",val:": typing.Optional[bool] = False"}],parametersDescription:[{anchor:"huggingface_hub.hf_hub_download.repo_id",description:`<strong>repo_id</strong> (<code>str</code>) &#x2014;
A user or an organization name and a repo name separated by a <code>/</code>.`,name:"repo_id"},{anchor:"huggingface_hub.hf_hub_download.filename",description:`<strong>filename</strong> (<code>str</code>) &#x2014;
The name of the file in the repo.`,name:"filename"},{anchor:"huggingface_hub.hf_hub_download.subfolder",description:`<strong>subfolder</strong> (<code>str</code>, <em>optional</em>) &#x2014;
An optional value corresponding to a folder inside the model repo.`,name:"subfolder"},{anchor:"huggingface_hub.hf_hub_download.repo_type",description:`<strong>repo_type</strong> (<code>str</code>, <em>optional</em>) &#x2014;
Set to <code>&quot;dataset&quot;</code> or <code>&quot;space&quot;</code> if uploading to a dataset or space,
<code>None</code> or <code>&quot;model&quot;</code> if uploading to a model. Default is <code>None</code>.`,name:"repo_type"},{anchor:"huggingface_hub.hf_hub_download.revision",description:`<strong>revision</strong> (<code>str</code>, <em>optional</em>) &#x2014;
An optional Git revision id which can be a branch name, a tag, or a
commit hash.`,name:"revision"},{anchor:"huggingface_hub.hf_hub_download.library_name",description:`<strong>library_name</strong> (<code>str</code>, <em>optional</em>) &#x2014;
The name of the library to which the object corresponds.`,name:"library_name"},{anchor:"huggingface_hub.hf_hub_download.library_version",description:`<strong>library_version</strong> (<code>str</code>, <em>optional</em>) &#x2014;
The version of the library.`,name:"library_version"},{anchor:"huggingface_hub.hf_hub_download.cache_dir",description:`<strong>cache_dir</strong> (<code>str</code>, <code>Path</code>, <em>optional</em>) &#x2014;
Path to the folder where cached files are stored.`,name:"cache_dir"},{anchor:"huggingface_hub.hf_hub_download.user_agent",description:`<strong>user_agent</strong> (<code>dict</code>, <code>str</code>, <em>optional</em>) &#x2014;
The user-agent info in the form of a dictionary or a string.`,name:"user_agent"},{anchor:"huggingface_hub.hf_hub_download.force_download",description:`<strong>force_download</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether the file should be downloaded even if it already exists in
the local cache.`,name:"force_download"},{anchor:"huggingface_hub.hf_hub_download.proxies",description:`<strong>proxies</strong> (<code>dict</code>, <em>optional</em>) &#x2014;
Dictionary mapping protocol to the URL of the proxy passed to
<code>requests.request</code>.`,name:"proxies"},{anchor:"huggingface_hub.hf_hub_download.etag_timeout",description:`<strong>etag_timeout</strong> (<code>float</code>, <em>optional</em>, defaults to <code>10</code>) &#x2014;
When fetching ETag, how many seconds to wait for the server to send
data before giving up which is passed to <code>requests.request</code>.`,name:"etag_timeout"},{anchor:"huggingface_hub.hf_hub_download.resume_download",description:`<strong>resume_download</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
If <code>True</code>, resume a previously interrupted download.`,name:"resume_download"},{anchor:"huggingface_hub.hf_hub_download.use_auth_token",description:`<strong>use_auth_token</strong> (<code>str</code>, <code>bool</code>, <em>optional</em>) &#x2014;
A token to be used for the download.<ul>
<li>If <code>True</code>, the token is read from the HuggingFace config
folder.</li>
<li>If a string, it&#x2019;s used as the authentication token.</li>
</ul>`,name:"use_auth_token"},{anchor:"huggingface_hub.hf_hub_download.local_files_only",description:`<strong>local_files_only</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
If <code>True</code>, avoid downloading the file and return the path to the
local cached file if it exists.`,name:"local_files_only"},{anchor:"huggingface_hub.hf_hub_download.legacy_cache_layout",description:`<strong>legacy_cache_layout</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
If <code>True</code>, uses the legacy file cache layout i.e. just call <code>hf_hub_url</code>
then <code>cached_download</code>. This is deprecated as the new cache layout is
more powerful.`,name:"legacy_cache_layout"}],source:"https://github.com/huggingface/huggingface_hub/blob/vr_878/src/huggingface_hub/file_download.py#L765",returnDescription:`
<p>Local path (string) of file or if networking is off, last version of
file cached on disk.</p>
`}}),de=new Se({props:{$$slots:{default:[jo]},$$scope:{ctx:X}}}),ge=new je({props:{name:"huggingface_hub.snapshot_download",anchor:"huggingface_hub.snapshot_download",parameters:[{name:"repo_id",val:": str"},{name:"revision",val:": typing.Optional[str] = None"},{name:"repo_type",val:": typing.Optional[str] = None"},{name:"cache_dir",val:": typing.Union[str, pathlib.Path, NoneType] = None"},{name:"library_name",val:": typing.Optional[str] = None"},{name:"library_version",val:": typing.Optional[str] = None"},{name:"user_agent",val:": typing.Union[typing.Dict, str, NoneType] = None"},{name:"proxies",val:": typing.Optional[typing.Dict] = None"},{name:"etag_timeout",val:": typing.Optional[float] = 10"},{name:"resume_download",val:": typing.Optional[bool] = False"},{name:"use_auth_token",val:": typing.Union[bool, str, NoneType] = None"},{name:"local_files_only",val:": typing.Optional[bool] = False"},{name:"allow_regex",val:": typing.Union[typing.List[str], str, NoneType] = None"},{name:"ignore_regex",val:": typing.Union[typing.List[str], str, NoneType] = None"}],parametersDescription:[{anchor:"huggingface_hub.snapshot_download.repo_id",description:`<strong>repo_id</strong> (<code>str</code>) &#x2014;
A user or an organization name and a repo name separated by a <code>/</code>.`,name:"repo_id"},{anchor:"huggingface_hub.snapshot_download.revision",description:`<strong>revision</strong> (<code>str</code>, <em>optional</em>) &#x2014;
An optional Git revision id which can be a branch name, a tag, or a
commit hash.`,name:"revision"},{anchor:"huggingface_hub.snapshot_download.repo_type",description:`<strong>repo_type</strong> (<code>str</code>, <em>optional</em>) &#x2014;
Set to <code>&quot;dataset&quot;</code> or <code>&quot;space&quot;</code> if uploading to a dataset or space,
<code>None</code> or <code>&quot;model&quot;</code> if uploading to a model. Default is <code>None</code>.`,name:"repo_type"},{anchor:"huggingface_hub.snapshot_download.cache_dir",description:`<strong>cache_dir</strong> (<code>str</code>, <code>Path</code>, <em>optional</em>) &#x2014;
Path to the folder where cached files are stored.`,name:"cache_dir"},{anchor:"huggingface_hub.snapshot_download.library_name",description:`<strong>library_name</strong> (<code>str</code>, <em>optional</em>) &#x2014;
The name of the library to which the object corresponds.`,name:"library_name"},{anchor:"huggingface_hub.snapshot_download.library_version",description:`<strong>library_version</strong> (<code>str</code>, <em>optional</em>) &#x2014;
The version of the library.`,name:"library_version"},{anchor:"huggingface_hub.snapshot_download.user_agent",description:`<strong>user_agent</strong> (<code>str</code>, <code>dict</code>, <em>optional</em>) &#x2014;
The user-agent info in the form of a dictionary or a string.`,name:"user_agent"},{anchor:"huggingface_hub.snapshot_download.proxies",description:`<strong>proxies</strong> (<code>dict</code>, <em>optional</em>) &#x2014;
Dictionary mapping protocol to the URL of the proxy passed to
<code>requests.request</code>.`,name:"proxies"},{anchor:"huggingface_hub.snapshot_download.etag_timeout",description:`<strong>etag_timeout</strong> (<code>float</code>, <em>optional</em>, defaults to <code>10</code>) &#x2014;
When fetching ETag, how many seconds to wait for the server to send
data before giving up which is passed to <code>requests.request</code>.`,name:"etag_timeout"},{anchor:"huggingface_hub.snapshot_download.resume_download",description:"<strong>resume_download</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False) -- If </code>True`, resume a previously interrupted download.",name:"resume_download"},{anchor:"huggingface_hub.snapshot_download.use_auth_token",description:`<strong>use_auth_token</strong> (<code>str</code>, <code>bool</code>, <em>optional</em>) &#x2014;
A token to be used for the download.<ul>
<li>If <code>True</code>, the token is read from the HuggingFace config
folder.</li>
<li>If a string, it&#x2019;s used as the authentication token.</li>
</ul>`,name:"use_auth_token"},{anchor:"huggingface_hub.snapshot_download.local_files_only",description:`<strong>local_files_only</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
If <code>True</code>, avoid downloading the file and return the path to the
local cached file if it exists.`,name:"local_files_only"},{anchor:"huggingface_hub.snapshot_download.allow_regex",description:`<strong>allow_regex</strong> (<code>list of str</code>, <code>str</code>, <em>optional</em>) &#x2014;
If provided, only files matching this regex are downloaded.`,name:"allow_regex"},{anchor:"huggingface_hub.snapshot_download.ignore_regex",description:`<strong>ignore_regex</strong> (<code>list of str</code>, <code>str</code>, <em>optional</em>) &#x2014;
If provided, files matching this regex are not downloaded.`,name:"ignore_regex"}],source:"https://github.com/huggingface/huggingface_hub/blob/vr_878/src/huggingface_hub/snapshot_download.py#L42",returnDescription:`
<p>Local folder path (string) of repo snapshot</p>
`}}),ce=new Se({props:{$$slots:{default:[Vo]},$$scope:{ctx:X}}}),me=new je({props:{name:"huggingface_hub.cached_download",anchor:"huggingface_hub.cached_download",parameters:[{name:"url",val:": str"},{name:"library_name",val:": typing.Optional[str] = None"},{name:"library_version",val:": typing.Optional[str] = None"},{name:"cache_dir",val:": typing.Union[str, pathlib.Path, NoneType] = None"},{name:"user_agent",val:": typing.Union[typing.Dict, str, NoneType] = None"},{name:"force_download",val:": typing.Optional[bool] = False"},{name:"force_filename",val:": typing.Optional[str] = None"},{name:"proxies",val:": typing.Optional[typing.Dict] = None"},{name:"etag_timeout",val:": typing.Optional[float] = 10"},{name:"resume_download",val:": typing.Optional[bool] = False"},{name:"use_auth_token",val:": typing.Union[bool, str, NoneType] = None"},{name:"local_files_only",val:": typing.Optional[bool] = False"}],parametersDescription:[{anchor:"huggingface_hub.cached_download.url",description:`<strong>url</strong> (<code>str</code>) &#x2014;
The path to the file to be downloaded.`,name:"url"},{anchor:"huggingface_hub.cached_download.library_name",description:`<strong>library_name</strong> (<code>str</code>, <em>optional</em>) &#x2014;
The name of the library to which the object corresponds.`,name:"library_name"},{anchor:"huggingface_hub.cached_download.library_version",description:`<strong>library_version</strong> (<code>str</code>, <em>optional</em>) &#x2014;
The version of the library.`,name:"library_version"},{anchor:"huggingface_hub.cached_download.cache_dir",description:`<strong>cache_dir</strong> (<code>str</code>, <code>Path</code>, <em>optional</em>) &#x2014;
Path to the folder where cached files are stored.`,name:"cache_dir"},{anchor:"huggingface_hub.cached_download.user_agent",description:`<strong>user_agent</strong> (<code>dict</code>, <code>str</code>, <em>optional</em>) &#x2014;
The user-agent info in the form of a dictionary or a string.`,name:"user_agent"},{anchor:"huggingface_hub.cached_download.force_download",description:`<strong>force_download</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether the file should be downloaded even if it already exists in
the local cache.`,name:"force_download"},{anchor:"huggingface_hub.cached_download.force_filename",description:`<strong>force_filename</strong> (<code>str</code>, <em>optional</em>) &#x2014;
Use this name instead of a generated file name.`,name:"force_filename"},{anchor:"huggingface_hub.cached_download.proxies",description:`<strong>proxies</strong> (<code>dict</code>, <em>optional</em>) &#x2014;
Dictionary mapping protocol to the URL of the proxy passed to
<code>requests.request</code>.`,name:"proxies"},{anchor:"huggingface_hub.cached_download.etag_timeout",description:`<strong>etag_timeout</strong> (<code>float</code>, <em>optional</em> defaults to <code>10</code>) &#x2014;
When fetching ETag, how many seconds to wait for the server to send
data before giving up which is passed to <code>requests.request</code>.`,name:"etag_timeout"},{anchor:"huggingface_hub.cached_download.resume_download",description:`<strong>resume_download</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
If <code>True</code>, resume a previously interrupted download.`,name:"resume_download"},{anchor:"huggingface_hub.cached_download.use_auth_token",description:`<strong>use_auth_token</strong> (<code>bool</code>, <code>str</code>, <em>optional</em>) &#x2014;
A token to be used for the download.<ul>
<li>If <code>True</code>, the token is read from the HuggingFace config
folder.</li>
<li>If a string, it&#x2019;s used as the authentication token.</li>
</ul>`,name:"use_auth_token"},{anchor:"huggingface_hub.cached_download.local_files_only",description:`<strong>local_files_only</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
If <code>True</code>, avoid downloading the file and return the path to the
local cached file if it exists.`,name:"local_files_only"}],source:"https://github.com/huggingface/huggingface_hub/blob/vr_878/src/huggingface_hub/file_download.py#L456",returnDescription:`
<p>Local path (string) of file or if networking is off, last version of
file cached on disk.</p>
`}}),he=new Se({props:{$$slots:{default:[Mo]},$$scope:{ctx:X}}}),_e=new je({props:{name:"huggingface_hub.hf_hub_url",anchor:"huggingface_hub.hf_hub_url",parameters:[{name:"repo_id",val:": str"},{name:"filename",val:": str"},{name:"subfolder",val:": typing.Optional[str] = None"},{name:"repo_type",val:": typing.Optional[str] = None"},{name:"revision",val:": typing.Optional[str] = None"}],parametersDescription:[{anchor:"huggingface_hub.hf_hub_url.repo_id",description:`<strong>repo_id</strong> (<code>str</code>) &#x2014;
A namespace (user or an organization) name and a repo name separated
by a <code>/</code>.`,name:"repo_id"},{anchor:"huggingface_hub.hf_hub_url.filename",description:`<strong>filename</strong> (<code>str</code>) &#x2014;
The name of the file in the repo.`,name:"filename"},{anchor:"huggingface_hub.hf_hub_url.subfolder",description:`<strong>subfolder</strong> (<code>str</code>, <em>optional</em>) &#x2014;
An optional value corresponding to a folder inside the repo.`,name:"subfolder"},{anchor:"huggingface_hub.hf_hub_url.repo_type",description:`<strong>repo_type</strong> (<code>str</code>, <em>optional</em>) &#x2014;
Set to <code>&quot;dataset&quot;</code> or <code>&quot;space&quot;</code> if uploading to a dataset or space,
<code>None</code> or <code>&quot;model&quot;</code> if uploading to a model. Default is <code>None</code>.`,name:"repo_type"},{anchor:"huggingface_hub.hf_hub_url.revision",description:`<strong>revision</strong> (<code>str</code>, <em>optional</em>) &#x2014;
An optional Git revision id which can be a branch name, a tag, or a
commit hash.`,name:"revision"}],source:"https://github.com/huggingface/huggingface_hub/blob/vr_878/src/huggingface_hub/file_download.py#L154"}}),fe=new So({props:{anchor:"huggingface_hub.hf_hub_url.example",$$slots:{default:[Bo]},$$scope:{ctx:X}}}),pe=new Se({props:{$$slots:{default:[Ho]},$$scope:{ctx:X}}}),{c(){h=n("meta"),O=p(),_=n("h1"),i=n("a"),f=n("span"),ne(d.$$.fragment),m=p(),I=n("span"),A=l("Downloading files"),y=p(),b=n("div"),ne(N.$$.fragment),R=p(),E=n("p"),c=l("Download a given file if it\u2019s not already present in the local cache."),v=p(),U=n("p"),S=l("The new cache file layout looks like this:"),C=p(),w=n("ul"),T=n("li"),q=l("The cache directory contains one subfolder per repo_id (namespaced by repo type)"),V=p(),j=n("li"),g=l("inside each repo folder:"),$=n("ul"),D=n("li"),P=l("refs is a list of the latest known revision => commit_hash pairs"),Y=p(),z=n("li"),Z=l(`blobs contains the actual file blobs (identified by their git-sha or sha256, depending on
whether they\u2019re LFS files or not)`),M=p(),G=n("li"),ee=l(`snapshots contains one subfolder per commit, each \u201Ccommit\u201D contains the subset of the files
that have been resolved at that particular commit. Each filename is a symlink to the blob
at that particular commit.`),B=p(),K=n("p"),oe=l(`[  96]  .
\u2514\u2500\u2500 [ 160]  models\u2014julien-c\u2014EsperBERTo-small
\u251C\u2500\u2500 [ 160]  blobs
\u2502   \u251C\u2500\u2500 [321M]  403450e234d65943a7dcf7e05a771ce3c92faa84dd07db4ac20f592037a1e4bd
\u2502   \u251C\u2500\u2500 [ 398]  7cb18dc9bafbfcf74629a4b760af1b160957a83e
\u2502   \u2514\u2500\u2500 [1.4K]  d7edf6bd2a681fb0175f7735299831ee1b22b812
\u251C\u2500\u2500 [  96]  refs
\u2502   \u2514\u2500\u2500 [  40]  main
\u2514\u2500\u2500 [ 128]  snapshots
\u251C\u2500\u2500 [ 128]  2439f60ef33a0d46d85da5001d52aeda5b00ce9f
\u2502   \u251C\u2500\u2500 [  52]  README.md -> ../../blobs/d7edf6bd2a681fb0175f7735299831ee1b22b812
\u2502   \u2514\u2500\u2500 [  76]  pytorch_model.bin -> ../../blobs/403450e234d65943a7dcf7e05a771ce3c92faa84dd07db4ac20f592037a1e4bd
\u2514\u2500\u2500 [ 128]  bbc77c8132af1cc5cf678da3f1ddf2de43606d48
\u251C\u2500\u2500 [  52]  README.md -> ../../blobs/7cb18dc9bafbfcf74629a4b760af1b160957a83e
\u2514\u2500\u2500 [  76]  pytorch_model.bin -> ../../blobs/403450e234d65943a7dcf7e05a771ce3c92faa84dd07db4ac20f592037a1e4bd`),Ve=p(),ne(de.$$.fragment),Ae=p(),H=n("div"),ne(ge.$$.fragment),Me=p(),Ee=n("p"),Be=l("Download all files of a repo."),He=p(),$e=n("p"),We=l(`Downloads a whole snapshot of a repo\u2019s files at the specified revision. This
is useful when you want all files from a repo, because you don\u2019t know which
ones you will need a priori. All files are nested inside a folder in order
to keep their actual filename relative to that folder.`),ze=p(),xe=n("p"),Ge=l(`An alternative would be to just clone a repo but this would require that the
user always has git and git-lfs installed, and properly configured.`),Ke=p(),ne(ce.$$.fragment),Ue=p(),Q=n("div"),ne(me.$$.fragment),Je=p(),Te=n("p"),Qe=l(`Download from a given URL and cache it if it\u2019s not already present in the
local cache.`),Xe=p(),ke=n("p"),Ye=l(`Given a URL, this function looks for the corresponding file in the local
cache. If it\u2019s not there, download it. Then return the path to the cached
file.`),Ze=p(),ne(he.$$.fragment),Ce=p(),F=n("div"),ne(_e.$$.fragment),eo=p(),De=n("p"),oo=l("Construct the URL of a file from the given information."),no=p(),Ne=n("p"),to=l(`The resolved address can either be a huggingface.co-hosted url, or a link to
Cloudfront (a Content Delivery Network, or CDN) for large files which are
more than a few MBs.`),ao=p(),ne(fe.$$.fragment),ro=p(),ne(pe.$$.fragment),io=p(),Oe=n("p"),lo=l("References:"),so=p(),Le=n("ul"),ye=n("li"),co=l("[1] "),be=n("a"),ho=l("https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/ETag"),this.h()},l(r){const L=Ao('[data-svelte="svelte-1phssyn"]',document.head);h=t(L,"META",{name:!0,content:!0}),L.forEach(o),O=u(r),_=t(r,"H1",{class:!0});var ve=a(_);i=t(ve,"A",{id:!0,class:!0,href:!0});var Ie=a(i);f=t(Ie,"SPAN",{});var qe=a(f);te(d.$$.fragment,qe),qe.forEach(o),Ie.forEach(o),m=u(ve),I=t(ve,"SPAN",{});var Pe=a(I);A=s(Pe,"Downloading files"),Pe.forEach(o),ve.forEach(o),y=u(r),b=t(r,"DIV",{class:!0});var W=a(b);te(N.$$.fragment,W),R=u(W),E=t(W,"P",{});var uo=a(E);c=s(uo,"Download a given file if it\u2019s not already present in the local cache."),uo.forEach(o),v=u(W),U=t(W,"P",{});var go=a(U);S=s(go,"The new cache file layout looks like this:"),go.forEach(o),C=u(W),w=t(W,"UL",{});var Fe=a(w);T=t(Fe,"LI",{});var mo=a(T);q=s(mo,"The cache directory contains one subfolder per repo_id (namespaced by repo type)"),mo.forEach(o),V=u(Fe),j=t(Fe,"LI",{});var fo=a(j);g=s(fo,"inside each repo folder:"),$=t(fo,"UL",{});var we=a($);D=t(we,"LI",{});var _o=a(D);P=s(_o,"refs is a list of the latest known revision => commit_hash pairs"),_o.forEach(o),Y=u(we),z=t(we,"LI",{});var bo=a(z);Z=s(bo,`blobs contains the actual file blobs (identified by their git-sha or sha256, depending on
whether they\u2019re LFS files or not)`),bo.forEach(o),M=u(we),G=t(we,"LI",{});var vo=a(G);ee=s(vo,`snapshots contains one subfolder per commit, each \u201Ccommit\u201D contains the subset of the files
that have been resolved at that particular commit. Each filename is a symlink to the blob
at that particular commit.`),vo.forEach(o),we.forEach(o),fo.forEach(o),Fe.forEach(o),B=u(W),K=t(W,"P",{});var yo=a(K);oe=s(yo,`[  96]  .
\u2514\u2500\u2500 [ 160]  models\u2014julien-c\u2014EsperBERTo-small
\u251C\u2500\u2500 [ 160]  blobs
\u2502   \u251C\u2500\u2500 [321M]  403450e234d65943a7dcf7e05a771ce3c92faa84dd07db4ac20f592037a1e4bd
\u2502   \u251C\u2500\u2500 [ 398]  7cb18dc9bafbfcf74629a4b760af1b160957a83e
\u2502   \u2514\u2500\u2500 [1.4K]  d7edf6bd2a681fb0175f7735299831ee1b22b812
\u251C\u2500\u2500 [  96]  refs
\u2502   \u2514\u2500\u2500 [  40]  main
\u2514\u2500\u2500 [ 128]  snapshots
\u251C\u2500\u2500 [ 128]  2439f60ef33a0d46d85da5001d52aeda5b00ce9f
\u2502   \u251C\u2500\u2500 [  52]  README.md -> ../../blobs/d7edf6bd2a681fb0175f7735299831ee1b22b812
\u2502   \u2514\u2500\u2500 [  76]  pytorch_model.bin -> ../../blobs/403450e234d65943a7dcf7e05a771ce3c92faa84dd07db4ac20f592037a1e4bd
\u2514\u2500\u2500 [ 128]  bbc77c8132af1cc5cf678da3f1ddf2de43606d48
\u251C\u2500\u2500 [  52]  README.md -> ../../blobs/7cb18dc9bafbfcf74629a4b760af1b160957a83e
\u2514\u2500\u2500 [  76]  pytorch_model.bin -> ../../blobs/403450e234d65943a7dcf7e05a771ce3c92faa84dd07db4ac20f592037a1e4bd`),yo.forEach(o),Ve=u(W),te(de.$$.fragment,W),W.forEach(o),Ae=u(r),H=t(r,"DIV",{class:!0});var se=a(H);te(ge.$$.fragment,se),Me=u(se),Ee=t(se,"P",{});var wo=a(Ee);Be=s(wo,"Download all files of a repo."),wo.forEach(o),He=u(se),$e=t(se,"P",{});var Eo=a($e);We=s(Eo,`Downloads a whole snapshot of a repo\u2019s files at the specified revision. This
is useful when you want all files from a repo, because you don\u2019t know which
ones you will need a priori. All files are nested inside a folder in order
to keep their actual filename relative to that folder.`),Eo.forEach(o),ze=u(se),xe=t(se,"P",{});var $o=a(xe);Ge=s($o,`An alternative would be to just clone a repo but this would require that the
user always has git and git-lfs installed, and properly configured.`),$o.forEach(o),Ke=u(se),te(ce.$$.fragment,se),se.forEach(o),Ue=u(r),Q=t(r,"DIV",{class:!0});var ue=a(Q);te(me.$$.fragment,ue),Je=u(ue),Te=t(ue,"P",{});var xo=a(Te);Qe=s(xo,`Download from a given URL and cache it if it\u2019s not already present in the
local cache.`),xo.forEach(o),Xe=u(ue),ke=t(ue,"P",{});var To=a(ke);Ye=s(To,`Given a URL, this function looks for the corresponding file in the local
cache. If it\u2019s not there, download it. Then return the path to the cached
file.`),To.forEach(o),Ze=u(ue),te(he.$$.fragment,ue),ue.forEach(o),Ce=u(r),F=t(r,"DIV",{class:!0});var J=a(F);te(_e.$$.fragment,J),eo=u(J),De=t(J,"P",{});var ko=a(De);oo=s(ko,"Construct the URL of a file from the given information."),ko.forEach(o),no=u(J),Ne=t(J,"P",{});var Do=a(Ne);to=s(Do,`The resolved address can either be a huggingface.co-hosted url, or a link to
Cloudfront (a Content Delivery Network, or CDN) for large files which are
more than a few MBs.`),Do.forEach(o),ao=u(J),te(fe.$$.fragment,J),ro=u(J),te(pe.$$.fragment,J),io=u(J),Oe=t(J,"P",{});var No=a(Oe);lo=s(No,"References:"),No.forEach(o),so=u(J),Le=t(J,"UL",{});var Oo=a(Le);ye=t(Oo,"LI",{});var po=a(ye);co=s(po,"[1] "),be=t(po,"A",{href:!0,rel:!0});var Lo=a(be);ho=s(Lo,"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/ETag"),Lo.forEach(o),po.forEach(o),Oo.forEach(o),J.forEach(o),this.h()},h(){x(h,"name","hf:doc:metadata"),x(h,"content",JSON.stringify(zo)),x(i,"id","huggingface_hub.hf_hub_download"),x(i,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),x(i,"href","#huggingface_hub.hf_hub_download"),x(_,"class","relative group"),x(b,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),x(H,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),x(Q,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),x(be,"href","https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/ETag"),x(be,"rel","nofollow"),x(F,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8")},m(r,L){e(document.head,h),k(r,O,L),k(r,_,L),e(_,i),e(i,f),ae(d,f,null),e(_,m),e(_,I),e(I,A),k(r,y,L),k(r,b,L),ae(N,b,null),e(b,R),e(b,E),e(E,c),e(b,v),e(b,U),e(U,S),e(b,C),e(b,w),e(w,T),e(T,q),e(w,V),e(w,j),e(j,g),e(j,$),e($,D),e(D,P),e($,Y),e($,z),e(z,Z),e($,M),e($,G),e(G,ee),e(b,B),e(b,K),e(K,oe),e(b,Ve),ae(de,b,null),k(r,Ae,L),k(r,H,L),ae(ge,H,null),e(H,Me),e(H,Ee),e(Ee,Be),e(H,He),e(H,$e),e($e,We),e(H,ze),e(H,xe),e(xe,Ge),e(H,Ke),ae(ce,H,null),k(r,Ue,L),k(r,Q,L),ae(me,Q,null),e(Q,Je),e(Q,Te),e(Te,Qe),e(Q,Xe),e(Q,ke),e(ke,Ye),e(Q,Ze),ae(he,Q,null),k(r,Ce,L),k(r,F,L),ae(_e,F,null),e(F,eo),e(F,De),e(De,oo),e(F,no),e(F,Ne),e(Ne,to),e(F,ao),ae(fe,F,null),e(F,ro),ae(pe,F,null),e(F,io),e(F,Oe),e(Oe,lo),e(F,so),e(F,Le),e(Le,ye),e(ye,co),e(ye,be),e(be,ho),Re=!0},p(r,[L]){const ve={};L&2&&(ve.$$scope={dirty:L,ctx:r}),de.$set(ve);const Ie={};L&2&&(Ie.$$scope={dirty:L,ctx:r}),ce.$set(Ie);const qe={};L&2&&(qe.$$scope={dirty:L,ctx:r}),he.$set(qe);const Pe={};L&2&&(Pe.$$scope={dirty:L,ctx:r}),fe.$set(Pe);const W={};L&2&&(W.$$scope={dirty:L,ctx:r}),pe.$set(W)},i(r){Re||(re(d.$$.fragment,r),re(N.$$.fragment,r),re(de.$$.fragment,r),re(ge.$$.fragment,r),re(ce.$$.fragment,r),re(me.$$.fragment,r),re(he.$$.fragment,r),re(_e.$$.fragment,r),re(fe.$$.fragment,r),re(pe.$$.fragment,r),Re=!0)},o(r){ie(d.$$.fragment,r),ie(N.$$.fragment,r),ie(de.$$.fragment,r),ie(ge.$$.fragment,r),ie(ce.$$.fragment,r),ie(me.$$.fragment,r),ie(he.$$.fragment,r),ie(_e.$$.fragment,r),ie(fe.$$.fragment,r),ie(pe.$$.fragment,r),Re=!1},d(r){o(h),r&&o(O),r&&o(_),le(d),r&&o(y),r&&o(b),le(N),le(de),r&&o(Ae),r&&o(H),le(ge),le(ce),r&&o(Ue),r&&o(Q),le(me),le(he),r&&o(Ce),r&&o(F),le(_e),le(fe),le(pe)}}}const zo={local:"huggingface_hub.hf_hub_download",title:"Downloading files"};function Go(X){return Uo(()=>{new URLSearchParams(window.location.search).get("fw")}),[]}class en extends Io{constructor(h){super();qo(this,h,Go,Wo,Po,{})}}export{en as default,zo as metadata};
