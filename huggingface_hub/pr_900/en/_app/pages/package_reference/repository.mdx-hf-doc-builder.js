import{S as ng,i as ag,s as sg,e as r,k as l,w as d,t as s,M as ig,c as n,d as o,m as c,a,x as u,h as i,b as p,G as e,g as $,y as m,q as f,o as _,B as b,v as lg,L as cg}from"../../chunks/vendor-hf-doc-builder.js";import{D as v}from"../../chunks/Docstring-hf-doc-builder.js";import{C as gg}from"../../chunks/CodeBlock-hf-doc-builder.js";import{I as Tn}from"../../chunks/IconCopyLink-hf-doc-builder.js";import{E as hg}from"../../chunks/ExampleCodeBlock-hf-doc-builder.js";function pg(xr){let E,se,D,x,j;return x=new gg({props:{code:`with Repository(
    "text-files",
    clone_from="<user>/text-files",
    use_auth_token=True,
).commit("My first file :)"):
    with open("file.txt", "w+") as f:
        f.write(json.dumps({"hey": 8}))

import torch

model = torch.nn.Transformer()
with Repository(
    "torch-model",
    clone_from="<user>/torch-model",
    use_auth_token=True,
).commit("My cool model :)"):
    torch.save(model.state_dict(), "model.pt")`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">with</span> Repository(
<span class="hljs-meta">... </span>    <span class="hljs-string">&quot;text-files&quot;</span>,
<span class="hljs-meta">... </span>    clone_from=<span class="hljs-string">&quot;&lt;user&gt;/text-files&quot;</span>,
<span class="hljs-meta">... </span>    use_auth_token=<span class="hljs-literal">True</span>,
<span class="hljs-meta">&gt;&gt;&gt; </span>).commit(<span class="hljs-string">&quot;My first file :)&quot;</span>):
<span class="hljs-meta">... </span>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;file.txt&quot;</span>, <span class="hljs-string">&quot;w+&quot;</span>) <span class="hljs-keyword">as</span> f:
<span class="hljs-meta">... </span>        f.write(json.dumps({<span class="hljs-string">&quot;hey&quot;</span>: <span class="hljs-number">8</span>}))

<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> torch

<span class="hljs-meta">&gt;&gt;&gt; </span>model = torch.nn.Transformer()
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">with</span> Repository(
<span class="hljs-meta">... </span>    <span class="hljs-string">&quot;torch-model&quot;</span>,
<span class="hljs-meta">... </span>    clone_from=<span class="hljs-string">&quot;&lt;user&gt;/torch-model&quot;</span>,
<span class="hljs-meta">... </span>    use_auth_token=<span class="hljs-literal">True</span>,
<span class="hljs-meta">&gt;&gt;&gt; </span>).commit(<span class="hljs-string">&quot;My cool model :)&quot;</span>):
<span class="hljs-meta">... </span>    torch.save(model.state_dict(), <span class="hljs-string">&quot;model.pt&quot;</span>)`}}),{c(){E=r("p"),se=s("Examples:"),D=l(),d(x.$$.fragment)},l(w){E=n(w,"P",{});var H=a(E);se=i(H,"Examples:"),H.forEach(o),D=c(w),u(x.$$.fragment,w)},m(w,H){$(w,E,H),e(E,se),$(w,D,H),m(x,w,H),j=!0},p:cg,i(w){j||(f(x.$$.fragment,w),j=!0)},o(w){_(x.$$.fragment,w),j=!1},d(w){w&&o(E),w&&o(D),b(x,w)}}}function dg(xr){let E,se,D,x,j,w,H,Jt,Pn,Dr,R,In,Kt,On,Ln,Qt,Cn,Fn,Xt,Nn,jn,Rr,ie,Hn,Yt,Vn,An,Tr,W,le,Zt,Ue,Sn,eo,qn,Pr,g,Me,Un,to,Mn,Wn,oo,Bn,Gn,T,We,zn,ro,Jn,Kn,B,Qn,no,Xn,Yn,ao,Zn,ea,ta,P,so,oa,ra,io,na,aa,lo,sa,ia,co,la,ca,ga,ce,Be,ha,go,pa,da,I,Ge,ua,ho,ma,fa,po,_a,ba,uo,ya,va,ge,ze,$a,mo,wa,ka,he,Je,Ea,fo,xa,Da,pe,Ke,Ra,G,Ta,_o,Pa,Ia,bo,Oa,La,Ca,V,Qe,Fa,yo,Na,ja,vo,Ha,Va,A,Xe,Aa,z,Sa,$o,qa,Ua,wo,Ma,Wa,Ba,de,Ga,ue,Ye,za,ko,Ja,Ka,S,Ze,Qa,Eo,Xa,Ya,C,Za,xo,es,ts,Do,os,rs,Ro,ns,as,ss,q,et,is,To,ls,cs,J,gs,Po,hs,ps,Io,ds,us,ms,me,tt,fs,Oo,_s,bs,fe,ot,ys,Lo,vs,$s,_e,rt,ws,Ft,ks,Co,Es,xs,be,nt,Ds,Fo,Rs,Ts,ye,at,Ps,No,Is,Os,ve,st,Ls,jo,Cs,Fs,U,it,Ns,Ho,js,Hs,K,Vs,Vo,As,Ss,Ao,qs,Us,Ms,$e,lt,Ws,So,Bs,Gs,we,ct,zs,qo,Js,Ks,ke,gt,Qs,Uo,Xs,Ys,Ee,ht,Zs,Mo,ei,ti,M,pt,oi,Wo,ri,ni,F,ai,Bo,si,ii,Go,li,ci,zo,gi,hi,pi,xe,dt,di,Jo,ui,mi,De,ut,fi,Ko,_i,bi,Re,mt,yi,Qo,vi,$i,Te,ft,wi,Xo,ki,Ei,Pe,_t,xi,Yo,Di,Ir,Q,Ie,Zo,bt,Ri,er,Ti,Or,X,yt,Pi,tr,Ii,Lr,Y,vt,Oi,or,Li,Cr,Z,$t,Ci,rr,Fi,Fr,ee,wt,Ni,nr,ji,Nr,te,kt,Hi,ar,Vi,jr,oe,Et,Ai,sr,Si,Hr,N,xt,qi,ir,Ui,Mi,lr,Wi,Vr,re,Oe,cr,Dt,Bi,gr,Gi,Ar,Le,zi,hr,Ji,Ki,Sr,O,pr,dr,Qi,Xi,ur,mr,Yi,Zi,fr,_r,el,tl,Rt,ol,br,rl,nl,qr,Nt,al,Ur,k,Tt,sl,yr,il,ll,vr,cl,gl,Ce,Pt,hl,$r,pl,dl,Fe,It,ul,wr,ml,fl,Ne,Ot,_l,kr,bl,Mr,ne,Lt,yl,Er,vl,Wr;return w=new Tn({}),Ue=new Tn({}),Me=new v({props:{name:"class huggingface_hub.Repository",anchor:"huggingface_hub.Repository",parameters:[{name:"local_dir",val:": str"},{name:"clone_from",val:": typing.Optional[str] = None"},{name:"repo_type",val:": typing.Optional[str] = None"},{name:"use_auth_token",val:": typing.Union[bool, str] = True"},{name:"git_user",val:": typing.Optional[str] = None"},{name:"git_email",val:": typing.Optional[str] = None"},{name:"revision",val:": typing.Optional[str] = None"},{name:"private",val:": bool = False"},{name:"skip_lfs_files",val:": bool = False"},{name:"client",val:": typing.Optional[huggingface_hub.hf_api.HfApi] = None"}],source:"https://github.com/huggingface/huggingface_hub/blob/vr_900/src/huggingface_hub/repository.py#L413"}}),We=new v({props:{name:"__init__",anchor:"huggingface_hub.Repository.__init__",parameters:[{name:"local_dir",val:": str"},{name:"clone_from",val:": typing.Optional[str] = None"},{name:"repo_type",val:": typing.Optional[str] = None"},{name:"use_auth_token",val:": typing.Union[bool, str] = True"},{name:"git_user",val:": typing.Optional[str] = None"},{name:"git_email",val:": typing.Optional[str] = None"},{name:"revision",val:": typing.Optional[str] = None"},{name:"private",val:": bool = False"},{name:"skip_lfs_files",val:": bool = False"},{name:"client",val:": typing.Optional[huggingface_hub.hf_api.HfApi] = None"}],parametersDescription:[{anchor:"huggingface_hub.Repository.__init__.local_dir",description:`<strong>local_dir</strong> (<code>str</code>) &#x2014;
path (e.g. <code>&apos;my_trained_model/&apos;</code>) to the local directory, where
the <code>Repository</code> will be initalized.`,name:"local_dir"},{anchor:"huggingface_hub.Repository.__init__.clone_from",description:`<strong>clone_from</strong> (<code>str</code>, <em>optional</em>) &#x2014;
repository url (e.g.
<code>&apos;https://huggingface.co/philschmid/playground-tests&apos;</code>).`,name:"clone_from"},{anchor:"huggingface_hub.Repository.__init__.repo_type",description:`<strong>repo_type</strong> (<code>str</code>, <em>optional</em>) &#x2014;
To set when creating a repo: et to &#x201C;dataset&#x201D; or &#x201C;space&#x201D; if
creating a dataset or space, default is model.`,name:"repo_type"},{anchor:"huggingface_hub.Repository.__init__.use_auth_token",description:`<strong>use_auth_token</strong> (<code>str</code> or <code>bool</code>, <em>optional</em>, defaults to <code>True</code>) &#x2014;
huggingface_token can be extract from <code>HfApi().login(username, password)</code> and is used to authenticate against the hub (useful
from Google Colab for instance).`,name:"use_auth_token"},{anchor:"huggingface_hub.Repository.__init__.git_user",description:`<strong>git_user</strong> (<code>str</code>, <em>optional</em>) &#x2014;
will override the <code>git config user.name</code> for committing and
pushing files to the hub.`,name:"git_user"},{anchor:"huggingface_hub.Repository.__init__.git_email",description:`<strong>git_email</strong> (<code>str</code>, <em>optional</em>) &#x2014;
will override the <code>git config user.email</code> for committing and
pushing files to the hub.`,name:"git_email"},{anchor:"huggingface_hub.Repository.__init__.revision",description:`<strong>revision</strong> (<code>str</code>, <em>optional</em>) &#x2014;
Revision to checkout after initializing the repository. If the
revision doesn&#x2019;t exist, a branch will be created with that
revision name from the default branch&#x2019;s current HEAD.`,name:"revision"},{anchor:"huggingface_hub.Repository.__init__.private",description:`<strong>private</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
whether the repository is private or not.`,name:"private"},{anchor:"huggingface_hub.Repository.__init__.skip_lfs_files",description:`<strong>skip_lfs_files</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
whether to skip git-LFS files or not.`,name:"skip_lfs_files"},{anchor:"huggingface_hub.Repository.__init__.client",description:`<strong>client</strong> (<code>HfApi</code>, <em>optional</em>) &#x2014;
Instance of HfApi to use when calling the HF Hub API. A new
instance will be created if this is left to <code>None</code>.`,name:"client"}],source:"https://github.com/huggingface/huggingface_hub/blob/vr_900/src/huggingface_hub/repository.py#L424"}}),Be=new v({props:{name:"current_branch",anchor:"huggingface_hub.Repository.current_branch",parameters:[],source:"https://github.com/huggingface/huggingface_hub/blob/vr_900/src/huggingface_hub/repository.py#L534",returnDescription:`
<p>Current checked out branch.</p>
`,returnType:`
<p><code>str</code></p>
`}}),Ge=new v({props:{name:"add_tag",anchor:"huggingface_hub.Repository.add_tag",parameters:[{name:"tag_name",val:": str"},{name:"message",val:": str = None"},{name:"remote",val:": typing.Optional[str] = None"}],parametersDescription:[{anchor:"huggingface_hub.Repository.add_tag.tag_name",description:`<strong>tag_name</strong> (<code>str</code>) &#x2014;
The name of the tag to be added.`,name:"tag_name"},{anchor:"huggingface_hub.Repository.add_tag.message",description:`<strong>message</strong> (<code>str</code>, <em>optional</em>) &#x2014;
The message that accompanies the tag. The tag will turn into an
annotated tag if a message is passed.`,name:"message"},{anchor:"huggingface_hub.Repository.add_tag.remote",description:`<strong>remote</strong> (<code>str</code>, <em>optional</em>) &#x2014;
The remote on which to add the tag.`,name:"remote"}],source:"https://github.com/huggingface/huggingface_hub/blob/vr_900/src/huggingface_hub/repository.py#L1294"}}),ze=new v({props:{name:"auto_track_binary_files",anchor:"huggingface_hub.Repository.auto_track_binary_files",parameters:[{name:"pattern",val:": typing.Optional[str] = '.'"}],parametersDescription:[{anchor:"huggingface_hub.Repository.auto_track_binary_files.pattern",description:`<strong>pattern</strong> (<code>str</code>, <em>optional</em>, defaults to &#x201D;.&#x201C;) &#x2014;
The pattern with which to track files that are binary.`,name:"pattern"}],source:"https://github.com/huggingface/huggingface_hub/blob/vr_900/src/huggingface_hub/repository.py#L904",returnDescription:`
<p>List of filenames that are now tracked due to being
binary files</p>
`,returnType:`
<p><code>List[str]</code></p>
`}}),Je=new v({props:{name:"auto_track_large_files",anchor:"huggingface_hub.Repository.auto_track_large_files",parameters:[{name:"pattern",val:": typing.Optional[str] = '.'"}],parametersDescription:[{anchor:"huggingface_hub.Repository.auto_track_large_files.pattern",description:`<strong>pattern</strong> (<code>str</code>, <em>optional</em>, defaults to &#x201D;.&#x201C;) &#x2014;
The pattern with which to track files that are above 10MBs.`,name:"pattern"}],source:"https://github.com/huggingface/huggingface_hub/blob/vr_900/src/huggingface_hub/repository.py#L947",returnDescription:`
<p>List of filenames that are now tracked due to their
size.</p>
`,returnType:`
<p><code>List[str]</code></p>
`}}),Ke=new v({props:{name:"check_git_versions",anchor:"huggingface_hub.Repository.check_git_versions",parameters:[],source:"https://github.com/huggingface/huggingface_hub/blob/vr_900/src/huggingface_hub/repository.py#L551"}}),Qe=new v({props:{name:"clone_from",anchor:"huggingface_hub.Repository.clone_from",parameters:[{name:"repo_url",val:": str"},{name:"use_auth_token",val:": typing.Union[bool, str, NoneType] = None"}],parametersDescription:[{anchor:"huggingface_hub.Repository.clone_from.repo_url",description:`<strong>repo_url</strong> (<code>str</code>) &#x2014;
The URL from which to clone the repository`,name:"repo_url"},{anchor:"huggingface_hub.Repository.clone_from.use_auth_token",description:`<strong>use_auth_token</strong> (<code>Union[str, bool]</code>, <em>optional</em>) &#x2014;
Whether to use the authentication token. It can be:<ul>
<li>a string which is the token itself</li>
<li><code>False</code>, which would not use the authentication token</li>
<li><code>True</code>, which would fetch the authentication token from the
local folder and use it (you should be logged in for this to
work).</li>
<li><code>None</code>, which would retrieve the value of
<code>self.huggingface_token</code>.</li>
</ul>`,name:"use_auth_token"}],source:"https://github.com/huggingface/huggingface_hub/blob/vr_900/src/huggingface_hub/repository.py#L579"}}),Xe=new v({props:{name:"commit",anchor:"huggingface_hub.Repository.commit",parameters:[{name:"commit_message",val:": str"},{name:"branch",val:": typing.Optional[str] = None"},{name:"track_large_files",val:": typing.Optional[bool] = True"},{name:"blocking",val:": typing.Optional[bool] = True"},{name:"auto_lfs_prune",val:": typing.Optional[bool] = False"}],parametersDescription:[{anchor:"huggingface_hub.Repository.commit.commit_message",description:`<strong>commit_message</strong> (<code>str</code>) &#x2014;
Message to use for the commit.`,name:"commit_message"},{anchor:"huggingface_hub.Repository.commit.branch",description:`<strong>branch</strong> (<code>str</code>, <em>optional</em>) &#x2014;
The branch on which the commit will appear. This branch will be
checked-out before any operation.`,name:"branch"},{anchor:"huggingface_hub.Repository.commit.track_large_files",description:`<strong>track_large_files</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>True</code>) &#x2014;
Whether to automatically track large files or not. Will do so by
default.`,name:"track_large_files"},{anchor:"huggingface_hub.Repository.commit.blocking",description:`<strong>blocking</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>True</code>) &#x2014;
Whether the function should return only when the <code>git push</code> has
finished.`,name:"blocking"},{anchor:"huggingface_hub.Repository.commit.auto_lfs_prune",description:`<strong>auto_lfs_prune</strong> (<code>bool</code>, defaults to <code>True</code>) &#x2014;
Whether to automatically prune files once they have been pushed
to the remote.`,name:"auto_lfs_prune"}],source:"https://github.com/huggingface/huggingface_hub/blob/vr_900/src/huggingface_hub/repository.py#L1382"}}),de=new hg({props:{anchor:"huggingface_hub.Repository.commit.example",$$slots:{default:[pg]},$$scope:{ctx:xr}}}),Ye=new v({props:{name:"delete_tag",anchor:"huggingface_hub.Repository.delete_tag",parameters:[{name:"tag_name",val:": str"},{name:"remote",val:": typing.Optional[str] = None"}],parametersDescription:[{anchor:"huggingface_hub.Repository.delete_tag.tag_name",description:`<strong>tag_name</strong> (<code>str</code>) &#x2014;
The tag name to delete.`,name:"tag_name"},{anchor:"huggingface_hub.Repository.delete_tag.remote",description:`<strong>remote</strong> (<code>str</code>, <em>optional</em>) &#x2014;
The remote on which to delete the tag.`,name:"remote"}],source:"https://github.com/huggingface/huggingface_hub/blob/vr_900/src/huggingface_hub/repository.py#L1253",returnDescription:`
<p><code>True</code> if deleted, <code>False</code> if the tag didn\u2019t exist.
If remote is not passed, will just be updated locally</p>
`,returnType:`
<p><code>bool</code></p>
`}}),Ze=new v({props:{name:"git_add",anchor:"huggingface_hub.Repository.git_add",parameters:[{name:"pattern",val:": typing.Optional[str] = '.'"},{name:"auto_lfs_track",val:": typing.Optional[bool] = False"}],parametersDescription:[{anchor:"huggingface_hub.Repository.git_add.pattern",description:`<strong>pattern</strong> (<code>str</code>, <em>optional</em>, defaults to &#x201D;.&#x201C;) &#x2014;
The pattern with which to add files to staging.`,name:"pattern"},{anchor:"huggingface_hub.Repository.git_add.auto_lfs_track",description:`<strong>auto_lfs_track</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether to automatically track large and binary files with
git-lfs. Any file over 10MB in size, or in binary format, will
be automatically tracked.`,name:"auto_lfs_track"}],source:"https://github.com/huggingface/huggingface_hub/blob/vr_900/src/huggingface_hub/repository.py#L1035"}}),et=new v({props:{name:"git_checkout",anchor:"huggingface_hub.Repository.git_checkout",parameters:[{name:"revision",val:": str"},{name:"create_branch_ok",val:": typing.Optional[bool] = False"}],parametersDescription:[{anchor:"huggingface_hub.Repository.git_checkout.revision",description:`<strong>revision</strong> (<code>str</code>) &#x2014;
The revision to checkout.`,name:"revision"},{anchor:"huggingface_hub.Repository.git_checkout.create_branch_ok",description:`<strong>create_branch_ok</strong> (<code>str</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether creating a branch named with the <code>revision</code> passed at
the current checked-out reference if <code>revision</code> isn&#x2019;t an
existing revision is allowed.`,name:"create_branch_ok"}],source:"https://github.com/huggingface/huggingface_hub/blob/vr_900/src/huggingface_hub/repository.py#L1184"}}),tt=new v({props:{name:"git_commit",anchor:"huggingface_hub.Repository.git_commit",parameters:[{name:"commit_message",val:": str = 'commit files to HF hub'"}],parametersDescription:[{anchor:"huggingface_hub.Repository.git_commit.commit_message",description:`<strong>commit_message</strong> (<code>str</code>, <em>optional</em>, defaults to &#x201C;commit files to HF hub&#x201D;) &#x2014;
The message attributed to the commit.`,name:"commit_message"}],source:"https://github.com/huggingface/huggingface_hub/blob/vr_900/src/huggingface_hub/repository.py#L1071"}}),ot=new v({props:{name:"git_config_username_and_email",anchor:"huggingface_hub.Repository.git_config_username_and_email",parameters:[{name:"git_user",val:": typing.Optional[str] = None"},{name:"git_email",val:": typing.Optional[str] = None"}],parametersDescription:[{anchor:"huggingface_hub.Repository.git_config_username_and_email.git_user",description:`<strong>git_user</strong> (<code>str</code>, <em>optional</em>) &#x2014;
The username to register through <code>git</code>.`,name:"git_user"},{anchor:"huggingface_hub.Repository.git_config_username_and_email.git_email",description:`<strong>git_email</strong> (<code>str</code>, <em>optional</em>) &#x2014;
The email to register through <code>git</code>.`,name:"git_email"}],source:"https://github.com/huggingface/huggingface_hub/blob/vr_900/src/huggingface_hub/repository.py#L729"}}),rt=new v({props:{name:"git_credential_helper_store",anchor:"huggingface_hub.Repository.git_credential_helper_store",parameters:[],source:"https://github.com/huggingface/huggingface_hub/blob/vr_900/src/huggingface_hub/repository.py#L754"}}),nt=new v({props:{name:"git_head_commit_url",anchor:"huggingface_hub.Repository.git_head_commit_url",parameters:[],source:"https://github.com/huggingface/huggingface_hub/blob/vr_900/src/huggingface_hub/repository.py#L793",returnDescription:`
<p>The URL to the current checked-out commit.</p>
`,returnType:`
<p><code>str</code></p>
`}}),at=new v({props:{name:"git_head_hash",anchor:"huggingface_hub.Repository.git_head_hash",parameters:[],source:"https://github.com/huggingface/huggingface_hub/blob/vr_900/src/huggingface_hub/repository.py#L763",returnDescription:`
<p>The current checked out commit SHA.</p>
`,returnType:`
<p><code>str</code></p>
`}}),st=new v({props:{name:"git_pull",anchor:"huggingface_hub.Repository.git_pull",parameters:[{name:"rebase",val:": typing.Optional[bool] = False"},{name:"lfs",val:": typing.Optional[bool] = False"}],parametersDescription:[{anchor:"huggingface_hub.Repository.git_pull.rebase",description:`<strong>rebase</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether to rebase the current branch on top of the upstream
branch after fetching.`,name:"rebase"},{anchor:"huggingface_hub.Repository.git_pull.lfs",description:`<strong>lfs</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether to fetch the LFS files too. This option only changes the
behavior when a repository was cloned without fetching the LFS
files; calling <code>repo.git_pull(lfs=True)</code> will then fetch the LFS
file from the remote repository.`,name:"lfs"}],source:"https://github.com/huggingface/huggingface_hub/blob/vr_900/src/huggingface_hub/repository.py#L1008"}}),it=new v({props:{name:"git_push",anchor:"huggingface_hub.Repository.git_push",parameters:[{name:"upstream",val:": typing.Optional[str] = None"},{name:"blocking",val:": typing.Optional[bool] = True"},{name:"auto_lfs_prune",val:": typing.Optional[bool] = False"}],parametersDescription:[{anchor:"huggingface_hub.Repository.git_push.upstream",description:`<strong>upstream</strong> (<code>str</code>, <em>optional</em>) &#x2014;
Upstream to which this should push. If not specified, will push
to the lastly defined upstream or to the default one (<code>origin main</code>).`,name:"upstream"},{anchor:"huggingface_hub.Repository.git_push.blocking",description:`<strong>blocking</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>True</code>) &#x2014;
Whether the function should return only when the push has
finished. Setting this to <code>False</code> will return an
<code>CommandInProgress</code> object which has an <code>is_done</code> property. This
property will be set to <code>True</code> when the push is finished.`,name:"blocking"},{anchor:"huggingface_hub.Repository.git_push.auto_lfs_prune",description:`<strong>auto_lfs_prune</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether to automatically prune files once they have been pushed
to the remote.`,name:"auto_lfs_prune"}],source:"https://github.com/huggingface/huggingface_hub/blob/vr_900/src/huggingface_hub/repository.py#L1090"}}),lt=new v({props:{name:"git_remote_url",anchor:"huggingface_hub.Repository.git_remote_url",parameters:[],source:"https://github.com/huggingface/huggingface_hub/blob/vr_900/src/huggingface_hub/repository.py#L776",returnDescription:`
<p>The URL of the <code>origin</code> remote.</p>
`,returnType:`
<p><code>str</code></p>
`}}),ct=new v({props:{name:"is_repo_clean",anchor:"huggingface_hub.Repository.is_repo_clean",parameters:[],source:"https://github.com/huggingface/huggingface_hub/blob/vr_900/src/huggingface_hub/repository.py#L1330",returnDescription:`
<p><code>True</code> if the git status is clean, <code>False</code> otherwise.</p>
`,returnType:`
<p><code>bool</code></p>
`}}),gt=new v({props:{name:"lfs_enable_largefiles",anchor:"huggingface_hub.Repository.lfs_enable_largefiles",parameters:[],source:"https://github.com/huggingface/huggingface_hub/blob/vr_900/src/huggingface_hub/repository.py#L890"}}),ht=new v({props:{name:"lfs_prune",anchor:"huggingface_hub.Repository.lfs_prune",parameters:[{name:"recent",val:" = False"}],parametersDescription:[{anchor:"huggingface_hub.Repository.lfs_prune.recent",description:`<strong>recent</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether to prune files even if they were referenced by recent
commits. See the following
<a href="https://github.com/git-lfs/git-lfs/blob/f3d43f0428a84fc4f1e5405b76b5a73ec2437e65/docs/man/git-lfs-prune.1.ronn#recent-files" rel="nofollow">link</a>
for more information.`,name:"recent"}],source:"https://github.com/huggingface/huggingface_hub/blob/vr_900/src/huggingface_hub/repository.py#L984"}}),pt=new v({props:{name:"lfs_track",anchor:"huggingface_hub.Repository.lfs_track",parameters:[{name:"patterns",val:": typing.Union[str, typing.List[str]]"},{name:"filename",val:": typing.Optional[bool] = False"}],parametersDescription:[{anchor:"huggingface_hub.Repository.lfs_track.patterns",description:`<strong>patterns</strong> (<code>Union[str, List[str]]</code>) &#x2014;
The pattern, or list of patterns, to track with git-lfs.`,name:"patterns"},{anchor:"huggingface_hub.Repository.lfs_track.filename",description:`<strong>filename</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether to use the patterns as literal filenames.`,name:"filename"}],source:"https://github.com/huggingface/huggingface_hub/blob/vr_900/src/huggingface_hub/repository.py#L848"}}),dt=new v({props:{name:"lfs_untrack",anchor:"huggingface_hub.Repository.lfs_untrack",parameters:[{name:"patterns",val:": typing.Union[str, typing.List[str]]"}],parametersDescription:[{anchor:"huggingface_hub.Repository.lfs_untrack.patterns",description:`<strong>patterns</strong> (<code>Union[str, List[str]]</code>) &#x2014;
The pattern, or list of patterns, to untrack with git-lfs.`,name:"patterns"}],source:"https://github.com/huggingface/huggingface_hub/blob/vr_900/src/huggingface_hub/repository.py#L874"}}),ut=new v({props:{name:"list_deleted_files",anchor:"huggingface_hub.Repository.list_deleted_files",parameters:[],source:"https://github.com/huggingface/huggingface_hub/blob/vr_900/src/huggingface_hub/repository.py#L807",returnDescription:`
<p>A list of files that have been deleted in the working
directory or index.</p>
`,returnType:`
<p><code>List[str]</code></p>
`}}),mt=new v({props:{name:"push_to_hub",anchor:"huggingface_hub.Repository.push_to_hub",parameters:[{name:"commit_message",val:": typing.Optional[str] = 'commit files to HF hub'"},{name:"blocking",val:": typing.Optional[bool] = True"},{name:"clean_ok",val:": typing.Optional[bool] = True"},{name:"auto_lfs_prune",val:": typing.Optional[bool] = False"}],parametersDescription:[{anchor:"huggingface_hub.Repository.push_to_hub.commit_message",description:`<strong>commit_message</strong> (<code>str</code>) &#x2014;
Message to use for the commit.`,name:"commit_message"},{anchor:"huggingface_hub.Repository.push_to_hub.blocking",description:`<strong>blocking</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>True</code>) &#x2014;
Whether the function should return only when the <code>git push</code> has
finished.`,name:"blocking"},{anchor:"huggingface_hub.Repository.push_to_hub.clean_ok",description:`<strong>clean_ok</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>True</code>) &#x2014;
If True, this function will return None if the repo is
untouched. Default behavior is to fail because the git command
fails.`,name:"clean_ok"},{anchor:"huggingface_hub.Repository.push_to_hub.auto_lfs_prune",description:`<strong>auto_lfs_prune</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether to automatically prune files once they have been pushed
to the remote.`,name:"auto_lfs_prune"}],source:"https://github.com/huggingface/huggingface_hub/blob/vr_900/src/huggingface_hub/repository.py#L1346"}}),ft=new v({props:{name:"tag_exists",anchor:"huggingface_hub.Repository.tag_exists",parameters:[{name:"tag_name",val:": str"},{name:"remote",val:": typing.Optional[str] = None"}],parametersDescription:[{anchor:"huggingface_hub.Repository.tag_exists.tag_name",description:`<strong>tag_name</strong> (<code>str</code>) &#x2014;
The name of the tag to check.`,name:"tag_name"},{anchor:"huggingface_hub.Repository.tag_exists.remote",description:`<strong>remote</strong> (<code>str</code>, <em>optional</em>) &#x2014;
Whether to check if the tag exists on a remote. This parameter
should be the identifier of the remote.`,name:"remote"}],source:"https://github.com/huggingface/huggingface_hub/blob/vr_900/src/huggingface_hub/repository.py#L1219",returnDescription:`
<p>Whether the tag exists.</p>
`,returnType:`
<p><code>bool</code></p>
`}}),_t=new v({props:{name:"wait_for_commands",anchor:"huggingface_hub.Repository.wait_for_commands",parameters:[],source:"https://github.com/huggingface/huggingface_hub/blob/vr_900/src/huggingface_hub/repository.py#L1517"}}),bt=new Tn({}),yt=new v({props:{name:"huggingface_hub.repository.is_git_repo",anchor:"huggingface_hub.repository.is_git_repo",parameters:[{name:"folder",val:": typing.Union[str, pathlib.Path]"}],parametersDescription:[{anchor:"huggingface_hub.repository.is_git_repo.folder",description:`<strong>folder</strong> (<code>str</code>) &#x2014;
The folder in which to run the command.`,name:"folder"}],source:"https://github.com/huggingface/huggingface_hub/blob/vr_900/src/huggingface_hub/repository.py#L109",returnDescription:`
<p><code>True</code> if the repository is part of a repository, <code>False</code>
otherwise.</p>
`,returnType:`
<p><code>bool</code></p>
`}}),vt=new v({props:{name:"huggingface_hub.repository.is_local_clone",anchor:"huggingface_hub.repository.is_local_clone",parameters:[{name:"folder",val:": typing.Union[str, pathlib.Path]"},{name:"remote_url",val:": str"}],parametersDescription:[{anchor:"huggingface_hub.repository.is_local_clone.folder",description:`<strong>folder</strong> (<code>str</code> or <code>Path</code>) &#x2014;
The folder in which to run the command.`,name:"folder"},{anchor:"huggingface_hub.repository.is_local_clone.remote_url",description:`<strong>remote_url</strong> (<code>str</code>) &#x2014;
The url of a git repository.`,name:"remote_url"}],source:"https://github.com/huggingface/huggingface_hub/blob/vr_900/src/huggingface_hub/repository.py#L128",returnDescription:`
<p><code>True</code> if the repository is a local clone of the remote
repository specified, <code>False</code> otherwise.</p>
`,returnType:`
<p><code>bool</code></p>
`}}),$t=new v({props:{name:"huggingface_hub.repository.is_tracked_with_lfs",anchor:"huggingface_hub.repository.is_tracked_with_lfs",parameters:[{name:"filename",val:": typing.Union[str, pathlib.Path]"}],parametersDescription:[{anchor:"huggingface_hub.repository.is_tracked_with_lfs.filename",description:`<strong>filename</strong> (<code>str</code> or <code>Path</code>) &#x2014;
The filename to check.`,name:"filename"}],source:"https://github.com/huggingface/huggingface_hub/blob/vr_900/src/huggingface_hub/repository.py#L153",returnDescription:`
<p><code>True</code> if the file passed is tracked with git-lfs, <code>False</code>
otherwise.</p>
`,returnType:`
<p><code>bool</code></p>
`}}),wt=new v({props:{name:"huggingface_hub.repository.is_git_ignored",anchor:"huggingface_hub.repository.is_git_ignored",parameters:[{name:"filename",val:": typing.Union[str, pathlib.Path]"}],parametersDescription:[{anchor:"huggingface_hub.repository.is_git_ignored.filename",description:`<strong>filename</strong> (<code>str</code> or <code>Path</code>) &#x2014;
The filename to check.`,name:"filename"}],source:"https://github.com/huggingface/huggingface_hub/blob/vr_900/src/huggingface_hub/repository.py#L190",returnDescription:`
<p><code>True</code> if the file passed is ignored by <code>git</code>, <code>False</code>
otherwise.</p>
`,returnType:`
<p><code>bool</code></p>
`}}),kt=new v({props:{name:"huggingface_hub.repository.files_to_be_staged",anchor:"huggingface_hub.repository.files_to_be_staged",parameters:[{name:"pattern",val:": str"},{name:"folder",val:": typing.Union[str, pathlib.Path]"}],parametersDescription:[{anchor:"huggingface_hub.repository.files_to_be_staged.pattern",description:`<strong>pattern</strong> (<code>str</code> or <code>Path</code>) &#x2014;
The pattern of filenames to check. Put <code>.</code> to get all files.`,name:"pattern"},{anchor:"huggingface_hub.repository.files_to_be_staged.folder",description:`<strong>folder</strong> (<code>str</code> or <code>Path</code>) &#x2014;
The folder in which to run the command.`,name:"folder"}],source:"https://github.com/huggingface/huggingface_hub/blob/vr_900/src/huggingface_hub/repository.py#L240",returnDescription:`
<p>List of files that are to be staged.</p>
`,returnType:`
<p><code>List[str]</code></p>
`}}),Et=new v({props:{name:"huggingface_hub.repository.is_tracked_upstream",anchor:"huggingface_hub.repository.is_tracked_upstream",parameters:[{name:"folder",val:": typing.Union[str, pathlib.Path]"}],parametersDescription:[{anchor:"huggingface_hub.repository.is_tracked_upstream.folder",description:`<strong>folder</strong> (<code>str</code> or <code>Path</code>) &#x2014;
The folder in which to run the command.`,name:"folder"}],source:"https://github.com/huggingface/huggingface_hub/blob/vr_900/src/huggingface_hub/repository.py#L265",returnDescription:`
<p><code>True</code> if the current checked-out branch is tracked upstream,
<code>False</code> otherwise.</p>
`,returnType:`
<p><code>bool</code></p>
`}}),xt=new v({props:{name:"huggingface_hub.repository.commits_to_push",anchor:"huggingface_hub.repository.commits_to_push",parameters:[{name:"folder",val:": typing.Union[str, pathlib.Path]"},{name:"upstream",val:": typing.Optional[str] = None"}],parametersDescription:[{anchor:"huggingface_hub.repository.commits_to_push.folder",description:`<strong>folder</strong> (<code>str</code> or <code>Path</code>) &#x2014;
The folder in which to run the command.`,name:"folder"},{anchor:"huggingface_hub.repository.commits_to_push.upstream",description:"<strong>upstream</strong> (<code>str</code>, <em>optional</em>) &#x2014;",name:"upstream"}],source:"https://github.com/huggingface/huggingface_hub/blob/vr_900/src/huggingface_hub/repository.py#L289",returnDescription:`
<p>Number of commits that would be pushed upstream were a <code>git push</code> to proceed.</p>
`,returnType:`
<p><code>int</code></p>
`}}),Dt=new Tn({}),Tt=new v({props:{name:"class huggingface_hub.Repository",anchor:"huggingface_hub.Repository",parameters:[{name:"local_dir",val:": str"},{name:"clone_from",val:": typing.Optional[str] = None"},{name:"repo_type",val:": typing.Optional[str] = None"},{name:"use_auth_token",val:": typing.Union[bool, str] = True"},{name:"git_user",val:": typing.Optional[str] = None"},{name:"git_email",val:": typing.Optional[str] = None"},{name:"revision",val:": typing.Optional[str] = None"},{name:"private",val:": bool = False"},{name:"skip_lfs_files",val:": bool = False"},{name:"client",val:": typing.Optional[huggingface_hub.hf_api.HfApi] = None"}],source:"https://github.com/huggingface/huggingface_hub/blob/vr_900/src/huggingface_hub/repository.py#L413"}}),Pt=new v({props:{name:"commands_failed",anchor:"huggingface_hub.Repository.commands_failed",parameters:[],source:"https://github.com/huggingface/huggingface_hub/blob/vr_900/src/huggingface_hub/repository.py#L1503"}}),It=new v({props:{name:"commands_in_progress",anchor:"huggingface_hub.Repository.commands_in_progress",parameters:[],source:"https://github.com/huggingface/huggingface_hub/blob/vr_900/src/huggingface_hub/repository.py#L1510"}}),Ot=new v({props:{name:"wait_for_commands",anchor:"huggingface_hub.Repository.wait_for_commands",parameters:[],source:"https://github.com/huggingface/huggingface_hub/blob/vr_900/src/huggingface_hub/repository.py#L1517"}}),Lt=new v({props:{name:"class huggingface_hub.repository.CommandInProgress",anchor:"huggingface_hub.repository.CommandInProgress",parameters:[{name:"title",val:": str"},{name:"is_done_method",val:": typing.Callable"},{name:"status_method",val:": typing.Callable"},{name:"process",val:": Popen"},{name:"post_method",val:": typing.Optional[typing.Callable] = None"}],source:"https://github.com/huggingface/huggingface_hub/blob/vr_900/src/huggingface_hub/repository.py#L28"}}),{c(){E=r("meta"),se=l(),D=r("h1"),x=r("a"),j=r("span"),d(w.$$.fragment),H=l(),Jt=r("span"),Pn=s("Managing local and online repositories"),Dr=l(),R=r("p"),In=s("The "),Kt=r("code"),On=s("Repository"),Ln=s(" class is a helper class that wraps "),Qt=r("code"),Cn=s("git"),Fn=s(" and "),Xt=r("code"),Nn=s("git-lfs"),jn=s(` commands. It provides tooling adapted
for managing repositories which can be very large.`),Rr=l(),ie=r("p"),Hn=s("It is the recommended tool as soon as any "),Yt=r("code"),Vn=s("git"),An=s(` operation is involved, or when collaboration will be a point
of focus with the repository itself.`),Tr=l(),W=r("h2"),le=r("a"),Zt=r("span"),d(Ue.$$.fragment),Sn=l(),eo=r("span"),qn=s("The Repository class"),Pr=l(),g=r("div"),d(Me.$$.fragment),Un=l(),to=r("p"),Mn=s("Helper class to wrap the git and git-lfs commands."),Wn=l(),oo=r("p"),Bn=s(`The aim is to facilitate interacting with huggingface.co hosted model or
dataset repos, though not a lot here (if any) is actually specific to
huggingface.co.`),Gn=l(),T=r("div"),d(We.$$.fragment),zn=l(),ro=r("p"),Jn=s("Instantiate a local clone of a git repo."),Kn=l(),B=r("p"),Qn=s("If specifying a "),no=r("code"),Xn=s("clone_from"),Yn=s(`, it will clone an existing remote
repository, for instance one that was previously created using
`),ao=r("code"),Zn=s("HfApi().create_repo(repo_id=repo_name)"),ea=s("."),ta=l(),P=r("p"),so=r("code"),oa=s("Repository"),ra=s(` uses the local git credentials by default, but if required,
the `),io=r("code"),na=s("huggingface_token"),aa=s(" as well as the git "),lo=r("code"),sa=s("user"),ia=s(" and the "),co=r("code"),la=s("email"),ca=s(` can be
explicitly specified.`),ga=l(),ce=r("div"),d(Be.$$.fragment),ha=l(),go=r("p"),pa=s("Returns the current checked out branch."),da=l(),I=r("div"),d(Ge.$$.fragment),ua=l(),ho=r("p"),ma=s("Add a tag at the current head and push it"),fa=l(),po=r("p"),_a=s("If remote is None, will just be updated locally"),ba=l(),uo=r("p"),ya=s(`If no message is provided, the tag will be lightweight. if a message is
provided, the tag will be annotated.`),va=l(),ge=r("div"),d(ze.$$.fragment),$a=l(),mo=r("p"),wa=s("Automatically track binary files with git-lfs."),ka=l(),he=r("div"),d(Je.$$.fragment),Ea=l(),fo=r("p"),xa=s(`Automatically track large files (files that weigh more than 10MBs) with
git-lfs.`),Da=l(),pe=r("div"),d(Ke.$$.fragment),Ra=l(),G=r("p"),Ta=s("Checks that "),_o=r("code"),Pa=s("git"),Ia=s(" and "),bo=r("code"),Oa=s("git-lfs"),La=s(" can be run."),Ca=l(),V=r("div"),d(Qe.$$.fragment),Fa=l(),yo=r("p"),Na=s(`Clone from a remote. If the folder already exists, will try to clone the
repository within it.`),ja=l(),vo=r("p"),Ha=s(`If this folder is a git repository with linked history, will try to
update the repository.`),Va=l(),A=r("div"),d(Xe.$$.fragment),Aa=l(),z=r("p"),Sa=s(`Context manager utility to handle committing to a repository. This
automatically tracks large files (>10Mb) with git-lfs. Set the
`),$o=r("code"),qa=s("track_large_files"),Ua=s(" argument to "),wo=r("code"),Ma=s("False"),Wa=s(` if you wish to ignore that
behavior.`),Ba=l(),d(de.$$.fragment),Ga=l(),ue=r("div"),d(Ye.$$.fragment),za=l(),ko=r("p"),Ja=s("Delete a tag, both local and remote, if it exists"),Ka=l(),S=r("div"),d(Ze.$$.fragment),Qa=l(),Eo=r("p"),Xa=s("git add"),Ya=l(),C=r("p"),Za=s("Setting the "),xo=r("code"),es=s("auto_lfs_track"),ts=s(" parameter to "),Do=r("code"),os=s("True"),rs=s(` will automatically
track files that are larger than 10MB with `),Ro=r("code"),ns=s("git-lfs"),as=s("."),ss=l(),q=r("div"),d(et.$$.fragment),is=l(),To=r("p"),ls=s("git checkout a given revision"),cs=l(),J=r("p"),gs=s("Specifying "),Po=r("code"),hs=s("create_branch_ok"),ps=s(" to "),Io=r("code"),ds=s("True"),us=s(` will create the branch to the
given revision if that revision doesn\u2019t exist.`),ms=l(),me=r("div"),d(tt.$$.fragment),fs=l(),Oo=r("p"),_s=s("git commit"),bs=l(),fe=r("div"),d(ot.$$.fragment),ys=l(),Lo=r("p"),vs=s("Sets git username and email (only in the current repo)."),$s=l(),_e=r("div"),d(rt.$$.fragment),ws=l(),Ft=r("p"),ks=s("Sets the git credential helper to "),Co=r("code"),Es=s("store"),xs=l(),be=r("div"),d(nt.$$.fragment),Ds=l(),Fo=r("p"),Rs=s(`Get URL to last commit on HEAD. We assume it\u2019s been pushed, and the url
scheme is the same one as for GitHub or HuggingFace.`),Ts=l(),ye=r("div"),d(at.$$.fragment),Ps=l(),No=r("p"),Is=s("Get commit sha on top of HEAD."),Os=l(),ve=r("div"),d(st.$$.fragment),Ls=l(),jo=r("p"),Cs=s("git pull"),Fs=l(),U=r("div"),d(it.$$.fragment),Ns=l(),Ho=r("p"),js=s("git push"),Hs=l(),K=r("p"),Vs=s("If used without setting "),Vo=r("code"),As=s("blocking"),Ss=s(`, will return url to commit on remote
repo. If used with `),Ao=r("code"),qs=s("blocking=True"),Us=s(`, will return a tuple containing the
url to commit and the command object to follow for information about the
process.`),Ms=l(),$e=r("div"),d(lt.$$.fragment),Ws=l(),So=r("p"),Bs=s("Get URL to origin remote."),Gs=l(),we=r("div"),d(ct.$$.fragment),zs=l(),qo=r("p"),Js=s("Return whether or not the git status is clean or not"),Ks=l(),ke=r("div"),d(gt.$$.fragment),Qs=l(),Uo=r("p"),Xs=s("HF-specific. This enables upload support of files >5GB."),Ys=l(),Ee=r("div"),d(ht.$$.fragment),Zs=l(),Mo=r("p"),ei=s("git lfs prune"),ti=l(),M=r("div"),d(pt.$$.fragment),oi=l(),Wo=r("p"),ri=s("Tell git-lfs to track files according to a pattern."),ni=l(),F=r("p"),ai=s("Setting the "),Bo=r("code"),si=s("filename"),ii=s(" argument to "),Go=r("code"),li=s("True"),ci=s(` will treat the arguments as
literal filenames, not as patterns. Any special glob characters in the
filename will be escaped when writing to the `),zo=r("code"),gi=s(".gitattributes"),hi=s(" file."),pi=l(),xe=r("div"),d(dt.$$.fragment),di=l(),Jo=r("p"),ui=s("Tell git-lfs to untrack those files."),mi=l(),De=r("div"),d(ut.$$.fragment),fi=l(),Ko=r("p"),_i=s(`Returns a list of the files that are deleted in the working directory or
index.`),bi=l(),Re=r("div"),d(mt.$$.fragment),yi=l(),Qo=r("p"),vi=s(`Helper to add, commit, and push files to remote repository on the
HuggingFace Hub. Will automatically track large files (>10MB).`),$i=l(),Te=r("div"),d(ft.$$.fragment),wi=l(),Xo=r("p"),ki=s("Check if a tag exists or not."),Ei=l(),Pe=r("div"),d(_t.$$.fragment),xi=l(),Yo=r("p"),Di=s(`Blocking method: blocks all subsequent execution until all commands have
been processed.`),Ir=l(),Q=r("h2"),Ie=r("a"),Zo=r("span"),d(bt.$$.fragment),Ri=l(),er=r("span"),Ti=s("Helper methods"),Or=l(),X=r("div"),d(yt.$$.fragment),Pi=l(),tr=r("p"),Ii=s("Check if the folder is the root or part of a git repository"),Lr=l(),Y=r("div"),d(vt.$$.fragment),Oi=l(),or=r("p"),Li=s("Check if the folder is a local clone of the remote_url"),Cr=l(),Z=r("div"),d($t.$$.fragment),Ci=l(),rr=r("p"),Fi=s("Check if the file passed is tracked with git-lfs."),Fr=l(),ee=r("div"),d(wt.$$.fragment),Ni=l(),nr=r("p"),ji=s("Check if file is git-ignored. Supports nested .gitignore files."),Nr=l(),te=r("div"),d(kt.$$.fragment),Hi=l(),ar=r("p"),Vi=s("Returns a list of filenames that are to be staged."),jr=l(),oe=r("div"),d(Et.$$.fragment),Ai=l(),sr=r("p"),Si=s("Check if the current checked-out branch is tracked upstream."),Hr=l(),N=r("div"),d(xt.$$.fragment),qi=l(),ir=r("p"),Ui=s("Check the number of commits that would be pushed upstream"),Mi=l(),lr=r("p"),Wi=s(`The name of the upstream repository with which the comparison should be
made.`),Vr=l(),re=r("h2"),Oe=r("a"),cr=r("span"),d(Dt.$$.fragment),Bi=l(),gr=r("span"),Gi=s("Following asynchronous commands"),Ar=l(),Le=r("p"),zi=s("The "),hr=r("code"),Ji=s("Repository"),Ki=s(" utility offers several methods which can be launched asynchronously:"),Sr=l(),O=r("ul"),pr=r("li"),dr=r("code"),Qi=s("git_push"),Xi=l(),ur=r("li"),mr=r("code"),Yi=s("git_pull"),Zi=l(),fr=r("li"),_r=r("code"),el=s("push_to_hub"),tl=l(),Rt=r("li"),ol=s("The "),br=r("code"),rl=s("commit"),nl=s(" context manager"),qr=l(),Nt=r("p"),al=s("See below for utilities to manage such asynchronous methods."),Ur=l(),k=r("div"),d(Tt.$$.fragment),sl=l(),yr=r("p"),il=s("Helper class to wrap the git and git-lfs commands."),ll=l(),vr=r("p"),cl=s(`The aim is to facilitate interacting with huggingface.co hosted model or
dataset repos, though not a lot here (if any) is actually specific to
huggingface.co.`),gl=l(),Ce=r("div"),d(Pt.$$.fragment),hl=l(),$r=r("p"),pl=s("Returns the asynchronous commands that failed."),dl=l(),Fe=r("div"),d(It.$$.fragment),ul=l(),wr=r("p"),ml=s("Returns the asynchronous commands that are currently in progress."),fl=l(),Ne=r("div"),d(Ot.$$.fragment),_l=l(),kr=r("p"),bl=s(`Blocking method: blocks all subsequent execution until all commands have
been processed.`),Mr=l(),ne=r("div"),d(Lt.$$.fragment),yl=l(),Er=r("p"),vl=s("Utility to follow commands launched asynchronously."),this.h()},l(t){const y=ig('[data-svelte="svelte-1phssyn"]',document.head);E=n(y,"META",{name:!0,content:!0}),y.forEach(o),se=c(t),D=n(t,"H1",{class:!0});var Ct=a(D);x=n(Ct,"A",{id:!0,class:!0,href:!0});var wl=a(x);j=n(wl,"SPAN",{});var kl=a(j);u(w.$$.fragment,kl),kl.forEach(o),wl.forEach(o),H=c(Ct),Jt=n(Ct,"SPAN",{});var El=a(Jt);Pn=i(El,"Managing local and online repositories"),El.forEach(o),Ct.forEach(o),Dr=c(t),R=n(t,"P",{});var je=a(R);In=i(je,"The "),Kt=n(je,"CODE",{});var xl=a(Kt);On=i(xl,"Repository"),xl.forEach(o),Ln=i(je," class is a helper class that wraps "),Qt=n(je,"CODE",{});var Dl=a(Qt);Cn=i(Dl,"git"),Dl.forEach(o),Fn=i(je," and "),Xt=n(je,"CODE",{});var Rl=a(Xt);Nn=i(Rl,"git-lfs"),Rl.forEach(o),jn=i(je,` commands. It provides tooling adapted
for managing repositories which can be very large.`),je.forEach(o),Rr=c(t),ie=n(t,"P",{});var Br=a(ie);Hn=i(Br,"It is the recommended tool as soon as any "),Yt=n(Br,"CODE",{});var Tl=a(Yt);Vn=i(Tl,"git"),Tl.forEach(o),An=i(Br,` operation is involved, or when collaboration will be a point
of focus with the repository itself.`),Br.forEach(o),Tr=c(t),W=n(t,"H2",{class:!0});var Gr=a(W);le=n(Gr,"A",{id:!0,class:!0,href:!0});var Pl=a(le);Zt=n(Pl,"SPAN",{});var Il=a(Zt);u(Ue.$$.fragment,Il),Il.forEach(o),Pl.forEach(o),Sn=c(Gr),eo=n(Gr,"SPAN",{});var Ol=a(eo);qn=i(Ol,"The Repository class"),Ol.forEach(o),Gr.forEach(o),Pr=c(t),g=n(t,"DIV",{class:!0});var h=a(g);u(Me.$$.fragment,h),Un=c(h),to=n(h,"P",{});var Ll=a(to);Mn=i(Ll,"Helper class to wrap the git and git-lfs commands."),Ll.forEach(o),Wn=c(h),oo=n(h,"P",{});var Cl=a(oo);Bn=i(Cl,`The aim is to facilitate interacting with huggingface.co hosted model or
dataset repos, though not a lot here (if any) is actually specific to
huggingface.co.`),Cl.forEach(o),Gn=c(h),T=n(h,"DIV",{class:!0});var He=a(T);u(We.$$.fragment,He),zn=c(He),ro=n(He,"P",{});var Fl=a(ro);Jn=i(Fl,"Instantiate a local clone of a git repo."),Fl.forEach(o),Kn=c(He),B=n(He,"P",{});var jt=a(B);Qn=i(jt,"If specifying a "),no=n(jt,"CODE",{});var Nl=a(no);Xn=i(Nl,"clone_from"),Nl.forEach(o),Yn=i(jt,`, it will clone an existing remote
repository, for instance one that was previously created using
`),ao=n(jt,"CODE",{});var jl=a(ao);Zn=i(jl,"HfApi().create_repo(repo_id=repo_name)"),jl.forEach(o),ea=i(jt,"."),jt.forEach(o),ta=c(He),P=n(He,"P",{});var ae=a(P);so=n(ae,"CODE",{});var Hl=a(so);oa=i(Hl,"Repository"),Hl.forEach(o),ra=i(ae,` uses the local git credentials by default, but if required,
the `),io=n(ae,"CODE",{});var Vl=a(io);na=i(Vl,"huggingface_token"),Vl.forEach(o),aa=i(ae," as well as the git "),lo=n(ae,"CODE",{});var Al=a(lo);sa=i(Al,"user"),Al.forEach(o),ia=i(ae," and the "),co=n(ae,"CODE",{});var Sl=a(co);la=i(Sl,"email"),Sl.forEach(o),ca=i(ae,` can be
explicitly specified.`),ae.forEach(o),He.forEach(o),ga=c(h),ce=n(h,"DIV",{class:!0});var zr=a(ce);u(Be.$$.fragment,zr),ha=c(zr),go=n(zr,"P",{});var ql=a(go);pa=i(ql,"Returns the current checked out branch."),ql.forEach(o),zr.forEach(o),da=c(h),I=n(h,"DIV",{class:!0});var Ve=a(I);u(Ge.$$.fragment,Ve),ua=c(Ve),ho=n(Ve,"P",{});var Ul=a(ho);ma=i(Ul,"Add a tag at the current head and push it"),Ul.forEach(o),fa=c(Ve),po=n(Ve,"P",{});var Ml=a(po);_a=i(Ml,"If remote is None, will just be updated locally"),Ml.forEach(o),ba=c(Ve),uo=n(Ve,"P",{});var Wl=a(uo);ya=i(Wl,`If no message is provided, the tag will be lightweight. if a message is
provided, the tag will be annotated.`),Wl.forEach(o),Ve.forEach(o),va=c(h),ge=n(h,"DIV",{class:!0});var Jr=a(ge);u(ze.$$.fragment,Jr),$a=c(Jr),mo=n(Jr,"P",{});var Bl=a(mo);wa=i(Bl,"Automatically track binary files with git-lfs."),Bl.forEach(o),Jr.forEach(o),ka=c(h),he=n(h,"DIV",{class:!0});var Kr=a(he);u(Je.$$.fragment,Kr),Ea=c(Kr),fo=n(Kr,"P",{});var Gl=a(fo);xa=i(Gl,`Automatically track large files (files that weigh more than 10MBs) with
git-lfs.`),Gl.forEach(o),Kr.forEach(o),Da=c(h),pe=n(h,"DIV",{class:!0});var Qr=a(pe);u(Ke.$$.fragment,Qr),Ra=c(Qr),G=n(Qr,"P",{});var Ht=a(G);Ta=i(Ht,"Checks that "),_o=n(Ht,"CODE",{});var zl=a(_o);Pa=i(zl,"git"),zl.forEach(o),Ia=i(Ht," and "),bo=n(Ht,"CODE",{});var Jl=a(bo);Oa=i(Jl,"git-lfs"),Jl.forEach(o),La=i(Ht," can be run."),Ht.forEach(o),Qr.forEach(o),Ca=c(h),V=n(h,"DIV",{class:!0});var Vt=a(V);u(Qe.$$.fragment,Vt),Fa=c(Vt),yo=n(Vt,"P",{});var Kl=a(yo);Na=i(Kl,`Clone from a remote. If the folder already exists, will try to clone the
repository within it.`),Kl.forEach(o),ja=c(Vt),vo=n(Vt,"P",{});var Ql=a(vo);Ha=i(Ql,`If this folder is a git repository with linked history, will try to
update the repository.`),Ql.forEach(o),Vt.forEach(o),Va=c(h),A=n(h,"DIV",{class:!0});var At=a(A);u(Xe.$$.fragment,At),Aa=c(At),z=n(At,"P",{});var St=a(z);Sa=i(St,`Context manager utility to handle committing to a repository. This
automatically tracks large files (>10Mb) with git-lfs. Set the
`),$o=n(St,"CODE",{});var Xl=a($o);qa=i(Xl,"track_large_files"),Xl.forEach(o),Ua=i(St," argument to "),wo=n(St,"CODE",{});var Yl=a(wo);Ma=i(Yl,"False"),Yl.forEach(o),Wa=i(St,` if you wish to ignore that
behavior.`),St.forEach(o),Ba=c(At),u(de.$$.fragment,At),At.forEach(o),Ga=c(h),ue=n(h,"DIV",{class:!0});var Xr=a(ue);u(Ye.$$.fragment,Xr),za=c(Xr),ko=n(Xr,"P",{});var Zl=a(ko);Ja=i(Zl,"Delete a tag, both local and remote, if it exists"),Zl.forEach(o),Xr.forEach(o),Ka=c(h),S=n(h,"DIV",{class:!0});var qt=a(S);u(Ze.$$.fragment,qt),Qa=c(qt),Eo=n(qt,"P",{});var ec=a(Eo);Xa=i(ec,"git add"),ec.forEach(o),Ya=c(qt),C=n(qt,"P",{});var Ae=a(C);Za=i(Ae,"Setting the "),xo=n(Ae,"CODE",{});var tc=a(xo);es=i(tc,"auto_lfs_track"),tc.forEach(o),ts=i(Ae," parameter to "),Do=n(Ae,"CODE",{});var oc=a(Do);os=i(oc,"True"),oc.forEach(o),rs=i(Ae,` will automatically
track files that are larger than 10MB with `),Ro=n(Ae,"CODE",{});var rc=a(Ro);ns=i(rc,"git-lfs"),rc.forEach(o),as=i(Ae,"."),Ae.forEach(o),qt.forEach(o),ss=c(h),q=n(h,"DIV",{class:!0});var Ut=a(q);u(et.$$.fragment,Ut),is=c(Ut),To=n(Ut,"P",{});var nc=a(To);ls=i(nc,"git checkout a given revision"),nc.forEach(o),cs=c(Ut),J=n(Ut,"P",{});var Mt=a(J);gs=i(Mt,"Specifying "),Po=n(Mt,"CODE",{});var ac=a(Po);hs=i(ac,"create_branch_ok"),ac.forEach(o),ps=i(Mt," to "),Io=n(Mt,"CODE",{});var sc=a(Io);ds=i(sc,"True"),sc.forEach(o),us=i(Mt,` will create the branch to the
given revision if that revision doesn\u2019t exist.`),Mt.forEach(o),Ut.forEach(o),ms=c(h),me=n(h,"DIV",{class:!0});var Yr=a(me);u(tt.$$.fragment,Yr),fs=c(Yr),Oo=n(Yr,"P",{});var ic=a(Oo);_s=i(ic,"git commit"),ic.forEach(o),Yr.forEach(o),bs=c(h),fe=n(h,"DIV",{class:!0});var Zr=a(fe);u(ot.$$.fragment,Zr),ys=c(Zr),Lo=n(Zr,"P",{});var lc=a(Lo);vs=i(lc,"Sets git username and email (only in the current repo)."),lc.forEach(o),Zr.forEach(o),$s=c(h),_e=n(h,"DIV",{class:!0});var en=a(_e);u(rt.$$.fragment,en),ws=c(en),Ft=n(en,"P",{});var $l=a(Ft);ks=i($l,"Sets the git credential helper to "),Co=n($l,"CODE",{});var cc=a(Co);Es=i(cc,"store"),cc.forEach(o),$l.forEach(o),en.forEach(o),xs=c(h),be=n(h,"DIV",{class:!0});var tn=a(be);u(nt.$$.fragment,tn),Ds=c(tn),Fo=n(tn,"P",{});var gc=a(Fo);Rs=i(gc,`Get URL to last commit on HEAD. We assume it\u2019s been pushed, and the url
scheme is the same one as for GitHub or HuggingFace.`),gc.forEach(o),tn.forEach(o),Ts=c(h),ye=n(h,"DIV",{class:!0});var on=a(ye);u(at.$$.fragment,on),Ps=c(on),No=n(on,"P",{});var hc=a(No);Is=i(hc,"Get commit sha on top of HEAD."),hc.forEach(o),on.forEach(o),Os=c(h),ve=n(h,"DIV",{class:!0});var rn=a(ve);u(st.$$.fragment,rn),Ls=c(rn),jo=n(rn,"P",{});var pc=a(jo);Cs=i(pc,"git pull"),pc.forEach(o),rn.forEach(o),Fs=c(h),U=n(h,"DIV",{class:!0});var Wt=a(U);u(it.$$.fragment,Wt),Ns=c(Wt),Ho=n(Wt,"P",{});var dc=a(Ho);js=i(dc,"git push"),dc.forEach(o),Hs=c(Wt),K=n(Wt,"P",{});var Bt=a(K);Vs=i(Bt,"If used without setting "),Vo=n(Bt,"CODE",{});var uc=a(Vo);As=i(uc,"blocking"),uc.forEach(o),Ss=i(Bt,`, will return url to commit on remote
repo. If used with `),Ao=n(Bt,"CODE",{});var mc=a(Ao);qs=i(mc,"blocking=True"),mc.forEach(o),Us=i(Bt,`, will return a tuple containing the
url to commit and the command object to follow for information about the
process.`),Bt.forEach(o),Wt.forEach(o),Ms=c(h),$e=n(h,"DIV",{class:!0});var nn=a($e);u(lt.$$.fragment,nn),Ws=c(nn),So=n(nn,"P",{});var fc=a(So);Bs=i(fc,"Get URL to origin remote."),fc.forEach(o),nn.forEach(o),Gs=c(h),we=n(h,"DIV",{class:!0});var an=a(we);u(ct.$$.fragment,an),zs=c(an),qo=n(an,"P",{});var _c=a(qo);Js=i(_c,"Return whether or not the git status is clean or not"),_c.forEach(o),an.forEach(o),Ks=c(h),ke=n(h,"DIV",{class:!0});var sn=a(ke);u(gt.$$.fragment,sn),Qs=c(sn),Uo=n(sn,"P",{});var bc=a(Uo);Xs=i(bc,"HF-specific. This enables upload support of files >5GB."),bc.forEach(o),sn.forEach(o),Ys=c(h),Ee=n(h,"DIV",{class:!0});var ln=a(Ee);u(ht.$$.fragment,ln),Zs=c(ln),Mo=n(ln,"P",{});var yc=a(Mo);ei=i(yc,"git lfs prune"),yc.forEach(o),ln.forEach(o),ti=c(h),M=n(h,"DIV",{class:!0});var Gt=a(M);u(pt.$$.fragment,Gt),oi=c(Gt),Wo=n(Gt,"P",{});var vc=a(Wo);ri=i(vc,"Tell git-lfs to track files according to a pattern."),vc.forEach(o),ni=c(Gt),F=n(Gt,"P",{});var Se=a(F);ai=i(Se,"Setting the "),Bo=n(Se,"CODE",{});var $c=a(Bo);si=i($c,"filename"),$c.forEach(o),ii=i(Se," argument to "),Go=n(Se,"CODE",{});var wc=a(Go);li=i(wc,"True"),wc.forEach(o),ci=i(Se,` will treat the arguments as
literal filenames, not as patterns. Any special glob characters in the
filename will be escaped when writing to the `),zo=n(Se,"CODE",{});var kc=a(zo);gi=i(kc,".gitattributes"),kc.forEach(o),hi=i(Se," file."),Se.forEach(o),Gt.forEach(o),pi=c(h),xe=n(h,"DIV",{class:!0});var cn=a(xe);u(dt.$$.fragment,cn),di=c(cn),Jo=n(cn,"P",{});var Ec=a(Jo);ui=i(Ec,"Tell git-lfs to untrack those files."),Ec.forEach(o),cn.forEach(o),mi=c(h),De=n(h,"DIV",{class:!0});var gn=a(De);u(ut.$$.fragment,gn),fi=c(gn),Ko=n(gn,"P",{});var xc=a(Ko);_i=i(xc,`Returns a list of the files that are deleted in the working directory or
index.`),xc.forEach(o),gn.forEach(o),bi=c(h),Re=n(h,"DIV",{class:!0});var hn=a(Re);u(mt.$$.fragment,hn),yi=c(hn),Qo=n(hn,"P",{});var Dc=a(Qo);vi=i(Dc,`Helper to add, commit, and push files to remote repository on the
HuggingFace Hub. Will automatically track large files (>10MB).`),Dc.forEach(o),hn.forEach(o),$i=c(h),Te=n(h,"DIV",{class:!0});var pn=a(Te);u(ft.$$.fragment,pn),wi=c(pn),Xo=n(pn,"P",{});var Rc=a(Xo);ki=i(Rc,"Check if a tag exists or not."),Rc.forEach(o),pn.forEach(o),Ei=c(h),Pe=n(h,"DIV",{class:!0});var dn=a(Pe);u(_t.$$.fragment,dn),xi=c(dn),Yo=n(dn,"P",{});var Tc=a(Yo);Di=i(Tc,`Blocking method: blocks all subsequent execution until all commands have
been processed.`),Tc.forEach(o),dn.forEach(o),h.forEach(o),Ir=c(t),Q=n(t,"H2",{class:!0});var un=a(Q);Ie=n(un,"A",{id:!0,class:!0,href:!0});var Pc=a(Ie);Zo=n(Pc,"SPAN",{});var Ic=a(Zo);u(bt.$$.fragment,Ic),Ic.forEach(o),Pc.forEach(o),Ri=c(un),er=n(un,"SPAN",{});var Oc=a(er);Ti=i(Oc,"Helper methods"),Oc.forEach(o),un.forEach(o),Or=c(t),X=n(t,"DIV",{class:!0});var mn=a(X);u(yt.$$.fragment,mn),Pi=c(mn),tr=n(mn,"P",{});var Lc=a(tr);Ii=i(Lc,"Check if the folder is the root or part of a git repository"),Lc.forEach(o),mn.forEach(o),Lr=c(t),Y=n(t,"DIV",{class:!0});var fn=a(Y);u(vt.$$.fragment,fn),Oi=c(fn),or=n(fn,"P",{});var Cc=a(or);Li=i(Cc,"Check if the folder is a local clone of the remote_url"),Cc.forEach(o),fn.forEach(o),Cr=c(t),Z=n(t,"DIV",{class:!0});var _n=a(Z);u($t.$$.fragment,_n),Ci=c(_n),rr=n(_n,"P",{});var Fc=a(rr);Fi=i(Fc,"Check if the file passed is tracked with git-lfs."),Fc.forEach(o),_n.forEach(o),Fr=c(t),ee=n(t,"DIV",{class:!0});var bn=a(ee);u(wt.$$.fragment,bn),Ni=c(bn),nr=n(bn,"P",{});var Nc=a(nr);ji=i(Nc,"Check if file is git-ignored. Supports nested .gitignore files."),Nc.forEach(o),bn.forEach(o),Nr=c(t),te=n(t,"DIV",{class:!0});var yn=a(te);u(kt.$$.fragment,yn),Hi=c(yn),ar=n(yn,"P",{});var jc=a(ar);Vi=i(jc,"Returns a list of filenames that are to be staged."),jc.forEach(o),yn.forEach(o),jr=c(t),oe=n(t,"DIV",{class:!0});var vn=a(oe);u(Et.$$.fragment,vn),Ai=c(vn),sr=n(vn,"P",{});var Hc=a(sr);Si=i(Hc,"Check if the current checked-out branch is tracked upstream."),Hc.forEach(o),vn.forEach(o),Hr=c(t),N=n(t,"DIV",{class:!0});var zt=a(N);u(xt.$$.fragment,zt),qi=c(zt),ir=n(zt,"P",{});var Vc=a(ir);Ui=i(Vc,"Check the number of commits that would be pushed upstream"),Vc.forEach(o),Mi=c(zt),lr=n(zt,"P",{});var Ac=a(lr);Wi=i(Ac,`The name of the upstream repository with which the comparison should be
made.`),Ac.forEach(o),zt.forEach(o),Vr=c(t),re=n(t,"H2",{class:!0});var $n=a(re);Oe=n($n,"A",{id:!0,class:!0,href:!0});var Sc=a(Oe);cr=n(Sc,"SPAN",{});var qc=a(cr);u(Dt.$$.fragment,qc),qc.forEach(o),Sc.forEach(o),Bi=c($n),gr=n($n,"SPAN",{});var Uc=a(gr);Gi=i(Uc,"Following asynchronous commands"),Uc.forEach(o),$n.forEach(o),Ar=c(t),Le=n(t,"P",{});var wn=a(Le);zi=i(wn,"The "),hr=n(wn,"CODE",{});var Mc=a(hr);Ji=i(Mc,"Repository"),Mc.forEach(o),Ki=i(wn," utility offers several methods which can be launched asynchronously:"),wn.forEach(o),Sr=c(t),O=n(t,"UL",{});var qe=a(O);pr=n(qe,"LI",{});var Wc=a(pr);dr=n(Wc,"CODE",{});var Bc=a(dr);Qi=i(Bc,"git_push"),Bc.forEach(o),Wc.forEach(o),Xi=c(qe),ur=n(qe,"LI",{});var Gc=a(ur);mr=n(Gc,"CODE",{});var zc=a(mr);Yi=i(zc,"git_pull"),zc.forEach(o),Gc.forEach(o),Zi=c(qe),fr=n(qe,"LI",{});var Jc=a(fr);_r=n(Jc,"CODE",{});var Kc=a(_r);el=i(Kc,"push_to_hub"),Kc.forEach(o),Jc.forEach(o),tl=c(qe),Rt=n(qe,"LI",{});var kn=a(Rt);ol=i(kn,"The "),br=n(kn,"CODE",{});var Qc=a(br);rl=i(Qc,"commit"),Qc.forEach(o),nl=i(kn," context manager"),kn.forEach(o),qe.forEach(o),qr=c(t),Nt=n(t,"P",{});var Xc=a(Nt);al=i(Xc,"See below for utilities to manage such asynchronous methods."),Xc.forEach(o),Ur=c(t),k=n(t,"DIV",{class:!0});var L=a(k);u(Tt.$$.fragment,L),sl=c(L),yr=n(L,"P",{});var Yc=a(yr);il=i(Yc,"Helper class to wrap the git and git-lfs commands."),Yc.forEach(o),ll=c(L),vr=n(L,"P",{});var Zc=a(vr);cl=i(Zc,`The aim is to facilitate interacting with huggingface.co hosted model or
dataset repos, though not a lot here (if any) is actually specific to
huggingface.co.`),Zc.forEach(o),gl=c(L),Ce=n(L,"DIV",{class:!0});var En=a(Ce);u(Pt.$$.fragment,En),hl=c(En),$r=n(En,"P",{});var eg=a($r);pl=i(eg,"Returns the asynchronous commands that failed."),eg.forEach(o),En.forEach(o),dl=c(L),Fe=n(L,"DIV",{class:!0});var xn=a(Fe);u(It.$$.fragment,xn),ul=c(xn),wr=n(xn,"P",{});var tg=a(wr);ml=i(tg,"Returns the asynchronous commands that are currently in progress."),tg.forEach(o),xn.forEach(o),fl=c(L),Ne=n(L,"DIV",{class:!0});var Dn=a(Ne);u(Ot.$$.fragment,Dn),_l=c(Dn),kr=n(Dn,"P",{});var og=a(kr);bl=i(og,`Blocking method: blocks all subsequent execution until all commands have
been processed.`),og.forEach(o),Dn.forEach(o),L.forEach(o),Mr=c(t),ne=n(t,"DIV",{class:!0});var Rn=a(ne);u(Lt.$$.fragment,Rn),yl=c(Rn),Er=n(Rn,"P",{});var rg=a(Er);vl=i(rg,"Utility to follow commands launched asynchronously."),rg.forEach(o),Rn.forEach(o),this.h()},h(){p(E,"name","hf:doc:metadata"),p(E,"content",JSON.stringify(ug)),p(x,"id","managing-local-and-online-repositories"),p(x,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),p(x,"href","#managing-local-and-online-repositories"),p(D,"class","relative group"),p(le,"id","huggingface_hub.Repository"),p(le,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),p(le,"href","#huggingface_hub.Repository"),p(W,"class","relative group"),p(T,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),p(ce,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),p(I,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),p(ge,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),p(he,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),p(pe,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),p(V,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),p(A,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),p(ue,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),p(S,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),p(q,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),p(me,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),p(fe,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),p(_e,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),p(be,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),p(ye,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),p(ve,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),p(U,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),p($e,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),p(we,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),p(ke,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),p(Ee,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),p(M,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),p(xe,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),p(De,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),p(Re,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),p(Te,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),p(Pe,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),p(g,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),p(Ie,"id","huggingface_hub.repository.is_git_repo"),p(Ie,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),p(Ie,"href","#huggingface_hub.repository.is_git_repo"),p(Q,"class","relative group"),p(X,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),p(Y,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),p(Z,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),p(ee,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),p(te,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),p(oe,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),p(N,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),p(Oe,"id","huggingface_hub.Repository"),p(Oe,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),p(Oe,"href","#huggingface_hub.Repository"),p(re,"class","relative group"),p(Ce,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),p(Fe,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),p(Ne,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),p(k,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),p(ne,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8")},m(t,y){e(document.head,E),$(t,se,y),$(t,D,y),e(D,x),e(x,j),m(w,j,null),e(D,H),e(D,Jt),e(Jt,Pn),$(t,Dr,y),$(t,R,y),e(R,In),e(R,Kt),e(Kt,On),e(R,Ln),e(R,Qt),e(Qt,Cn),e(R,Fn),e(R,Xt),e(Xt,Nn),e(R,jn),$(t,Rr,y),$(t,ie,y),e(ie,Hn),e(ie,Yt),e(Yt,Vn),e(ie,An),$(t,Tr,y),$(t,W,y),e(W,le),e(le,Zt),m(Ue,Zt,null),e(W,Sn),e(W,eo),e(eo,qn),$(t,Pr,y),$(t,g,y),m(Me,g,null),e(g,Un),e(g,to),e(to,Mn),e(g,Wn),e(g,oo),e(oo,Bn),e(g,Gn),e(g,T),m(We,T,null),e(T,zn),e(T,ro),e(ro,Jn),e(T,Kn),e(T,B),e(B,Qn),e(B,no),e(no,Xn),e(B,Yn),e(B,ao),e(ao,Zn),e(B,ea),e(T,ta),e(T,P),e(P,so),e(so,oa),e(P,ra),e(P,io),e(io,na),e(P,aa),e(P,lo),e(lo,sa),e(P,ia),e(P,co),e(co,la),e(P,ca),e(g,ga),e(g,ce),m(Be,ce,null),e(ce,ha),e(ce,go),e(go,pa),e(g,da),e(g,I),m(Ge,I,null),e(I,ua),e(I,ho),e(ho,ma),e(I,fa),e(I,po),e(po,_a),e(I,ba),e(I,uo),e(uo,ya),e(g,va),e(g,ge),m(ze,ge,null),e(ge,$a),e(ge,mo),e(mo,wa),e(g,ka),e(g,he),m(Je,he,null),e(he,Ea),e(he,fo),e(fo,xa),e(g,Da),e(g,pe),m(Ke,pe,null),e(pe,Ra),e(pe,G),e(G,Ta),e(G,_o),e(_o,Pa),e(G,Ia),e(G,bo),e(bo,Oa),e(G,La),e(g,Ca),e(g,V),m(Qe,V,null),e(V,Fa),e(V,yo),e(yo,Na),e(V,ja),e(V,vo),e(vo,Ha),e(g,Va),e(g,A),m(Xe,A,null),e(A,Aa),e(A,z),e(z,Sa),e(z,$o),e($o,qa),e(z,Ua),e(z,wo),e(wo,Ma),e(z,Wa),e(A,Ba),m(de,A,null),e(g,Ga),e(g,ue),m(Ye,ue,null),e(ue,za),e(ue,ko),e(ko,Ja),e(g,Ka),e(g,S),m(Ze,S,null),e(S,Qa),e(S,Eo),e(Eo,Xa),e(S,Ya),e(S,C),e(C,Za),e(C,xo),e(xo,es),e(C,ts),e(C,Do),e(Do,os),e(C,rs),e(C,Ro),e(Ro,ns),e(C,as),e(g,ss),e(g,q),m(et,q,null),e(q,is),e(q,To),e(To,ls),e(q,cs),e(q,J),e(J,gs),e(J,Po),e(Po,hs),e(J,ps),e(J,Io),e(Io,ds),e(J,us),e(g,ms),e(g,me),m(tt,me,null),e(me,fs),e(me,Oo),e(Oo,_s),e(g,bs),e(g,fe),m(ot,fe,null),e(fe,ys),e(fe,Lo),e(Lo,vs),e(g,$s),e(g,_e),m(rt,_e,null),e(_e,ws),e(_e,Ft),e(Ft,ks),e(Ft,Co),e(Co,Es),e(g,xs),e(g,be),m(nt,be,null),e(be,Ds),e(be,Fo),e(Fo,Rs),e(g,Ts),e(g,ye),m(at,ye,null),e(ye,Ps),e(ye,No),e(No,Is),e(g,Os),e(g,ve),m(st,ve,null),e(ve,Ls),e(ve,jo),e(jo,Cs),e(g,Fs),e(g,U),m(it,U,null),e(U,Ns),e(U,Ho),e(Ho,js),e(U,Hs),e(U,K),e(K,Vs),e(K,Vo),e(Vo,As),e(K,Ss),e(K,Ao),e(Ao,qs),e(K,Us),e(g,Ms),e(g,$e),m(lt,$e,null),e($e,Ws),e($e,So),e(So,Bs),e(g,Gs),e(g,we),m(ct,we,null),e(we,zs),e(we,qo),e(qo,Js),e(g,Ks),e(g,ke),m(gt,ke,null),e(ke,Qs),e(ke,Uo),e(Uo,Xs),e(g,Ys),e(g,Ee),m(ht,Ee,null),e(Ee,Zs),e(Ee,Mo),e(Mo,ei),e(g,ti),e(g,M),m(pt,M,null),e(M,oi),e(M,Wo),e(Wo,ri),e(M,ni),e(M,F),e(F,ai),e(F,Bo),e(Bo,si),e(F,ii),e(F,Go),e(Go,li),e(F,ci),e(F,zo),e(zo,gi),e(F,hi),e(g,pi),e(g,xe),m(dt,xe,null),e(xe,di),e(xe,Jo),e(Jo,ui),e(g,mi),e(g,De),m(ut,De,null),e(De,fi),e(De,Ko),e(Ko,_i),e(g,bi),e(g,Re),m(mt,Re,null),e(Re,yi),e(Re,Qo),e(Qo,vi),e(g,$i),e(g,Te),m(ft,Te,null),e(Te,wi),e(Te,Xo),e(Xo,ki),e(g,Ei),e(g,Pe),m(_t,Pe,null),e(Pe,xi),e(Pe,Yo),e(Yo,Di),$(t,Ir,y),$(t,Q,y),e(Q,Ie),e(Ie,Zo),m(bt,Zo,null),e(Q,Ri),e(Q,er),e(er,Ti),$(t,Or,y),$(t,X,y),m(yt,X,null),e(X,Pi),e(X,tr),e(tr,Ii),$(t,Lr,y),$(t,Y,y),m(vt,Y,null),e(Y,Oi),e(Y,or),e(or,Li),$(t,Cr,y),$(t,Z,y),m($t,Z,null),e(Z,Ci),e(Z,rr),e(rr,Fi),$(t,Fr,y),$(t,ee,y),m(wt,ee,null),e(ee,Ni),e(ee,nr),e(nr,ji),$(t,Nr,y),$(t,te,y),m(kt,te,null),e(te,Hi),e(te,ar),e(ar,Vi),$(t,jr,y),$(t,oe,y),m(Et,oe,null),e(oe,Ai),e(oe,sr),e(sr,Si),$(t,Hr,y),$(t,N,y),m(xt,N,null),e(N,qi),e(N,ir),e(ir,Ui),e(N,Mi),e(N,lr),e(lr,Wi),$(t,Vr,y),$(t,re,y),e(re,Oe),e(Oe,cr),m(Dt,cr,null),e(re,Bi),e(re,gr),e(gr,Gi),$(t,Ar,y),$(t,Le,y),e(Le,zi),e(Le,hr),e(hr,Ji),e(Le,Ki),$(t,Sr,y),$(t,O,y),e(O,pr),e(pr,dr),e(dr,Qi),e(O,Xi),e(O,ur),e(ur,mr),e(mr,Yi),e(O,Zi),e(O,fr),e(fr,_r),e(_r,el),e(O,tl),e(O,Rt),e(Rt,ol),e(Rt,br),e(br,rl),e(Rt,nl),$(t,qr,y),$(t,Nt,y),e(Nt,al),$(t,Ur,y),$(t,k,y),m(Tt,k,null),e(k,sl),e(k,yr),e(yr,il),e(k,ll),e(k,vr),e(vr,cl),e(k,gl),e(k,Ce),m(Pt,Ce,null),e(Ce,hl),e(Ce,$r),e($r,pl),e(k,dl),e(k,Fe),m(It,Fe,null),e(Fe,ul),e(Fe,wr),e(wr,ml),e(k,fl),e(k,Ne),m(Ot,Ne,null),e(Ne,_l),e(Ne,kr),e(kr,bl),$(t,Mr,y),$(t,ne,y),m(Lt,ne,null),e(ne,yl),e(ne,Er),e(Er,vl),Wr=!0},p(t,[y]){const Ct={};y&2&&(Ct.$$scope={dirty:y,ctx:t}),de.$set(Ct)},i(t){Wr||(f(w.$$.fragment,t),f(Ue.$$.fragment,t),f(Me.$$.fragment,t),f(We.$$.fragment,t),f(Be.$$.fragment,t),f(Ge.$$.fragment,t),f(ze.$$.fragment,t),f(Je.$$.fragment,t),f(Ke.$$.fragment,t),f(Qe.$$.fragment,t),f(Xe.$$.fragment,t),f(de.$$.fragment,t),f(Ye.$$.fragment,t),f(Ze.$$.fragment,t),f(et.$$.fragment,t),f(tt.$$.fragment,t),f(ot.$$.fragment,t),f(rt.$$.fragment,t),f(nt.$$.fragment,t),f(at.$$.fragment,t),f(st.$$.fragment,t),f(it.$$.fragment,t),f(lt.$$.fragment,t),f(ct.$$.fragment,t),f(gt.$$.fragment,t),f(ht.$$.fragment,t),f(pt.$$.fragment,t),f(dt.$$.fragment,t),f(ut.$$.fragment,t),f(mt.$$.fragment,t),f(ft.$$.fragment,t),f(_t.$$.fragment,t),f(bt.$$.fragment,t),f(yt.$$.fragment,t),f(vt.$$.fragment,t),f($t.$$.fragment,t),f(wt.$$.fragment,t),f(kt.$$.fragment,t),f(Et.$$.fragment,t),f(xt.$$.fragment,t),f(Dt.$$.fragment,t),f(Tt.$$.fragment,t),f(Pt.$$.fragment,t),f(It.$$.fragment,t),f(Ot.$$.fragment,t),f(Lt.$$.fragment,t),Wr=!0)},o(t){_(w.$$.fragment,t),_(Ue.$$.fragment,t),_(Me.$$.fragment,t),_(We.$$.fragment,t),_(Be.$$.fragment,t),_(Ge.$$.fragment,t),_(ze.$$.fragment,t),_(Je.$$.fragment,t),_(Ke.$$.fragment,t),_(Qe.$$.fragment,t),_(Xe.$$.fragment,t),_(de.$$.fragment,t),_(Ye.$$.fragment,t),_(Ze.$$.fragment,t),_(et.$$.fragment,t),_(tt.$$.fragment,t),_(ot.$$.fragment,t),_(rt.$$.fragment,t),_(nt.$$.fragment,t),_(at.$$.fragment,t),_(st.$$.fragment,t),_(it.$$.fragment,t),_(lt.$$.fragment,t),_(ct.$$.fragment,t),_(gt.$$.fragment,t),_(ht.$$.fragment,t),_(pt.$$.fragment,t),_(dt.$$.fragment,t),_(ut.$$.fragment,t),_(mt.$$.fragment,t),_(ft.$$.fragment,t),_(_t.$$.fragment,t),_(bt.$$.fragment,t),_(yt.$$.fragment,t),_(vt.$$.fragment,t),_($t.$$.fragment,t),_(wt.$$.fragment,t),_(kt.$$.fragment,t),_(Et.$$.fragment,t),_(xt.$$.fragment,t),_(Dt.$$.fragment,t),_(Tt.$$.fragment,t),_(Pt.$$.fragment,t),_(It.$$.fragment,t),_(Ot.$$.fragment,t),_(Lt.$$.fragment,t),Wr=!1},d(t){o(E),t&&o(se),t&&o(D),b(w),t&&o(Dr),t&&o(R),t&&o(Rr),t&&o(ie),t&&o(Tr),t&&o(W),b(Ue),t&&o(Pr),t&&o(g),b(Me),b(We),b(Be),b(Ge),b(ze),b(Je),b(Ke),b(Qe),b(Xe),b(de),b(Ye),b(Ze),b(et),b(tt),b(ot),b(rt),b(nt),b(at),b(st),b(it),b(lt),b(ct),b(gt),b(ht),b(pt),b(dt),b(ut),b(mt),b(ft),b(_t),t&&o(Ir),t&&o(Q),b(bt),t&&o(Or),t&&o(X),b(yt),t&&o(Lr),t&&o(Y),b(vt),t&&o(Cr),t&&o(Z),b($t),t&&o(Fr),t&&o(ee),b(wt),t&&o(Nr),t&&o(te),b(kt),t&&o(jr),t&&o(oe),b(Et),t&&o(Hr),t&&o(N),b(xt),t&&o(Vr),t&&o(re),b(Dt),t&&o(Ar),t&&o(Le),t&&o(Sr),t&&o(O),t&&o(qr),t&&o(Nt),t&&o(Ur),t&&o(k),b(Tt),b(Pt),b(It),b(Ot),t&&o(Mr),t&&o(ne),b(Lt)}}}const ug={local:"managing-local-and-online-repositories",sections:[{local:"huggingface_hub.Repository",title:"The Repository class"},{local:"huggingface_hub.repository.is_git_repo",title:"Helper methods"},{local:"huggingface_hub.Repository",title:"Following asynchronous commands"}],title:"Managing local and online repositories"};function mg(xr){return lg(()=>{new URLSearchParams(window.location.search).get("fw")}),[]}class $g extends ng{constructor(E){super();ag(this,E,mg,dg,sg,{})}}export{$g as default,ug as metadata};
