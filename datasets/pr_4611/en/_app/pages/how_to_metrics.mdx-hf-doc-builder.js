import{S as _l,i as gl,s as vl,e as a,k as c,w as _,t as n,M as wl,c as r,d as t,m as f,a as o,x as g,h as i,b as u,G as s,g as p,y as v,q as w,o as $,B as y,v as $l}from"../chunks/vendor-hf-doc-builder.js";import{T as Jr}from"../chunks/Tip-hf-doc-builder.js";import{I as ie}from"../chunks/IconCopyLink-hf-doc-builder.js";import{C as I}from"../chunks/CodeBlock-hf-doc-builder.js";function yl(R){let d,b;return{c(){d=a("p"),b=n("Metrics accepts various input formats (Python lists, NumPy arrays, PyTorch tensors, etc.) and converts them to an appropriate format for storage and computation.")},l(h){d=r(h,"P",{});var m=o(d);b=i(m,"Metrics accepts various input formats (Python lists, NumPy arrays, PyTorch tensors, etc.) and converts them to an appropriate format for storage and computation."),m.forEach(t)},m(h,m){p(h,d,m),s(d,b)},d(h){h&&t(d)}}}function bl(R){let d,b,h,m,L;return{c(){d=a("p"),b=n("Get jump started with our metric loading script "),h=a("a"),m=n("template"),L=n("!"),this.h()},l(j){d=r(j,"P",{});var E=o(d);b=i(E,"Get jump started with our metric loading script "),h=r(E,"A",{href:!0,rel:!0});var H=o(h);m=i(H,"template"),H.forEach(t),L=i(E,"!"),E.forEach(t),this.h()},h(){u(h,"href","https://github.com/huggingface/datasets/blob/master/templates/new_metric_script.py"),u(h,"rel","nofollow")},m(j,E){p(j,d,E),s(d,b),s(d,h),s(h,m),s(d,L)},d(j){j&&t(d)}}}function jl(R){let d,b;return{c(){d=a("p"),b=n("If the files are stored locally, provide a dictionary of path(s) instead of URLs.")},l(h){d=r(h,"P",{});var m=o(d);b=i(m,"If the files are stored locally, provide a dictionary of path(s) instead of URLs."),m.forEach(t)},m(h,m){p(h,d,m),s(d,b)},d(h){h&&t(d)}}}function ql(R){let d,b,h,m,L,j,E,H,la,Xt,Ue,na,Zt,Be,ia,es,k,nt,pa,ca,it,fa,ua,pt,da,ts,C,z,ct,pe,ha,ft,ma,ss,K,_a,Re,ga,va,as,V,ut,P,He,wa,$a,dt,ya,ba,ht,ja,qa,Ea,mt,A,ze,ka,Pa,_t,Aa,xa,gt,Ia,La,rs,Q,Ca,Ke,Sa,Ta,os,ce,ls,W,ns,S,Y,vt,fe,Ma,wt,Oa,is,G,Da,Ve,Na,Ua,ps,F,Ba,ue,Ra,Ha,cs,Qe,$t,za,fs,de,us,he,yt,Ka,ds,me,hs,_e,T,Va,bt,Qa,Wa,jt,Ya,Ga,ms,ge,_s,We,gs,M,J,qt,ve,Fa,Et,Ja,vs,X,Xa,Ye,Za,er,ws,Z,tr,we,sr,ar,$s,ee,ys,O,te,kt,$e,rr,Pt,or,bs,se,lr,At,nr,ir,js,q,xt,Ge,It,pr,cr,fr,Lt,Fe,Ct,ur,dr,hr,St,Je,Tt,mr,_r,gr,Mt,Xe,Ot,vr,wr,qs,Ze,$r,Es,ye,ks,D,ae,Dt,be,yr,Nt,br,Ps,x,jr,Ut,qr,Er,je,kr,Pr,As,et,Bt,Ar,xs,qe,Is,re,Ls,Ee,tt,Rt,xr,Ir,Cs,ke,Ss,N,oe,Ht,Pe,Lr,zt,Cr,Ts,U,Kt,Sr,Tr,Ae,Mr,Or,Ms,st,xe,Dr,Vt,Nr,Ur,Os,Ie,Ds,Le,Ce,Br,Qt,Rr,Hr,Ns,Se,Us,B,le,Wt,Te,zr,Yt,Kr,Bs,at,Vr,Rs,Me,Hs;return j=new ie({}),pe=new ie({}),ce=new I({props:{code:`import datasets
metric = datasets.load_metric('my_metric')
for model_input, gold_references in evaluation_dataset:
    model_predictions = model(model_inputs)
    metric.add_batch(predictions=model_predictions, references=gold_references)
final_score = metric.compute()`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> datasets
<span class="hljs-meta">&gt;&gt;&gt; </span>metric = datasets.load_metric(<span class="hljs-string">&#x27;my_metric&#x27;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">for</span> model_input, gold_references <span class="hljs-keyword">in</span> evaluation_dataset:
<span class="hljs-meta">... </span>    model_predictions = model(model_inputs)
<span class="hljs-meta">... </span>    metric.add_batch(predictions=model_predictions, references=gold_references)
<span class="hljs-meta">&gt;&gt;&gt; </span>final_score = metric.compute()`}}),W=new Jr({props:{$$slots:{default:[yl]},$$scope:{ctx:R}}}),fe=new ie({}),de=new I({props:{code:`import datasets
metric = datasets.load_metric('sacrebleu')`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> datasets
<span class="hljs-meta">&gt;&gt;&gt; </span>metric = datasets.load_metric(<span class="hljs-string">&#x27;sacrebleu&#x27;</span>)`}}),me=new I({props:{code:`print(metric.inputs_description)
`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(metric.inputs_description)
Produces BLEU scores along <span class="hljs-keyword">with</span> its sufficient statistics
<span class="hljs-keyword">from</span> a source against one <span class="hljs-keyword">or</span> more references.

Args:
    predictions: The system stream (a sequence of segments).
    references: A <span class="hljs-built_in">list</span> of one <span class="hljs-keyword">or</span> more reference streams (each a sequence of segments).
    smooth_method: The smoothing method to use. (Default: <span class="hljs-string">&#x27;exp&#x27;</span>).
    smooth_value: The smoothing value. Only valid <span class="hljs-keyword">for</span> <span class="hljs-string">&#x27;floor&#x27;</span> <span class="hljs-keyword">and</span> <span class="hljs-string">&#x27;add-k&#x27;</span>. (Defaults: floor: <span class="hljs-number">0.1</span>, add-k: <span class="hljs-number">1</span>).
    tokenize: Tokenization method to use <span class="hljs-keyword">for</span> BLEU. If <span class="hljs-keyword">not</span> provided, defaults to <span class="hljs-string">&#x27;zh&#x27;</span> <span class="hljs-keyword">for</span> Chinese, <span class="hljs-string">&#x27;ja-mecab&#x27;</span> <span class="hljs-keyword">for</span> Japanese <span class="hljs-keyword">and</span> <span class="hljs-string">&#x27;13a&#x27;</span> (mteval) otherwise.
    lowercase: Lowercase the data. If <span class="hljs-literal">True</span>, enables case-insensitivity. (Default: <span class="hljs-literal">False</span>).
    force: Insist that your tokenized <span class="hljs-built_in">input</span> <span class="hljs-keyword">is</span> actually detokenized.
...`}}),ge=new I({props:{code:'score = metric.compute(smooth_method="floor", smooth_value=0.2)',highlighted:'<span class="hljs-meta">&gt;&gt;&gt; </span>score = metric.compute(smooth_method=<span class="hljs-string">&quot;floor&quot;</span>, smooth_value=<span class="hljs-number">0.2</span>)'}}),ve=new ie({}),ee=new Jr({props:{$$slots:{default:[bl]},$$scope:{ctx:R}}}),$e=new ie({}),ye=new I({props:{code:`class Squad(datasets.Metric):
    def _info(self):
        return datasets.MetricInfo(
            description=_DESCRIPTION,
            citation=_CITATION,
            inputs_description=_KWARGS_DESCRIPTION,
            features=datasets.Features(
                {
                    "predictions": {"id": datasets.Value("string"), "prediction_text": datasets.Value("string")},
                    "references": {
                        "id": datasets.Value("string"),
                        "answers": datasets.features.Sequence(
                            {
                                "text": datasets.Value("string"),
                                "answer_start": datasets.Value("int32"),
                            }
                        ),
                    },
                }
            ),
            codebase_urls=["https://rajpurkar.github.io/SQuAD-explorer/"],
            reference_urls=["https://rajpurkar.github.io/SQuAD-explorer/"],
        )`,highlighted:`<span class="hljs-keyword">class</span> <span class="hljs-title class_">Squad</span>(datasets.Metric):
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_info</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">return</span> datasets.MetricInfo(
            description=_DESCRIPTION,
            citation=_CITATION,
            inputs_description=_KWARGS_DESCRIPTION,
            features=datasets.Features(
                {
                    <span class="hljs-string">&quot;predictions&quot;</span>: {<span class="hljs-string">&quot;id&quot;</span>: datasets.Value(<span class="hljs-string">&quot;string&quot;</span>), <span class="hljs-string">&quot;prediction_text&quot;</span>: datasets.Value(<span class="hljs-string">&quot;string&quot;</span>)},
                    <span class="hljs-string">&quot;references&quot;</span>: {
                        <span class="hljs-string">&quot;id&quot;</span>: datasets.Value(<span class="hljs-string">&quot;string&quot;</span>),
                        <span class="hljs-string">&quot;answers&quot;</span>: datasets.features.<span class="hljs-type">Sequence</span>(
                            {
                                <span class="hljs-string">&quot;text&quot;</span>: datasets.Value(<span class="hljs-string">&quot;string&quot;</span>),
                                <span class="hljs-string">&quot;answer_start&quot;</span>: datasets.Value(<span class="hljs-string">&quot;int32&quot;</span>),
                            }
                        ),
                    },
                }
            ),
            codebase_urls=[<span class="hljs-string">&quot;https://rajpurkar.github.io/SQuAD-explorer/&quot;</span>],
            reference_urls=[<span class="hljs-string">&quot;https://rajpurkar.github.io/SQuAD-explorer/&quot;</span>],
        )`}}),be=new ie({}),qe=new I({props:{code:`CHECKPOINT_URLS = {
    "bleurt-tiny-128": "https://storage.googleapis.com/bleurt-oss/bleurt-tiny-128.zip",
    "bleurt-tiny-512": "https://storage.googleapis.com/bleurt-oss/bleurt-tiny-512.zip",
    "bleurt-base-128": "https://storage.googleapis.com/bleurt-oss/bleurt-base-128.zip",
    "bleurt-base-512": "https://storage.googleapis.com/bleurt-oss/bleurt-base-512.zip",
    "bleurt-large-128": "https://storage.googleapis.com/bleurt-oss/bleurt-large-128.zip",
    "bleurt-large-512": "https://storage.googleapis.com/bleurt-oss/bleurt-large-512.zip",
}`,highlighted:`CHECKPOINT_URLS = {
    <span class="hljs-string">&quot;bleurt-tiny-128&quot;</span>: <span class="hljs-string">&quot;https://storage.googleapis.com/bleurt-oss/bleurt-tiny-128.zip&quot;</span>,
    <span class="hljs-string">&quot;bleurt-tiny-512&quot;</span>: <span class="hljs-string">&quot;https://storage.googleapis.com/bleurt-oss/bleurt-tiny-512.zip&quot;</span>,
    <span class="hljs-string">&quot;bleurt-base-128&quot;</span>: <span class="hljs-string">&quot;https://storage.googleapis.com/bleurt-oss/bleurt-base-128.zip&quot;</span>,
    <span class="hljs-string">&quot;bleurt-base-512&quot;</span>: <span class="hljs-string">&quot;https://storage.googleapis.com/bleurt-oss/bleurt-base-512.zip&quot;</span>,
    <span class="hljs-string">&quot;bleurt-large-128&quot;</span>: <span class="hljs-string">&quot;https://storage.googleapis.com/bleurt-oss/bleurt-large-128.zip&quot;</span>,
    <span class="hljs-string">&quot;bleurt-large-512&quot;</span>: <span class="hljs-string">&quot;https://storage.googleapis.com/bleurt-oss/bleurt-large-512.zip&quot;</span>,
}`}}),re=new Jr({props:{$$slots:{default:[jl]},$$scope:{ctx:R}}}),ke=new I({props:{code:`
`,highlighted:`<span class="hljs-keyword">def</span> <span class="hljs-title function_">_download_and_prepare</span>(<span class="hljs-params">self, dl_manager</span>):

    <span class="hljs-comment"># check that config name specifies a valid BLEURT model</span>
    <span class="hljs-keyword">if</span> self.config_name == <span class="hljs-string">&quot;default&quot;</span>:
        logger.warning(
            <span class="hljs-string">&quot;Using default BLEURT-Base checkpoint for sequence maximum length 128. &quot;</span>
            <span class="hljs-string">&quot;You can use a bigger model for better results with e.g.: datasets.load_metric(&#x27;bleurt&#x27;, &#x27;bleurt-large-512&#x27;).&quot;</span>
        )
        self.config_name = <span class="hljs-string">&quot;bleurt-base-128&quot;</span>
    <span class="hljs-keyword">if</span> self.config_name <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> CHECKPOINT_URLS.keys():
        <span class="hljs-keyword">raise</span> KeyError(
            <span class="hljs-string">f&quot;<span class="hljs-subst">{self.config_name}</span> model not found. You should supply the name of a model checkpoint for bleurt in <span class="hljs-subst">{CHECKPOINT_URLS.keys()}</span>&quot;</span>
        )

    <span class="hljs-comment"># download the model checkpoint specified by self.config_name and set up the scorer</span>
    model_path = dl_manager.download_and_extract(CHECKPOINT_URLS[self.config_name])
    self.scorer = score.BleurtScorer(os.path.join(model_path, self.config_name))`}}),Pe=new ie({}),Ie=new I({props:{code:`
`,highlighted:`<span class="hljs-keyword">def</span> <span class="hljs-title function_">simple_accuracy</span>(<span class="hljs-params">preds, labels</span>):
    <span class="hljs-keyword">return</span> (preds == labels).mean().item()

<span class="hljs-keyword">def</span> <span class="hljs-title function_">acc_and_f1</span>(<span class="hljs-params">preds, labels</span>):
    acc = simple_accuracy(preds, labels)
    f1 = f1_score(y_true=labels, y_pred=preds).item()
    <span class="hljs-keyword">return</span> {
        <span class="hljs-string">&quot;accuracy&quot;</span>: acc,
        <span class="hljs-string">&quot;f1&quot;</span>: f1,
    }

<span class="hljs-keyword">def</span> <span class="hljs-title function_">pearson_and_spearman</span>(<span class="hljs-params">preds, labels</span>):
    pearson_corr = pearsonr(preds, labels)[<span class="hljs-number">0</span>].item()
    spearman_corr = spearmanr(preds, labels)[<span class="hljs-number">0</span>].item()
    <span class="hljs-keyword">return</span> {
        <span class="hljs-string">&quot;pearson&quot;</span>: pearson_corr,
        <span class="hljs-string">&quot;spearmanr&quot;</span>: spearman_corr,
    }`}}),Se=new I({props:{code:`def _compute(self, predictions, references):
    if self.config_name == "cola":
        return {"matthews_correlation": matthews_corrcoef(references, predictions)}
    elif self.config_name == "stsb":
        return pearson_and_spearman(predictions, references)
    elif self.config_name in ["mrpc", "qqp"]:
        return acc_and_f1(predictions, references)
    elif self.config_name in ["sst2", "mnli", "mnli_mismatched", "mnli_matched", "qnli", "rte", "wnli", "hans"]:
        return {"accuracy": simple_accuracy(predictions, references)}
    else:
        raise KeyError(
            "You should supply a configuration name selected in "
            '["sst2", "mnli", "mnli_mismatched", "mnli_matched", '
            '"cola", "stsb", "mrpc", "qqp", "qnli", "rte", "wnli", "hans"]'
        )`,highlighted:`<span class="hljs-keyword">def</span> <span class="hljs-title function_">_compute</span>(<span class="hljs-params">self, predictions, references</span>):
    <span class="hljs-keyword">if</span> self.config_name == <span class="hljs-string">&quot;cola&quot;</span>:
        <span class="hljs-keyword">return</span> {<span class="hljs-string">&quot;matthews_correlation&quot;</span>: matthews_corrcoef(references, predictions)}
    <span class="hljs-keyword">elif</span> self.config_name == <span class="hljs-string">&quot;stsb&quot;</span>:
        <span class="hljs-keyword">return</span> pearson_and_spearman(predictions, references)
    <span class="hljs-keyword">elif</span> self.config_name <span class="hljs-keyword">in</span> [<span class="hljs-string">&quot;mrpc&quot;</span>, <span class="hljs-string">&quot;qqp&quot;</span>]:
        <span class="hljs-keyword">return</span> acc_and_f1(predictions, references)
    <span class="hljs-keyword">elif</span> self.config_name <span class="hljs-keyword">in</span> [<span class="hljs-string">&quot;sst2&quot;</span>, <span class="hljs-string">&quot;mnli&quot;</span>, <span class="hljs-string">&quot;mnli_mismatched&quot;</span>, <span class="hljs-string">&quot;mnli_matched&quot;</span>, <span class="hljs-string">&quot;qnli&quot;</span>, <span class="hljs-string">&quot;rte&quot;</span>, <span class="hljs-string">&quot;wnli&quot;</span>, <span class="hljs-string">&quot;hans&quot;</span>]:
        <span class="hljs-keyword">return</span> {<span class="hljs-string">&quot;accuracy&quot;</span>: simple_accuracy(predictions, references)}
    <span class="hljs-keyword">else</span>:
        <span class="hljs-keyword">raise</span> KeyError(
            <span class="hljs-string">&quot;You should supply a configuration name selected in &quot;</span>
            <span class="hljs-string">&#x27;[&quot;sst2&quot;, &quot;mnli&quot;, &quot;mnli_mismatched&quot;, &quot;mnli_matched&quot;, &#x27;</span>
            <span class="hljs-string">&#x27;&quot;cola&quot;, &quot;stsb&quot;, &quot;mrpc&quot;, &quot;qqp&quot;, &quot;qnli&quot;, &quot;rte&quot;, &quot;wnli&quot;, &quot;hans&quot;]&#x27;</span>
        )`}}),Te=new ie({}),Me=new I({props:{code:`from datasets import load_metric
metric = load_metric('PATH/TO/MY/SCRIPT.py')`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> datasets <span class="hljs-keyword">import</span> load_metric
<span class="hljs-meta">&gt;&gt;&gt; </span>metric = load_metric(<span class="hljs-string">&#x27;PATH/TO/MY/SCRIPT.py&#x27;</span>)`}}),{c(){d=a("meta"),b=c(),h=a("h1"),m=a("a"),L=a("span"),_(j.$$.fragment),E=c(),H=a("span"),la=n("Metrics"),Xt=c(),Ue=a("p"),na=n("Metrics are important for evaluating a model\u2019s predictions. In the tutorial, you learned how to compute a metric over an entire evaluation set. You have also seen how to load a metric."),Zt=c(),Be=a("p"),ia=n("This guide will show you how to:"),es=c(),k=a("ul"),nt=a("li"),pa=n("Add predictions and references."),ca=c(),it=a("li"),fa=n("Compute metrics using different methods."),ua=c(),pt=a("li"),da=n("Write your own metric loading script."),ts=c(),C=a("h2"),z=a("a"),ct=a("span"),_(pe.$$.fragment),ha=c(),ft=a("span"),ma=n("Add predictions and references"),ss=c(),K=a("p"),_a=n("When you want to add model predictions and references to a "),Re=a("a"),ga=n("Metric"),va=n(" instance, you have two options:"),as=c(),V=a("ul"),ut=a("li"),P=a("p"),He=a("a"),wa=n("Metric.add()"),$a=n(" adds a single "),dt=a("code"),ya=n("prediction"),ba=n(" and "),ht=a("code"),ja=n("reference"),qa=n("."),Ea=c(),mt=a("li"),A=a("p"),ze=a("a"),ka=n("Metric.add_batch()"),Pa=n(" adds a batch of "),_t=a("code"),Aa=n("predictions"),xa=n(" and "),gt=a("code"),Ia=n("references"),La=n("."),rs=c(),Q=a("p"),Ca=n("Use "),Ke=a("a"),Sa=n("Metric.add_batch()"),Ta=n(" by passing it your model predictions, and the references the model predictions should be evaluated against:"),os=c(),_(ce.$$.fragment),ls=c(),_(W.$$.fragment),ns=c(),S=a("h2"),Y=a("a"),vt=a("span"),_(fe.$$.fragment),Ma=c(),wt=a("span"),Oa=n("Compute scores"),is=c(),G=a("p"),Da=n("The most straightforward way to calculate a metric is to call "),Ve=a("a"),Na=n("Metric.compute()"),Ua=n(". But some metrics have additional arguments that allow you to modify the metrics behavior."),ps=c(),F=a("p"),Ba=n("Let\u2019s load the "),ue=a("a"),Ra=n("SacreBLEU"),Ha=n(" metric, and compute it with a different smoothing method."),cs=c(),Qe=a("ol"),$t=a("li"),za=n("Load the SacreBLEU metric:"),fs=c(),_(de.$$.fragment),us=c(),he=a("ol"),yt=a("li"),Ka=n("Inspect the different argument methods for computing the metric:"),ds=c(),_(me.$$.fragment),hs=c(),_e=a("ol"),T=a("li"),Va=n("Compute the metric with the "),bt=a("code"),Qa=n("floor"),Wa=n(" method, and a different "),jt=a("code"),Ya=n("smooth_value"),Ga=n(":"),ms=c(),_(ge.$$.fragment),_s=c(),We=a("a"),gs=c(),M=a("h2"),J=a("a"),qt=a("span"),_(ve.$$.fragment),Fa=c(),Et=a("span"),Ja=n("Custom metric loading script"),vs=c(),X=a("p"),Xa=n("Write a metric loading script to use your own custom metric (or one that is not on the Hub). Then you can load it as usual with "),Ye=a("a"),Za=n("load_metric()"),er=n("."),ws=c(),Z=a("p"),tr=n("To help you get started, open the "),we=a("a"),sr=n("SQuAD metric loading script"),ar=n(" and follow along."),$s=c(),_(ee.$$.fragment),ys=c(),O=a("h3"),te=a("a"),kt=a("span"),_($e.$$.fragment),rr=c(),Pt=a("span"),or=n("Add metric attributes"),bs=c(),se=a("p"),lr=n("Start by adding some information about your metric in "),At=a("code"),nr=n("Metric._info()"),ir=n(". The most important attributes you should specify are:"),js=c(),q=a("ol"),xt=a("li"),Ge=a("p"),It=a("code"),pr=n("MetricInfo.description"),cr=n(" provides a brief description about your metric."),fr=c(),Lt=a("li"),Fe=a("p"),Ct=a("code"),ur=n("MetricInfo.citation"),dr=n(" contains a BibTex citation for the metric."),hr=c(),St=a("li"),Je=a("p"),Tt=a("code"),mr=n("MetricInfo.inputs_description"),_r=n(" describes the expected inputs and outputs. It may also provide an example usage of the metric."),gr=c(),Mt=a("li"),Xe=a("p"),Ot=a("code"),vr=n("MetricInfo.features"),wr=n(" defines the name and type of the predictions and references."),qs=c(),Ze=a("p"),$r=n("After you\u2019ve filled out all these fields in the template, it should look like the following example from the SQuAD metric script:"),Es=c(),_(ye.$$.fragment),ks=c(),D=a("h3"),ae=a("a"),Dt=a("span"),_(be.$$.fragment),yr=c(),Nt=a("span"),br=n("Download metric files"),Ps=c(),x=a("p"),jr=n("If your metric needs to download, or retrieve local files, you will need to use the "),Ut=a("code"),qr=n("Metric._download_and_prepare()"),Er=n(" method. For this example, let\u2019s examine the "),je=a("a"),kr=n("BLEURT metric loading script"),Pr=n("."),As=c(),et=a("ol"),Bt=a("li"),Ar=n("Provide a dictionary of URLs that point to the metric files:"),xs=c(),_(qe.$$.fragment),Is=c(),_(re.$$.fragment),Ls=c(),Ee=a("ol"),tt=a("li"),Rt=a("code"),xr=n("Metric._download_and_prepare()"),Ir=n(" will take the URLs and download the metric files specified:"),Cs=c(),_(ke.$$.fragment),Ss=c(),N=a("h3"),oe=a("a"),Ht=a("span"),_(Pe.$$.fragment),Lr=c(),zt=a("span"),Cr=n("Compute score"),Ts=c(),U=a("p"),Kt=a("code"),Sr=n("DatasetBuilder._compute"),Tr=n(" provides the actual instructions for how to compute a metric given the predictions and references. Now let\u2019s take a look at the "),Ae=a("a"),Mr=n("GLUE metric loading script"),Or=n("."),Ms=c(),st=a("ol"),xe=a("li"),Dr=n("Provide the functions for "),Vt=a("code"),Nr=n("DatasetBuilder._compute"),Ur=n(" to calculate your metric:"),Os=c(),_(Ie.$$.fragment),Ds=c(),Le=a("ol"),Ce=a("li"),Br=n("Create "),Qt=a("code"),Rr=n("DatasetBuilder._compute"),Hr=n(" with instructions for what metric to calculate for each configuration:"),Ns=c(),_(Se.$$.fragment),Us=c(),B=a("h3"),le=a("a"),Wt=a("span"),_(Te.$$.fragment),zr=c(),Yt=a("span"),Kr=n("Test"),Bs=c(),at=a("p"),Vr=n("Once you\u2019re finished writing your metric loading script, try to load it locally:"),Rs=c(),_(Me.$$.fragment),this.h()},l(e){const l=wl('[data-svelte="svelte-1phssyn"]',document.head);d=r(l,"META",{name:!0,content:!0}),l.forEach(t),b=f(e),h=r(e,"H1",{class:!0});var Oe=o(h);m=r(Oe,"A",{id:!0,class:!0,href:!0});var Gt=o(m);L=r(Gt,"SPAN",{});var Ft=o(L);g(j.$$.fragment,Ft),Ft.forEach(t),Gt.forEach(t),E=f(Oe),H=r(Oe,"SPAN",{});var Xr=o(H);la=i(Xr,"Metrics"),Xr.forEach(t),Oe.forEach(t),Xt=f(e),Ue=r(e,"P",{});var Zr=o(Ue);na=i(Zr,"Metrics are important for evaluating a model\u2019s predictions. In the tutorial, you learned how to compute a metric over an entire evaluation set. You have also seen how to load a metric."),Zr.forEach(t),Zt=f(e),Be=r(e,"P",{});var eo=o(Be);ia=i(eo,"This guide will show you how to:"),eo.forEach(t),es=f(e),k=r(e,"UL",{});var rt=o(k);nt=r(rt,"LI",{});var to=o(nt);pa=i(to,"Add predictions and references."),to.forEach(t),ca=f(rt),it=r(rt,"LI",{});var so=o(it);fa=i(so,"Compute metrics using different methods."),so.forEach(t),ua=f(rt),pt=r(rt,"LI",{});var ao=o(pt);da=i(ao,"Write your own metric loading script."),ao.forEach(t),rt.forEach(t),ts=f(e),C=r(e,"H2",{class:!0});var zs=o(C);z=r(zs,"A",{id:!0,class:!0,href:!0});var ro=o(z);ct=r(ro,"SPAN",{});var oo=o(ct);g(pe.$$.fragment,oo),oo.forEach(t),ro.forEach(t),ha=f(zs),ft=r(zs,"SPAN",{});var lo=o(ft);ma=i(lo,"Add predictions and references"),lo.forEach(t),zs.forEach(t),ss=f(e),K=r(e,"P",{});var Ks=o(K);_a=i(Ks,"When you want to add model predictions and references to a "),Re=r(Ks,"A",{href:!0});var no=o(Re);ga=i(no,"Metric"),no.forEach(t),va=i(Ks," instance, you have two options:"),Ks.forEach(t),as=f(e),V=r(e,"UL",{});var Vs=o(V);ut=r(Vs,"LI",{});var io=o(ut);P=r(io,"P",{});var De=o(P);He=r(De,"A",{href:!0});var po=o(He);wa=i(po,"Metric.add()"),po.forEach(t),$a=i(De," adds a single "),dt=r(De,"CODE",{});var co=o(dt);ya=i(co,"prediction"),co.forEach(t),ba=i(De," and "),ht=r(De,"CODE",{});var fo=o(ht);ja=i(fo,"reference"),fo.forEach(t),qa=i(De,"."),De.forEach(t),io.forEach(t),Ea=f(Vs),mt=r(Vs,"LI",{});var uo=o(mt);A=r(uo,"P",{});var Ne=o(A);ze=r(Ne,"A",{href:!0});var ho=o(ze);ka=i(ho,"Metric.add_batch()"),ho.forEach(t),Pa=i(Ne," adds a batch of "),_t=r(Ne,"CODE",{});var mo=o(_t);Aa=i(mo,"predictions"),mo.forEach(t),xa=i(Ne," and "),gt=r(Ne,"CODE",{});var _o=o(gt);Ia=i(_o,"references"),_o.forEach(t),La=i(Ne,"."),Ne.forEach(t),uo.forEach(t),Vs.forEach(t),rs=f(e),Q=r(e,"P",{});var Qs=o(Q);Ca=i(Qs,"Use "),Ke=r(Qs,"A",{href:!0});var go=o(Ke);Sa=i(go,"Metric.add_batch()"),go.forEach(t),Ta=i(Qs," by passing it your model predictions, and the references the model predictions should be evaluated against:"),Qs.forEach(t),os=f(e),g(ce.$$.fragment,e),ls=f(e),g(W.$$.fragment,e),ns=f(e),S=r(e,"H2",{class:!0});var Ws=o(S);Y=r(Ws,"A",{id:!0,class:!0,href:!0});var vo=o(Y);vt=r(vo,"SPAN",{});var wo=o(vt);g(fe.$$.fragment,wo),wo.forEach(t),vo.forEach(t),Ma=f(Ws),wt=r(Ws,"SPAN",{});var $o=o(wt);Oa=i($o,"Compute scores"),$o.forEach(t),Ws.forEach(t),is=f(e),G=r(e,"P",{});var Ys=o(G);Da=i(Ys,"The most straightforward way to calculate a metric is to call "),Ve=r(Ys,"A",{href:!0});var yo=o(Ve);Na=i(yo,"Metric.compute()"),yo.forEach(t),Ua=i(Ys,". But some metrics have additional arguments that allow you to modify the metrics behavior."),Ys.forEach(t),ps=f(e),F=r(e,"P",{});var Gs=o(F);Ba=i(Gs,"Let\u2019s load the "),ue=r(Gs,"A",{href:!0,rel:!0});var bo=o(ue);Ra=i(bo,"SacreBLEU"),bo.forEach(t),Ha=i(Gs," metric, and compute it with a different smoothing method."),Gs.forEach(t),cs=f(e),Qe=r(e,"OL",{});var jo=o(Qe);$t=r(jo,"LI",{});var qo=o($t);za=i(qo,"Load the SacreBLEU metric:"),qo.forEach(t),jo.forEach(t),fs=f(e),g(de.$$.fragment,e),us=f(e),he=r(e,"OL",{start:!0});var Eo=o(he);yt=r(Eo,"LI",{});var ko=o(yt);Ka=i(ko,"Inspect the different argument methods for computing the metric:"),ko.forEach(t),Eo.forEach(t),ds=f(e),g(me.$$.fragment,e),hs=f(e),_e=r(e,"OL",{start:!0});var Po=o(_e);T=r(Po,"LI",{});var ot=o(T);Va=i(ot,"Compute the metric with the "),bt=r(ot,"CODE",{});var Ao=o(bt);Qa=i(Ao,"floor"),Ao.forEach(t),Wa=i(ot," method, and a different "),jt=r(ot,"CODE",{});var xo=o(jt);Ya=i(xo,"smooth_value"),xo.forEach(t),Ga=i(ot,":"),ot.forEach(t),Po.forEach(t),ms=f(e),g(ge.$$.fragment,e),_s=f(e),We=r(e,"A",{id:!0}),o(We).forEach(t),gs=f(e),M=r(e,"H2",{class:!0});var Fs=o(M);J=r(Fs,"A",{id:!0,class:!0,href:!0});var Io=o(J);qt=r(Io,"SPAN",{});var Lo=o(qt);g(ve.$$.fragment,Lo),Lo.forEach(t),Io.forEach(t),Fa=f(Fs),Et=r(Fs,"SPAN",{});var Co=o(Et);Ja=i(Co,"Custom metric loading script"),Co.forEach(t),Fs.forEach(t),vs=f(e),X=r(e,"P",{});var Js=o(X);Xa=i(Js,"Write a metric loading script to use your own custom metric (or one that is not on the Hub). Then you can load it as usual with "),Ye=r(Js,"A",{href:!0});var So=o(Ye);Za=i(So,"load_metric()"),So.forEach(t),er=i(Js,"."),Js.forEach(t),ws=f(e),Z=r(e,"P",{});var Xs=o(Z);tr=i(Xs,"To help you get started, open the "),we=r(Xs,"A",{href:!0,rel:!0});var To=o(we);sr=i(To,"SQuAD metric loading script"),To.forEach(t),ar=i(Xs," and follow along."),Xs.forEach(t),$s=f(e),g(ee.$$.fragment,e),ys=f(e),O=r(e,"H3",{class:!0});var Zs=o(O);te=r(Zs,"A",{id:!0,class:!0,href:!0});var Mo=o(te);kt=r(Mo,"SPAN",{});var Oo=o(kt);g($e.$$.fragment,Oo),Oo.forEach(t),Mo.forEach(t),rr=f(Zs),Pt=r(Zs,"SPAN",{});var Do=o(Pt);or=i(Do,"Add metric attributes"),Do.forEach(t),Zs.forEach(t),bs=f(e),se=r(e,"P",{});var ea=o(se);lr=i(ea,"Start by adding some information about your metric in "),At=r(ea,"CODE",{});var No=o(At);nr=i(No,"Metric._info()"),No.forEach(t),ir=i(ea,". The most important attributes you should specify are:"),ea.forEach(t),js=f(e),q=r(e,"OL",{});var ne=o(q);xt=r(ne,"LI",{});var Uo=o(xt);Ge=r(Uo,"P",{});var Qr=o(Ge);It=r(Qr,"CODE",{});var Bo=o(It);pr=i(Bo,"MetricInfo.description"),Bo.forEach(t),cr=i(Qr," provides a brief description about your metric."),Qr.forEach(t),Uo.forEach(t),fr=f(ne),Lt=r(ne,"LI",{});var Ro=o(Lt);Fe=r(Ro,"P",{});var Wr=o(Fe);Ct=r(Wr,"CODE",{});var Ho=o(Ct);ur=i(Ho,"MetricInfo.citation"),Ho.forEach(t),dr=i(Wr," contains a BibTex citation for the metric."),Wr.forEach(t),Ro.forEach(t),hr=f(ne),St=r(ne,"LI",{});var zo=o(St);Je=r(zo,"P",{});var Yr=o(Je);Tt=r(Yr,"CODE",{});var Ko=o(Tt);mr=i(Ko,"MetricInfo.inputs_description"),Ko.forEach(t),_r=i(Yr," describes the expected inputs and outputs. It may also provide an example usage of the metric."),Yr.forEach(t),zo.forEach(t),gr=f(ne),Mt=r(ne,"LI",{});var Vo=o(Mt);Xe=r(Vo,"P",{});var Gr=o(Xe);Ot=r(Gr,"CODE",{});var Qo=o(Ot);vr=i(Qo,"MetricInfo.features"),Qo.forEach(t),wr=i(Gr," defines the name and type of the predictions and references."),Gr.forEach(t),Vo.forEach(t),ne.forEach(t),qs=f(e),Ze=r(e,"P",{});var Wo=o(Ze);$r=i(Wo,"After you\u2019ve filled out all these fields in the template, it should look like the following example from the SQuAD metric script:"),Wo.forEach(t),Es=f(e),g(ye.$$.fragment,e),ks=f(e),D=r(e,"H3",{class:!0});var ta=o(D);ae=r(ta,"A",{id:!0,class:!0,href:!0});var Yo=o(ae);Dt=r(Yo,"SPAN",{});var Go=o(Dt);g(be.$$.fragment,Go),Go.forEach(t),Yo.forEach(t),yr=f(ta),Nt=r(ta,"SPAN",{});var Fo=o(Nt);br=i(Fo,"Download metric files"),Fo.forEach(t),ta.forEach(t),Ps=f(e),x=r(e,"P",{});var lt=o(x);jr=i(lt,"If your metric needs to download, or retrieve local files, you will need to use the "),Ut=r(lt,"CODE",{});var Jo=o(Ut);qr=i(Jo,"Metric._download_and_prepare()"),Jo.forEach(t),Er=i(lt," method. For this example, let\u2019s examine the "),je=r(lt,"A",{href:!0,rel:!0});var Xo=o(je);kr=i(Xo,"BLEURT metric loading script"),Xo.forEach(t),Pr=i(lt,"."),lt.forEach(t),As=f(e),et=r(e,"OL",{});var Zo=o(et);Bt=r(Zo,"LI",{});var el=o(Bt);Ar=i(el,"Provide a dictionary of URLs that point to the metric files:"),el.forEach(t),Zo.forEach(t),xs=f(e),g(qe.$$.fragment,e),Is=f(e),g(re.$$.fragment,e),Ls=f(e),Ee=r(e,"OL",{start:!0});var tl=o(Ee);tt=r(tl,"LI",{});var Fr=o(tt);Rt=r(Fr,"CODE",{});var sl=o(Rt);xr=i(sl,"Metric._download_and_prepare()"),sl.forEach(t),Ir=i(Fr," will take the URLs and download the metric files specified:"),Fr.forEach(t),tl.forEach(t),Cs=f(e),g(ke.$$.fragment,e),Ss=f(e),N=r(e,"H3",{class:!0});var sa=o(N);oe=r(sa,"A",{id:!0,class:!0,href:!0});var al=o(oe);Ht=r(al,"SPAN",{});var rl=o(Ht);g(Pe.$$.fragment,rl),rl.forEach(t),al.forEach(t),Lr=f(sa),zt=r(sa,"SPAN",{});var ol=o(zt);Cr=i(ol,"Compute score"),ol.forEach(t),sa.forEach(t),Ts=f(e),U=r(e,"P",{});var Jt=o(U);Kt=r(Jt,"CODE",{});var ll=o(Kt);Sr=i(ll,"DatasetBuilder._compute"),ll.forEach(t),Tr=i(Jt," provides the actual instructions for how to compute a metric given the predictions and references. Now let\u2019s take a look at the "),Ae=r(Jt,"A",{href:!0,rel:!0});var nl=o(Ae);Mr=i(nl,"GLUE metric loading script"),nl.forEach(t),Or=i(Jt,"."),Jt.forEach(t),Ms=f(e),st=r(e,"OL",{});var il=o(st);xe=r(il,"LI",{});var aa=o(xe);Dr=i(aa,"Provide the functions for "),Vt=r(aa,"CODE",{});var pl=o(Vt);Nr=i(pl,"DatasetBuilder._compute"),pl.forEach(t),Ur=i(aa," to calculate your metric:"),aa.forEach(t),il.forEach(t),Os=f(e),g(Ie.$$.fragment,e),Ds=f(e),Le=r(e,"OL",{start:!0});var cl=o(Le);Ce=r(cl,"LI",{});var ra=o(Ce);Br=i(ra,"Create "),Qt=r(ra,"CODE",{});var fl=o(Qt);Rr=i(fl,"DatasetBuilder._compute"),fl.forEach(t),Hr=i(ra," with instructions for what metric to calculate for each configuration:"),ra.forEach(t),cl.forEach(t),Ns=f(e),g(Se.$$.fragment,e),Us=f(e),B=r(e,"H3",{class:!0});var oa=o(B);le=r(oa,"A",{id:!0,class:!0,href:!0});var ul=o(le);Wt=r(ul,"SPAN",{});var dl=o(Wt);g(Te.$$.fragment,dl),dl.forEach(t),ul.forEach(t),zr=f(oa),Yt=r(oa,"SPAN",{});var hl=o(Yt);Kr=i(hl,"Test"),hl.forEach(t),oa.forEach(t),Bs=f(e),at=r(e,"P",{});var ml=o(at);Vr=i(ml,"Once you\u2019re finished writing your metric loading script, try to load it locally:"),ml.forEach(t),Rs=f(e),g(Me.$$.fragment,e),this.h()},h(){u(d,"name","hf:doc:metadata"),u(d,"content",JSON.stringify(El)),u(m,"id","metrics"),u(m,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),u(m,"href","#metrics"),u(h,"class","relative group"),u(z,"id","add-predictions-and-references"),u(z,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),u(z,"href","#add-predictions-and-references"),u(C,"class","relative group"),u(Re,"href","/docs/datasets/pr_4611/en/package_reference/main_classes#datasets.Metric"),u(He,"href","/docs/datasets/pr_4611/en/package_reference/main_classes#datasets.Metric.add"),u(ze,"href","/docs/datasets/pr_4611/en/package_reference/main_classes#datasets.Metric.add_batch"),u(Ke,"href","/docs/datasets/pr_4611/en/package_reference/main_classes#datasets.Metric.add_batch"),u(Y,"id","compute-scores"),u(Y,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),u(Y,"href","#compute-scores"),u(S,"class","relative group"),u(Ve,"href","/docs/datasets/pr_4611/en/package_reference/main_classes#datasets.Metric.compute"),u(ue,"href","https://huggingface.co/metrics/sacrebleu"),u(ue,"rel","nofollow"),u(he,"start","2"),u(_e,"start","3"),u(We,"id","metric_script"),u(J,"id","custom-metric-loading-script"),u(J,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),u(J,"href","#custom-metric-loading-script"),u(M,"class","relative group"),u(Ye,"href","/docs/datasets/pr_4611/en/package_reference/loading_methods#datasets.load_metric"),u(we,"href","https://github.com/huggingface/datasets/blob/master/metrics/squad/squad.py"),u(we,"rel","nofollow"),u(te,"id","add-metric-attributes"),u(te,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),u(te,"href","#add-metric-attributes"),u(O,"class","relative group"),u(ae,"id","download-metric-files"),u(ae,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),u(ae,"href","#download-metric-files"),u(D,"class","relative group"),u(je,"href","https://github.com/huggingface/datasets/blob/master/metrics/bleurt/bleurt.py"),u(je,"rel","nofollow"),u(Ee,"start","2"),u(oe,"id","compute-score"),u(oe,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),u(oe,"href","#compute-score"),u(N,"class","relative group"),u(Ae,"href","https://github.com/huggingface/datasets/blob/master/metrics/glue/glue.py"),u(Ae,"rel","nofollow"),u(Le,"start","2"),u(le,"id","test"),u(le,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),u(le,"href","#test"),u(B,"class","relative group")},m(e,l){s(document.head,d),p(e,b,l),p(e,h,l),s(h,m),s(m,L),v(j,L,null),s(h,E),s(h,H),s(H,la),p(e,Xt,l),p(e,Ue,l),s(Ue,na),p(e,Zt,l),p(e,Be,l),s(Be,ia),p(e,es,l),p(e,k,l),s(k,nt),s(nt,pa),s(k,ca),s(k,it),s(it,fa),s(k,ua),s(k,pt),s(pt,da),p(e,ts,l),p(e,C,l),s(C,z),s(z,ct),v(pe,ct,null),s(C,ha),s(C,ft),s(ft,ma),p(e,ss,l),p(e,K,l),s(K,_a),s(K,Re),s(Re,ga),s(K,va),p(e,as,l),p(e,V,l),s(V,ut),s(ut,P),s(P,He),s(He,wa),s(P,$a),s(P,dt),s(dt,ya),s(P,ba),s(P,ht),s(ht,ja),s(P,qa),s(V,Ea),s(V,mt),s(mt,A),s(A,ze),s(ze,ka),s(A,Pa),s(A,_t),s(_t,Aa),s(A,xa),s(A,gt),s(gt,Ia),s(A,La),p(e,rs,l),p(e,Q,l),s(Q,Ca),s(Q,Ke),s(Ke,Sa),s(Q,Ta),p(e,os,l),v(ce,e,l),p(e,ls,l),v(W,e,l),p(e,ns,l),p(e,S,l),s(S,Y),s(Y,vt),v(fe,vt,null),s(S,Ma),s(S,wt),s(wt,Oa),p(e,is,l),p(e,G,l),s(G,Da),s(G,Ve),s(Ve,Na),s(G,Ua),p(e,ps,l),p(e,F,l),s(F,Ba),s(F,ue),s(ue,Ra),s(F,Ha),p(e,cs,l),p(e,Qe,l),s(Qe,$t),s($t,za),p(e,fs,l),v(de,e,l),p(e,us,l),p(e,he,l),s(he,yt),s(yt,Ka),p(e,ds,l),v(me,e,l),p(e,hs,l),p(e,_e,l),s(_e,T),s(T,Va),s(T,bt),s(bt,Qa),s(T,Wa),s(T,jt),s(jt,Ya),s(T,Ga),p(e,ms,l),v(ge,e,l),p(e,_s,l),p(e,We,l),p(e,gs,l),p(e,M,l),s(M,J),s(J,qt),v(ve,qt,null),s(M,Fa),s(M,Et),s(Et,Ja),p(e,vs,l),p(e,X,l),s(X,Xa),s(X,Ye),s(Ye,Za),s(X,er),p(e,ws,l),p(e,Z,l),s(Z,tr),s(Z,we),s(we,sr),s(Z,ar),p(e,$s,l),v(ee,e,l),p(e,ys,l),p(e,O,l),s(O,te),s(te,kt),v($e,kt,null),s(O,rr),s(O,Pt),s(Pt,or),p(e,bs,l),p(e,se,l),s(se,lr),s(se,At),s(At,nr),s(se,ir),p(e,js,l),p(e,q,l),s(q,xt),s(xt,Ge),s(Ge,It),s(It,pr),s(Ge,cr),s(q,fr),s(q,Lt),s(Lt,Fe),s(Fe,Ct),s(Ct,ur),s(Fe,dr),s(q,hr),s(q,St),s(St,Je),s(Je,Tt),s(Tt,mr),s(Je,_r),s(q,gr),s(q,Mt),s(Mt,Xe),s(Xe,Ot),s(Ot,vr),s(Xe,wr),p(e,qs,l),p(e,Ze,l),s(Ze,$r),p(e,Es,l),v(ye,e,l),p(e,ks,l),p(e,D,l),s(D,ae),s(ae,Dt),v(be,Dt,null),s(D,yr),s(D,Nt),s(Nt,br),p(e,Ps,l),p(e,x,l),s(x,jr),s(x,Ut),s(Ut,qr),s(x,Er),s(x,je),s(je,kr),s(x,Pr),p(e,As,l),p(e,et,l),s(et,Bt),s(Bt,Ar),p(e,xs,l),v(qe,e,l),p(e,Is,l),v(re,e,l),p(e,Ls,l),p(e,Ee,l),s(Ee,tt),s(tt,Rt),s(Rt,xr),s(tt,Ir),p(e,Cs,l),v(ke,e,l),p(e,Ss,l),p(e,N,l),s(N,oe),s(oe,Ht),v(Pe,Ht,null),s(N,Lr),s(N,zt),s(zt,Cr),p(e,Ts,l),p(e,U,l),s(U,Kt),s(Kt,Sr),s(U,Tr),s(U,Ae),s(Ae,Mr),s(U,Or),p(e,Ms,l),p(e,st,l),s(st,xe),s(xe,Dr),s(xe,Vt),s(Vt,Nr),s(xe,Ur),p(e,Os,l),v(Ie,e,l),p(e,Ds,l),p(e,Le,l),s(Le,Ce),s(Ce,Br),s(Ce,Qt),s(Qt,Rr),s(Ce,Hr),p(e,Ns,l),v(Se,e,l),p(e,Us,l),p(e,B,l),s(B,le),s(le,Wt),v(Te,Wt,null),s(B,zr),s(B,Yt),s(Yt,Kr),p(e,Bs,l),p(e,at,l),s(at,Vr),p(e,Rs,l),v(Me,e,l),Hs=!0},p(e,[l]){const Oe={};l&2&&(Oe.$$scope={dirty:l,ctx:e}),W.$set(Oe);const Gt={};l&2&&(Gt.$$scope={dirty:l,ctx:e}),ee.$set(Gt);const Ft={};l&2&&(Ft.$$scope={dirty:l,ctx:e}),re.$set(Ft)},i(e){Hs||(w(j.$$.fragment,e),w(pe.$$.fragment,e),w(ce.$$.fragment,e),w(W.$$.fragment,e),w(fe.$$.fragment,e),w(de.$$.fragment,e),w(me.$$.fragment,e),w(ge.$$.fragment,e),w(ve.$$.fragment,e),w(ee.$$.fragment,e),w($e.$$.fragment,e),w(ye.$$.fragment,e),w(be.$$.fragment,e),w(qe.$$.fragment,e),w(re.$$.fragment,e),w(ke.$$.fragment,e),w(Pe.$$.fragment,e),w(Ie.$$.fragment,e),w(Se.$$.fragment,e),w(Te.$$.fragment,e),w(Me.$$.fragment,e),Hs=!0)},o(e){$(j.$$.fragment,e),$(pe.$$.fragment,e),$(ce.$$.fragment,e),$(W.$$.fragment,e),$(fe.$$.fragment,e),$(de.$$.fragment,e),$(me.$$.fragment,e),$(ge.$$.fragment,e),$(ve.$$.fragment,e),$(ee.$$.fragment,e),$($e.$$.fragment,e),$(ye.$$.fragment,e),$(be.$$.fragment,e),$(qe.$$.fragment,e),$(re.$$.fragment,e),$(ke.$$.fragment,e),$(Pe.$$.fragment,e),$(Ie.$$.fragment,e),$(Se.$$.fragment,e),$(Te.$$.fragment,e),$(Me.$$.fragment,e),Hs=!1},d(e){t(d),e&&t(b),e&&t(h),y(j),e&&t(Xt),e&&t(Ue),e&&t(Zt),e&&t(Be),e&&t(es),e&&t(k),e&&t(ts),e&&t(C),y(pe),e&&t(ss),e&&t(K),e&&t(as),e&&t(V),e&&t(rs),e&&t(Q),e&&t(os),y(ce,e),e&&t(ls),y(W,e),e&&t(ns),e&&t(S),y(fe),e&&t(is),e&&t(G),e&&t(ps),e&&t(F),e&&t(cs),e&&t(Qe),e&&t(fs),y(de,e),e&&t(us),e&&t(he),e&&t(ds),y(me,e),e&&t(hs),e&&t(_e),e&&t(ms),y(ge,e),e&&t(_s),e&&t(We),e&&t(gs),e&&t(M),y(ve),e&&t(vs),e&&t(X),e&&t(ws),e&&t(Z),e&&t($s),y(ee,e),e&&t(ys),e&&t(O),y($e),e&&t(bs),e&&t(se),e&&t(js),e&&t(q),e&&t(qs),e&&t(Ze),e&&t(Es),y(ye,e),e&&t(ks),e&&t(D),y(be),e&&t(Ps),e&&t(x),e&&t(As),e&&t(et),e&&t(xs),y(qe,e),e&&t(Is),y(re,e),e&&t(Ls),e&&t(Ee),e&&t(Cs),y(ke,e),e&&t(Ss),e&&t(N),y(Pe),e&&t(Ts),e&&t(U),e&&t(Ms),e&&t(st),e&&t(Os),y(Ie,e),e&&t(Ds),e&&t(Le),e&&t(Ns),y(Se,e),e&&t(Us),e&&t(B),y(Te),e&&t(Bs),e&&t(at),e&&t(Rs),y(Me,e)}}}const El={local:"metrics",sections:[{local:"add-predictions-and-references",title:"Add predictions and references"},{local:"compute-scores",title:"Compute scores"},{local:"custom-metric-loading-script",sections:[{local:"add-metric-attributes",title:"Add metric attributes"},{local:"download-metric-files",title:"Download metric files"},{local:"compute-score",title:"Compute score"},{local:"test",title:"Test"}],title:"Custom metric loading script"}],title:"Metrics"};function kl(R){return $l(()=>{new URLSearchParams(window.location.search).get("fw")}),[]}class Ll extends _l{constructor(d){super();gl(this,d,kl,ql,vl,{})}}export{Ll as default,El as metadata};
