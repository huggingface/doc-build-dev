import{S as At,i as gt,s as Pt,e as o,k as h,w as Qe,t as i,M as kt,c as r,d as a,m,a as l,x as Ye,h as s,b as d,G as t,g as c,y as Je,L as $t,q as Ke,o as Ve,B as Xe,v as Tt}from"../chunks/vendor-hf-doc-builder.js";import{I as Ze}from"../chunks/IconCopyLink-hf-doc-builder.js";function xt(et){let b,K,y,_,L,$,he,N,me,V,A,pe,C,fe,ve,X,w,g,I,T,be,B,ye,R,we,Z,P,Ee,S,_e,Ae,ee,p,ge,H,Pe,ke,j,$e,Te,te,E,k,F,x,xe,W,Ue,ae,u,Ce,q,Be,Se,z,Ge,Me,U,Oe,De,Q,Le,Ne,oe,G,Ie,ie,f,Re,Y,He,je,J,Fe,We,re,M,qe,se;return $=new Ze({}),T=new Ze({}),x=new Ze({}),{c(){b=o("meta"),K=h(),y=o("h1"),_=o("a"),L=o("span"),Qe($.$$.fragment),he=h(),N=o("span"),me=i("All about metrics"),V=h(),A=o("p"),pe=i("\u{1F917} Evaluate provides access to a wide range of NLP metrics. You can load metrics associated with benchmark datasets like GLUE or SQuAD, and complex metrics like BLEURT or BERTScore, with a single command: "),C=o("a"),fe=i("evaluate.load()"),ve=i(". Once you\u2019ve loaded a metric, easily compute and evaluate a model\u2019s performance."),X=h(),w=o("h2"),g=o("a"),I=o("span"),Qe(T.$$.fragment),be=h(),B=o("span"),ye=i("ELI5: "),R=o("code"),we=i("evaluate.load"),Z=h(),P=o("p"),Ee=i("When you call "),S=o("a"),_e=i("evaluate.load()"),Ae=i(", the metric loading script is downloaded and imported from GitHub (if it hasn\u2019t already been downloaded before). It contains information about the metric such as it\u2019s citation, homepage, and description."),ee=h(),p=o("p"),ge=i("The metric loading script will instantiate and return a "),H=o("code"),Pe=i("EvaluationModule"),ke=i(" object. This stores the predictions and references, which you need to compute the metric values. The "),j=o("code"),$e=i("EvaluationModule"),Te=i(" object is stored as an Apache Arrow table. As a result, the predictions and references are stored directly on disk with memory-mapping. This enables \u{1F917} Evaluate to do a lazy computation of the metric, and makes it easier to gather all the predictions in a distributed setting."),te=h(),E=o("h2"),k=o("a"),F=o("span"),Qe(x.$$.fragment),xe=h(),W=o("span"),Ue=i("Distributed evaluation"),ae=h(),u=o("p"),Ce=i("Computing metrics in a distributed environment can be tricky. Metric evaluation is executed in separate Python processes, or nodes, on different subsets of a dataset. Typically, when a metric score is additive ("),q=o("code"),Be=i("f(AuB) = f(A) + f(B)"),Se=i("), you can use distributed reduce operations to gather the scores for each subset of the dataset. But when a metric is non-additive ("),z=o("code"),Ge=i("f(AuB) \u2260 f(A) + f(B)"),Me=i("), it\u2019s not that simple. For example, you can\u2019t take the sum of the "),U=o("a"),Oe=i("F1"),De=i(" scores of each data subset as your "),Q=o("strong"),Le=i("final metric"),Ne=i("."),oe=h(),G=o("p"),Ie=i("A common way to overcome this issue is to fallback on single process evaluation. The metrics are evaluated on a single GPU, which becomes inefficient."),ie=h(),f=o("p"),Re=i("\u{1F917} Evaluate solves this issue by only computing the final metric on the first node. The predictions and references are computed and provided to the metric separately for each node. These are temporarily stored in an Apache Arrow table, avoiding cluttering the GPU or CPU memory. When you are ready to "),Y=o("code"),He=i("EvaluationModule.compute"),je=i(" the final metric, the first node is able to access the predictions and references stored on all the other nodes. Once it has gathered all the predictions and references, "),J=o("code"),Fe=i("EvaluationModule.compute"),We=i(" will perform the final metric evaluation."),re=h(),M=o("p"),qe=i("This solution allows \u{1F917} Evaluate to perform distributed predictions, which is important for evaluation speed in distributed settings. At the same time, you can also use complex non-additive metrics without wasting valuable GPU or CPU memory. distributed predictions, which is important for evaluation speed in distributed settings. At the same time, you can also use complex non-additive metrics without wasting valuable GPU or CPU memory."),this.h()},l(e){const n=kt('[data-svelte="svelte-1phssyn"]',document.head);b=r(n,"META",{name:!0,content:!0}),n.forEach(a),K=m(e),y=r(e,"H1",{class:!0});var le=l(y);_=r(le,"A",{id:!0,class:!0,href:!0});var tt=l(_);L=r(tt,"SPAN",{});var at=l(L);Ye($.$$.fragment,at),at.forEach(a),tt.forEach(a),he=m(le),N=r(le,"SPAN",{});var ot=l(N);me=s(ot,"All about metrics"),ot.forEach(a),le.forEach(a),V=m(e),A=r(e,"P",{});var ne=l(A);pe=s(ne,"\u{1F917} Evaluate provides access to a wide range of NLP metrics. You can load metrics associated with benchmark datasets like GLUE or SQuAD, and complex metrics like BLEURT or BERTScore, with a single command: "),C=r(ne,"A",{href:!0});var it=l(C);fe=s(it,"evaluate.load()"),it.forEach(a),ve=s(ne,". Once you\u2019ve loaded a metric, easily compute and evaluate a model\u2019s performance."),ne.forEach(a),X=m(e),w=r(e,"H2",{class:!0});var ce=l(w);g=r(ce,"A",{id:!0,class:!0,href:!0});var rt=l(g);I=r(rt,"SPAN",{});var st=l(I);Ye(T.$$.fragment,st),st.forEach(a),rt.forEach(a),be=m(ce),B=r(ce,"SPAN",{});var ze=l(B);ye=s(ze,"ELI5: "),R=r(ze,"CODE",{});var lt=l(R);we=s(lt,"evaluate.load"),lt.forEach(a),ze.forEach(a),ce.forEach(a),Z=m(e),P=r(e,"P",{});var de=l(P);Ee=s(de,"When you call "),S=r(de,"A",{href:!0});var nt=l(S);_e=s(nt,"evaluate.load()"),nt.forEach(a),Ae=s(de,", the metric loading script is downloaded and imported from GitHub (if it hasn\u2019t already been downloaded before). It contains information about the metric such as it\u2019s citation, homepage, and description."),de.forEach(a),ee=m(e),p=r(e,"P",{});var O=l(p);ge=s(O,"The metric loading script will instantiate and return a "),H=r(O,"CODE",{});var ct=l(H);Pe=s(ct,"EvaluationModule"),ct.forEach(a),ke=s(O," object. This stores the predictions and references, which you need to compute the metric values. The "),j=r(O,"CODE",{});var dt=l(j);$e=s(dt,"EvaluationModule"),dt.forEach(a),Te=s(O," object is stored as an Apache Arrow table. As a result, the predictions and references are stored directly on disk with memory-mapping. This enables \u{1F917} Evaluate to do a lazy computation of the metric, and makes it easier to gather all the predictions in a distributed setting."),O.forEach(a),te=m(e),E=r(e,"H2",{class:!0});var ue=l(E);k=r(ue,"A",{id:!0,class:!0,href:!0});var ut=l(k);F=r(ut,"SPAN",{});var ht=l(F);Ye(x.$$.fragment,ht),ht.forEach(a),ut.forEach(a),xe=m(ue),W=r(ue,"SPAN",{});var mt=l(W);Ue=s(mt,"Distributed evaluation"),mt.forEach(a),ue.forEach(a),ae=m(e),u=r(e,"P",{});var v=l(u);Ce=s(v,"Computing metrics in a distributed environment can be tricky. Metric evaluation is executed in separate Python processes, or nodes, on different subsets of a dataset. Typically, when a metric score is additive ("),q=r(v,"CODE",{});var pt=l(q);Be=s(pt,"f(AuB) = f(A) + f(B)"),pt.forEach(a),Se=s(v,"), you can use distributed reduce operations to gather the scores for each subset of the dataset. But when a metric is non-additive ("),z=r(v,"CODE",{});var ft=l(z);Ge=s(ft,"f(AuB) \u2260 f(A) + f(B)"),ft.forEach(a),Me=s(v,"), it\u2019s not that simple. For example, you can\u2019t take the sum of the "),U=r(v,"A",{href:!0,rel:!0});var vt=l(U);Oe=s(vt,"F1"),vt.forEach(a),De=s(v," scores of each data subset as your "),Q=r(v,"STRONG",{});var bt=l(Q);Le=s(bt,"final metric"),bt.forEach(a),Ne=s(v,"."),v.forEach(a),oe=m(e),G=r(e,"P",{});var yt=l(G);Ie=s(yt,"A common way to overcome this issue is to fallback on single process evaluation. The metrics are evaluated on a single GPU, which becomes inefficient."),yt.forEach(a),ie=m(e),f=r(e,"P",{});var D=l(f);Re=s(D,"\u{1F917} Evaluate solves this issue by only computing the final metric on the first node. The predictions and references are computed and provided to the metric separately for each node. These are temporarily stored in an Apache Arrow table, avoiding cluttering the GPU or CPU memory. When you are ready to "),Y=r(D,"CODE",{});var wt=l(Y);He=s(wt,"EvaluationModule.compute"),wt.forEach(a),je=s(D," the final metric, the first node is able to access the predictions and references stored on all the other nodes. Once it has gathered all the predictions and references, "),J=r(D,"CODE",{});var Et=l(J);Fe=s(Et,"EvaluationModule.compute"),Et.forEach(a),We=s(D," will perform the final metric evaluation."),D.forEach(a),re=m(e),M=r(e,"P",{});var _t=l(M);qe=s(_t,"This solution allows \u{1F917} Evaluate to perform distributed predictions, which is important for evaluation speed in distributed settings. At the same time, you can also use complex non-additive metrics without wasting valuable GPU or CPU memory. distributed predictions, which is important for evaluation speed in distributed settings. At the same time, you can also use complex non-additive metrics without wasting valuable GPU or CPU memory."),_t.forEach(a),this.h()},h(){d(b,"name","hf:doc:metadata"),d(b,"content",JSON.stringify(Ut)),d(_,"id","all-about-metrics"),d(_,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),d(_,"href","#all-about-metrics"),d(y,"class","relative group"),d(C,"href","/docs/evaluate/pr_68/en/package_reference/loading_methods#evaluate.load"),d(g,"id","eli5-evaluateload"),d(g,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),d(g,"href","#eli5-evaluateload"),d(w,"class","relative group"),d(S,"href","/docs/evaluate/pr_68/en/package_reference/loading_methods#evaluate.load"),d(k,"id","distributed-evaluation"),d(k,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),d(k,"href","#distributed-evaluation"),d(E,"class","relative group"),d(U,"href","https://huggingface.co/metrics/f1"),d(U,"rel","nofollow")},m(e,n){t(document.head,b),c(e,K,n),c(e,y,n),t(y,_),t(_,L),Je($,L,null),t(y,he),t(y,N),t(N,me),c(e,V,n),c(e,A,n),t(A,pe),t(A,C),t(C,fe),t(A,ve),c(e,X,n),c(e,w,n),t(w,g),t(g,I),Je(T,I,null),t(w,be),t(w,B),t(B,ye),t(B,R),t(R,we),c(e,Z,n),c(e,P,n),t(P,Ee),t(P,S),t(S,_e),t(P,Ae),c(e,ee,n),c(e,p,n),t(p,ge),t(p,H),t(H,Pe),t(p,ke),t(p,j),t(j,$e),t(p,Te),c(e,te,n),c(e,E,n),t(E,k),t(k,F),Je(x,F,null),t(E,xe),t(E,W),t(W,Ue),c(e,ae,n),c(e,u,n),t(u,Ce),t(u,q),t(q,Be),t(u,Se),t(u,z),t(z,Ge),t(u,Me),t(u,U),t(U,Oe),t(u,De),t(u,Q),t(Q,Le),t(u,Ne),c(e,oe,n),c(e,G,n),t(G,Ie),c(e,ie,n),c(e,f,n),t(f,Re),t(f,Y),t(Y,He),t(f,je),t(f,J),t(J,Fe),t(f,We),c(e,re,n),c(e,M,n),t(M,qe),se=!0},p:$t,i(e){se||(Ke($.$$.fragment,e),Ke(T.$$.fragment,e),Ke(x.$$.fragment,e),se=!0)},o(e){Ve($.$$.fragment,e),Ve(T.$$.fragment,e),Ve(x.$$.fragment,e),se=!1},d(e){a(b),e&&a(K),e&&a(y),Xe($),e&&a(V),e&&a(A),e&&a(X),e&&a(w),Xe(T),e&&a(Z),e&&a(P),e&&a(ee),e&&a(p),e&&a(te),e&&a(E),Xe(x),e&&a(ae),e&&a(u),e&&a(oe),e&&a(G),e&&a(ie),e&&a(f),e&&a(re),e&&a(M)}}}const Ut={local:"all-about-metrics",sections:[{local:"eli5-evaluateload",title:"ELI5: `evaluate.load`"},{local:"distributed-evaluation",title:"Distributed evaluation"}],title:"All about metrics"};function Ct(et){return Tt(()=>{new URLSearchParams(window.location.search).get("fw")}),[]}class Gt extends At{constructor(b){super();gt(this,b,Ct,xt,Pt,{})}}export{Gt as default,Ut as metadata};
