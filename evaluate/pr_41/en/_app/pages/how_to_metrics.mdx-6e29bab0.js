import{S as _l,i as gl,s as vl,e as a,k as c,w as _,t as n,M as wl,c as r,d as t,m as u,a as o,x as g,h as i,b as f,F as s,g as p,y as v,q as w,o as y,B as $,v as yl}from"../chunks/vendor-e830fc9c.js";import{C as I,T as Jr}from"../chunks/CodeBlock-7b28e4e9.js";import{I as ie}from"../chunks/IconCopyLink-af4c5c5b.js";function $l(B){let d,b;return{c(){d=a("p"),b=n("Metrics accepts various input formats (Python lists, NumPy arrays, PyTorch tensors, etc.) and converts them to an appropriate format for storage and computation.")},l(h){d=r(h,"P",{});var m=o(d);b=i(m,"Metrics accepts various input formats (Python lists, NumPy arrays, PyTorch tensors, etc.) and converts them to an appropriate format for storage and computation."),m.forEach(t)},m(h,m){p(h,d,m),s(d,b)},d(h){h&&t(d)}}}function bl(B){let d,b,h,m,L;return{c(){d=a("p"),b=n("Get jump started with our metric loading script "),h=a("a"),m=n("template"),L=n("!"),this.h()},l(j){d=r(j,"P",{});var q=o(d);b=i(q,"Get jump started with our metric loading script "),h=r(q,"A",{href:!0,rel:!0});var H=o(h);m=i(H,"template"),H.forEach(t),L=i(q,"!"),q.forEach(t),this.h()},h(){f(h,"href","https://github.com/huggingface/datasets/blob/master/templates/new_metric_script.py"),f(h,"rel","nofollow")},m(j,q){p(j,d,q),s(d,b),s(d,h),s(h,m),s(d,L)},d(j){j&&t(d)}}}function jl(B){let d,b;return{c(){d=a("p"),b=n("If the files are stored locally, provide a dictionary of path(s) instead of URLs.")},l(h){d=r(h,"P",{});var m=o(d);b=i(m,"If the files are stored locally, provide a dictionary of path(s) instead of URLs."),m.forEach(t)},m(h,m){p(h,d,m),s(d,b)},d(h){h&&t(d)}}}function El(B){let d,b,h,m,L,j,q,H,la,Xt,Ue,na,Zt,Re,ia,es,k,nt,pa,ca,it,ua,fa,pt,da,ts,C,z,ct,pe,ha,ut,ma,ss,K,_a,Be,ga,va,as,V,ft,P,He,wa,ya,dt,$a,ba,ht,ja,Ea,qa,mt,x,ze,ka,Pa,_t,xa,Aa,gt,Ia,La,rs,Y,Ca,Ke,Sa,Ta,os,ce,ls,Q,ns,S,W,vt,ue,Ma,wt,Oa,is,F,Da,Ve,Na,Ua,ps,G,Ra,fe,Ba,Ha,cs,Ye,yt,za,us,de,fs,he,$t,Ka,ds,me,hs,_e,T,Va,bt,Ya,Qa,jt,Wa,Fa,ms,ge,_s,Qe,gs,M,J,Et,ve,Ga,qt,Ja,vs,X,Xa,We,Za,er,ws,Z,tr,we,sr,ar,ys,ee,$s,O,te,kt,ye,rr,Pt,or,bs,se,lr,xt,nr,ir,js,E,At,Fe,It,pr,cr,ur,Lt,Ge,Ct,fr,dr,hr,St,Je,Tt,mr,_r,gr,Mt,Xe,Ot,vr,wr,Es,Ze,yr,qs,$e,ks,D,ae,Dt,be,$r,Nt,br,Ps,A,jr,Ut,Er,qr,je,kr,Pr,xs,et,Rt,xr,As,Ee,Is,re,Ls,qe,tt,Bt,Ar,Ir,Cs,ke,Ss,N,oe,Ht,Pe,Lr,zt,Cr,Ts,U,Kt,Sr,Tr,xe,Mr,Or,Ms,st,Ae,Dr,Vt,Nr,Ur,Os,Ie,Ds,Le,Ce,Rr,Yt,Br,Hr,Ns,Se,Us,R,le,Qt,Te,zr,Wt,Kr,Rs,at,Vr,Bs,Me,Hs;return j=new ie({}),pe=new ie({}),ce=new I({props:{code:`import datasets
metric = evaluate.load_metric('my_metric')
for model_input, gold_references in evaluation_dataset:
    model_predictions = model(model_inputs)
    metric.add_batch(predictions=model_predictions, references=gold_references)
final_score = metric.compute()`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> datasets
<span class="hljs-meta">&gt;&gt;&gt; </span>metric = evaluate.load_metric(<span class="hljs-string">&#x27;my_metric&#x27;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">for</span> model_input, gold_references <span class="hljs-keyword">in</span> evaluation_dataset:
<span class="hljs-meta">... </span>    model_predictions = model(model_inputs)
<span class="hljs-meta">... </span>    metric.add_batch(predictions=model_predictions, references=gold_references)
<span class="hljs-meta">&gt;&gt;&gt; </span>final_score = metric.compute()`}}),Q=new Jr({props:{$$slots:{default:[$l]},$$scope:{ctx:B}}}),ue=new ie({}),de=new I({props:{code:`import datasets
metric = evaluate.load_metric('sacrebleu')`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> datasets
<span class="hljs-meta">&gt;&gt;&gt; </span>metric = evaluate.load_metric(<span class="hljs-string">&#x27;sacrebleu&#x27;</span>)`}}),me=new I({props:{code:`print(metric.inputs_description)
`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(metric.inputs_description)
Produces BLEU scores along <span class="hljs-keyword">with</span> its sufficient statistics
<span class="hljs-keyword">from</span> a source against one <span class="hljs-keyword">or</span> more references.

Args:
    predictions: The system stream (a sequence of segments).
    references: A <span class="hljs-built_in">list</span> of one <span class="hljs-keyword">or</span> more reference streams (each a sequence of segments).
    smooth_method: The smoothing method to use. (Default: <span class="hljs-string">&#x27;exp&#x27;</span>).
    smooth_value: The smoothing value. Only valid <span class="hljs-keyword">for</span> <span class="hljs-string">&#x27;floor&#x27;</span> <span class="hljs-keyword">and</span> <span class="hljs-string">&#x27;add-k&#x27;</span>. (Defaults: floor: <span class="hljs-number">0.1</span>, add-k: <span class="hljs-number">1</span>).
    tokenize: Tokenization method to use <span class="hljs-keyword">for</span> BLEU. If <span class="hljs-keyword">not</span> provided, defaults to <span class="hljs-string">&#x27;zh&#x27;</span> <span class="hljs-keyword">for</span> Chinese, <span class="hljs-string">&#x27;ja-mecab&#x27;</span> <span class="hljs-keyword">for</span> Japanese <span class="hljs-keyword">and</span> <span class="hljs-string">&#x27;13a&#x27;</span> (mteval) otherwise.
    lowercase: Lowercase the data. If <span class="hljs-literal">True</span>, enables case-insensitivity. (Default: <span class="hljs-literal">False</span>).
    force: Insist that your tokenized <span class="hljs-built_in">input</span> <span class="hljs-keyword">is</span> actually detokenized.
...`}}),ge=new I({props:{code:'score = metric.compute(smooth_method="floor", smooth_value=0.2)',highlighted:'<span class="hljs-meta">&gt;&gt;&gt; </span>score = metric.compute(smooth_method=<span class="hljs-string">&quot;floor&quot;</span>, smooth_value=<span class="hljs-number">0.2</span>)'}}),ve=new ie({}),ee=new Jr({props:{$$slots:{default:[bl]},$$scope:{ctx:B}}}),ye=new ie({}),$e=new I({props:{code:`class Squad(evaluate.Metric):
    def _info(self):
        return evaluate.MetricInfo(
            description=_DESCRIPTION,
            citation=_CITATION,
            inputs_description=_KWARGS_DESCRIPTION,
            features=datasets.Features(
                {
                    "predictions": {"id": datasets.Value("string"), "prediction_text": datasets.Value("string")},
                    "references": {
                        "id": datasets.Value("string"),
                        "answers": datasets.features.Sequence(
                            {
                                "text": datasets.Value("string"),
                                "answer_start": datasets.Value("int32"),
                            }
                        ),
                    },
                }
            ),
            codebase_urls=["https://rajpurkar.github.io/SQuAD-explorer/"],
            reference_urls=["https://rajpurkar.github.io/SQuAD-explorer/"],
        )`,highlighted:`<span class="hljs-keyword">class</span> <span class="hljs-title class_">Squad</span>(evaluate.Metric):
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_info</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">return</span> evaluate.MetricInfo(
            description=_DESCRIPTION,
            citation=_CITATION,
            inputs_description=_KWARGS_DESCRIPTION,
            features=datasets.Features(
                {
                    <span class="hljs-string">&quot;predictions&quot;</span>: {<span class="hljs-string">&quot;id&quot;</span>: datasets.Value(<span class="hljs-string">&quot;string&quot;</span>), <span class="hljs-string">&quot;prediction_text&quot;</span>: datasets.Value(<span class="hljs-string">&quot;string&quot;</span>)},
                    <span class="hljs-string">&quot;references&quot;</span>: {
                        <span class="hljs-string">&quot;id&quot;</span>: datasets.Value(<span class="hljs-string">&quot;string&quot;</span>),
                        <span class="hljs-string">&quot;answers&quot;</span>: datasets.features.<span class="hljs-type">Sequence</span>(
                            {
                                <span class="hljs-string">&quot;text&quot;</span>: datasets.Value(<span class="hljs-string">&quot;string&quot;</span>),
                                <span class="hljs-string">&quot;answer_start&quot;</span>: datasets.Value(<span class="hljs-string">&quot;int32&quot;</span>),
                            }
                        ),
                    },
                }
            ),
            codebase_urls=[<span class="hljs-string">&quot;https://rajpurkar.github.io/SQuAD-explorer/&quot;</span>],
            reference_urls=[<span class="hljs-string">&quot;https://rajpurkar.github.io/SQuAD-explorer/&quot;</span>],
        )`}}),be=new ie({}),Ee=new I({props:{code:`CHECKPOINT_URLS = {
    "bleurt-tiny-128": "https://storage.googleapis.com/bleurt-oss/bleurt-tiny-128.zip",
    "bleurt-tiny-512": "https://storage.googleapis.com/bleurt-oss/bleurt-tiny-512.zip",
    "bleurt-base-128": "https://storage.googleapis.com/bleurt-oss/bleurt-base-128.zip",
    "bleurt-base-512": "https://storage.googleapis.com/bleurt-oss/bleurt-base-512.zip",
    "bleurt-large-128": "https://storage.googleapis.com/bleurt-oss/bleurt-large-128.zip",
    "bleurt-large-512": "https://storage.googleapis.com/bleurt-oss/bleurt-large-512.zip",
}`,highlighted:`CHECKPOINT_URLS = {
    <span class="hljs-string">&quot;bleurt-tiny-128&quot;</span>: <span class="hljs-string">&quot;https://storage.googleapis.com/bleurt-oss/bleurt-tiny-128.zip&quot;</span>,
    <span class="hljs-string">&quot;bleurt-tiny-512&quot;</span>: <span class="hljs-string">&quot;https://storage.googleapis.com/bleurt-oss/bleurt-tiny-512.zip&quot;</span>,
    <span class="hljs-string">&quot;bleurt-base-128&quot;</span>: <span class="hljs-string">&quot;https://storage.googleapis.com/bleurt-oss/bleurt-base-128.zip&quot;</span>,
    <span class="hljs-string">&quot;bleurt-base-512&quot;</span>: <span class="hljs-string">&quot;https://storage.googleapis.com/bleurt-oss/bleurt-base-512.zip&quot;</span>,
    <span class="hljs-string">&quot;bleurt-large-128&quot;</span>: <span class="hljs-string">&quot;https://storage.googleapis.com/bleurt-oss/bleurt-large-128.zip&quot;</span>,
    <span class="hljs-string">&quot;bleurt-large-512&quot;</span>: <span class="hljs-string">&quot;https://storage.googleapis.com/bleurt-oss/bleurt-large-512.zip&quot;</span>,
}`}}),re=new Jr({props:{$$slots:{default:[jl]},$$scope:{ctx:B}}}),ke=new I({props:{code:`def _download_and_prepare(self, dl_manager):

    # check that config name specifies a valid BLEURT model
    if self.config_name == "default":
        logger.warning(
            "Using default BLEURT-Base checkpoint for sequence maximum length 128. "
            "You can use a bigger model for better results with e.g.: evaluate.load_metric('bleurt', 'bleurt-large-512')."
        )
        self.config_name = "bleurt-base-128"
    if self.config_name not in CHECKPOINT_URLS.keys():
        raise KeyError(
            f"{self.config_name} model not found. You should supply the name of a model checkpoint for bleurt in {CHECKPOINT_URLS.keys()}"
        )

    # download the model checkpoint specified by self.config_name and set up the scorer
    model_path = dl_manager.download_and_extract(CHECKPOINT_URLS[self.config_name])
    self.scorer = score.BleurtScorer(os.path.join(model_path, self.config_name))`,highlighted:`<span class="hljs-keyword">def</span> <span class="hljs-title function_">_download_and_prepare</span>(<span class="hljs-params">self, dl_manager</span>):

    <span class="hljs-comment"># check that config name specifies a valid BLEURT model</span>
    <span class="hljs-keyword">if</span> self.config_name == <span class="hljs-string">&quot;default&quot;</span>:
        logger.warning(
            <span class="hljs-string">&quot;Using default BLEURT-Base checkpoint for sequence maximum length 128. &quot;</span>
            <span class="hljs-string">&quot;You can use a bigger model for better results with e.g.: evaluate.load_metric(&#x27;bleurt&#x27;, &#x27;bleurt-large-512&#x27;).&quot;</span>
        )
        self.config_name = <span class="hljs-string">&quot;bleurt-base-128&quot;</span>
    <span class="hljs-keyword">if</span> self.config_name <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> CHECKPOINT_URLS.keys():
        <span class="hljs-keyword">raise</span> KeyError(
            <span class="hljs-string">f&quot;<span class="hljs-subst">{self.config_name}</span> model not found. You should supply the name of a model checkpoint for bleurt in <span class="hljs-subst">{CHECKPOINT_URLS.keys()}</span>&quot;</span>
        )

    <span class="hljs-comment"># download the model checkpoint specified by self.config_name and set up the scorer</span>
    model_path = dl_manager.download_and_extract(CHECKPOINT_URLS[self.config_name])
    self.scorer = score.BleurtScorer(os.path.join(model_path, self.config_name))`}}),Pe=new ie({}),Ie=new I({props:{code:`def simple_accuracy(preds, labels):
    return (preds == labels).mean().item()

def acc_and_f1(preds, labels):
    acc = simple_accuracy(preds, labels)
    f1 = f1_score(y_true=labels, y_pred=preds).item()
    return {
        "accuracy": acc,
        "f1": f1,
    }

def pearson_and_spearman(preds, labels):
    pearson_corr = pearsonr(preds, labels)[0].item()
    spearman_corr = spearmanr(preds, labels)[0].item()
    return {
        "pearson": pearson_corr,
        "spearmanr": spearman_corr,
    }`,highlighted:`<span class="hljs-keyword">def</span> <span class="hljs-title function_">simple_accuracy</span>(<span class="hljs-params">preds, labels</span>):
    <span class="hljs-keyword">return</span> (preds == labels).mean().item()

<span class="hljs-keyword">def</span> <span class="hljs-title function_">acc_and_f1</span>(<span class="hljs-params">preds, labels</span>):
    acc = simple_accuracy(preds, labels)
    f1 = f1_score(y_true=labels, y_pred=preds).item()
    <span class="hljs-keyword">return</span> {
        <span class="hljs-string">&quot;accuracy&quot;</span>: acc,
        <span class="hljs-string">&quot;f1&quot;</span>: f1,
    }

<span class="hljs-keyword">def</span> <span class="hljs-title function_">pearson_and_spearman</span>(<span class="hljs-params">preds, labels</span>):
    pearson_corr = pearsonr(preds, labels)[<span class="hljs-number">0</span>].item()
    spearman_corr = spearmanr(preds, labels)[<span class="hljs-number">0</span>].item()
    <span class="hljs-keyword">return</span> {
        <span class="hljs-string">&quot;pearson&quot;</span>: pearson_corr,
        <span class="hljs-string">&quot;spearmanr&quot;</span>: spearman_corr,
    }`}}),Se=new I({props:{code:`def _compute(self, predictions, references):
    if self.config_name == "cola":
        return {"matthews_correlation": matthews_corrcoef(references, predictions)}
    elif self.config_name == "stsb":
        return pearson_and_spearman(predictions, references)
    elif self.config_name in ["mrpc", "qqp"]:
        return acc_and_f1(predictions, references)
    elif self.config_name in ["sst2", "mnli", "mnli_mismatched", "mnli_matched", "qnli", "rte", "wnli", "hans"]:
        return {"accuracy": simple_accuracy(predictions, references)}
    else:
        raise KeyError(
            "You should supply a configuration name selected in "
            '["sst2", "mnli", "mnli_mismatched", "mnli_matched", '
            '"cola", "stsb", "mrpc", "qqp", "qnli", "rte", "wnli", "hans"]'
        )`,highlighted:`<span class="hljs-keyword">def</span> <span class="hljs-title function_">_compute</span>(<span class="hljs-params">self, predictions, references</span>):
    <span class="hljs-keyword">if</span> self.config_name == <span class="hljs-string">&quot;cola&quot;</span>:
        <span class="hljs-keyword">return</span> {<span class="hljs-string">&quot;matthews_correlation&quot;</span>: matthews_corrcoef(references, predictions)}
    <span class="hljs-keyword">elif</span> self.config_name == <span class="hljs-string">&quot;stsb&quot;</span>:
        <span class="hljs-keyword">return</span> pearson_and_spearman(predictions, references)
    <span class="hljs-keyword">elif</span> self.config_name <span class="hljs-keyword">in</span> [<span class="hljs-string">&quot;mrpc&quot;</span>, <span class="hljs-string">&quot;qqp&quot;</span>]:
        <span class="hljs-keyword">return</span> acc_and_f1(predictions, references)
    <span class="hljs-keyword">elif</span> self.config_name <span class="hljs-keyword">in</span> [<span class="hljs-string">&quot;sst2&quot;</span>, <span class="hljs-string">&quot;mnli&quot;</span>, <span class="hljs-string">&quot;mnli_mismatched&quot;</span>, <span class="hljs-string">&quot;mnli_matched&quot;</span>, <span class="hljs-string">&quot;qnli&quot;</span>, <span class="hljs-string">&quot;rte&quot;</span>, <span class="hljs-string">&quot;wnli&quot;</span>, <span class="hljs-string">&quot;hans&quot;</span>]:
        <span class="hljs-keyword">return</span> {<span class="hljs-string">&quot;accuracy&quot;</span>: simple_accuracy(predictions, references)}
    <span class="hljs-keyword">else</span>:
        <span class="hljs-keyword">raise</span> KeyError(
            <span class="hljs-string">&quot;You should supply a configuration name selected in &quot;</span>
            <span class="hljs-string">&#x27;[&quot;sst2&quot;, &quot;mnli&quot;, &quot;mnli_mismatched&quot;, &quot;mnli_matched&quot;, &#x27;</span>
            <span class="hljs-string">&#x27;&quot;cola&quot;, &quot;stsb&quot;, &quot;mrpc&quot;, &quot;qqp&quot;, &quot;qnli&quot;, &quot;rte&quot;, &quot;wnli&quot;, &quot;hans&quot;]&#x27;</span>
        )`}}),Te=new ie({}),Me=new I({props:{code:`from evaluate import load_metric
metric = load_metric('PATH/TO/MY/SCRIPT.py')`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> evaluate <span class="hljs-keyword">import</span> load_metric
<span class="hljs-meta">&gt;&gt;&gt; </span>metric = load_metric(<span class="hljs-string">&#x27;PATH/TO/MY/SCRIPT.py&#x27;</span>)`}}),{c(){d=a("meta"),b=c(),h=a("h1"),m=a("a"),L=a("span"),_(j.$$.fragment),q=c(),H=a("span"),la=n("Metrics"),Xt=c(),Ue=a("p"),na=n("Metrics are important for evaluating a model\u2019s predictions. In the tutorial, you learned how to compute a metric over an entire evaluation set. You have also seen how to load a metric."),Zt=c(),Re=a("p"),ia=n("This guide will show you how to:"),es=c(),k=a("ul"),nt=a("li"),pa=n("Add predictions and references."),ca=c(),it=a("li"),ua=n("Compute metrics using different methods."),fa=c(),pt=a("li"),da=n("Write your own metric loading script."),ts=c(),C=a("h2"),z=a("a"),ct=a("span"),_(pe.$$.fragment),ha=c(),ut=a("span"),ma=n("Add predictions and references"),ss=c(),K=a("p"),_a=n("When you want to add model predictions and references to a "),Be=a("a"),ga=n("Metric"),va=n(" instance, you have two options:"),as=c(),V=a("ul"),ft=a("li"),P=a("p"),He=a("a"),wa=n("Metric.add()"),ya=n(" adds a single "),dt=a("code"),$a=n("prediction"),ba=n(" and "),ht=a("code"),ja=n("reference"),Ea=n("."),qa=c(),mt=a("li"),x=a("p"),ze=a("a"),ka=n("Metric.add_batch()"),Pa=n(" adds a batch of "),_t=a("code"),xa=n("predictions"),Aa=n(" and "),gt=a("code"),Ia=n("references"),La=n("."),rs=c(),Y=a("p"),Ca=n("Use "),Ke=a("a"),Sa=n("Metric.add_batch()"),Ta=n(" by passing it your model predictions, and the references the model predictions should be evaluated against:"),os=c(),_(ce.$$.fragment),ls=c(),_(Q.$$.fragment),ns=c(),S=a("h2"),W=a("a"),vt=a("span"),_(ue.$$.fragment),Ma=c(),wt=a("span"),Oa=n("Compute scores"),is=c(),F=a("p"),Da=n("The most straightforward way to calculate a metric is to call "),Ve=a("a"),Na=n("Metric.compute()"),Ua=n(". But some metrics have additional arguments that allow you to modify the metrics behavior."),ps=c(),G=a("p"),Ra=n("Let\u2019s load the "),fe=a("a"),Ba=n("SacreBLEU"),Ha=n(" metric, and compute it with a different smoothing method."),cs=c(),Ye=a("ol"),yt=a("li"),za=n("Load the SacreBLEU metric:"),us=c(),_(de.$$.fragment),fs=c(),he=a("ol"),$t=a("li"),Ka=n("Inspect the different argument methods for computing the metric:"),ds=c(),_(me.$$.fragment),hs=c(),_e=a("ol"),T=a("li"),Va=n("Compute the metric with the "),bt=a("code"),Ya=n("floor"),Qa=n(" method, and a different "),jt=a("code"),Wa=n("smooth_value"),Fa=n(":"),ms=c(),_(ge.$$.fragment),_s=c(),Qe=a("a"),gs=c(),M=a("h2"),J=a("a"),Et=a("span"),_(ve.$$.fragment),Ga=c(),qt=a("span"),Ja=n("Custom metric loading script"),vs=c(),X=a("p"),Xa=n("Write a metric loading script to use your own custom metric (or one that is not on the Hub). Then you can load it as usual with "),We=a("a"),Za=n("load_metric()"),er=n("."),ws=c(),Z=a("p"),tr=n("To help you get started, open the "),we=a("a"),sr=n("SQuAD metric loading script"),ar=n(" and follow along."),ys=c(),_(ee.$$.fragment),$s=c(),O=a("h3"),te=a("a"),kt=a("span"),_(ye.$$.fragment),rr=c(),Pt=a("span"),or=n("Add metric attributes"),bs=c(),se=a("p"),lr=n("Start by adding some information about your metric in "),xt=a("code"),nr=n("Metric._info()"),ir=n(". The most important attributes you should specify are:"),js=c(),E=a("ol"),At=a("li"),Fe=a("p"),It=a("code"),pr=n("MetricInfo.description"),cr=n(" provides a brief description about your metric."),ur=c(),Lt=a("li"),Ge=a("p"),Ct=a("code"),fr=n("MetricInfo.citation"),dr=n(" contains a BibTex citation for the metric."),hr=c(),St=a("li"),Je=a("p"),Tt=a("code"),mr=n("MetricInfo.inputs_description"),_r=n(" describes the expected inputs and outputs. It may also provide an example usage of the metric."),gr=c(),Mt=a("li"),Xe=a("p"),Ot=a("code"),vr=n("MetricInfo.features"),wr=n(" defines the name and type of the predictions and references."),Es=c(),Ze=a("p"),yr=n("After you\u2019ve filled out all these fields in the template, it should look like the following example from the SQuAD metric script:"),qs=c(),_($e.$$.fragment),ks=c(),D=a("h3"),ae=a("a"),Dt=a("span"),_(be.$$.fragment),$r=c(),Nt=a("span"),br=n("Download metric files"),Ps=c(),A=a("p"),jr=n("If your metric needs to download, or retrieve local files, you will need to use the "),Ut=a("code"),Er=n("Metric._download_and_prepare()"),qr=n(" method. For this example, let\u2019s examine the "),je=a("a"),kr=n("BLEURT metric loading script"),Pr=n("."),xs=c(),et=a("ol"),Rt=a("li"),xr=n("Provide a dictionary of URLs that point to the metric files:"),As=c(),_(Ee.$$.fragment),Is=c(),_(re.$$.fragment),Ls=c(),qe=a("ol"),tt=a("li"),Bt=a("code"),Ar=n("Metric._download_and_prepare()"),Ir=n(" will take the URLs and download the metric files specified:"),Cs=c(),_(ke.$$.fragment),Ss=c(),N=a("h3"),oe=a("a"),Ht=a("span"),_(Pe.$$.fragment),Lr=c(),zt=a("span"),Cr=n("Compute score"),Ts=c(),U=a("p"),Kt=a("code"),Sr=n("DatasetBuilder._compute"),Tr=n(" provides the actual instructions for how to compute a metric given the predictions and references. Now let\u2019s take a look at the "),xe=a("a"),Mr=n("GLUE metric loading script"),Or=n("."),Ms=c(),st=a("ol"),Ae=a("li"),Dr=n("Provide the functions for "),Vt=a("code"),Nr=n("DatasetBuilder._compute"),Ur=n(" to calculate your metric:"),Os=c(),_(Ie.$$.fragment),Ds=c(),Le=a("ol"),Ce=a("li"),Rr=n("Create "),Yt=a("code"),Br=n("DatasetBuilder._compute"),Hr=n(" with instructions for what metric to calculate for each configuration:"),Ns=c(),_(Se.$$.fragment),Us=c(),R=a("h3"),le=a("a"),Qt=a("span"),_(Te.$$.fragment),zr=c(),Wt=a("span"),Kr=n("Test"),Rs=c(),at=a("p"),Vr=n("Once you\u2019re finished writing your metric loading script, try to load it locally:"),Bs=c(),_(Me.$$.fragment),this.h()},l(e){const l=wl('[data-svelte="svelte-1phssyn"]',document.head);d=r(l,"META",{name:!0,content:!0}),l.forEach(t),b=u(e),h=r(e,"H1",{class:!0});var Oe=o(h);m=r(Oe,"A",{id:!0,class:!0,href:!0});var Ft=o(m);L=r(Ft,"SPAN",{});var Gt=o(L);g(j.$$.fragment,Gt),Gt.forEach(t),Ft.forEach(t),q=u(Oe),H=r(Oe,"SPAN",{});var Xr=o(H);la=i(Xr,"Metrics"),Xr.forEach(t),Oe.forEach(t),Xt=u(e),Ue=r(e,"P",{});var Zr=o(Ue);na=i(Zr,"Metrics are important for evaluating a model\u2019s predictions. In the tutorial, you learned how to compute a metric over an entire evaluation set. You have also seen how to load a metric."),Zr.forEach(t),Zt=u(e),Re=r(e,"P",{});var eo=o(Re);ia=i(eo,"This guide will show you how to:"),eo.forEach(t),es=u(e),k=r(e,"UL",{});var rt=o(k);nt=r(rt,"LI",{});var to=o(nt);pa=i(to,"Add predictions and references."),to.forEach(t),ca=u(rt),it=r(rt,"LI",{});var so=o(it);ua=i(so,"Compute metrics using different methods."),so.forEach(t),fa=u(rt),pt=r(rt,"LI",{});var ao=o(pt);da=i(ao,"Write your own metric loading script."),ao.forEach(t),rt.forEach(t),ts=u(e),C=r(e,"H2",{class:!0});var zs=o(C);z=r(zs,"A",{id:!0,class:!0,href:!0});var ro=o(z);ct=r(ro,"SPAN",{});var oo=o(ct);g(pe.$$.fragment,oo),oo.forEach(t),ro.forEach(t),ha=u(zs),ut=r(zs,"SPAN",{});var lo=o(ut);ma=i(lo,"Add predictions and references"),lo.forEach(t),zs.forEach(t),ss=u(e),K=r(e,"P",{});var Ks=o(K);_a=i(Ks,"When you want to add model predictions and references to a "),Be=r(Ks,"A",{href:!0});var no=o(Be);ga=i(no,"Metric"),no.forEach(t),va=i(Ks," instance, you have two options:"),Ks.forEach(t),as=u(e),V=r(e,"UL",{});var Vs=o(V);ft=r(Vs,"LI",{});var io=o(ft);P=r(io,"P",{});var De=o(P);He=r(De,"A",{href:!0});var po=o(He);wa=i(po,"Metric.add()"),po.forEach(t),ya=i(De," adds a single "),dt=r(De,"CODE",{});var co=o(dt);$a=i(co,"prediction"),co.forEach(t),ba=i(De," and "),ht=r(De,"CODE",{});var uo=o(ht);ja=i(uo,"reference"),uo.forEach(t),Ea=i(De,"."),De.forEach(t),io.forEach(t),qa=u(Vs),mt=r(Vs,"LI",{});var fo=o(mt);x=r(fo,"P",{});var Ne=o(x);ze=r(Ne,"A",{href:!0});var ho=o(ze);ka=i(ho,"Metric.add_batch()"),ho.forEach(t),Pa=i(Ne," adds a batch of "),_t=r(Ne,"CODE",{});var mo=o(_t);xa=i(mo,"predictions"),mo.forEach(t),Aa=i(Ne," and "),gt=r(Ne,"CODE",{});var _o=o(gt);Ia=i(_o,"references"),_o.forEach(t),La=i(Ne,"."),Ne.forEach(t),fo.forEach(t),Vs.forEach(t),rs=u(e),Y=r(e,"P",{});var Ys=o(Y);Ca=i(Ys,"Use "),Ke=r(Ys,"A",{href:!0});var go=o(Ke);Sa=i(go,"Metric.add_batch()"),go.forEach(t),Ta=i(Ys," by passing it your model predictions, and the references the model predictions should be evaluated against:"),Ys.forEach(t),os=u(e),g(ce.$$.fragment,e),ls=u(e),g(Q.$$.fragment,e),ns=u(e),S=r(e,"H2",{class:!0});var Qs=o(S);W=r(Qs,"A",{id:!0,class:!0,href:!0});var vo=o(W);vt=r(vo,"SPAN",{});var wo=o(vt);g(ue.$$.fragment,wo),wo.forEach(t),vo.forEach(t),Ma=u(Qs),wt=r(Qs,"SPAN",{});var yo=o(wt);Oa=i(yo,"Compute scores"),yo.forEach(t),Qs.forEach(t),is=u(e),F=r(e,"P",{});var Ws=o(F);Da=i(Ws,"The most straightforward way to calculate a metric is to call "),Ve=r(Ws,"A",{href:!0});var $o=o(Ve);Na=i($o,"Metric.compute()"),$o.forEach(t),Ua=i(Ws,". But some metrics have additional arguments that allow you to modify the metrics behavior."),Ws.forEach(t),ps=u(e),G=r(e,"P",{});var Fs=o(G);Ra=i(Fs,"Let\u2019s load the "),fe=r(Fs,"A",{href:!0,rel:!0});var bo=o(fe);Ba=i(bo,"SacreBLEU"),bo.forEach(t),Ha=i(Fs," metric, and compute it with a different smoothing method."),Fs.forEach(t),cs=u(e),Ye=r(e,"OL",{});var jo=o(Ye);yt=r(jo,"LI",{});var Eo=o(yt);za=i(Eo,"Load the SacreBLEU metric:"),Eo.forEach(t),jo.forEach(t),us=u(e),g(de.$$.fragment,e),fs=u(e),he=r(e,"OL",{start:!0});var qo=o(he);$t=r(qo,"LI",{});var ko=o($t);Ka=i(ko,"Inspect the different argument methods for computing the metric:"),ko.forEach(t),qo.forEach(t),ds=u(e),g(me.$$.fragment,e),hs=u(e),_e=r(e,"OL",{start:!0});var Po=o(_e);T=r(Po,"LI",{});var ot=o(T);Va=i(ot,"Compute the metric with the "),bt=r(ot,"CODE",{});var xo=o(bt);Ya=i(xo,"floor"),xo.forEach(t),Qa=i(ot," method, and a different "),jt=r(ot,"CODE",{});var Ao=o(jt);Wa=i(Ao,"smooth_value"),Ao.forEach(t),Fa=i(ot,":"),ot.forEach(t),Po.forEach(t),ms=u(e),g(ge.$$.fragment,e),_s=u(e),Qe=r(e,"A",{id:!0}),o(Qe).forEach(t),gs=u(e),M=r(e,"H2",{class:!0});var Gs=o(M);J=r(Gs,"A",{id:!0,class:!0,href:!0});var Io=o(J);Et=r(Io,"SPAN",{});var Lo=o(Et);g(ve.$$.fragment,Lo),Lo.forEach(t),Io.forEach(t),Ga=u(Gs),qt=r(Gs,"SPAN",{});var Co=o(qt);Ja=i(Co,"Custom metric loading script"),Co.forEach(t),Gs.forEach(t),vs=u(e),X=r(e,"P",{});var Js=o(X);Xa=i(Js,"Write a metric loading script to use your own custom metric (or one that is not on the Hub). Then you can load it as usual with "),We=r(Js,"A",{href:!0});var So=o(We);Za=i(So,"load_metric()"),So.forEach(t),er=i(Js,"."),Js.forEach(t),ws=u(e),Z=r(e,"P",{});var Xs=o(Z);tr=i(Xs,"To help you get started, open the "),we=r(Xs,"A",{href:!0,rel:!0});var To=o(we);sr=i(To,"SQuAD metric loading script"),To.forEach(t),ar=i(Xs," and follow along."),Xs.forEach(t),ys=u(e),g(ee.$$.fragment,e),$s=u(e),O=r(e,"H3",{class:!0});var Zs=o(O);te=r(Zs,"A",{id:!0,class:!0,href:!0});var Mo=o(te);kt=r(Mo,"SPAN",{});var Oo=o(kt);g(ye.$$.fragment,Oo),Oo.forEach(t),Mo.forEach(t),rr=u(Zs),Pt=r(Zs,"SPAN",{});var Do=o(Pt);or=i(Do,"Add metric attributes"),Do.forEach(t),Zs.forEach(t),bs=u(e),se=r(e,"P",{});var ea=o(se);lr=i(ea,"Start by adding some information about your metric in "),xt=r(ea,"CODE",{});var No=o(xt);nr=i(No,"Metric._info()"),No.forEach(t),ir=i(ea,". The most important attributes you should specify are:"),ea.forEach(t),js=u(e),E=r(e,"OL",{});var ne=o(E);At=r(ne,"LI",{});var Uo=o(At);Fe=r(Uo,"P",{});var Yr=o(Fe);It=r(Yr,"CODE",{});var Ro=o(It);pr=i(Ro,"MetricInfo.description"),Ro.forEach(t),cr=i(Yr," provides a brief description about your metric."),Yr.forEach(t),Uo.forEach(t),ur=u(ne),Lt=r(ne,"LI",{});var Bo=o(Lt);Ge=r(Bo,"P",{});var Qr=o(Ge);Ct=r(Qr,"CODE",{});var Ho=o(Ct);fr=i(Ho,"MetricInfo.citation"),Ho.forEach(t),dr=i(Qr," contains a BibTex citation for the metric."),Qr.forEach(t),Bo.forEach(t),hr=u(ne),St=r(ne,"LI",{});var zo=o(St);Je=r(zo,"P",{});var Wr=o(Je);Tt=r(Wr,"CODE",{});var Ko=o(Tt);mr=i(Ko,"MetricInfo.inputs_description"),Ko.forEach(t),_r=i(Wr," describes the expected inputs and outputs. It may also provide an example usage of the metric."),Wr.forEach(t),zo.forEach(t),gr=u(ne),Mt=r(ne,"LI",{});var Vo=o(Mt);Xe=r(Vo,"P",{});var Fr=o(Xe);Ot=r(Fr,"CODE",{});var Yo=o(Ot);vr=i(Yo,"MetricInfo.features"),Yo.forEach(t),wr=i(Fr," defines the name and type of the predictions and references."),Fr.forEach(t),Vo.forEach(t),ne.forEach(t),Es=u(e),Ze=r(e,"P",{});var Qo=o(Ze);yr=i(Qo,"After you\u2019ve filled out all these fields in the template, it should look like the following example from the SQuAD metric script:"),Qo.forEach(t),qs=u(e),g($e.$$.fragment,e),ks=u(e),D=r(e,"H3",{class:!0});var ta=o(D);ae=r(ta,"A",{id:!0,class:!0,href:!0});var Wo=o(ae);Dt=r(Wo,"SPAN",{});var Fo=o(Dt);g(be.$$.fragment,Fo),Fo.forEach(t),Wo.forEach(t),$r=u(ta),Nt=r(ta,"SPAN",{});var Go=o(Nt);br=i(Go,"Download metric files"),Go.forEach(t),ta.forEach(t),Ps=u(e),A=r(e,"P",{});var lt=o(A);jr=i(lt,"If your metric needs to download, or retrieve local files, you will need to use the "),Ut=r(lt,"CODE",{});var Jo=o(Ut);Er=i(Jo,"Metric._download_and_prepare()"),Jo.forEach(t),qr=i(lt," method. For this example, let\u2019s examine the "),je=r(lt,"A",{href:!0,rel:!0});var Xo=o(je);kr=i(Xo,"BLEURT metric loading script"),Xo.forEach(t),Pr=i(lt,"."),lt.forEach(t),xs=u(e),et=r(e,"OL",{});var Zo=o(et);Rt=r(Zo,"LI",{});var el=o(Rt);xr=i(el,"Provide a dictionary of URLs that point to the metric files:"),el.forEach(t),Zo.forEach(t),As=u(e),g(Ee.$$.fragment,e),Is=u(e),g(re.$$.fragment,e),Ls=u(e),qe=r(e,"OL",{start:!0});var tl=o(qe);tt=r(tl,"LI",{});var Gr=o(tt);Bt=r(Gr,"CODE",{});var sl=o(Bt);Ar=i(sl,"Metric._download_and_prepare()"),sl.forEach(t),Ir=i(Gr," will take the URLs and download the metric files specified:"),Gr.forEach(t),tl.forEach(t),Cs=u(e),g(ke.$$.fragment,e),Ss=u(e),N=r(e,"H3",{class:!0});var sa=o(N);oe=r(sa,"A",{id:!0,class:!0,href:!0});var al=o(oe);Ht=r(al,"SPAN",{});var rl=o(Ht);g(Pe.$$.fragment,rl),rl.forEach(t),al.forEach(t),Lr=u(sa),zt=r(sa,"SPAN",{});var ol=o(zt);Cr=i(ol,"Compute score"),ol.forEach(t),sa.forEach(t),Ts=u(e),U=r(e,"P",{});var Jt=o(U);Kt=r(Jt,"CODE",{});var ll=o(Kt);Sr=i(ll,"DatasetBuilder._compute"),ll.forEach(t),Tr=i(Jt," provides the actual instructions for how to compute a metric given the predictions and references. Now let\u2019s take a look at the "),xe=r(Jt,"A",{href:!0,rel:!0});var nl=o(xe);Mr=i(nl,"GLUE metric loading script"),nl.forEach(t),Or=i(Jt,"."),Jt.forEach(t),Ms=u(e),st=r(e,"OL",{});var il=o(st);Ae=r(il,"LI",{});var aa=o(Ae);Dr=i(aa,"Provide the functions for "),Vt=r(aa,"CODE",{});var pl=o(Vt);Nr=i(pl,"DatasetBuilder._compute"),pl.forEach(t),Ur=i(aa," to calculate your metric:"),aa.forEach(t),il.forEach(t),Os=u(e),g(Ie.$$.fragment,e),Ds=u(e),Le=r(e,"OL",{start:!0});var cl=o(Le);Ce=r(cl,"LI",{});var ra=o(Ce);Rr=i(ra,"Create "),Yt=r(ra,"CODE",{});var ul=o(Yt);Br=i(ul,"DatasetBuilder._compute"),ul.forEach(t),Hr=i(ra," with instructions for what metric to calculate for each configuration:"),ra.forEach(t),cl.forEach(t),Ns=u(e),g(Se.$$.fragment,e),Us=u(e),R=r(e,"H3",{class:!0});var oa=o(R);le=r(oa,"A",{id:!0,class:!0,href:!0});var fl=o(le);Qt=r(fl,"SPAN",{});var dl=o(Qt);g(Te.$$.fragment,dl),dl.forEach(t),fl.forEach(t),zr=u(oa),Wt=r(oa,"SPAN",{});var hl=o(Wt);Kr=i(hl,"Test"),hl.forEach(t),oa.forEach(t),Rs=u(e),at=r(e,"P",{});var ml=o(at);Vr=i(ml,"Once you\u2019re finished writing your metric loading script, try to load it locally:"),ml.forEach(t),Bs=u(e),g(Me.$$.fragment,e),this.h()},h(){f(d,"name","hf:doc:metadata"),f(d,"content",JSON.stringify(ql)),f(m,"id","metrics"),f(m,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),f(m,"href","#metrics"),f(h,"class","relative group"),f(z,"id","add-predictions-and-references"),f(z,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),f(z,"href","#add-predictions-and-references"),f(C,"class","relative group"),f(Be,"href","/docs/evaluate/pr_41/en/package_reference/main_classes#evaluate.Metric"),f(He,"href","/docs/evaluate/pr_41/en/package_reference/main_classes#evaluate.Metric.add"),f(ze,"href","/docs/evaluate/pr_41/en/package_reference/main_classes#evaluate.Metric.add_batch"),f(Ke,"href","/docs/evaluate/pr_41/en/package_reference/main_classes#evaluate.Metric.add_batch"),f(W,"id","compute-scores"),f(W,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),f(W,"href","#compute-scores"),f(S,"class","relative group"),f(Ve,"href","/docs/evaluate/pr_41/en/package_reference/main_classes#evaluate.Metric.compute"),f(fe,"href","https://huggingface.co/metrics/sacrebleu"),f(fe,"rel","nofollow"),f(he,"start","2"),f(_e,"start","3"),f(Qe,"id","metric_script"),f(J,"id","custom-metric-loading-script"),f(J,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),f(J,"href","#custom-metric-loading-script"),f(M,"class","relative group"),f(We,"href","/docs/evaluate/pr_41/en/package_reference/loading_methods#evaluate.load_metric"),f(we,"href","https://github.com/huggingface/datasets/blob/master/metrics/squad/squad.py"),f(we,"rel","nofollow"),f(te,"id","add-metric-attributes"),f(te,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),f(te,"href","#add-metric-attributes"),f(O,"class","relative group"),f(ae,"id","download-metric-files"),f(ae,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),f(ae,"href","#download-metric-files"),f(D,"class","relative group"),f(je,"href","https://github.com/huggingface/datasets/blob/master/metrics/bleurt/bleurt.py"),f(je,"rel","nofollow"),f(qe,"start","2"),f(oe,"id","compute-score"),f(oe,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),f(oe,"href","#compute-score"),f(N,"class","relative group"),f(xe,"href","https://github.com/huggingface/datasets/blob/master/metrics/glue/glue.py"),f(xe,"rel","nofollow"),f(Le,"start","2"),f(le,"id","test"),f(le,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),f(le,"href","#test"),f(R,"class","relative group")},m(e,l){s(document.head,d),p(e,b,l),p(e,h,l),s(h,m),s(m,L),v(j,L,null),s(h,q),s(h,H),s(H,la),p(e,Xt,l),p(e,Ue,l),s(Ue,na),p(e,Zt,l),p(e,Re,l),s(Re,ia),p(e,es,l),p(e,k,l),s(k,nt),s(nt,pa),s(k,ca),s(k,it),s(it,ua),s(k,fa),s(k,pt),s(pt,da),p(e,ts,l),p(e,C,l),s(C,z),s(z,ct),v(pe,ct,null),s(C,ha),s(C,ut),s(ut,ma),p(e,ss,l),p(e,K,l),s(K,_a),s(K,Be),s(Be,ga),s(K,va),p(e,as,l),p(e,V,l),s(V,ft),s(ft,P),s(P,He),s(He,wa),s(P,ya),s(P,dt),s(dt,$a),s(P,ba),s(P,ht),s(ht,ja),s(P,Ea),s(V,qa),s(V,mt),s(mt,x),s(x,ze),s(ze,ka),s(x,Pa),s(x,_t),s(_t,xa),s(x,Aa),s(x,gt),s(gt,Ia),s(x,La),p(e,rs,l),p(e,Y,l),s(Y,Ca),s(Y,Ke),s(Ke,Sa),s(Y,Ta),p(e,os,l),v(ce,e,l),p(e,ls,l),v(Q,e,l),p(e,ns,l),p(e,S,l),s(S,W),s(W,vt),v(ue,vt,null),s(S,Ma),s(S,wt),s(wt,Oa),p(e,is,l),p(e,F,l),s(F,Da),s(F,Ve),s(Ve,Na),s(F,Ua),p(e,ps,l),p(e,G,l),s(G,Ra),s(G,fe),s(fe,Ba),s(G,Ha),p(e,cs,l),p(e,Ye,l),s(Ye,yt),s(yt,za),p(e,us,l),v(de,e,l),p(e,fs,l),p(e,he,l),s(he,$t),s($t,Ka),p(e,ds,l),v(me,e,l),p(e,hs,l),p(e,_e,l),s(_e,T),s(T,Va),s(T,bt),s(bt,Ya),s(T,Qa),s(T,jt),s(jt,Wa),s(T,Fa),p(e,ms,l),v(ge,e,l),p(e,_s,l),p(e,Qe,l),p(e,gs,l),p(e,M,l),s(M,J),s(J,Et),v(ve,Et,null),s(M,Ga),s(M,qt),s(qt,Ja),p(e,vs,l),p(e,X,l),s(X,Xa),s(X,We),s(We,Za),s(X,er),p(e,ws,l),p(e,Z,l),s(Z,tr),s(Z,we),s(we,sr),s(Z,ar),p(e,ys,l),v(ee,e,l),p(e,$s,l),p(e,O,l),s(O,te),s(te,kt),v(ye,kt,null),s(O,rr),s(O,Pt),s(Pt,or),p(e,bs,l),p(e,se,l),s(se,lr),s(se,xt),s(xt,nr),s(se,ir),p(e,js,l),p(e,E,l),s(E,At),s(At,Fe),s(Fe,It),s(It,pr),s(Fe,cr),s(E,ur),s(E,Lt),s(Lt,Ge),s(Ge,Ct),s(Ct,fr),s(Ge,dr),s(E,hr),s(E,St),s(St,Je),s(Je,Tt),s(Tt,mr),s(Je,_r),s(E,gr),s(E,Mt),s(Mt,Xe),s(Xe,Ot),s(Ot,vr),s(Xe,wr),p(e,Es,l),p(e,Ze,l),s(Ze,yr),p(e,qs,l),v($e,e,l),p(e,ks,l),p(e,D,l),s(D,ae),s(ae,Dt),v(be,Dt,null),s(D,$r),s(D,Nt),s(Nt,br),p(e,Ps,l),p(e,A,l),s(A,jr),s(A,Ut),s(Ut,Er),s(A,qr),s(A,je),s(je,kr),s(A,Pr),p(e,xs,l),p(e,et,l),s(et,Rt),s(Rt,xr),p(e,As,l),v(Ee,e,l),p(e,Is,l),v(re,e,l),p(e,Ls,l),p(e,qe,l),s(qe,tt),s(tt,Bt),s(Bt,Ar),s(tt,Ir),p(e,Cs,l),v(ke,e,l),p(e,Ss,l),p(e,N,l),s(N,oe),s(oe,Ht),v(Pe,Ht,null),s(N,Lr),s(N,zt),s(zt,Cr),p(e,Ts,l),p(e,U,l),s(U,Kt),s(Kt,Sr),s(U,Tr),s(U,xe),s(xe,Mr),s(U,Or),p(e,Ms,l),p(e,st,l),s(st,Ae),s(Ae,Dr),s(Ae,Vt),s(Vt,Nr),s(Ae,Ur),p(e,Os,l),v(Ie,e,l),p(e,Ds,l),p(e,Le,l),s(Le,Ce),s(Ce,Rr),s(Ce,Yt),s(Yt,Br),s(Ce,Hr),p(e,Ns,l),v(Se,e,l),p(e,Us,l),p(e,R,l),s(R,le),s(le,Qt),v(Te,Qt,null),s(R,zr),s(R,Wt),s(Wt,Kr),p(e,Rs,l),p(e,at,l),s(at,Vr),p(e,Bs,l),v(Me,e,l),Hs=!0},p(e,[l]){const Oe={};l&2&&(Oe.$$scope={dirty:l,ctx:e}),Q.$set(Oe);const Ft={};l&2&&(Ft.$$scope={dirty:l,ctx:e}),ee.$set(Ft);const Gt={};l&2&&(Gt.$$scope={dirty:l,ctx:e}),re.$set(Gt)},i(e){Hs||(w(j.$$.fragment,e),w(pe.$$.fragment,e),w(ce.$$.fragment,e),w(Q.$$.fragment,e),w(ue.$$.fragment,e),w(de.$$.fragment,e),w(me.$$.fragment,e),w(ge.$$.fragment,e),w(ve.$$.fragment,e),w(ee.$$.fragment,e),w(ye.$$.fragment,e),w($e.$$.fragment,e),w(be.$$.fragment,e),w(Ee.$$.fragment,e),w(re.$$.fragment,e),w(ke.$$.fragment,e),w(Pe.$$.fragment,e),w(Ie.$$.fragment,e),w(Se.$$.fragment,e),w(Te.$$.fragment,e),w(Me.$$.fragment,e),Hs=!0)},o(e){y(j.$$.fragment,e),y(pe.$$.fragment,e),y(ce.$$.fragment,e),y(Q.$$.fragment,e),y(ue.$$.fragment,e),y(de.$$.fragment,e),y(me.$$.fragment,e),y(ge.$$.fragment,e),y(ve.$$.fragment,e),y(ee.$$.fragment,e),y(ye.$$.fragment,e),y($e.$$.fragment,e),y(be.$$.fragment,e),y(Ee.$$.fragment,e),y(re.$$.fragment,e),y(ke.$$.fragment,e),y(Pe.$$.fragment,e),y(Ie.$$.fragment,e),y(Se.$$.fragment,e),y(Te.$$.fragment,e),y(Me.$$.fragment,e),Hs=!1},d(e){t(d),e&&t(b),e&&t(h),$(j),e&&t(Xt),e&&t(Ue),e&&t(Zt),e&&t(Re),e&&t(es),e&&t(k),e&&t(ts),e&&t(C),$(pe),e&&t(ss),e&&t(K),e&&t(as),e&&t(V),e&&t(rs),e&&t(Y),e&&t(os),$(ce,e),e&&t(ls),$(Q,e),e&&t(ns),e&&t(S),$(ue),e&&t(is),e&&t(F),e&&t(ps),e&&t(G),e&&t(cs),e&&t(Ye),e&&t(us),$(de,e),e&&t(fs),e&&t(he),e&&t(ds),$(me,e),e&&t(hs),e&&t(_e),e&&t(ms),$(ge,e),e&&t(_s),e&&t(Qe),e&&t(gs),e&&t(M),$(ve),e&&t(vs),e&&t(X),e&&t(ws),e&&t(Z),e&&t(ys),$(ee,e),e&&t($s),e&&t(O),$(ye),e&&t(bs),e&&t(se),e&&t(js),e&&t(E),e&&t(Es),e&&t(Ze),e&&t(qs),$($e,e),e&&t(ks),e&&t(D),$(be),e&&t(Ps),e&&t(A),e&&t(xs),e&&t(et),e&&t(As),$(Ee,e),e&&t(Is),$(re,e),e&&t(Ls),e&&t(qe),e&&t(Cs),$(ke,e),e&&t(Ss),e&&t(N),$(Pe),e&&t(Ts),e&&t(U),e&&t(Ms),e&&t(st),e&&t(Os),$(Ie,e),e&&t(Ds),e&&t(Le),e&&t(Ns),$(Se,e),e&&t(Us),e&&t(R),$(Te),e&&t(Rs),e&&t(at),e&&t(Bs),$(Me,e)}}}const ql={local:"metrics",sections:[{local:"add-predictions-and-references",title:"Add predictions and references"},{local:"compute-scores",title:"Compute scores"},{local:"custom-metric-loading-script",sections:[{local:"add-metric-attributes",title:"Add metric attributes"},{local:"download-metric-files",title:"Download metric files"},{local:"compute-score",title:"Compute score"},{local:"test",title:"Test"}],title:"Custom metric loading script"}],title:"Metrics"};function kl(B){return yl(()=>{new URLSearchParams(window.location.search).get("fw")}),[]}class Il extends _l{constructor(d){super();gl(this,d,kl,El,vl,{})}}export{Il as default,ql as metadata};
